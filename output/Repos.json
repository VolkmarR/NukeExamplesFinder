[
  {
    "Id": 453037,
    "FirstIndexed": "2020-04-25T15:47:03.6114059+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630129+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8429923+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893596+02:00",
    "Name": "CsvHelper",
    "Owner": "JoshClose",
    "HtmlUrl": "https://github.com/JoshClose/CsvHelper",
    "Description": "Library to help reading and writing CSV files",
    "Archived": false,
    "Stars": 2753,
    "Watchers": 133,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/JoshClose/CsvHelper/blob/master/build/Build.cs",
    "BuildFileSize": 4669,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022NuGet server URL.\u0022)]\n\treadonly string NugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter(\u0022API Key for the NuGet server.\u0022)]\n\treadonly string NugetApiKey;\n\t[Parameter(\u0022Version to use for package.\u0022)]\n\treadonly string Version;\n\n    [Solution]\n\treadonly Solution Solution;\n    [GitRepository]\n\treadonly GitRepository GitRepository;\n    [GitVersion]\n\treadonly GitVersion GitVersion;\n\t\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Project CsvHelperProject =\u003E Solution.GetProject(\u0022CsvHelper\u0022);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n\t\t\t);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .EnableNoRestore()\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(Version ?? GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(Version ?? GitVersion.InformationalVersion)\n\t\t\t);\n\n            DotNetPublish(s =\u003E s\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(Version ?? GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(Version ?? GitVersion.InformationalVersion)\n\t\t\t\t.CombineWith(\n\t\t\t\t\tfrom project in new[] { CsvHelperProject }\n\t\t\t\t\tfrom framework in project.GetTargetFrameworks()\n                    select new { project, framework }, (cs, v) =\u003E cs\n\t\t\t\t\t\t.SetProject(v.project)\n\t\t\t\t\t\t.SetFramework(v.framework)\n\t\t\t\t)\n\t\t\t);\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .EnableNoBuild()\n            );\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean, Test)\n\t\t.Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .EnableNoRestore()\n                .EnableNoBuild()\n\t\t\t\t.SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(Version ?? GitVersion.NuGetVersionV2)\n\t\t\t\t.SetIncludeSymbols(true)\n\t\t\t\t.SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n            );\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n\t\t\t\t.SetSource(NugetSource)\n\t\t\t\t.SetApiKey(NugetApiKey)\n\t\t\t\t.CombineWith(ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022), (s, v) =\u003E s\n\t\t\t\t\t.SetTargetPath(v)\n\t\t\t\t)\n            );\n        });\n}\n"
  },
  {
    "Id": 1098358,
    "FirstIndexed": "2020-04-25T15:47:03.6115482+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631744+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430657+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936568+02:00",
    "Name": "YouTrackSharp",
    "Owner": "JetBrains",
    "HtmlUrl": "https://github.com/JetBrains/YouTrackSharp",
    "Description": ".NET Standard 2.0 Library to access YouTrack API.",
    "Archived": false,
    "Stars": 101,
    "Watchers": 24,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/JetBrains/YouTrackSharp/blob/192/build/Build.cs",
    "BuildFileSize": 3144,
    "BuildFileContent": "using System;\nusing JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    \n    [Parameter(\u0022Package version suffix\u0022)]\n    readonly string PackageVersionSuffix = \u0022develop-\u0022 \u002B DateTime.UtcNow.ToString(\u0022yyyyMMddhhmm\u0022);\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] [UsedImplicitly] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    [UsedImplicitly]\n    Target Initialize =\u003E _ =\u003E _\n        .Before(Clean)\n        .Executes(() =\u003E\n        {\n            SetVariable(\u0022DOTNET_CLI_TELEMETRY_OPTOUT\u0022, \u00221\u0022);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n    \n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(settings =\u003E settings\n                .SetProjectFile(TestsDirectory / \u0022YouTrackSharp.Tests\u0022 / \u0022YouTrackSharp.Tests.csproj\u0022)\n                .EnableNoBuild());\n        });\n    \n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(ArtifactsDirectory);\n\n            DotNetPack(settings =\u003E settings\n                .SetOutputDirectory(ArtifactsDirectory)\n                .EnableIncludeSource()\n                .EnableIncludeSymbols()\n                .SetVersionSuffix(PackageVersionSuffix));\n        });\n}"
  },
  {
    "Id": 2247604,
    "FirstIndexed": "2020-04-25T15:50:44.7356938+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630846+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434485+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940198+02:00",
    "Name": "DateTimeExtensions",
    "Owner": "joaomatossilva",
    "HtmlUrl": "https://github.com/joaomatossilva/DateTimeExtensions",
    "Description": "This project is a merge of several common DateTime operations on the form of  extensions to System.DateTime, including natural date difference text (precise and human rounded), holidays and working days calculations on several culture locales.",
    "Archived": false,
    "Stars": 345,
    "Watchers": 22,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/joaomatossilva/DateTimeExtensions/blob/master/build/Build.cs",
    "BuildFileSize": 2377,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.EnvironmentInfo;\nusing System.IO;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.CI.AppVeyor;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    // Auto-injection fields:\n    // [GitVersion] readonly GitVersion GitVersion;\n    //  - Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n    // [GitRepository] readonly GitRepository GitRepository;\n    //  - Parses origin, branch name and head from git config.\n    // [Parameter] readonly string MyGetApiKey;\n    //  - Returns command-line arguments and environment variables.\n\n    public bool IsTagged =\u003E AppVeyor.Instance?.RepositoryTag ?? false;\n\n    int Revision =\u003E AppVeyor.Instance?.BuildNumber ?? 1;\n\n    public string RevisionString =\u003E IsTagged ? null : $\u0022rev{Revision:D4}\u0022;\n\n    public string ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    public string OutputDirectory =\u003E RootDirectory / \u0022.output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                EnsureCleanDirectory(OutputDirectory);\n                EnsureCleanDirectory(ArtifactsDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore();\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E s\n                    .SetVersionSuffix(RevisionString));\n            });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetProject(RootDirectory / \u0022src\u0022 / \u0022DateTimeExtensions\u0022)\n                .SetVersionSuffix(RevisionString));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(RootDirectory / \u0022tests\u0022 / \u0022DateTimeExtensions.Tests\u0022));\n        });\n}\n"
  },
  {
    "Id": 2426450,
    "FirstIndexed": "2020-04-25T15:50:44.7356909+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627273+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434474+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "OSDB.net",
    "Owner": "joaomatossilva",
    "HtmlUrl": "https://github.com/joaomatossilva/OSDB.net",
    "Description": "OSDB implementation for .Net (OpenSubtitles.org)",
    "Archived": true,
    "Stars": 23,
    "Watchers": 7,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 3190217,
    "FirstIndexed": "2020-04-25T15:50:44.7351192+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629139+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433302+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939071+02:00",
    "Name": "GoogleAnalyticsTracker",
    "Owner": "maartenba",
    "HtmlUrl": "https://github.com/maartenba/GoogleAnalyticsTracker",
    "Description": "GoogleAnalyticsTracker - A C# library for tracking Google Analytics",
    "Archived": false,
    "Stars": 268,
    "Watchers": 25,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/maartenba/GoogleAnalyticsTracker/blob/master/build/Build.cs",
    "BuildFileSize": 2993,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\npublic static class Extensions\n{\n    public static string Until(this string source, string marker)\n    {\n        if (string.IsNullOrEmpty(source)) return source;\n\n        var length = source.IndexOf(marker, StringComparison.OrdinalIgnoreCase);\n\n        if (length \u003C 0 || length \u003E source.Length) return source;\n        \n        return source.Substring(0, length);\n    }\n}\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n// ReSharper disable once ClassNeverInstantiated.Global\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    static string AssemblyVersion = Environment.GetEnvironmentVariable(\u0022VersionFormat\u0022)?.Replace(\u0022{0}\u0022, \u00220\u0022)?.Until(\u0022-\u0022) ?? \u00220.0.1\u0022;\n    static string PackageVersion = Environment.GetEnvironmentVariable(\u0022PackageVersion\u0022) ?? AssemblyVersion \u002B \u0022-dev\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(AssemblyVersion)\n                .SetFileVersion(AssemblyVersion)\n                .SetInformationalVersion(PackageVersion)\n                .EnableNoRestore());\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            foreach (var project in Solution.AllProjects.Where(p =\u003E p.GetProperty\u003Cbool\u003E(\u0022GeneratePackageOnBuild\u0022)).ToList())\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .EnableIncludeSource()\n                    .EnableIncludeSymbols()\n                    .EnableNoRestore()\n                    .EnableNoBuild()\n                    .SetVersion(PackageVersion)\n                    .SetOutputDirectory(ArtifactsDirectory));\n            }\n        });\n}"
  },
  {
    "Id": 4137931,
    "FirstIndexed": "2020-04-25T15:47:03.611324+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162775+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430674+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936585+02:00",
    "Name": "snoopwpf",
    "Owner": "snoopwpf",
    "HtmlUrl": "https://github.com/snoopwpf/snoopwpf",
    "Description": "Snoop - The WPF Spy Utility",
    "Archived": false,
    "Stars": 1005,
    "Watchers": 82,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/snoopwpf/snoopwpf/blob/develop/.build/Build.cs",
    "BuildFileSize": 8176,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    static Build()\n    {\n        // generated with http://patorjk.com/software/taag/#p=display\u0026f=ANSI%20Shadow\u0026t=SnoopWPF\n        Logger.Normal(\u0022\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u0022);\n        Logger.Normal(\u0022\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u0022);\n        Logger.Normal(\u0022\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2588\u2588\u2588\u2557  \u0022);\n        Logger.Normal(\u0022\u255A\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255A\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255D \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255D \u2588\u2588\u2554\u2550\u2550\u255D  \u0022);\n        Logger.Normal(\u0022\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551 \u255A\u2588\u2588\u2588\u2588\u2551\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551     \u255A\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255D\u2588\u2588\u2551     \u2588\u2588\u2551     \u0022);\n        Logger.Normal(\u0022\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u255A\u2550\u255D  \u255A\u2550\u2550\u2550\u255D \u255A\u2550\u2550\u2550\u2550\u2550\u255D  \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D      \u255A\u2550\u2550\u255D\u255A\u2550\u2550\u255D \u255A\u2550\u255D     \u255A\u2550\u255D     \u0022);\n    }\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    protected override void OnBuildInitialized()\n    {\n        base.OnBuildInitialized();\n\n        ProcessTasks.DefaultLogInvocation = true;\n        ProcessTasks.DefaultLogOutput = true;\n\n        Console.WriteLine(\u0022IsLocalBuild           : {0}\u0022, IsLocalBuild);\n        Console.WriteLine(\u0022Informational   Version: {0}\u0022, GitVersion.InformationalVersion);\n        Console.WriteLine(\u0022SemVer          Version: {0}\u0022, GitVersion.SemVer);\n        Console.WriteLine(\u0022AssemblySemVer  Version: {0}\u0022, GitVersion.AssemblySemVer);\n        Console.WriteLine(\u0022MajorMinorPatch Version: {0}\u0022, GitVersion.MajorMinorPatch);\n        Console.WriteLine(\u0022NuGet           Version: {0}\u0022, GitVersion.NuGetVersion);\n    }\n\n    string ProjectName = \u0022Snoop\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [GitVersion(Framework = \u0022netcoreapp3.1\u0022)] readonly GitVersion GitVersion;\n    \n    readonly List\u003Cstring\u003E checkSumFiles = new List\u003Cstring\u003E();\n\n    AbsolutePath BuildBinDirectory =\u003E RootDirectory / \u0022bin\u0022;\n\n    AbsolutePath CurrentBuildOutputDirectory =\u003E BuildBinDirectory / Configuration;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    AbsolutePath ChocolateyDirectory =\u003E RootDirectory / \u0022chocolatey\u0022;\n\n    string CandleExecutable =\u003E ToolPathResolver.GetPackageExecutable(\u0022wix\u0022, \u0022candle.exe\u0022);\n\n    string LightExecutable =\u003E ToolPathResolver.GetPackageExecutable(\u0022wix\u0022, \u0022light.exe\u0022);\n\n    string FenceOutput = \u0022\u0022.PadLeft(30, \u0027#\u0027);\n\n    Target CleanOutput =\u003E _ =\u003E _\n        .Executes(() =\u003E {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E {\n            MSBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                \n                .SetNodeReuse(false)\n                .SetMaxCpuCount(1)\n                .SetRestoreDisableParallel(true)\n                .SetVerbosity(MSBuildVerbosity.Minimal));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(CleanOutput)\n        .DependsOn(Compile)\n        .Executes(() =\u003E {\n            // Generate ingore files to prevent chocolatey from generating shims for them\n            foreach (var launcher in CurrentBuildOutputDirectory.GlobFiles($\u0022{ProjectName}.InjectorLauncher.*.exe\u0022))\n            {\n                using (System.IO.File.Create(launcher \u002B \u0022.ignore\u0022)) { };\n            }\n\n            NuGetTasks.NuGetPack(s =\u003E s\n                .SetTargetPath(ChocolateyDirectory / $\u0022{ProjectName}.nuspec\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(OutputDirectory)\n                .SetNoPackageAnalysis(true));\n\n            var tempDirectory = TemporaryDirectory / $\u0022{ProjectName}Build\u0022;\n\n            if (DirectoryExists(tempDirectory))\n            {\n                DeleteDirectory(tempDirectory);\n            }\n\n            var nupkgs = OutputDirectory.GlobFiles($\u0022{ProjectName}.{GitVersion.NuGetVersion}.nupkg\u0022);\n            var nupkg = nupkgs.First();\n\n            {\n                var outputFile = nupkg;\n                checkSumFiles.Add(outputFile);\n            }\n\n            {\n                CompressionTasks.UncompressZip(nupkg, tempDirectory);\n\n                var outputFile = OutputDirectory / $\u0022{ProjectName}.{GitVersion.NuGetVersion}.zip\u0022;\n                CompressionTasks.Compress(tempDirectory / \u0022tools\u0022,  outputFile, info =\u003E info.Name.Contains(\u0022chocolatey\u0022) == false \u0026\u0026 info.Name != \u0022VERIFICATION.txt\u0022);\n                checkSumFiles.Add(outputFile);\n            }\n        });\n\n    Target Setup =\u003E _ =\u003E _\n        .DependsOn(CleanOutput)\n        .DependsOn(Compile)\n        .After(Pack)\n        .Executes(() =\u003E {\n            var candleProcess = ProcessTasks.StartProcess(CandleExecutable, \n                $\u0022{ProjectName}.wxs -ext WixUIExtension -o \\\u0022{OutputDirectory / $\u0022{ProjectName}.wixobj\u0022}\\\u0022 -dProductVersion=\\\u0022{GitVersion.MajorMinorPatch}\\\u0022 -nologo\u0022);\n            candleProcess.AssertZeroExitCode();\n\n            var outputFile = $\u0022{OutputDirectory / $\u0022{ProjectName}.{GitVersion.NuGetVersion}.msi\u0022}\u0022;\n            var lightProcess = ProcessTasks.StartProcess(LightExecutable, \n                $\u0022-out \\\u0022{outputFile}\\\u0022 -b \\\u0022{CurrentBuildOutputDirectory}\\\u0022 \\\u0022{OutputDirectory / $\u0022{ProjectName}.wixobj\u0022}\\\u0022 -ext WixUIExtension -dProductVersion=\\\u0022{GitVersion.MajorMinorPatch}\\\u0022 -pdbout \\\u0022{OutputDirectory / $\u0022{ProjectName}.wixpdb\u0022}\\\u0022 -nologo -sice:ICE61\u0022);\n            lightProcess.AssertZeroExitCode();\n\n            checkSumFiles.Add(outputFile);\n        });\n\n    Target CheckSums =\u003E _ =\u003E _\n        .TriggeredBy(Pack, Setup)\n        .Executes(() =\u003E {\n            foreach (var item in checkSumFiles)\n            {\n                var checkSum = FileHelper.SHA256CheckSum(item);\n                Logger.Info(FenceOutput);\n                Logger.Info($\u0022CheckSum for \\\u0022{item}\\\u0022.\u0022);\n                Logger.Info($\u0022SHA256 \\\u0022{checkSum}\\\u0022.\u0022);\n                Logger.Info(FenceOutput);\n            }\n        });\n\n    Target CI =\u003E _ =\u003E _\n        .DependsOn(Compile, Pack, Setup);\n}"
  },
  {
    "Id": 4435095,
    "FirstIndexed": "2020-04-25T15:50:44.7355806+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626726+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434002+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893976+02:00",
    "Name": "Injector",
    "Owner": "nefarius",
    "HtmlUrl": "https://github.com/nefarius/Injector",
    "Description": "Command line utility to inject and eject DLLs",
    "Archived": false,
    "Stars": 90,
    "Watchers": 8,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nefarius/Injector/blob/master/build/Build.cs",
    "BuildFileSize": 2074,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(SolutionFile)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(SolutionFile)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild)\n                .SetTargetPlatform(MSBuildTargetPlatform.x64));\n\n            MSBuild(s =\u003E s\n                .SetTargetPath(SolutionFile)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild)\n                .SetTargetPlatform(MSBuildTargetPlatform.Win32));\n        });\n\n    private Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(SolutionFile)\n                .SetTargets(\u0022Restore\u0022, \u0022Pack\u0022)\n                .SetPackageOutputPath(ArtifactsDirectory)\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols());\n        });\n}\n"
  },
  {
    "Id": 6658903,
    "FirstIndexed": "2020-04-25T15:50:44.7354691+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632336+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433546+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939316+02:00",
    "Name": "SimpleWavSplitter",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/SimpleWavSplitter",
    "Description": "Split multi-channel WAV files into single channel WAV files.",
    "Archived": false,
    "Stars": 10,
    "Watchers": 5,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/SimpleWavSplitter/blob/master/build/build/Build.cs",
    "BuildFileSize": 3744,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 7077822,
    "FirstIndexed": "2020-04-25T15:50:44.7355368+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632205+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433808+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939572+02:00",
    "Name": "ForTea",
    "Owner": "MrJul",
    "HtmlUrl": "https://github.com/MrJul/ForTea",
    "Description": "A plugin for ReSharper that adds support for T4 (.tt) files",
    "Archived": false,
    "Stars": 190,
    "Watchers": 29,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/MrJul/ForTea/blob/master/build/Build.cs",
    "BuildFileSize": 4079,
    "BuildFileContent": "using System;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\n[CheckBuildProjectConfigurations]\ninternal class Build : NukeBuild {\n\n\t/// Support plugins are available for:\n\t/// - JetBrains ReSharper        https://nuke.build/resharper\n\t/// - JetBrains Rider            https://nuke.build/rider\n\t/// - Microsoft VisualStudio     https://nuke.build/visualstudio\n\t/// - Microsoft VSCode           https://nuke.build/vscode\n\n\t[Parameter] public readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\t[Parameter] public readonly string NuGetSource = \u0022https://plugins.jetbrains.com/\u0022;\n\t[Parameter] public readonly string NuGetApiKey;\n\n\t[Solution] private readonly Solution _solution;\n\n\tprivate const string MainProjectName = \u0022GammaJul.ReSharper.ForTea\u0022;\n\n\tprivate AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\tprivate AbsolutePath MainProjectDirectory =\u003E SourceDirectory / MainProjectName;\n\tprivate AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022 / Configuration;\n\n\tpublic Target Clean\n\t\t=\u003E _ =\u003E _\n\t\t\t.Before(Restore)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\t\tEnsureCleanDirectory(OutputDirectory);\n\t\t\t});\n\n\tpublic Target Restore\n\t\t=\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tMSBuild(s =\u003E s\n\t\t\t\t\t.SetTargetPath(_solution)\n\t\t\t\t\t.SetTargets(\u0022Restore\u0022));\n\t\t\t});\n\n\tpublic Target Compile\n\t\t=\u003E _ =\u003E _\n\t\t\t.DependsOn(Restore)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tMSBuild(s =\u003E s\n\t\t\t\t\t.SetTargetPath(_solution)\n\t\t\t\t\t.SetTargets(\u0022Rebuild\u0022)\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetMaxCpuCount(Environment.ProcessorCount)\n\t\t\t\t\t.SetNodeReuse(IsLocalBuild));\n\t\t\t});\n\n\tpublic Target Pack\n\t\t=\u003E _ =\u003E _\n\t\t\t.DependsOn(Compile)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar version = GetReleaseVersion();\n\t\t\t\tvar currentYear = DateTime.Now.Year.ToString(CultureInfo.InvariantCulture);\n\t\t\t\tvar releaseNotes = GetReleaseNotes();\n\t\t\t\tvar wave = GetWaveVersion();\n\n\t\t\t\tNuGetPack(s =\u003E s\n\t\t\t\t\t.SetTargetPath(MainProjectDirectory / (MainProjectName \u002B \u0022.nuspec\u0022))\n\t\t\t\t\t.SetBasePath(MainProjectDirectory)\n\t\t\t\t\t.SetOutputDirectory(OutputDirectory)\n\t\t\t\t\t.SetProperty(\u0022version\u0022, version)\n\t\t\t\t\t.SetProperty(\u0022currentyear\u0022, currentYear)\n\t\t\t\t\t.SetProperty(\u0022releasenotes\u0022, releaseNotes)\n\t\t\t\t\t.SetProperty(\u0022wave\u0022, wave)\n\t\t\t\t\t.SetProperty(\u0022configuration\u0022, Configuration.ToString())\n\t\t\t\t\t.EnableNoPackageAnalysis());\n\t\t\t});\n\n\tpublic Target Push\n\t\t=\u003E _ =\u003E _\n\t\t\t.DependsOn(Pack)\n\t\t\t.Requires(() =\u003E NuGetApiKey)\n\t\t\t.Requires(() =\u003E Configuration.Release.Equals(Configuration))\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tGlobFiles(OutputDirectory, \u0022*.nupkg\u0022)\n\t\t\t\t\t.ForEach(x =\u003E NuGetPush(s =\u003E s\n\t\t\t\t\t\t.SetTargetPath(x)\n\t\t\t\t\t\t.SetSource(NuGetSource)\n\t\t\t\t\t\t.SetApiKey(NuGetApiKey)));\n\t\t\t});\n\n\tprivate string GetReleaseVersion()\n\t\t=\u003E File.ReadAllLines(MainProjectDirectory / \u0022Properties/AssemblyInfo.cs\u0022)\n\t\t\t.Select(x =\u003E Regex.Match(x, @\u0022^\\[assembly: AssemblyVersion\\(\u0022\u0022([^\u0022\u0022]*)\u0022\u0022\\)\\]$\u0022))\n\t\t\t.Where(x =\u003E x.Success)\n\t\t\t.Select(x =\u003E x.Groups[1].Value)\n\t\t\t.FirstOrDefault();\n\n\tprivate static string GetReleaseNotes()\n\t\t=\u003E File.ReadAllLines(RootDirectory / \u0022CHANGELOG.md\u0022)\n\t\t\t.SkipWhile(x =\u003E !x.StartsWith(\u0022##\u0022))\n\t\t\t.Skip(1)\n\t\t\t.TakeWhile(x =\u003E !String.IsNullOrWhiteSpace(x))\n\t\t\t.Select(x =\u003E $\u0022\\u2022{x.TrimStart(\u0027-\u0027)}\u0022)\n\t\t\t.JoinNewLine();\n\n\tprivate string GetWaveVersion()\n\t\t=\u003E NuGetPackageResolver.GetLocalInstalledPackages(MainProjectDirectory / (MainProjectName \u002B \u0022.csproj\u0022))\n\t\t\t.SingleOrDefault(x =\u003E x.Id == \u0022Wave\u0022)\n\t\t\t.NotNull(\u0022fullWaveVersion != null\u0022)\n\t\t\t.Version\n\t\t\t.Version\n\t\t\t.ToString(2);\n\n\tpublic static int Main()\n\t\t=\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n}"
  },
  {
    "Id": 10620543,
    "FirstIndexed": "2020-04-25T15:50:44.7356841+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627227+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434445+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940164+02:00",
    "Name": "LocoBase",
    "Owner": "NpoSaut",
    "HtmlUrl": "https://github.com/NpoSaut/LocoBase",
    "Description": "\u0411\u0430\u0437\u0430 \u0434\u0430\u043D\u043D\u044B\u0445 \u043B\u043E\u043A\u043E\u043C\u043E\u0442\u0438\u0432\u043D\u044B\u0445 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u043E\u0432, \u0437\u0430\u043F\u0438\u0441\u044C \u043F\u043E\u0441\u0442\u043E\u044F\u043D\u043D\u044B\u0445 \u0445\u0430\u0440\u0430\u043A\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043A",
    "Archived": false,
    "Stars": 1,
    "Watchers": 4,
    "BuildFilePath": "build/ConfiguratorScript.cs",
    "BuildFileUrl": "https://github.com/NpoSaut/LocoBase/blob/master/build/ConfiguratorScript.cs",
    "BuildFileSize": 1192,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing InstallerTools;\nusing Nuke.Core.IO;\nusing WixSharp;\n\npublic class ConfiguratorScript : InstallerScript\n{\n    readonly PathConstruction.AbsolutePath SolutionDirectory;\n\n    public ConfiguratorScript(PathConstruction.AbsolutePath BinariesPath, string IconFile, PathConstruction.AbsolutePath SolutionDirectory) : base(BinariesPath)\n    {\n        this.SolutionDirectory = SolutionDirectory;\n        this.IconFile          = IconFile;\n    }\n\n    protected override string        IconFile        { get; }\n    protected override Guid          ApplicationGuid =\u003E new Guid(\u002262358510-4DB0-4E83-8092-7C49D84D25C3\u0022);\n    protected override DotNetVersion DotNetVersion   =\u003E DotNetVersion.DotNet4;\n    protected override string        WebPageLink     =\u003E \u0022https://repo.saut.ru/#/tools?tool=\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440\u0022;\n\n    protected override IEnumerable\u003CWixObject\u003E GetAdditionalEntities(IDictionary\u003Cstring, Feature\u003E Features)\n    {\n        yield return new Dir(Features[MainFeatureName], InstallerHelper.GetCommonDataLocation(ProjectName),\n                             new Files(SolutionDirectory / \u0022Data\u0022 / \u0022*.*\u0022));\n    }\n}\n"
  },
  {
    "Id": 11718424,
    "FirstIndexed": "2020-04-25T15:47:03.6112119+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628149+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430685+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936597+02:00",
    "Name": "fluentassertions",
    "Owner": "fluentassertions",
    "HtmlUrl": "https://github.com/fluentassertions/fluentassertions",
    "Description": "Fluent API for asserting the results of unit tests that targets .NET Framework 4.5, 4.7, .NET Standard 1.3, 1.6 and 2.0. Supports the unit test frameworks MSTest, MSTest2, Gallio, NUnit, XUnit, MBunit, MSpec, and NSpec.",
    "Archived": false,
    "Stars": 1785,
    "Watchers": 75,
    "BuildFilePath": "Build/Build.cs",
    "BuildFileUrl": "https://github.com/fluentassertions/fluentassertions/blob/develop/Build/Build.cs",
    "BuildFileSize": 4307,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.Xunit;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[DotNetVerbosityMapping]\nclass Build : NukeBuild\n{\n    /* Support plugins are available for:\n       - JetBrains ReSharper        https://nuke.build/resharper\n       - JetBrains Rider            https://nuke.build/rider\n       - Microsoft VisualStudio     https://nuke.build/visualstudio\n       - Microsoft VSCode           https://nuke.build/vscode\n    */\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(\n        x =\u003E x.UnitTests,\n        x =\u003E x.Pack);\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n    [PackageExecutable(\u0022nspec\u0022, \u0022NSpecRunner.exe\u0022, Version = \u00223.1.0\u0022)] Tool NSpec3;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022Artifacts\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022Tests\u0022;\n    AbsolutePath TestFrameworkDirectory =\u003E TestsDirectory / \u0022TestFrameworks\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoCache()\n                .SetConfigFile(RootDirectory / \u0022nuget.config\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration.Debug)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target ApiChecks =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration.Debug)\n                .CombineWith(\n                    cc =\u003E cc.SetProjectFile(Solution.GetProject(\u0022Approval.Tests\u0022))));\n        });\n\n    Target UnitTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            Xunit2(s =\u003E s\n                .SetFramework(\u0022net47\u0022)\n                .AddTargetAssemblies(GlobFiles(\n                    TestsDirectory,\n                    \u0022FluentAssertions.Specs/bin/Debug/net47/*.Specs.dll\u0022).NotEmpty()));\n\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022FluentAssertions.Specs\u0022))\n                .SetConfiguration(Configuration.Debug)\n                .CombineWith(\n                    cc =\u003E cc.SetFramework(\u0022netcoreapp2.0\u0022),\n                    cc =\u003E cc.SetFramework(\u0022netcoreapp2.1\u0022),\n                    cc =\u003E cc.SetFramework(\u0022netcoreapp3.0\u0022)));\n        });\n\n    Target TestFrameworks =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration.Debug)\n                .CombineWith(\n                    cc =\u003E cc.SetProjectFile(Solution.GetProject(\u0022MSpec.Specs\u0022)),\n                    cc =\u003E cc.SetProjectFile(Solution.GetProject(\u0022MSTestV2.Specs\u0022)),\n                    cc =\u003E cc.SetProjectFile(Solution.GetProject(\u0022NUnit3.Specs\u0022)),\n                    cc =\u003E cc.SetProjectFile(Solution.GetProject(\u0022XUnit2.Specs\u0022))));\n\n            NSpec3(TestFrameworkDirectory / \u0022NSpec3.Net47.Specs\u0022 / \u0022bin\u0022 / \u0022Debug\u0022 / \u0022net47\u0022 / \u0022NSpec3.Specs.dll\u0022);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(ApiChecks)\n        .DependsOn(TestFrameworks)\n        .DependsOn(UnitTests)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022FluentAssertions\u0022))\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetConfiguration(Configuration.Release)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n}\n"
  },
  {
    "Id": 12201538,
    "FirstIndexed": "2020-04-25T15:47:03.6110754+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627915+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430696+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936614+02:00",
    "Name": "aspnetboilerplate",
    "Owner": "aspnetboilerplate",
    "HtmlUrl": "https://github.com/aspnetboilerplate/aspnetboilerplate",
    "Description": "ASP.NET Boilerplate - Web Application Framework",
    "Archived": false,
    "Stars": 8239,
    "Watchers": 804,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/aspnetboilerplate/aspnetboilerplate/blob/dev/build/Build.cs",
    "BuildFileSize": 4820,
    "BuildFileContent": "using System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[MSBuildVerbosityMapping]\n[AzurePipelines(\n    AzurePipelinesImage.WindowsLatest,\n    InvokedTargets = new[] {nameof(Test)},\n    ExcludedTargets = new[] {nameof(Clean)},\n    NonEntryTargets = new[] {nameof(Restore), nameof(Compile)})]\n[AppVeyor(\n    AppVeyorImage.VisualStudioLatest,\n    InvokedTargets = new[] {nameof(Test)},\n    AutoGenerate = false)]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [CI] readonly AzurePipelines AzurePipelines;\n    [Solution] readonly Solution Solution;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            RootDirectory\n                .GlobDirectories(\n                    \u0022*/src/*/obj\u0022,\n                    \u0022*/src/*/bin\u0022,\n                    \u0022*/test/*/obj\u0022,\n                    \u0022*/test/*/bin\u0022)\n                .ForEach(DeleteDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            NuGetRestore(_ =\u003E _\n                .SetTargetPath(Solution));\n\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022SourceLinkCreate\u0022, true));\n        });\n\n    static AbsolutePath PackagesDirectory =\u003E RootDirectory / \u0022output\u0022 / \u0022packages\u0022;\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackagesDirectory)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetProperty(\u0022SourceLinkCreate\u0022, true)\n                .CombineWith(\n                    Solution.AllProjects.Where(x =\u003E x.SolutionFolder?.Name == \u0022src\u0022), (_, v) =\u003E _\n                        .SetProject(v)));\n        });\n\n    [Partition(4)] readonly Partition TestPartition;\n\n    AbsolutePath TestResultDirectory =\u003E RootDirectory / \u0022output\u0022 / \u0022test-results\u0022;\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Partition(() =\u003E TestPartition)\n        .Executes(() =\u003E\n        {\n            var allTestConfigurations =\n                from project in Solution.GetProjects(\u0022*Tests\u0022)\n                from targetFramework in project.GetTargetFrameworks()\n                select (project, targetFramework);\n            var relevantTestConfigurations = TestPartition.GetCurrent(allTestConfigurations);\n\n            try\n            {\n                DotNetTest(_ =\u003E _\n                        .SetConfiguration(Configuration.Release)\n                        .SetNoBuild(InvokedTargets.Contains(Compile))\n                        .SetResultsDirectory(TestResultDirectory)\n                        .CombineWith(relevantTestConfigurations, (_, v) =\u003E _\n                            .SetProjectFile(v.project)\n                            .SetFramework(v.targetFramework)\n                            .SetLogger($\u0022trx;LogFileName={v.project.Name}.trx\u0022)),\n                    completeOnFailure: true);\n            }\n            finally\n            {\n                TestResultDirectory.GlobFiles(\u0022*.trx\u0022).ForEach(x =\u003E\n                    AzurePipelines?.PublishTestResults(\n                        type: AzurePipelinesTestResultsType.VSTest,\n                        title: $\u0022{Path.GetFileNameWithoutExtension(x)} ({AzurePipelines.StageDisplayName})\u0022,\n                        files: new string[] { x }));\n            }\n        });\n}\n"
  },
  {
    "Id": 12639576,
    "FirstIndexed": "2020-04-25T15:50:44.7356818+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627216+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434434+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940152+02:00",
    "Name": "netFirmwaring",
    "Owner": "NpoSaut",
    "HtmlUrl": "https://github.com/NpoSaut/netFirmwaring",
    "Description": "\u0423\u0442\u0438\u043B\u0438\u0442\u044B \u0434\u043B\u044F \u0440\u0430\u0431\u043E\u0442\u044B \u0441 \u043F\u0440\u043E\u0448\u0438\u0432\u043A\u0430\u043C\u0438 \u044F\u0447\u0435\u0435\u043A \u0411\u041B\u041E\u041A",
    "Archived": false,
    "Stars": 1,
    "Watchers": 5,
    "BuildFilePath": "build/AstronautInstallerScript.cs",
    "BuildFileUrl": "https://github.com/NpoSaut/netFirmwaring/blob/master/build/AstronautInstallerScript.cs",
    "BuildFileSize": 668,
    "BuildFileContent": "\uFEFFusing System;\nusing InstallerTools;\nusing Nuke.Core.IO;\n\npublic class AstronautInstallerScript : InstallerScript\n{\n    public AstronautInstallerScript(PathConstruction.AbsolutePath BinariesPath, PathConstruction.AbsolutePath IconFile)\n        : base(BinariesPath)\n    {\n        this.IconFile = IconFile;\n    }\n\n    protected override string        IconFile        { get; }\n    protected override Guid          ApplicationGuid =\u003E new Guid(\u00229199EFD7-6BD3-4D38-BB63-EC7472EF5B41\u0022);\n    protected override DotNetVersion DotNetVersion   =\u003E DotNetVersion.DotNet461;\n    protected override string        WebPageLink     =\u003E \u0022https://repo.saut.ru/#/tools?tool=Astronaut\u0022;\n}\n"
  },
  {
    "Id": 13089025,
    "FirstIndexed": "2020-04-25T15:50:44.7356795+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627199+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434423+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940141+02:00",
    "Name": "netRemoteUpdater",
    "Owner": "NpoSaut",
    "HtmlUrl": "https://github.com/NpoSaut/netRemoteUpdater",
    "Description": "\u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430 \u0434\u043B\u044F \u0434\u0438\u0441\u0442\u0430\u043D\u0446\u0438\u043E\u043D\u043D\u043E\u0433\u043E \u043E\u0431\u0441\u043B\u0443\u0436\u0438\u0432\u0430\u043D\u0438\u044F \u043C\u043E\u0434\u0443\u043B\u0435\u0439",
    "Archived": false,
    "Stars": 0,
    "Watchers": 5,
    "BuildFilePath": "build/CanProgScanInstallerScript.cs",
    "BuildFileUrl": "https://github.com/NpoSaut/netRemoteUpdater/blob/master/build/CanProgScanInstallerScript.cs",
    "BuildFileSize": 643,
    "BuildFileContent": "\uFEFFusing System;\nusing InstallerTools;\nusing Nuke.Core.IO;\n\npublic class CanProgScanInstallerScript : InstallerScript\n{\n    public CanProgScanInstallerScript(PathConstruction.AbsolutePath BinariesPath, string IconFile) : base(BinariesPath)\n    {\n        this.IconFile = IconFile;\n    }\n\n    protected override string        IconFile        { get; }\n    protected override Guid          ApplicationGuid =\u003E new Guid(\u0022D88D727E-0CB0-4D59-B71E-430871CE51BF\u0022);\n    protected override DotNetVersion DotNetVersion   =\u003E DotNetVersion.DotNet461;\n    protected override string        WebPageLink     =\u003E \u0022http://repo.saut.ru/#/tools?tool=CanProg_Scan\u0022;\n}\n"
  },
  {
    "Id": 14964475,
    "FirstIndexed": "2020-04-25T15:50:44.7359082+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629588+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434588+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.89403+02:00",
    "Name": "Avalonia",
    "Owner": "AvaloniaUI",
    "HtmlUrl": "https://github.com/AvaloniaUI/Avalonia",
    "Description": "A multi-platform .NET UI framework",
    "Archived": false,
    "Stars": 8528,
    "Watchers": 440,
    "BuildFilePath": "nukebuild/Build.cs",
    "BuildFileUrl": "https://github.com/AvaloniaUI/Avalonia/blob/master/nukebuild/Build.cs",
    "BuildFileSize": 11479,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing System.Xml.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\nusing static Nuke.Common.Tools.VSWhere.VSWhereTasks;\n\n/*\n Before editing this file, install support plugin for your IDE,\n running and debugging a particular target (optionally without deps) would be way easier\n ReSharper/Rider - https://plugins.jetbrains.com/plugin/10803-nuke-support\n VSCode - https://marketplace.visualstudio.com/items?itemName=nuke.support\n\n */\n\npartial class Build : NukeBuild\n{\n    [Solution(\u0022Avalonia.sln\u0022)] readonly Solution Solution;\n\n    static Lazy\u003Cstring\u003E MsBuildExe = new Lazy\u003Cstring\u003E(() =\u003E\n    {\n        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            return null;\n\n        var msBuildDirectory = VSWhere(\u0022-latest -nologo -property installationPath -format value -prerelease\u0022).FirstOrDefault().Text;\n\n        if (!string.IsNullOrWhiteSpace(msBuildDirectory))\n        {\n            string msBuildExe = Path.Combine(msBuildDirectory, @\u0022MSBuild\\Current\\Bin\\MSBuild.exe\u0022);\n            if (!System.IO.File.Exists(msBuildExe))\n                msBuildExe = Path.Combine(msBuildDirectory, @\u0022MSBuild\\15.0\\Bin\\MSBuild.exe\u0022);\n\n            return msBuildExe;\n        }\n\n        return null;\n    }, false);\n\n    BuildParameters Parameters { get; set; }\n    protected override void OnBuildInitialized()\n    {\n        Parameters = new BuildParameters(this);\n        Information(\u0022Building version {0} of Avalonia ({1}) using version {2} of Nuke.\u0022,\n            Parameters.Version,\n            Parameters.Configuration,\n            typeof(NukeBuild).Assembly.GetName().Version.ToString());\n\n        if (Parameters.IsLocalBuild)\n        {\n            Information(\u0022Repository Name: \u0022 \u002B Parameters.RepositoryName);\n            Information(\u0022Repository Branch: \u0022 \u002B Parameters.RepositoryBranch);\n        }\n        Information(\u0022Configuration: \u0022 \u002B Parameters.Configuration);\n        Information(\u0022IsLocalBuild: \u0022 \u002B Parameters.IsLocalBuild);\n        Information(\u0022IsRunningOnUnix: \u0022 \u002B Parameters.IsRunningOnUnix);\n        Information(\u0022IsRunningOnWindows: \u0022 \u002B Parameters.IsRunningOnWindows);\n        Information(\u0022IsRunningOnAzure:\u0022 \u002B Parameters.IsRunningOnAzure);\n        Information(\u0022IsPullRequest: \u0022 \u002B Parameters.IsPullRequest);\n        Information(\u0022IsMainRepo: \u0022 \u002B Parameters.IsMainRepo);\n        Information(\u0022IsMasterBranch: \u0022 \u002B Parameters.IsMasterBranch);\n        Information(\u0022IsReleaseBranch: \u0022 \u002B Parameters.IsReleaseBranch);\n        Information(\u0022IsReleasable: \u0022 \u002B Parameters.IsReleasable);\n        Information(\u0022IsMyGetRelease: \u0022 \u002B Parameters.IsMyGetRelease);\n        Information(\u0022IsNuGetRelease: \u0022 \u002B Parameters.IsNuGetRelease);\n\n        void ExecWait(string preamble, string command, string args)\n        {\n            Console.WriteLine(preamble);\n            Process.Start(new ProcessStartInfo(command, args) {UseShellExecute = false}).WaitForExit();\n        }\n        ExecWait(\u0022dotnet version:\u0022, \u0022dotnet\u0022, \u0022--version\u0022);\n        if (Parameters.IsRunningOnUnix)\n            ExecWait(\u0022Mono version:\u0022, \u0022mono\u0022, \u0022--version\u0022);\n\n\n    }\n\n    IReadOnlyCollection\u003COutput\u003E MsBuildCommon(\n        string projectFile,\n        Configure\u003CMSBuildSettings\u003E configurator = null)\n    {\n        return MSBuild(c =\u003E c\n            .SetProjectFile(projectFile)\n            // This is required for VS2019 image on Azure Pipelines\n            .When(Parameters.IsRunningOnWindows \u0026\u0026\n                  Parameters.IsRunningOnAzure, c =\u003E c\n                .AddProperty(\u0022JavaSdkDirectory\u0022, GetVariable\u003Cstring\u003E(\u0022JAVA_HOME_8_X64\u0022)))\n            .AddProperty(\u0022PackageVersion\u0022, Parameters.Version)\n            .AddProperty(\u0022iOSRoslynPathHackRequired\u0022, true)\n            .SetToolPath(MsBuildExe.Value)\n            .SetConfiguration(Parameters.Configuration)\n            .SetVerbosity(MSBuildVerbosity.Minimal)\n            .Apply(configurator));\n    }\n\n    Target Clean =\u003E _ =\u003E _.Executes(() =\u003E\n    {\n        Parameters.BuildDirs.ForEach(DeleteDirectory);\n        Parameters.BuildDirs.ForEach(EnsureCleanDirectory);\n        EnsureCleanDirectory(Parameters.ArtifactsDir);\n        EnsureCleanDirectory(Parameters.NugetIntermediateRoot);\n        EnsureCleanDirectory(Parameters.NugetRoot);\n        EnsureCleanDirectory(Parameters.ZipRoot);\n        EnsureCleanDirectory(Parameters.TestResultsRoot);\n    });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            if (Parameters.IsRunningOnWindows)\n                MsBuildCommon(Parameters.MSBuildSolution, c =\u003E c\n                    .SetArgumentConfigurator(a =\u003E a.Add(\u0022/r\u0022))\n                    .AddTargets(\u0022Build\u0022)\n                );\n\n            else\n                DotNetBuild(c =\u003E c\n                    .SetProjectFile(Parameters.MSBuildSolution)\n                    .AddProperty(\u0022PackageVersion\u0022, Parameters.Version)\n                    .SetConfiguration(Parameters.Configuration)\n                );\n        });\n\n    void RunCoreTest(string projectName)\n    {\n        Information($\u0022Running tests from {projectName}\u0022);\n        var project = Solution.GetProject(projectName).NotNull(\u0022project != null\u0022);\n\n        foreach (var fw in project.GetTargetFrameworks())\n        {\n            if (fw.StartsWith(\u0022net4\u0022)\n                \u0026\u0026 RuntimeInformation.IsOSPlatform(OSPlatform.Linux)\n                \u0026\u0026 Environment.GetEnvironmentVariable(\u0022FORCE_LINUX_TESTS\u0022) != \u00221\u0022)\n            {\n                Information($\u0022Skipping {projectName} ({fw}) tests on Linux - https://github.com/mono/mono/issues/13969\u0022);\n                continue;\n            }\n\n            Information($\u0022Running for {projectName} ({fw}) ...\u0022);\n\n            DotNetTest(c =\u003E c\n                .SetProjectFile(project)\n                .SetConfiguration(Parameters.Configuration)\n                .SetFramework(fw)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .When(Parameters.PublishTestResults, c =\u003E c\n                    .SetLogger(\u0022trx\u0022)\n                    .SetResultsDirectory(Parameters.TestResultsRoot)));\n        }\n    }\n\n    Target RunCoreLibsTests =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !Parameters.SkipTests)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            RunCoreTest(\u0022Avalonia.Animation.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Base.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Controls.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Controls.DataGrid.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Input.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Interactivity.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Layout.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Markup.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Markup.Xaml.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Styling.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Visuals.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.Skia.UnitTests\u0022);\n            RunCoreTest(\u0022Avalonia.ReactiveUI.UnitTests\u0022);\n        });\n\n    Target RunRenderTests =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !Parameters.SkipTests)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            RunCoreTest(\u0022Avalonia.Skia.RenderTests\u0022);\n            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n                RunCoreTest(\u0022Avalonia.Direct2D1.RenderTests\u0022);\n        });\n\n    Target RunDesignerTests =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !Parameters.SkipTests \u0026\u0026 Parameters.IsRunningOnWindows)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            RunCoreTest(\u0022Avalonia.DesignerSupport.Tests\u0022);\n        });\n\n    [PackageExecutable(\u0022JetBrains.dotMemoryUnit\u0022, \u0022dotMemoryUnit.exe\u0022)] readonly Tool DotMemoryUnit;\n\n    Target RunLeakTests =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !Parameters.SkipTests \u0026\u0026 Parameters.IsRunningOnWindows)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testAssembly = \u0022tests\\\\Avalonia.LeakTests\\\\bin\\\\Release\\\\net461\\\\Avalonia.LeakTests.dll\u0022;\n            DotMemoryUnit(\n                $\u0022{XunitPath.DoubleQuoteIfNeeded()} --propagate-exit-code -- {testAssembly}\u0022,\n                timeout: 120_000);\n        });\n\n    Target ZipFiles =\u003E _ =\u003E _\n        .After(CreateNugetPackages, Compile, RunCoreLibsTests, Package)\n        .Executes(() =\u003E\n        {\n            var data = Parameters;\n            Zip(data.ZipCoreArtifacts, data.BinRoot);\n            Zip(data.ZipNuGetArtifacts, data.NugetRoot);\n            Zip(data.ZipTargetControlCatalogDesktopDir,\n                GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.dll\u0022).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.config\u0022)).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.so\u0022)).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.dylib\u0022)).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.exe\u0022)));\n        });\n\n    Target CreateIntermediateNugetPackages =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .After(RunTests)\n        .Executes(() =\u003E\n        {\n            if (Parameters.IsRunningOnWindows)\n\n                MsBuildCommon(Parameters.MSBuildSolution, c =\u003E c\n                    .AddTargets(\u0022Pack\u0022));\n            else\n                DotNetPack(c =\u003E c\n                    .SetProject(Parameters.MSBuildSolution)\n                    .SetConfiguration(Parameters.Configuration)\n                    .AddProperty(\u0022PackageVersion\u0022, Parameters.Version));\n        });\n\n    Target CreateNugetPackages =\u003E _ =\u003E _\n        .DependsOn(CreateIntermediateNugetPackages)\n        .Executes(() =\u003E\n        {\n            var config = Numerge.MergeConfiguration.LoadFile(RootDirectory / \u0022nukebuild\u0022 / \u0022numerge.config\u0022);\n            EnsureCleanDirectory(Parameters.NugetRoot);\n            if(!Numerge.NugetPackageMerger.Merge(Parameters.NugetIntermediateRoot, Parameters.NugetRoot, config,\n                new NumergeNukeLogger()))\n                throw new Exception(\u0022Package merge failed\u0022);\n        });\n\n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(RunCoreLibsTests)\n        .DependsOn(RunRenderTests)\n        .DependsOn(RunDesignerTests)\n        .DependsOn(RunLeakTests);\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(RunTests)\n        .DependsOn(CreateNugetPackages);\n\n    Target CiAzureLinux =\u003E _ =\u003E _\n        .DependsOn(RunTests);\n\n    Target CiAzureOSX =\u003E _ =\u003E _\n        .DependsOn(Package)\n        .DependsOn(ZipFiles);\n\n    Target CiAzureWindows =\u003E _ =\u003E _\n        .DependsOn(Package)\n        .DependsOn(ZipFiles);\n\n\n    public static int Main() =\u003E\n        RuntimeInformation.IsOSPlatform(OSPlatform.Windows)\n            ? Execute\u003CBuild\u003E(x =\u003E x.Package)\n            : Execute\u003CBuild\u003E(x =\u003E x.RunTests);\n\n}\n\npublic static class ToolSettingsExtensions\n{\n    public static T Apply\u003CT\u003E(this T settings, Configure\u003CT\u003E configurator)\n    {\n        return configurator != null ? configurator(settings) : settings;\n    }\n}\n"
  },
  {
    "Id": 15092321,
    "FirstIndexed": "2020-04-25T15:50:44.735448+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630715+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843345+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939231+02:00",
    "Name": "ReSharper.EnhancedTooltip",
    "Owner": "MrJul",
    "HtmlUrl": "https://github.com/MrJul/ReSharper.EnhancedTooltip",
    "Description": "A plugin for JetBrains Resharper that colorizes the tooltip and parameter information.",
    "Archived": false,
    "Stars": 140,
    "Watchers": 27,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/MrJul/ReSharper.EnhancedTooltip/blob/master/build/Build.cs",
    "BuildFileSize": 4159,
    "BuildFileContent": "using System;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\n[CheckBuildProjectConfigurations]\ninternal class Build : NukeBuild {\n\n\t// Support plugins are available for:\n\t// - JetBrains ReSharper        https://nuke.build/resharper\n\t// - JetBrains Rider            https://nuke.build/rider\n\t// - Microsoft VisualStudio     https://nuke.build/visualstudio\n\t// - Microsoft VSCode           https://nuke.build/vscode\n\n\t[Parameter] public readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\t[Parameter] public readonly string NuGetSource = \u0022https://plugins.jetbrains.com/\u0022;\n\t[Parameter] public readonly string NuGetApiKey;\n\n\t[Solution] private readonly Solution _solution;\n\n\tprivate const string MainProjectName = \u0022GammaJul.ReSharper.EnhancedTooltip\u0022;\n\n\tprivate AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\tprivate AbsolutePath MainProjectDirectory =\u003E SourceDirectory / MainProjectName;\n\tprivate AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022 / Configuration;\n\n\tpublic Target Clean\n\t\t=\u003E _ =\u003E _\n\t\t\t.Before(Restore)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\t\tEnsureCleanDirectory(OutputDirectory);\n\t\t\t});\n\n\tpublic Target Restore\n\t\t=\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tMSBuild(s =\u003E s\n\t\t\t\t\t.SetTargetPath(_solution)\n\t\t\t\t\t.SetTargets(\u0022Restore\u0022));\n\t\t\t});\n\n\tpublic Target Compile\n\t\t=\u003E _ =\u003E _\n\t\t\t.DependsOn(Restore)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tMSBuild(s =\u003E s\n\t\t\t\t\t.SetTargetPath(_solution)\n\t\t\t\t\t.SetTargets(\u0022Rebuild\u0022)\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetMaxCpuCount(Environment.ProcessorCount)\n\t\t\t\t\t.SetNodeReuse(IsLocalBuild));\n\t\t\t});\n\n\tpublic Target Pack\n\t\t=\u003E _ =\u003E _\n\t\t\t.DependsOn(Compile)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar version = GetReleaseVersion();\n\t\t\t\tvar currentYear = DateTime.Now.Year.ToString(CultureInfo.InvariantCulture);\n\t\t\t\tvar releaseNotes = GetReleaseNotes();\n\t\t\t\tvar wave = GetWaveVersion();\n\n\t\t\t\tif (Configuration.Equals(Configuration.Debug))\n\t\t\t\t\tversion \u002B= \u0022-pre\u0022;\n\n\t\t\t\tNuGetPack(s =\u003E s\n\t\t\t\t\t.SetTargetPath(MainProjectDirectory / (MainProjectName \u002B \u0022.nuspec\u0022))\n\t\t\t\t\t.SetBasePath(MainProjectDirectory)\n\t\t\t\t\t.SetOutputDirectory(OutputDirectory)\n\t\t\t\t\t.SetProperty(\u0022version\u0022, version)\n\t\t\t\t\t.SetProperty(\u0022currentyear\u0022, currentYear)\n\t\t\t\t\t.SetProperty(\u0022releasenotes\u0022, releaseNotes)\n\t\t\t\t\t.SetProperty(\u0022wave\u0022, wave)\n\t\t\t\t\t.SetProperty(\u0022configuration\u0022, Configuration.ToString())\n\t\t\t\t\t.EnableNoPackageAnalysis());\n\t\t\t});\n\n\tpublic Target Push\n\t\t=\u003E _ =\u003E _\n\t\t\t.DependsOn(Pack)\n\t\t\t.Requires(() =\u003E NuGetApiKey)\n\t\t\t.Requires(() =\u003E Configuration.Release.Equals(Configuration))\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tGlobFiles(OutputDirectory, \u0022*.nupkg\u0022)\n\t\t\t\t\t.ForEach(x =\u003E NuGetPush(s =\u003E s\n\t\t\t\t\t\t.SetTargetPath(x)\n\t\t\t\t\t\t.SetSource(NuGetSource)\n\t\t\t\t\t\t.SetApiKey(NuGetApiKey)));\n\t\t\t});\n\n\tprivate string GetReleaseVersion()\n\t\t=\u003E File.ReadAllLines(MainProjectDirectory / \u0022Properties/AssemblyInfo.cs\u0022)\n\t\t\t.Select(x =\u003E Regex.Match(x, @\u0022^\\[assembly: AssemblyVersion\\(\u0022\u0022([^\u0022\u0022]*)\u0022\u0022\\)\\]$\u0022))\n\t\t\t.Where(x =\u003E x.Success)\n\t\t\t.Select(x =\u003E x.Groups[1].Value)\n\t\t\t.FirstOrDefault();\n\n\tprivate static string GetReleaseNotes()\n\t\t=\u003E File.ReadAllLines(RootDirectory / \u0022CHANGELOG.md\u0022)\n\t\t\t.SkipWhile(x =\u003E !x.StartsWith(\u0022##\u0022))\n\t\t\t.Skip(1)\n\t\t\t.TakeWhile(x =\u003E !String.IsNullOrWhiteSpace(x))\n\t\t\t.Select(x =\u003E $\u0022\\u2022{x.TrimStart(\u0027-\u0027)}\u0022)\n\t\t\t.JoinNewLine();\n\n\tprivate string GetWaveVersion()\n\t\t=\u003E NuGetPackageResolver.GetLocalInstalledPackages(MainProjectDirectory / (MainProjectName \u002B \u0022.csproj\u0022))\n\t\t\t.SingleOrDefault(x =\u003E x.Id == \u0022Wave\u0022)\n\t\t\t.NotNull(\u0022fullWaveVersion != null\u0022)\n\t\t\t.Version\n\t\t\t.Version\n\t\t\t.ToString(2);\n\n\tpublic static int Main()\n\t\t=\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n}"
  },
  {
    "Id": 16904123,
    "FirstIndexed": "2020-04-25T15:50:44.7356773+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627182+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434417+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940135+02:00",
    "Name": "netEMapTools",
    "Owner": "NpoSaut",
    "HtmlUrl": "https://github.com/NpoSaut/netEMapTools",
    "Description": "\u0423\u0442\u0438\u043B\u0438\u0442\u044B \u0434\u043B\u044F \u0432\u0438\u0437\u0443\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u0438 \u0440\u0430\u0431\u043E\u0442\u044B \u0441 \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0439 \u041A\u041B\u0423\u0411",
    "Archived": false,
    "Stars": 0,
    "Watchers": 6,
    "BuildFilePath": "build/MapViewerInstallerScript.cs",
    "BuildFileUrl": "https://github.com/NpoSaut/netEMapTools/blob/master/build/MapViewerInstallerScript.cs",
    "BuildFileSize": 1169,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing InstallerTools;\nusing Nuke.Core.IO;\nusing WixSharp;\nusing WixSharp.CommonTasks;\n\nclass MapViewerInstallerScript : InstallerScript\n{\n    public MapViewerInstallerScript(PathConstruction.AbsolutePath BinariesPath, string IconFile) : base(BinariesPath)\n    {\n        this.IconFile = IconFile;\n    }\n\n    protected override string        IconFile        { get; }\n    protected override Guid          ApplicationGuid =\u003E new Guid(\u0022E9D8C57F-D4D0-4772-A508-1F21C627B892\u0022);\n    protected override DotNetVersion DotNetVersion   =\u003E DotNetVersion.DotNet45;\n    protected override string        WebPageLink     =\u003E \u0022https://repo.saut.ru/#/tools?tool=MapViewer\u0022;\n\n    protected override void ConfigureProject(Project Project)\n    {\n        Project.ResolveWildCards(true)\n               .FindFile(f =\u003E f.Name.EndsWith(ExeFileName))\n               .First()\n               .AddAssociation(new FileAssociation(\u0022gps\u0022, \u0022application/blok-map-project\u0022, \u0022\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0432 MapViewer\u0022, \u0022\\\u0022%1\\\u0022\u0022)\n               {\n                   Icon        = \u0022gpsfile.ico\u0022,\n                   Description = \u0022\u041A\u0430\u0440\u0442\u0430 \u041A\u041B\u0423\u0411/\u0411\u041B\u041E\u041A\u0022\n               });\n    }\n}\n"
  },
  {
    "Id": 17229547,
    "FirstIndexed": "2020-04-25T15:47:03.6114349+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631335+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430708+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936625+02:00",
    "Name": "RateLimiters",
    "Owner": "robertmircea",
    "HtmlUrl": "https://github.com/robertmircea/RateLimiters",
    "Description": "Token bucket and leaky token bucket implementations in .NET",
    "Archived": false,
    "Stars": 113,
    "Watchers": 10,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/robertmircea/RateLimiters/blob/master/build/Build.cs",
    "BuildFileSize": 4038,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    string Source =\u003E \u0022https://api.nuget.org/v3/index.json\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath SrcDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n    \n    \n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s \n                .SetProject(Solution.GetProject(\u0022Bert.RateLimiters\u0022))\n                .SetAuthors(\u0022Robert Mircea\u0022)\n                .SetPackageId(\u0022Bert.RateLimiters\u0022)\n                .SetPackageLicenseUrl(\u0022https://raw.githubusercontent.com/robertmircea/RateLimiters/master/LICENSE\u0022)\n                .SetPackageProjectUrl(\u0022https://github.com/robertmircea/RateLimiters\u0022)\n                .SetDescription(\u0022Popular rate limiting algorithms. C# implementations of fixed token bucket and leaky token bucket throttling strategies\u0022)\n                .SetPackageReleaseNotes(\u0022Updated to .NETStandard\u0022)\n                .SetCopyright(\u00222014-2019\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols()\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .SetPackageRequireLicenseAcceptance(false)\n                .SetPackageTags(\u0022ratelimiting\u0022,\u0022throttling\u0022,\u0022leakybucket\u0022,\u0022tokenbucket\u0022)\n            );\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Equals(Configuration, Configuration.Release))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)));\n        });\n}\n"
  },
  {
    "Id": 21444864,
    "FirstIndexed": "2020-04-25T15:50:44.735506+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630043+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433706+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893947+02:00",
    "Name": "snowflake",
    "Owner": "SnowflakePowered",
    "HtmlUrl": "https://github.com/SnowflakePowered/snowflake",
    "Description": " :snowflake: :video_game: Extensible Emulator Frontend written in C# and Javascript",
    "Archived": false,
    "Stars": 172,
    "Watchers": 10,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/SnowflakePowered/snowflake/blob/master/build/Build.cs",
    "BuildFileSize": 5457,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Xml;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E GetOutDirectory();\n\n    AbsolutePath Tooling =\u003E SourceDirectory / \u0022Snowflake.Tooling.Taskrunner\u0022;\n    AbsolutePath Tests =\u003E SourceDirectory / \u0022Snowflake.Framework.Tests\u0022;\n\n    AbsolutePath BuildDirectory =\u003E RootDirectory / \u0022build\u0022;\n    AbsolutePath CoveragePath =\u003E BuildDirectory / \u0022coverage\u0022;\n\n    AbsolutePath ToolingDirectory =\u003E BuildDirectory / \u0022snowflake-cli\u0022;\n\n    Target RestoreTooling =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetToolUpdate(s =\u003E s\n                .SetPackageName(\u0022Snowflake.Tooling.Cli\u0022)\n            );\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target BuildTooling =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .Executes(() =\u003E\n       {\n           DotNetBuild(s =\u003E s\n               .SetProjectFile(Tooling)\n               .SetOutputDirectory(ToolingDirectory));\n       });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Tests)\n                .SetLogger(\u0022trx\u0022)\n                \n            );\n        });\n\n    Target PackModules =\u003E _ =\u003E _\n        .DependsOn(RestoreTooling)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(OutputDirectory);\n\n            foreach (Project p in Solution.GetProjects(\u0022Snowflake.*\u0022))\n            {\n                if (!GetSdkVersion(p).StartsWith(\u0022Snowflake.Framework.Sdk\u0022)) continue;\n                if (!File.Exists((p.Directory / \u0022module.json\u0022))) continue;\n\n                DotNet(\u0022snowflake build\u0022, p.Directory);\n                DotNet($\u0022snowflake pack -o \\\u0022{OutputDirectory}\\\u0022\u0022, p.Directory);\n            }\n        });\n\n    Target PackFramework =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(OutputDirectory);\n            foreach (Project p in Solution.GetProjects(\u0022Snowflake.Framework*\u0022))\n            {\n                DotNetPack(s =\u003E s\n                    .SetProject(p.Path)\n                    .SetOutputDirectory(OutputDirectory)\n                    .SetVersionSuffix($\u0022alpha.{GetBuildNumber()}\u0022));\n            }\n        });\n\n    Target Bootstrap =\u003E _ =\u003E _\n        .DependsOn(RestoreTooling)\n        .DependsOn(PackModules)\n        .Executes(() =\u003E\n        {\n            DotNet($\u0022snowflake install-all -d {OutputDirectory}\u0022);\n        });\n\n    Target PackAll =\u003E _ =\u003E _\n        // .DependsOn(Test)\n        .DependsOn(PackModules)\n        .DependsOn(PackFramework);\n    \n    static string GetBuildNumber()\n    {\n        string buildNumber = EnvironmentInfo.GetVariable\u003Cstring\u003E(\u0022BUILD_NUMBER\u0022);\n        if (String.IsNullOrWhiteSpace(buildNumber))\n        {\n            return \u0022dirty\u0022;\n        }\n        return buildNumber;\n    }\n\n    static AbsolutePath GetOutDirectory()\n    {\n        string staging = EnvironmentInfo.GetVariable\u003Cstring\u003E(\u0022STAGING\u0022);\n        if (String.IsNullOrWhiteSpace(staging))\n        {\n            return RootDirectory / \u0022out\u0022;\n        }\n        return (AbsolutePath)staging;\n    }\n\n    static string GetSdkVersion(Project p)\n    {\n        using (XmlReader reader = XmlReader.Create(p.Path))\n        {\n            if (reader.MoveToContent() == XmlNodeType.Element \u0026\u0026 reader.HasAttributes)\n            {\n                if (reader.MoveToAttribute(\u0022Sdk\u0022))\n                {\n                    return reader.ReadContentAsString();\n                }\n            }\n        }\n        return String.Empty;\n    }\n}\n"
  },
  {
    "Id": 24488923,
    "FirstIndexed": "2020-04-25T15:50:44.7361852+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632279+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434889+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940613+02:00",
    "Name": "Chill",
    "Owner": "ChillBDD",
    "HtmlUrl": "https://github.com/ChillBDD/Chill",
    "Description": "Chill, a BDD style testing framework - \u0022If you stick it in a container, Chill will keep it cool\u0022",
    "Archived": false,
    "Stars": 42,
    "Watchers": 8,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ChillBDD/Chill/blob/master/build/Build.cs",
    "BuildFileSize": 3865,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Tools.Xunit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\npublic class Build : NukeBuild\n{\n    public static int Main()\n    {\n        return Execute\u003CBuild\u003E(x =\u003E x.Package);\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022Chill.sln\u0022)] \n    readonly Solution Solution;\n        \n    [GitVersion] \n    readonly GitVersion GitVersion;\n\n    [PackageExecutable(\u0022ILRepack\u0022, \u0022ilrepack.exe\u0022)]\n    readonly Tool ILRepack;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target UnitTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(TestsDirectory / \u0022Chill.Specs/Chill.Specs.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .SetNoBuild(true)\n                );\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(UnitTests)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetNoBuild(true)\n                .SetProject(SourceDirectory / \u0022Chill/Chill.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .SetFramework(\u0022netstandard1.1\u0022));\n            \n            DotNetPublish(s =\u003E s\n                .SetNoBuild(true)\n                .SetProject(SourceDirectory / \u0022Chill/Chill.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .SetFramework(\u0022netstandard2.0\u0022));\n\n            ILRepack($\u0022/out:{ArtifactsDirectory}\\\\netstandard1.1\\\\Chill.dll /xmldocs \u0022 \u002B\n                     $\u0022{SourceDirectory}\\\\Chill\\\\bin/{Configuration}\\\\netstandard1.1\\\\publish\\\\Chill.dll \u0022 \u002B\n                     $\u0022{SourceDirectory}\\\\Chill\\\\bin/{Configuration}\\\\netstandard1.1\\\\publish\\\\Autofac.dll \u0022);\n\n            ILRepack($\u0022/out:{ArtifactsDirectory}\\\\netstandard2.0\\\\Chill.dll /xmldocs \u0022 \u002B\n                     $\u0022{SourceDirectory}\\\\Chill\\\\bin/{Configuration}\\\\netstandard2.0\\\\publish\\\\Chill.dll \u0022 \u002B\n                     $\u0022{SourceDirectory}\\\\Chill\\\\bin/{Configuration}\\\\netstandard2.0\\\\publish\\\\Autofac.dll \u0022);\n\n            NuGetTasks.NuGetPack(SourceDirectory / \u0022Chill/.nuspec\u0022, GitVersion.NuGetVersionV2, s =\u003E s\n                .SetBasePath(ArtifactsDirectory)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetBuild(false));\n        });\n}"
  },
  {
    "Id": 27265209,
    "FirstIndexed": "2020-04-25T15:50:44.7351129+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628706+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433279+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939049+02:00",
    "Name": "NodaMoney",
    "Owner": "DynamicHands",
    "HtmlUrl": "https://github.com/DynamicHands/NodaMoney",
    "Description": "NodaMoney provides a library that treats Money as a first class citizen and handles all the ugly bits like currencies and formatting. ",
    "Archived": false,
    "Stars": 120,
    "Watchers": 12,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/DynamicHands/NodaMoney/blob/master/build/Build.cs",
    "BuildFileSize": 5779,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.CoverallsNet;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.CoverallsNet.CoverallsNetTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.GitHub.GitHubTasks;\nusing static Nuke.Common.Tools.GitReleaseManager.GitReleaseManagerTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022NuGet Api Key\u0022)]\n    readonly string NuGetApiKey; // EnvironmentVariable NUGET_API_KEY\n\n    [Parameter(\u0022Coveralls Repository Token\u0022)]\n    readonly string CoverallsRepoToken; // EnvironmentVariable COVERALLS_REPO_TOKEN\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    [CI] readonly AppVeyor AppVeyor;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath CoverageFile =\u003E RootDirectory / \u0022artifacts\u0022 / \u0022coverage.xml\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.FullSemVer)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(CoverageFile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .When(ExecutingTargets.Contains(Coverage), s =\u003E s\n                    .EnableCollectCoverage()\n                    .SetCoverletOutput(CoverageFile)\n                    .SetCoverletOutputFormat(CoverletOutputFormat.opencover)));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(ArtifactsDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersion)\n                .EnableIncludeSymbols()\n                .EnableNoBuild());\n        });\n\n    Target NuGetPush =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .OnlyWhenStatic(() =\u003E AppVeyor.PullRequestNumber == 0) // if build not started by PR\n        .OnlyWhenStatic(() =\u003E AppVeyor.RepositoryTag) // if build has started by pushed tag\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E AppVeyor)\n        .Executes(() =\u003E\n        {\n            var packages = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022);\n\n            DotNetNuGetPush(s =\u003E s\n                .SetWorkingDirectory(ArtifactsDirectory)\n                .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                .SetApiKey(NuGetApiKey));\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .OnlyWhenStatic(() =\u003E AppVeyor.PullRequestNumber == 0) // if build not started by PR\n        .Requires(() =\u003E CoverallsRepoToken)\n        .Executes(() =\u003E\n        {\n            if (AppVeyor != null)\n            {\n                CoverallsNet(s =\u003E s\n                    .SetRepoToken(CoverallsRepoToken)\n                    .EnableOpenCover()\n                    .SetInput(CoverageFile) \n                    .SetCommitId(AppVeyor.RepositoryCommitSha)\n                    .SetCommitBranch(AppVeyor.RepositoryBranch)\n                    .SetCommitAuthor(AppVeyor.RepositoryCommitAuthor)\n                    .SetCommitEmail(AppVeyor.RepositoryCommitAuthorEmail)\n                    .SetCommitMessage(AppVeyor.RepositoryCommitMessage)\n                    .SetJobId(AppVeyor.BuildNumber)\n                    .SetServiceName(AppVeyor.GetType().Name));\n            }\n            else\n            {\n                CoverallsNet(s =\u003E s\n                    .SetRepoToken(CoverallsRepoToken)\n                    .EnableOpenCover()\n                    .SetInput(CoverageFile)\n                    .SetCommitId(GitVersion.Sha)\n                    .SetCommitBranch(GitVersion.BranchName)\n                    .SetServiceName(\u0022Local\u0022));\n            }\n        });\n\n    Target Publish  =\u003E _ =\u003E _\n        .DependsOn(Clean, Pack, Coverage, NuGetPush);\n}\n"
  },
  {
    "Id": 28628586,
    "FirstIndexed": "2020-04-25T15:47:03.611353+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631039+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430719+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936637+02:00",
    "Name": "AlphaVSS",
    "Owner": "alphaleonis",
    "HtmlUrl": "https://github.com/alphaleonis/AlphaVSS",
    "Description": "AlphaVSS is a .NET class library released under the MIT license providing a managed API for the Volume Shadow Copy Service also known as VSS.",
    "Archived": false,
    "Stars": 121,
    "Watchers": 9,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/alphaleonis/AlphaVSS/blob/develop/build/Build.cs",
    "BuildFileSize": 9211,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Newtonsoft.Json;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.VSWhere;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing Nuke.DocFX;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing Nuke.Common.CI.AzurePipelines;\nusing System.Threading;\nusing System.Text;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[MSBuildVerbosityMapping]\nclass AlphaVssBuild : NukeBuild\n{\n   public static int Main() =\u003E Execute\u003CAlphaVssBuild\u003E(x =\u003E x.Compile);\n   \n\n   [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n   readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n   [Parameter]\n   readonly string FeedUri;\n\n   [Parameter]\n   readonly string NuGetApiKey = \u0022VSTS\u0022;\n\n   [Solution] readonly Solution Solution;\n   [GitRepository] readonly GitRepository GitRepository;\n   [GitVersion] readonly GitVersion GitVersion;\n\n   string RequiredMSBuildVersion = \u0022[16.4,)\u0022;\n\n   AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n   AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n   AbsolutePath NuSpecDirectory =\u003E RootDirectory / \u0022build\u0022 / \u0022nuget\u0022;\n   AbsolutePath DocFxFile =\u003E RootDirectory / \u0022docs\u0022 / \u0022docfx.json\u0022;\n   AbsolutePath PackageArtifactsDirectory =\u003E ArtifactsDirectory / \u0022package\u0022;\n   AbsolutePath DocFxArtifactsDirectory =\u003E ArtifactsDirectory / \u0022docs\u0022;\n   AbsolutePath DocFxZipFilePath =\u003E ArtifactsDirectory / \u0022docs.zip\u0022;\n\n   string MSBuildToolPath;\n\n   protected override void OnBuildInitialized()\n   {\n      base.OnBuildInitialized();\n      var result =\n         VSWhereTasks.VSWhere(s =\u003E s\n            .SetVersion(RequiredMSBuildVersion)\n            .EnableLatest()\n            .EnablePrerelease()\n            .EnableUTF8()\n            .SetLogOutput(Verbosity == Verbosity.Verbose)\n            .SetProperty(\u0022InstallationPath\u0022)\n            .SetFormat(VSWhereFormat.value)\n      ).Output.EnsureOnlyStd().FirstOrDefault().Text;\n\n      var vsInstance = result.FirstOrDefault().NotNull($\u0022Unable to find VS version {RequiredMSBuildVersion}\u0022);\n      MSBuildToolPath = Path.Combine(result, \u0022MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe\u0022);\n      Logger.Normal($\u0022Using MSBuild at \\\u0022{MSBuildToolPath}\\\u0022\u0022);\n      MSBuildLogger = CustomMSBuildLogger;\n      NuGetLogger = CustomNuGetLogger;\n      if (IsServerBuild)\n      { \n         AzurePipelines.Instance.UpdateBuildNumber($\u0022AlphaVSS-{GitVersion.SemVer}\u0022)\n            ;\n      }\n   }\n\n   internal static void CustomMSBuildLogger(OutputType type, string output)\n   {\n      if (type == OutputType.Err || output.IndexOf(\u0022: error\u0022, StringComparison.Ordinal) != -1)\n         Logger.Error(output);\n      else if (output.IndexOf(\u0022: warning\u0022, StringComparison.Ordinal) != -1)\n         Logger.Warn(output);\n      else\n         Logger.Normal(output);\n\n   }\n\n   internal static void CustomNuGetLogger(OutputType type, string output)\n   {\n      if (type == OutputType.Err || output.StartsWith(\u0022ERROR:\u0022, StringComparison.OrdinalIgnoreCase))\n         Logger.Error(output);\n      else if (output.StartsWith(\u0022WARNING:\u0022, StringComparison.OrdinalIgnoreCase))\n         Logger.Warn(output);\n      else\n         Logger.Normal(output);\n   }\n\n   Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n           SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n           EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n   Target Restore =\u003E _ =\u003E _\n       .Executes(() =\u003E\n       {\n          MSBuild(_ =\u003E _\n               .SetToolPath(MSBuildToolPath)\n               .SetTargetPath(Solution)\n               .SetTargets(\u0022Restore\u0022));\n       });\n\n   Target Compile =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .Executes(() =\u003E\n       {\n          BuildProject(\u0022AlphaVSS.Common\u0022, Configuration, \u0022AnyCPU\u0022);\n\n          BuildPlatformProject(\u0022core31\u0022);\n          BuildPlatformProject(\u0022net45\u0022);\n\n\n          void BuildPlatformProject(string projectConfigurationPrefix)\n          {\n             projectConfigurationPrefix = Configuration == Configuration.Debug ? $\u0022{projectConfigurationPrefix}d\u0022 : projectConfigurationPrefix;\n             BuildProject(\u0022AlphaVSS.Platform\u0022, projectConfigurationPrefix, \u0022Win32\u0022);\n             BuildProject(\u0022AlphaVSS.Platform\u0022, projectConfigurationPrefix, \u0022x64\u0022);\n          }\n\n          void BuildProject(string projectName, string configuration, string platform)\n          {\n             var project = Solution.AllProjects.FirstOrDefault(p =\u003E p.Name == projectName).NotNull($\u0022Unable to find project named {projectName} in solution {Solution.Name}\u0022);\n\n             MSBuild(_ =\u003E _\n                  .SetToolPath(MSBuildToolPath)\n                  .SetTargetPath(project)\n                  .SetTargetPlatform((MSBuildTargetPlatform)platform)\n                  .SetConfiguration(configuration)\n                  .SetTargets(\u0022Build\u0022)\n                  .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                  .SetFileVersion(GitVersion.AssemblySemFileVer)\n                  .SetInformationalVersion(GitVersion.InformationalVersion)\n                  .AddProperty(\u0022BuildProjectReferences\u0022, false)\n                  .AddProperty(\u0022AlphaVss_VersionMajor\u0022, 1)\n                  .SetInformationalVersion(GitVersion.InformationalVersion)\n                  .SetMaxCpuCount(Environment.ProcessorCount)\n                  .SetNodeReuse(IsLocalBuild));\n          }\n       });\n\n   Target DocMetadata =\u003E _ =\u003E _\n      .DependsOn(Compile)\n      .Executes(() =\u003E\n      {\n         DocFXTasks.DocFXMetadata(s =\u003E s\n            .SetProjects(DocFxFile)\n            .SetLogLevel(DocFXLogLevel.Verbose)            \n         );\n      });\n\n   Target DocBuild =\u003E _ =\u003E _\n      .DependsOn(DocMetadata)\n      .Executes(() =\u003E\n      {\n         DocFXTasks.DocFXBuild(s =\u003E s\n            .SetConfigFile(DocFxFile)\n            .SetLogLevel(DocFXLogLevel.Verbose)\n            );         \n      });\n\n   Target DocPack =\u003E _ =\u003E _\n      .DependsOn(DocBuild)\n      .Executes(() =\u003E\n      {\n         CompressionTasks.CompressZip(DocFxArtifactsDirectory, DocFxZipFilePath);\n      });\n\n   Target ServeDocs =\u003E _ =\u003E _\n      .DependsOn(DocBuild)\n      .OnlyWhenStatic(() =\u003E IsLocalBuild)\n      .Executes(() =\u003E\n      {\n         DocFXTasks.DocFXServe(s =\u003E s\n            .SetFolder(ArtifactsDirectory / \u0022docs\u0022)\n         );\n      });\n\n   Target Build =\u003E _ =\u003E _\n      .DependsOn(Clean, Compile);\n\n   Target Pack =\u003E _ =\u003E _\n      .DependsOn(Build)\n      .Executes(() =\u003E\n      {\n         var version = GitVersion.NuGetVersion;\n         if (IsLocalBuild)\n            version \u002B= DateTime.UtcNow.ToString(\u0022yyMMddHHmmss\u0022);\n\n         foreach (var nuspec in GlobFiles(NuSpecDirectory, \u0022*.nuspec\u0022))\n         {\n            NuGetPack(s =\u003E s\n               .SetMSBuildPath(MSBuildToolPath)\n               .SetOutputDirectory(ArtifactsDirectory)\n               .AddProperty(\u0022branch\u0022, GitVersion.BranchName)\n               .AddProperty(\u0022commit\u0022, GitVersion.Sha)\n               .SetVersion(version)\n               .SetTargetPath(nuspec)\n            );\n         }\n      });\n\n   Target Push =\u003E _ =\u003E _\n      .DependsOn(Pack)\n      .Requires(() =\u003E FeedUri)\n      .Executes(() =\u003E\n      {\n         foreach (var file in GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022))\n         {\n            NuGetPush(s =\u003E s\n               .SetApiKey(NuGetApiKey)\n               .SetSource(FeedUri)\n               .SetTargetPath(file));\n         }\n      });\n\n   Target UploadArtifacts =\u003E _ =\u003E _\n      .DependsOn(Clean, Pack, DocPack)\n      .OnlyWhenStatic(() =\u003E IsServerBuild)\n      .Executes(() =\u003E\n      {\n         foreach (var file in GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022))\n         {\n            UploadAzureArtifact(\u0022Package\u0022, \u0022Package\u0022, file);\n         }\n         //UploadAzureArtifact(\u0022Package\u0022, \u0022Package\u0022, null);\n         \n         Thread.Sleep(2000);\n         AzurePipelines.Instance.UploadArtifacts(\u0022docs\u0022, \u0022docs\u0022, DocFxZipFilePath);         \n      });\n\n   private void UploadAzureArtifact(string containerFolder, string artifactName, string fileName)\n   {\n      // ##vso[artifact.upload containerfolder=testresult;artifactname=uploadedresult;]c:\\testresult.trx\n      StringBuilder command = new StringBuilder(\u0022##vso[artifact.upload containerfolder=\u0022);\n      command.Append(containerFolder);\n      command.Append(\u0027;\u0027);\n      if (!String.IsNullOrEmpty(artifactName))\n      {\n         command.Append(\u0022artifactname=\u0022);\n         command.Append(artifactName);\n         command.Append(\u0027;\u0027);\n      }\n\n      command.Append(\u0022]\u0022);\n      if (!String.IsNullOrEmpty(fileName))\n         command.Append(fileName);\n\n      Console.WriteLine(command.ToString());\n   }\n\n   Target DistBuild =\u003E _ =\u003E _\n      .DependsOn(Pack, UploadArtifacts);\n}\n"
  },
  {
    "Id": 33116326,
    "FirstIndexed": "2020-04-25T15:50:44.7355129+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631545+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843374+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939492+02:00",
    "Name": "aimp_dotnet",
    "Owner": "martin211",
    "HtmlUrl": "https://github.com/martin211/aimp_dotnet",
    "Description": "AIMP DotNet plugin",
    "Archived": false,
    "Stars": 34,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/martin211/aimp_dotnet/blob/master/build/Build.cs",
    "BuildFileSize": 13144,
    "BuildFileContent": "using System;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing Aimp.DotNet.Build;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.InspectCode;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing Nuke.Common.Tools.SonarScanner;\r\nusing Nuke.Common.Utilities;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\n\r\nclass Build : NukeBuild\r\n{\r\n    [Parameter(\u0022Indicates to push to nuget.org feed.\u0022)] readonly bool NuGet;\r\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\r\n    [Parameter] readonly string SonarUrl;\r\n    [Parameter] readonly string SonarUser;\r\n    [Parameter] readonly string SonarPassword;\r\n    [Parameter] readonly string SonarProjectKey;\r\n    [Parameter] readonly string SonarProjectName;\r\n    [Parameter] readonly string VmWareMachine;\r\n    [Parameter] readonly string BuildConfiguration;\r\n    [Parameter] readonly string NugetApiKey;\r\n\r\n    private string Source =\u003E NuGet\r\n        ? \u0022https://api.nuget.org/v3/index.json\u0022\r\n        : \u0022https://www.myget.org/F/aimpsdk/api/v2/package\u0022;\r\n\r\n    readonly string MasterBranch = \u0022master\u0022;\r\n    readonly string DevelopBranch = \u0022develop\u0022;\r\n    readonly string ReleaseBranchPrefix = \u0022release\u0022;\r\n    readonly string HotfixBranchPrefix = \u0022hotfix\u0022;\r\n\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\r\n\r\n    string DocFxFile =\u003E RootDirectory / \u0022documentation\u0022 / \u0022docfx.json\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            //DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\r\n            EnsureCleanDirectory(OutputDirectory);\r\n        });\r\n\r\n    Target SetConfiguration =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            Configuration = !string.IsNullOrWhiteSpace(BuildConfiguration) \u0026\u0026\r\n                            BuildConfiguration.Equals(\u0022release\u0022, StringComparison.OrdinalIgnoreCase)\r\n                ? Configuration.Release\r\n                : Configuration.Debug;\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration, Version)\r\n        .Requires(() =\u003E GitVersion != null)\r\n        .Executes(() =\u003E\r\n        {\r\n            MSBuildTasks.MSBuild(s =\u003E s\r\n                .SetNodeReuse(false)\r\n                .SetRestore(true)\r\n                .SetProjectFile(Solution)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .SetConfiguration(Configuration));\r\n        });\r\n\r\n    Target Version =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration)\r\n        .Executes(() =\u003E\r\n        {\r\n            var properties = GlobDirectories(SourceDirectory, \u0022**/Properties\u0022);\r\n            foreach (var property in properties)\r\n            {\r\n                ProcessTasks.StartProcess(GitVersionTasks.GitVersionPath, $\u0022/updateassemblyinfo {property}/AssemblyInfo.cs\u0022);\r\n            }\r\n\r\n            var rcFile = SourceDirectory / \u0022aimp_dotnet\u0022 / \u0022aimp_dotnet.rc\u0022;\r\n            if (File.Exists(rcFile))\r\n            {\r\n                Logger.Info($\u0022Update version for \u0027{rcFile}\u0027\u0022);\r\n                var fileContent = File.ReadAllText(rcFile);\r\n                fileContent = fileContent.Replace(\u00221,0,0,1\u0022, GitVersion.AssemblySemVer).Replace(\u00221.0.0.1\u0022, GitVersion.AssemblySemVer);\r\n                File.WriteAllText(rcFile, fileContent);\r\n            }\r\n        });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration)\r\n        .Executes(() =\u003E\r\n        {\r\n            Logger.Info(\u0022Start build Nuget packages\u0022);\r\n\r\n            var nugetFolder = RootDirectory / \u0022Nuget\u0022;\r\n            var version = GitVersion.AssemblySemVer;\r\n\r\n            NuGetTasks.NuGetPack(c =\u003E c\r\n                .SetTargetPath(nugetFolder / \u0022AimpSDK.nuspec\u0022)\r\n                .SetBasePath(RootDirectory)\r\n                .SetConfiguration(Configuration)\r\n                .SetVersion(version)\r\n                .SetOutputDirectory(OutputDirectory));\r\n\r\n            NuGetTasks.NuGetPack(c =\u003E c\r\n                .SetTargetPath(nugetFolder / \u0022AimpSDK.symbols.nuspec\u0022)\r\n                .SetBasePath(RootDirectory)\r\n                .SetVersion(version)\r\n                .SetConfiguration(Configuration)\r\n                .SetOutputDirectory(OutputDirectory)\r\n                .AddProperty(\u0022Symbols\u0022, string.Empty));\r\n\r\n            NuGetTasks.NuGetPack(c =\u003E c\r\n                .SetTargetPath(nugetFolder / \u0022AimpSDK.sources.nuspec\u0022)\r\n                .SetVersion(version)\r\n                .SetConfiguration(Configuration)\r\n                .SetBasePath(RootDirectory)\r\n                .SetOutputDirectory(OutputDirectory));\r\n        });\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration)\r\n        .Requires(() =\u003E ApiKey)\r\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\r\n        .Requires(() =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch) ||\r\n                        GitRepository.Branch.EqualsOrdinalIgnoreCase(DevelopBranch) ||\r\n                        GitRepository.Branch.EqualsOrdinalIgnoreCase(ReleaseBranchPrefix) ||\r\n                        GitRepository.Branch.EqualsOrdinalIgnoreCase(HotfixBranchPrefix))\r\n        .Executes(() =\u003E\r\n        {\r\n            Logger.Info(\u0022Deploying Nuget packages\u0022);\r\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\r\n                .Where(c =\u003E !c.EndsWith(\u0022symbols.nupkg\u0022))\r\n                .ForEach(c =\u003E NuGetTasks.NuGetPush(s =\u003E s\r\n                    .SetTargetPath(c)\r\n                    .SetSource(Source)\r\n                    .SetApiKey(ApiKey)));\r\n        });\r\n\r\n    Target Analysis =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration)\r\n        .Executes(() =\u003E\r\n        {\r\n            InspectCodeTasks.InspectCode(s =\u003E s.AddExtensions(\r\n                \u0022EtherealCode.ReSpeller\u0022,\r\n                \u0022PowerToys.CyclomaticComplexity\u0022,\r\n                \u0022ReSharper.ImplicitNullability\u0022,\r\n                \u0022ReSharper.SerializationInspections\u0022,\r\n                \u0022ReSharper.XmlDocInspections\u0022));\r\n        }\r\n      );\r\n\r\n    Target SonarQube =\u003E _ =\u003E _\r\n      .DependsOn(SetConfiguration)\r\n      .Requires(() =\u003E SonarUrl, () =\u003E SonarUser)\r\n      .Executes(() =\u003E\r\n      {\r\n          var configuration = new SonarBeginSettings();\r\n          configuration\r\n              .SetProjectKey(SonarProjectKey)\r\n              .SetIssueTrackerUrl(SonarUrl)\r\n              .SetServer(SonarUrl)\r\n              //.SetHomepage(SonarUrl)\r\n              .SetLogin(SonarUser)\r\n              .SetPassword(SonarPassword)\r\n              .SetName(SonarProjectName)\r\n              .SetWorkingDirectory(SourceDirectory)\r\n              .SetVerbose(true);\r\n\r\n          configuration = configuration.SetProjectBaseDir(SourceDirectory);\r\n\r\n          SonarScannerTasks.SonarScannerBegin(c =\u003E configuration);\r\n      }, () =\u003E\r\n      {\r\n          MSBuildTasks.MSBuild(c =\u003E c\r\n              .SetConfiguration(Configuration)\r\n              .SetTargets(\u0022Rebuild\u0022)\r\n              .SetNodeReuse(true));\r\n      }, () =\u003E\r\n      {\r\n          SonarScannerTasks.SonarScannerEnd(c =\u003E c\r\n              .SetLogin(SonarUser)\r\n              .SetPassword(SonarPassword)\r\n              .SetWorkingDirectory(SourceDirectory)\r\n          );\r\n      });\r\n\r\n    Target Artifacts =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration)\r\n        .Executes(() =\u003E\r\n        {\r\n            EnsureCleanDirectory(OutputDirectory / \u0022Artifacts\u0022);\r\n            Directory.CreateDirectory(OutputDirectory / \u0022Artifacts\u0022);\r\n\r\n            Logger.Info(\u0022Copy plugins to artifacts folder\u0022);\r\n            var directories = GlobDirectories(SourceDirectory / \u0022Plugins\u0022, $\u0022**/bin/{Configuration}\u0022);\r\n            foreach (var directory in directories)\r\n            {\r\n                var di = new DirectoryInfo(directory);\r\n                var pluginName = di.Parent?.Parent?.Name;\r\n\r\n                Directory.CreateDirectory(OutputDirectory / \u0022Artifacts\u0022 / \u0022Plugins\u0022 / pluginName);\r\n\r\n                var files = di.GetFiles(\u0022*.dll\u0022);\r\n                foreach (var file in files)\r\n                {\r\n                    string outFile = string.Empty;\r\n\r\n                    if (file.Name.StartsWith(pluginName))\r\n                    {\r\n                        outFile = OutputDirectory / \u0022Artifacts\u0022 / \u0022Plugins\u0022 / pluginName / $\u0022{Path.GetFileNameWithoutExtension(file.Name)}_plugin.dll\u0022;\r\n                    }\r\n                    else\r\n                    {\r\n                        outFile = OutputDirectory / \u0022Artifacts\u0022 / \u0022Plugins\u0022 / pluginName / file.Name;\r\n                    }\r\n\r\n                    if (file.Name.StartsWith(\u0022aimp_dotnet\u0022))\r\n                    {\r\n                        outFile = OutputDirectory / \u0022Artifacts\u0022 / \u0022Plugins\u0022 / pluginName / $\u0022{pluginName}.dll\u0022;\r\n                    }\r\n\r\n                    file.CopyTo(outFile, true);\r\n                }\r\n            }\r\n\r\n            Logger.Info(\u0022Copy SDK files to artifacts folder\u0022);\r\n            var sdkFolder = new DirectoryInfo(SourceDirectory / $\u0022{Configuration}\u0022);\r\n            Directory.CreateDirectory(OutputDirectory / \u0022Artifacts\u0022 / \u0022SDK\u0022);\r\n            var sdkFiles = sdkFolder.GetFiles(\u0022*.dll\u0022);\r\n            foreach (var file in sdkFiles)\r\n            {\r\n                var outFile = OutputDirectory / \u0022Artifacts\u0022 / \u0022SDK\u0022 / file.Name;\r\n                file.CopyTo(outFile, true);\r\n            }\r\n\r\n            Logger.Info(\u0022Compress artifacts\u0022);\r\n            ZipFile.CreateFromDirectory(OutputDirectory / \u0022Artifacts\u0022, OutputDirectory / \u0022aimp.sdk.zip\u0022);\r\n        });\r\n\r\n    Target PvsStudio =\u003E _ =\u003E _\r\n        .DependsOn(SetConfiguration)\r\n        .Executes(() =\u003E\r\n        {\r\n            ProcessTasks.StartProcess(\u0022git\u0022, $\u0022checkout {DevelopBranch}\u0022);\r\n            ProcessTasks.StartProcess(\u0022git\u0022, $\u0022branch -d pvs_{GitVersion.AssemblySemVer}\u0022);\r\n            ProcessTasks.StartProcess(\r\n                \u0022git\u0022,\r\n                $\u0022checkout -b pvs_{GitVersion.AssemblySemVer}\u0022,\r\n                SourceDirectory);\r\n\r\n            ProcessTasks.StartProcess(\r\n                \u0022PVS-Studio_Cmd\u0022,\r\n                $\u0022--target {Solution} --configuration {Configuration} --output {OutputDirectory / \u0022dot_net.plog\u0022}\u0022,\r\n                SourceDirectory).WaitForExit();\r\n        });\r\n\r\n    Target RunVmWare =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            bool CheckVmRunning()\r\n            {\r\n                bool isRunning = true;\r\n                bool checkVm = false;\r\n\r\n                ProcessTasks.StartProcess(\r\n                        \u0022vmrun.exe\u0022,\r\n                        \u0022list\u0022,\r\n                        null,\r\n                        null,\r\n                        null,\r\n                        true,\r\n                        false,\r\n                        ((type, s) =\u003E\r\n                        {\r\n                            var m = Regex.Match(s, @\u0022^.\u002B: (\\d)$\u0022);\r\n                            if (m.Success)\r\n                            {\r\n                                var count = int.Parse(m.Groups[1].Value);\r\n                                checkVm = count \u003E 0;\r\n                            }\r\n\r\n                            if (checkVm \u0026\u0026 s.Contains(VmWareMachine))\r\n                            {\r\n                                isRunning = false;\r\n                            }\r\n                        }))\r\n                    ?.WaitForExit();\r\n\r\n                return isRunning;\r\n            }\r\n\r\n            if (!CheckVmRunning())\r\n            {\r\n                Logger.Info($\u0022Starting Virtual Machine: {VmWareMachine}\u0022);\r\n                ProcessTasks.StartProcess(\u0022vmrun.exe\u0022, $\u0022start \\\u0022{VmWareMachine}\\\u0022 nogui\u0022)?.WaitForExit();\r\n                if (!CheckVmRunning())\r\n                {\r\n                    Logger.Error($\u0022Unable run machine: {VmWareMachine}\u0022);\r\n                }\r\n            }\r\n        });\r\n\r\n    Target Deploy =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            Logger.Info(\u0022Deploying Nuget packages\u0022);\r\n\r\n            var packages = Directory.GetFiles(OutputDirectory, \u0022AimpSDK.*\u0022);\r\n            foreach (var package in packages)\r\n            {\r\n                NuGetTasks.NuGetPush(c =\u003E c\r\n                    .SetTargetPath(package)\r\n                    .SetApiKey(NugetApiKey)\r\n                    .SetSymbolApiKey(NugetApiKey)\r\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                    .SetSymbolSource(\u0022https://api.nuget.org/v3/index.json\u0022));\r\n            }\r\n        });\r\n}\r\n"
  },
  {
    "Id": 40016123,
    "FirstIndexed": "2020-04-25T15:50:44.7354662+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632319+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433535+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939305+02:00",
    "Name": "SpiroNet",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/SpiroNet",
    "Description": "The .NET C# port of libspiro - conversion between spiro control points and bezier\u0027s.",
    "Archived": false,
    "Stars": 20,
    "Watchers": 6,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/SpiroNet/blob/master/build/build/Build.cs",
    "BuildFileSize": 3744,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 44004125,
    "FirstIndexed": "2020-04-25T15:50:44.7354804+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629458+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433592+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939367+02:00",
    "Name": "Core2D",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/Core2D",
    "Description": "A multi-platform data driven 2D diagram editor.",
    "Archived": false,
    "Stars": 305,
    "Watchers": 33,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/Core2D/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 47682683,
    "FirstIndexed": "2020-04-25T15:50:44.7354827+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629321+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433603+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939379+02:00",
    "Name": "AvaloniaBehaviors",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/AvaloniaBehaviors",
    "Description": "Port of Windows UWP Xaml Behaviors for Avalonia Xaml.",
    "Archived": false,
    "Stars": 47,
    "Watchers": 8,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/AvaloniaBehaviors/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 49339261,
    "FirstIndexed": "2020-04-25T15:50:44.735667+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631574+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434377+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940101+02:00",
    "Name": "WebDocu",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/WebDocu",
    "Description": "Small Asp.Net Core app to host static html content with user management",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/WebDocu/blob/master/build/Build.cs",
    "BuildFileSize": 10840,
    "BuildFileContent": "\uFEFFusing Nuke.CoberturaConverter;\nusing Nuke.Common;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.WebConfigTransformRunner;\nusing Nuke.Common.Utilities;\nusing Nuke.WebDeploy;\nusing System.IO;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.WebConfigTransformRunner.WebConfigTransformRunnerTasks;\nusing static Nuke.WebDeploy.WebDeployTasks;\nusing Nuke.Azure.KeyVault;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing System;\nusing static Nuke.Common.IO.TextTasks;\nusing Nuke.Common.Tools.GitVersion;\nusing Microsoft.Azure.Management.Fluent;\nusing Microsoft.Azure.Management.ResourceManager.Fluent;\nusing static Nuke.Common.IO.HttpTasks;\nusing Newtonsoft.Json.Linq;\nusing System.Linq;\nusing Nuke.Common.Utilities.Collections;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [KeyVault] KeyVault KeyVault;\n\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly string PublishEnvironmentName;\n    [Parameter] readonly string WebDeployUsernameSecretName;\n    [Parameter] readonly string WebDeployPasswordSecretName;\n    [Parameter] readonly string WebDeployPublishUrlSecretName;\n    [Parameter] readonly string WebDeploySiteNameSecretName;\n\n    [KeyVaultSecret(\u0022DanglDocu-AzureServicePrincipalClientId\u0022)] string AzureServicePrincipalClientId;\n    [KeyVaultSecret(\u0022DanglDocu-AzureServicePrincipalClientSecret\u0022)] string AzureServicePrincipalClientSecret;\n    [KeyVaultSecret(\u0022DanglDocu-AzureServicePrincipalTenantId\u0022)] string AzureServicePrincipalTenantId;\n    [KeyVaultSecret(\u0022DanglDocu-AzureAppServiceStagingSlotName\u0022)] string AzureAppServiceStagingSlotName;\n    [KeyVaultSecret(\u0022DanglDocu-AzureAppServiceName\u0022)] string AzureAppServiceName;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022Dangl.WebDocumentation.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target GenerateVersion =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var buildDate = DateTime.UtcNow;\n\n            var filePath = SourceDirectory / \u0022Dangl.WebDocumentation\u0022 / \u0022Services\u0022 / \u0022VersionsService.cs\u0022;\n\n            var currentDateUtc = $\u0022new DateTime({buildDate.Year}, {buildDate.Month}, {buildDate.Day}, {buildDate.Hour}, {buildDate.Minute}, {buildDate.Second}, DateTimeKind.Utc)\u0022;\n\n            var content = $@\u0022using System;\n\nnamespace Dangl.WebDocumentation.Services\n{{\n    // This file is automatically generated\n    [System.CodeDom.Compiler.GeneratedCode(\u0022\u0022GitVersionBuild\u0022\u0022, \u0022\u0022\u0022\u0022)]\n    public static class VersionsService\n    {{\n        public static string Version =\u003E \u0022\u0022{GitVersion.NuGetVersionV2}\u0022\u0022;\n        public static string CommitInfo =\u003E \u0022\u0022{GitVersion.FullBuildMetaData}\u0022\u0022;\n        public static string CommitDate =\u003E \u0022\u0022{GitVersion.CommitDate}\u0022\u0022;\n        public static string CommitHash =\u003E \u0022\u0022{GitVersion.Sha}\u0022\u0022;\n        public static string InformationalVersion =\u003E \u0022\u0022{GitVersion.InformationalVersion}\u0022\u0022;\n        public static DateTime BuildDateUtc {{ get; }} = {currentDateUtc};\n    }}\n}}\u0022;\n            WriteAllText(filePath, content);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .DependsOn(GenerateVersion)\n            .Executes(() =\u003E\n            {\n                DotNetRestore();\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(x =\u003E x\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore());\n            });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Debug\u0022)) // Required for coverage data gathering\n        .Executes(async () =\u003E\n        {\n            var testProjectDirectory = SolutionDirectory / \u0022test\u0022 / \u0022Dangl.WebDocumentation.Tests\u0022;\n\n            DotCoverAnalyse(x =\u003E x\n                .SetTargetExecutable(ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022))\n                .SetTargetWorkingDirectory(testProjectDirectory)\n                .SetTargetArguments($\u0022test --no-build --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={OutputDirectory / \u0022testresults.xml\u0022}\\\u0022\u0022)\n                .SetFilters(\u0022\u002B:Dangl.WebDocumentation\u0022)\n                .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                .SetOutputFile(OutputDirectory / \u0022dotCover.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            //// This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                .SetReports(OutputDirectory / \u0022dotCover.xml\u0022)\n                .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            //// This is the report in Cobertura format that integrates so nice in Jenkins\n            //// dashboard and allows to extract more metrics and set build health based\n            //// on coverage readings\n            await DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022dotCover.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura.xml\u0022))\n                .ConfigureAwait(false);\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s.SetProject(SourceDirectory / \u0022Dangl.WebDocumentation\u0022)\n                    .SetOutput(OutputDirectory)\n                    .SetConfiguration(Configuration));\n\n            WebConfigTransformRunner(p =\u003E p.SetWebConfigFilename(OutputDirectory / \u0022web.config\u0022)\n                .SetTransformFilename(OutputDirectory / $\u0022web.{PublishEnvironmentName}.config\u0022)\n                .SetOutputFilename(OutputDirectory / \u0022web.config\u0022));\n\n            foreach (var configFileToDelete in GlobFiles(OutputDirectory, \u0022web.*.config\u0022))\n            {\n                File.Delete(configFileToDelete);\n            }\n\n            foreach (var configFileToDelete in GlobFiles(OutputDirectory, \u0022appsettings.*.json\u0022))\n            {\n                if (!configFileToDelete.EndsWithOrdinalIgnoreCase($\u0022{PublishEnvironmentName}.json\u0022))\n                {\n                    File.Delete(configFileToDelete);\n                }\n            }\n        });\n\n    Target Deploy =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Requires(() =\u003E WebDeployUsernameSecretName)\n        .Requires(() =\u003E WebDeployPasswordSecretName)\n        .Requires(() =\u003E WebDeployPublishUrlSecretName)\n        .Requires(() =\u003E WebDeploySiteNameSecretName)\n        .Executes(async () =\u003E\n        {\n            var webDeployUsername = await KeyVault.GetSecret(WebDeployUsernameSecretName);\n            var webDeployPassword = await KeyVault.GetSecret(WebDeployPasswordSecretName);\n            var webDeployPublishUrl = await KeyVault.GetSecret(WebDeployPublishUrlSecretName);\n            var webDeploySiteName = await KeyVault.GetSecret(WebDeploySiteNameSecretName);\n\n            WebDeploy(s =\u003E s.SetSourcePath(OutputDirectory)\n                .SetUsername(webDeployUsername)\n                .SetPassword(webDeployPassword)\n                .SetEnableAppOfflineRule(true)\n                .SetPublishUrl(webDeployPublishUrl.TrimEnd(\u0027/\u0027) \u002B \u0022/msdeploy.axd?site=\u0022 \u002B webDeploySiteName)\n                .SetSiteName(webDeploySiteName)\n                .SetEnableDoNotDeleteRule(false)\n                .SetWrapAppOffline(true));\n        })\n        .Executes(SwapStagingAndProductionSlotsInAzure);\n\n    Target SwapStagingAndProductionSlotsInAzure =\u003E _ =\u003E _\n        .Requires(() =\u003E AzureServicePrincipalClientId)\n        .Requires(() =\u003E AzureServicePrincipalClientSecret)\n        .Requires(() =\u003E AzureServicePrincipalTenantId)\n        .Requires(() =\u003E AzureAppServiceStagingSlotName)\n        .Requires(() =\u003E AzureAppServiceName)\n        .Executes(async () =\u003E\n        {\n            if (PublishEnvironmentName == \u0022Production\u0022)\n            {\n                Logger.Log(LogLevel.Normal, \u0022Deployed to production, initiating slot swap with staging\u0022);\n\n                var azureCredentials = SdkContext.AzureCredentialsFactory.FromServicePrincipal(AzureServicePrincipalClientId,\n                    AzureServicePrincipalClientSecret,\n                    AzureServicePrincipalTenantId,\n                    AzureEnvironment.AzureGlobalCloud);\n                IAzure azure = Azure.Configure()\n                    .WithLogLevel(Microsoft.Azure.Management.ResourceManager.Fluent.Core.HttpLoggingDelegatingHandler.Level.Basic)\n                    .Authenticate(azureCredentials)\n                    .WithDefaultSubscription();\n                Logger.Log(LogLevel.Normal, \u0022Getting information about the web app\u0022);\n                var webApp = (await azure.AppServices.WebApps\n                    .ListAsync())\n                    .First(app =\u003E app.Name == AzureAppServiceName);\n                Logger.Log(LogLevel.Normal, \u0022Getting information about the staging slot\u0022);\n                var slot = (await webApp.DeploymentSlots.ListAsync())\n                    .First(s =\u003E s.Name == AzureAppServiceStagingSlotName);\n\n                var statusUrl = $\u0022https://{slot.DefaultHostName}/api/status\u0022;\n                if (!(bool)JObject.Parse(await HttpDownloadStringAsync(statusUrl))[\u0022isHealthy\u0022])\n                {\n                    ControlFlow.Fail(\u0022The web app in the staging slot does not report a healthy status\u0022);\n                }\n\n                Logger.Log(LogLevel.Normal, \u0022Starting swap\u0022);\n                // \u0022production\u0022 is the default name for the main slot\n                await slot.SwapAsync(\u0022production\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 51197111,
    "FirstIndexed": "2020-04-25T15:50:44.7363143+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7363155+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435105+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940824+02:00",
    "Name": "proteowizard",
    "Owner": "lgatto",
    "HtmlUrl": "https://github.com/lgatto/proteowizard",
    "Description": "The ProteoWizard Library and Tools for - http://proteowizard.sourceforge.net/",
    "Archived": false,
    "Stars": 4,
    "Watchers": 2,
    "BuildFilePath": "pwiz/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileUrl": "https://github.com/lgatto/proteowizard/blob/master/pwiz/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileSize": 7916,
    "BuildFileContent": "\uFEFF/*\r\n * Original author: Don Marsh \u003Cdonmarsh .at. u.washington.edu\u003E,\r\n *                  MacCoss Lab, Department of Genome Sciences, UW\r\n *\r\n * Copyright 2013 University of Washington - Seattle, WA\r\n * \r\n * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Windows.Forms;\r\nusing pwiz.Common.SystemUtil;\r\n\r\nnamespace SkylineTester\r\n{\r\n    public class TabBuild : TabBase\r\n    {\r\n        public TabBuild()\r\n        {\r\n            MainWindow.LabelSpecifyPath.Text =\r\n                \u0022(Specify absolute path or relative path from {0} folder)\u0022.With(Path.GetFileName(MainWindow.RootDir));\r\n        }\r\n\r\n        public override void Enter()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n            MainWindow.DefaultButton = MainWindow.RunBuild;\r\n        }\r\n\r\n        public override bool Run()\r\n        {\r\n            if (!MainWindow.HasBuildPrerequisites)\r\n                return false;\r\n            var architectures = GetArchitectures();\r\n            if (architectures.Count == 0)\r\n            {\r\n                MessageBox.Show(\u0022Select 32 or 64 bit architecture (or both).\u0022);\r\n                return false;\r\n            }\r\n\r\n            StartLog(\u0022Build\u0022, MainWindow.DefaultLogFile, true);\r\n            CreateBuildCommands(\r\n                GetBranchUrl(),\r\n                MainWindow.GetBuildRoot(), \r\n                architectures, \r\n                MainWindow.NukeBuild.Checked, \r\n                MainWindow.UpdateBuild.Checked,\r\n                MainWindow.RunBuildVerificationTests.Checked);\r\n            MainWindow.RunCommands();\r\n            return true;\r\n        }\r\n\r\n        public override bool Stop(bool success)\r\n        {\r\n            if (success \u0026\u0026 MainWindow.StartSln.Checked \u0026\u0026 MainWindow.Devenv != null)\r\n            {\r\n                var buildRoot = MainWindow.GetBuildRoot();\r\n                var slnDirectory = Path.Combine(buildRoot, @\u0022pwiz_tools\\Skyline\u0022);\r\n                var process = new Process\r\n                {\r\n                    StartInfo =\r\n                    {\r\n                        FileName = Path.Combine(slnDirectory, \u0022Skyline.sln\u0022),\r\n                        WorkingDirectory = slnDirectory,\r\n                        UseShellExecute = true,\r\n                    }\r\n                };\r\n                process.Start();\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public override int Find(string text, int position)\r\n        {\r\n            return VerifyFind(text, position, \u0022Build\u0022);\r\n        }\r\n\r\n        public static List\u003Cint\u003E GetArchitectures()\r\n        {\r\n            var architectures = new List\u003Cint\u003E();\r\n            if (MainWindow.Build32.Checked)\r\n                architectures.Add(32);\r\n            if (MainWindow.Build64.Checked)\r\n                architectures.Add(64);\r\n            return architectures;\r\n        }\r\n\r\n        public static string GetBranchUrl()\r\n        {\r\n            return MainWindow.BuildTrunk.Checked\r\n                ? @\u0022https://svn.code.sf.net/p/proteowizard/code/trunk/pwiz\u0022\r\n                : MainWindow.BranchUrl.Text;\r\n        }\r\n\r\n        public static void CreateBuildCommands(\r\n            string branchUrl, \r\n            string buildRoot, \r\n            IList\u003Cint\u003E architectures, \r\n            bool nukeBuild, \r\n            bool updateBuild,\r\n            bool runBuildTests)\r\n        {\r\n            var commandShell = MainWindow.CommandShell;\r\n            var branchParts = branchUrl.Split(\u0027/\u0027);\r\n            var branchName = \u0022Skyline ({0}/{1})\u0022.With(branchParts[branchParts.Length - 2], branchParts[branchParts.Length - 1]);\r\n            var subversion = MainWindow.Subversion;\r\n\r\n            var architectureList = string.Join(\u0022- and \u0022, architectures);\r\n            commandShell.Add(\u0022# Build {0} {1}-bit...\u0022, branchName, architectureList);\r\n\r\n            if (Directory.Exists(buildRoot))\r\n            {\r\n                if (nukeBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Deleting Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Deleting Build directory...\u0022);\r\n                    commandShell.Add(\u0022rmdir /s {0}\u0022, buildRoot.Quote());\r\n                }\r\n                else if (updateBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Updating Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Updating Build directory...\u0022);\r\n                    commandShell.Add(\u0022{0} cleanup {1}\u0022, subversion.Quote(), buildRoot.Quote());\r\n                    commandShell.Add(\u0022{0} update {1}\u0022, subversion.Quote(), buildRoot.Quote());\r\n                }\r\n            }\r\n\r\n            if (nukeBuild || updateBuild)\r\n            {\r\n                string tutorialsFolder = Path.Combine(PathEx.GetDownloadsPath(), \u0022Tutorials\u0022);\r\n                commandShell.Add(\u0022#@ Deleting Tutorials directory...\\n\u0022);\r\n                commandShell.Add(\u0022# Deleting Tutorials directory...\u0022);\r\n                commandShell.Add(\u0022rmdir /s {0}\u0022, tutorialsFolder);\r\n            }\r\n\r\n            if (nukeBuild)\r\n            {\r\n                commandShell.Add(\u0022#@ Checking out {0} source files...\\n\u0022, branchName);\r\n                commandShell.Add(\u0022# Checking out {0} source files...\u0022, branchName);\r\n                commandShell.Add(\u0022{0} checkout {1} {2}\u0022, subversion.Quote(), branchUrl.Quote(), buildRoot.Quote());\r\n            }\r\n\r\n            commandShell.Add(\u0022# Building Skyline...\u0022);\r\n            commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\r\n            foreach (int architecture in architectures)\r\n            {\r\n                commandShell.Add(\u0022#@ Building Skyline {0} bit...\\n\u0022, architecture);\r\n                commandShell.Add(\u0022{0} {1} {2} --i-agree-to-the-vendor-licenses toolset=msvc-12.0 nolog\u0022,\r\n                    Path.Combine(buildRoot, @\u0022pwiz_tools\\build-apps.bat\u0022).Quote(),\r\n                    architecture,\r\n                    runBuildTests ? \u0022pwiz_tools/Skyline\u0022 : \u0022pwiz_tools/Skyline//Skyline.exe\u0022);\r\n            }\r\n\r\n            commandShell.Add(\u0022# Build done.\u0022);\r\n        }\r\n\r\n        public void DeleteBuild()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            if (!Directory.Exists(buildRoot) ||\r\n                MessageBox.Show(MainWindow, \u0022Delete \\\u0022\u0022 \u002B buildRoot \u002B \u0022\\\u0022 folder?\u0022, \u0022Confirm delete\u0022,\r\n                    MessageBoxButtons.OKCancel) != DialogResult.OK)\r\n            {\r\n                return;\r\n            }\r\n\r\n            using (var deleteWindow = new DeleteWindow(buildRoot))\r\n            {\r\n                deleteWindow.ShowDialog();\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n        }\r\n\r\n        public void BrowseBuild()\r\n        {\r\n            using (var dlg = new FolderBrowserDialog\r\n            {\r\n                Description = \u0022Select or create a root folder for build source files.\u0022,\r\n                ShowNewFolderButton = true\r\n            })\r\n            {\r\n                if (dlg.ShowDialog(MainWindow) == DialogResult.OK)\r\n                    MainWindow.BuildRoot.Text = dlg.SelectedPath;\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(MainWindow.GetBuildRoot()); // MainWindow.GetBuildRoot() is the directory that actually gets deleted in DeleteBuild()\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 51879362,
    "FirstIndexed": "2020-04-25T15:50:44.7354736+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629304+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433564+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939339+02:00",
    "Name": "PanAndZoom",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/PanAndZoom",
    "Description": "Pan and zoom control for WPF and Avalonia.",
    "Archived": false,
    "Stars": 111,
    "Watchers": 10,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/PanAndZoom/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 53507584,
    "FirstIndexed": "2020-04-25T15:50:44.7361374+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631864+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434798+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "NetspherePirates",
    "Owner": "wtfblub",
    "HtmlUrl": "https://github.com/wtfblub/NetspherePirates",
    "Description": "Experimental S4 League server emulator - Development moved to https://gitlab.com/NetspherePirates/NetspherePirates",
    "Archived": true,
    "Stars": 70,
    "Watchers": 39,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 59696857,
    "FirstIndexed": "2020-04-25T15:50:44.7363121+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7363126+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435094+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940812+02:00",
    "Name": "pwiz",
    "Owner": "tomas-pluskal",
    "HtmlUrl": "https://github.com/tomas-pluskal/pwiz",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "pwiz/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileUrl": "https://github.com/tomas-pluskal/pwiz/blob/master/pwiz/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileSize": 7916,
    "BuildFileContent": "\uFEFF/*\r\n * Original author: Don Marsh \u003Cdonmarsh .at. u.washington.edu\u003E,\r\n *                  MacCoss Lab, Department of Genome Sciences, UW\r\n *\r\n * Copyright 2013 University of Washington - Seattle, WA\r\n * \r\n * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Windows.Forms;\r\nusing pwiz.Common.SystemUtil;\r\n\r\nnamespace SkylineTester\r\n{\r\n    public class TabBuild : TabBase\r\n    {\r\n        public TabBuild()\r\n        {\r\n            MainWindow.LabelSpecifyPath.Text =\r\n                \u0022(Specify absolute path or relative path from {0} folder)\u0022.With(Path.GetFileName(MainWindow.RootDir));\r\n        }\r\n\r\n        public override void Enter()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n            MainWindow.DefaultButton = MainWindow.RunBuild;\r\n        }\r\n\r\n        public override bool Run()\r\n        {\r\n            if (!MainWindow.HasBuildPrerequisites)\r\n                return false;\r\n            var architectures = GetArchitectures();\r\n            if (architectures.Count == 0)\r\n            {\r\n                MessageBox.Show(\u0022Select 32 or 64 bit architecture (or both).\u0022);\r\n                return false;\r\n            }\r\n\r\n            StartLog(\u0022Build\u0022, MainWindow.DefaultLogFile, true);\r\n            CreateBuildCommands(\r\n                GetBranchUrl(),\r\n                MainWindow.GetBuildRoot(), \r\n                architectures, \r\n                MainWindow.NukeBuild.Checked, \r\n                MainWindow.UpdateBuild.Checked,\r\n                MainWindow.RunBuildVerificationTests.Checked);\r\n            MainWindow.RunCommands();\r\n            return true;\r\n        }\r\n\r\n        public override bool Stop(bool success)\r\n        {\r\n            if (success \u0026\u0026 MainWindow.StartSln.Checked \u0026\u0026 MainWindow.Devenv != null)\r\n            {\r\n                var buildRoot = MainWindow.GetBuildRoot();\r\n                var slnDirectory = Path.Combine(buildRoot, @\u0022pwiz_tools\\Skyline\u0022);\r\n                var process = new Process\r\n                {\r\n                    StartInfo =\r\n                    {\r\n                        FileName = Path.Combine(slnDirectory, \u0022Skyline.sln\u0022),\r\n                        WorkingDirectory = slnDirectory,\r\n                        UseShellExecute = true,\r\n                    }\r\n                };\r\n                process.Start();\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public override int Find(string text, int position)\r\n        {\r\n            return VerifyFind(text, position, \u0022Build\u0022);\r\n        }\r\n\r\n        public static List\u003Cint\u003E GetArchitectures()\r\n        {\r\n            var architectures = new List\u003Cint\u003E();\r\n            if (MainWindow.Build32.Checked)\r\n                architectures.Add(32);\r\n            if (MainWindow.Build64.Checked)\r\n                architectures.Add(64);\r\n            return architectures;\r\n        }\r\n\r\n        public static string GetBranchUrl()\r\n        {\r\n            return MainWindow.BuildTrunk.Checked\r\n                ? @\u0022https://svn.code.sf.net/p/proteowizard/code/trunk/pwiz\u0022\r\n                : MainWindow.BranchUrl.Text;\r\n        }\r\n\r\n        public static void CreateBuildCommands(\r\n            string branchUrl, \r\n            string buildRoot, \r\n            IList\u003Cint\u003E architectures, \r\n            bool nukeBuild, \r\n            bool updateBuild,\r\n            bool runBuildTests)\r\n        {\r\n            var commandShell = MainWindow.CommandShell;\r\n            var branchParts = branchUrl.Split(\u0027/\u0027);\r\n            var branchName = \u0022Skyline ({0}/{1})\u0022.With(branchParts[branchParts.Length - 2], branchParts[branchParts.Length - 1]);\r\n            var subversion = MainWindow.Subversion;\r\n\r\n            var architectureList = string.Join(\u0022- and \u0022, architectures);\r\n            commandShell.Add(\u0022# Build {0} {1}-bit...\u0022, branchName, architectureList);\r\n\r\n            if (Directory.Exists(buildRoot))\r\n            {\r\n                if (nukeBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Deleting Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Deleting Build directory...\u0022);\r\n                    commandShell.Add(\u0022rmdir /s {0}\u0022, buildRoot.Quote());\r\n                }\r\n                else if (updateBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Updating Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Updating Build directory...\u0022);\r\n                    commandShell.Add(\u0022{0} cleanup {1}\u0022, subversion.Quote(), buildRoot.Quote());\r\n                    commandShell.Add(\u0022{0} update {1}\u0022, subversion.Quote(), buildRoot.Quote());\r\n                }\r\n            }\r\n\r\n            if (nukeBuild || updateBuild)\r\n            {\r\n                string tutorialsFolder = Path.Combine(PathEx.GetDownloadsPath(), \u0022Tutorials\u0022);\r\n                commandShell.Add(\u0022#@ Deleting Tutorials directory...\\n\u0022);\r\n                commandShell.Add(\u0022# Deleting Tutorials directory...\u0022);\r\n                commandShell.Add(\u0022rmdir /s {0}\u0022, tutorialsFolder);\r\n            }\r\n\r\n            if (nukeBuild)\r\n            {\r\n                commandShell.Add(\u0022#@ Checking out {0} source files...\\n\u0022, branchName);\r\n                commandShell.Add(\u0022# Checking out {0} source files...\u0022, branchName);\r\n                commandShell.Add(\u0022{0} checkout {1} {2}\u0022, subversion.Quote(), branchUrl.Quote(), buildRoot.Quote());\r\n            }\r\n\r\n            commandShell.Add(\u0022# Building Skyline...\u0022);\r\n            commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\r\n            foreach (int architecture in architectures)\r\n            {\r\n                commandShell.Add(\u0022#@ Building Skyline {0} bit...\\n\u0022, architecture);\r\n                commandShell.Add(\u0022{0} {1} {2} --i-agree-to-the-vendor-licenses toolset=msvc-12.0 nolog\u0022,\r\n                    Path.Combine(buildRoot, @\u0022pwiz_tools\\build-apps.bat\u0022).Quote(),\r\n                    architecture,\r\n                    runBuildTests ? \u0022pwiz_tools/Skyline\u0022 : \u0022pwiz_tools/Skyline//Skyline.exe\u0022);\r\n            }\r\n\r\n            commandShell.Add(\u0022# Build done.\u0022);\r\n        }\r\n\r\n        public void DeleteBuild()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            if (!Directory.Exists(buildRoot) ||\r\n                MessageBox.Show(MainWindow, \u0022Delete \\\u0022\u0022 \u002B buildRoot \u002B \u0022\\\u0022 folder?\u0022, \u0022Confirm delete\u0022,\r\n                    MessageBoxButtons.OKCancel) != DialogResult.OK)\r\n            {\r\n                return;\r\n            }\r\n\r\n            using (var deleteWindow = new DeleteWindow(buildRoot))\r\n            {\r\n                deleteWindow.ShowDialog();\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n        }\r\n\r\n        public void BrowseBuild()\r\n        {\r\n            using (var dlg = new FolderBrowserDialog\r\n            {\r\n                Description = \u0022Select or create a root folder for build source files.\u0022,\r\n                ShowNewFolderButton = true\r\n            })\r\n            {\r\n                if (dlg.ShowDialog(MainWindow) == DialogResult.OK)\r\n                    MainWindow.BuildRoot.Text = dlg.SelectedPath;\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(MainWindow.GetBuildRoot()); // MainWindow.GetBuildRoot() is the directory that actually gets deleted in DeleteBuild()\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 61509199,
    "FirstIndexed": "2020-04-25T15:47:03.6110589+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629213+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430736+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936648+02:00",
    "Name": "Luxa4Slack",
    "Owner": "gpailler",
    "HtmlUrl": "https://github.com/gpailler/Luxa4Slack",
    "Description": "Get Slack notifications on your Luxafor device",
    "Archived": false,
    "Stars": 7,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/gpailler/Luxa4Slack/blob/master/build/Build.cs",
    "BuildFileSize": 4268,
    "BuildFileContent": "using System;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.IO.CompressionTasks;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.TextTasks;\r\nusing static Nuke.Common.Logger;\r\nusing static Nuke.Common.Tools.GitVersion.GitVersionTasks;\r\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\r\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Solution]\r\n    readonly Solution Solution;\r\n\r\n    [GitVersion(Framework = \u0022netcoreapp2.1\u0022)]\r\n    readonly GitVersion GitVersion;\r\n\r\n    [PackageExecutable(\r\n        packageId: \u0022NSIS-Tool\u0022,\r\n        packageExecutable: \u0022makensis.exe\u0022,\r\n        Version = \u00223.0.5\u0022,\r\n        Framework = \u0022tools\u0022)]\r\n    readonly Tool MakeNsis;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n\r\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022bin\u0022 / Configuration;\r\n\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    AbsolutePath ArtifactFile =\u003E ArtifactsDirectory / $\u0022{Solution.Name}-{GitVersion.FullSemVer}.zip\u0022;\r\n\r\n    AbsolutePath InstallerFile =\u003E SourceDirectory / \u0022Luxa4Slack.Installer\u0022 / \u0022Luxa4Slack.Installer.nsi\u0022;\r\n\r\n    AbsolutePath InstallerVersionsFile =\u003E SourceDirectory / \u0022Luxa4Slack.Installer\u0022 / \u0022Versions.nsh\u0022;\r\n\r\n    AbsolutePath GlobalAssemblyInfoFile =\u003E SourceDirectory / \u0022GlobalAssemblyInfo.cs\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n\r\n            EnsureCleanDirectory(OutputDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            NuGetRestore(_ =\u003E _\r\n                .SetTargetPath(Solution)\r\n            );\r\n        });\r\n\r\n    Target PatchVersion =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            Info(\u0022Patch \u0022 \u002B GlobalAssemblyInfoFile);\r\n            GitVersion(_ =\u003E _\r\n                .SetFramework(\u0022netcoreapp2.1\u0022)\r\n                .SetArgumentConfigurator(_ =\u003E _\r\n                    .Add(\u0022/updateassemblyinfo {value}\u0022, GlobalAssemblyInfoFile)\r\n                )\r\n            );\r\n\r\n            Info(\u0022Patch \u0022 \u002B InstallerVersionsFile);\r\n            WriteAllLines(InstallerVersionsFile,\r\n                new[]\r\n                {\r\n                    $\u0022!define VERSIONMAJOR {GitVersion.Major}\u0022,\r\n                    $\u0022!define VERSIONMINOR {GitVersion.Minor}\u0022,\r\n                    $\u0022!define VERSIONPATCH {GitVersion.Patch}\u0022\r\n                });\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore, PatchVersion)\r\n        .Executes(() =\u003E\r\n        {\r\n            MSBuild(_ =\u003E _\r\n                .SetTargetPath(Solution)\r\n                .SetTargets(\u0022Rebuild\u0022)\r\n                .SetConfiguration(Configuration)\r\n                .SetMaxCpuCount(Environment.ProcessorCount)\r\n                .SetNodeReuse(IsLocalBuild));\r\n        });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Clean, Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            var extensions = new[] { \u0022.exe\u0022, \u0022.exe.config\u0022, \u0022.dll\u0022 };\r\n\r\n            CompressZip(\r\n                OutputDirectory,\r\n                ArtifactFile,\r\n                info =\u003E extensions.Any(extension =\u003E info.Name.EndsWith(extension)));\r\n        });\r\n\r\n    Target BuildInstaller =\u003E _ =\u003E _\r\n        .DependsOn(Clean, Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            MakeNsis(\r\n                arguments: $\u0022/V4 /DCONFIGURATION={Configuration} {InstallerFile}\u0022,\r\n                workingDirectory: InstallerFile.Parent,\r\n                logOutput: true);\r\n        });\r\n}\r\n"
  },
  {
    "Id": 63654418,
    "FirstIndexed": "2020-04-25T15:50:44.7356648+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627125+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434366+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894009+02:00",
    "Name": "Coconut",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/Coconut",
    "Description": "Small collection of experimental ReSharper features.",
    "Archived": false,
    "Stars": 8,
    "Watchers": 1,
    "BuildFilePath": "build/DefaultBuild.cs",
    "BuildFileUrl": "https://github.com/matkoch/Coconut/blob/master/build/DefaultBuild.cs",
    "BuildFileSize": 1745,
    "BuildFileContent": "\uFEFF// Copyright 2016, 2015, 2014 Matthias Koch\n// \n// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Core;\nusing Nuke.Core.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\nclass DefaultBuild : GitHubBuild\n{\n    public static void Main () =\u003E Execute\u003CDefaultBuild\u003E(x =\u003E x.Compile);\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(\n                () =\u003E DeleteDirectories(GlobDirectories(SolutionDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022)),\n                () =\u003E PrepareCleanDirectory(OutputDirectory));\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E NuGetRestore(SolutionFile));\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E MSBuild(s =\u003E DefaultSettings.MSBuildCompile));\n\n    Target Pack =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E GlobFiles(RootDirectory, \u0022/nuspec/*.nuspec\u0022)\n                    .ForEach(x =\u003E NuGetPack(x, s =\u003E DefaultSettings.NuGetPack\n                                .SetBasePath(SolutionDirectory))));\n}\n"
  },
  {
    "Id": 66568751,
    "FirstIndexed": "2020-04-25T15:50:44.7355527+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162655+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433882+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939635+02:00",
    "Name": "StyleCop.ReSharper",
    "Owner": "StyleCop",
    "HtmlUrl": "https://github.com/StyleCop/StyleCop.ReSharper",
    "Description": "Official ReSharper extension for StyleCop",
    "Archived": false,
    "Stars": 123,
    "Watchers": 16,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/StyleCop/StyleCop.ReSharper/blob/master/build/Build.cs",
    "BuildFileSize": 5168,
    "BuildFileContent": "\uFEFF// /*\n//  * Copyright 2007-2015 JetBrains\n//  *\n//  * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n//  * you may not use this file except in compliance with the License.\n//  * You may obtain a copy of the License at\n//  *\n//  * http://www.apache.org/licenses/LICENSE-2.0\n//  *\n//  * Unless required by applicable law or agreed to in writing, software\n//  * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  * See the License for the specific language governing permissions and\n//  * limitations under the License.\n//  */\n\nusing System;\nusing System.IO;\nusing System.Linq;\n\nusing Newtonsoft.Json.Linq;\n\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common;\nusing Nuke.Common.ChangeLog;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\n\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.HttpTasks;\nusing static Nuke.Common.IO.SerializationTasks;\nusing static Nuke.Common.IO.TextTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Common.Tooling.NuGetPackageResolver;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Logger;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\n\n// ReSharper disable ArrangeThisQualifier\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter] readonly string Configuration = \u0022Release\u0022;\n    [Parameter] readonly string Source = \u0022https://resharper-plugins.jetbrains.com/api/v2/package\u0022;\n    [Parameter] readonly string ApiKey;\n    [Parameter] readonly string Version;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    [Solution] readonly Solution Solution;\n\n    Project Project =\u003E Solution.GetProject(\u0022StyleCop.ReSharper\u0022);\n    string PackagesConfigFile =\u003E Project.Directory / \u0022packages.config\u0022;\n    string SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    string OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            NuGetRestore(s =\u003E s\n                .SetTargetPath(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetSolutionFile(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .DisableNodeReuse());\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E Version)\n        .Executes(() =\u003E\n        {\n            GlobFiles(RootDirectory / \u0022install\u0022, \u0022*.nuspec\u0022)\n                .ForEach(x =\u003E NuGetPack(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetConfiguration(Configuration)\n                    .SetVersion(Version)\n                    .SetBasePath(RootDirectory)\n                    .SetOutputDirectory(OutputDirectory)\n                    .SetProperty(\u0022wave\u0022, GetWaveVersion(PackagesConfigFile) \u002B \u0022.0\u0022)\n                    .SetProperty(\u0022currentyear\u0022, DateTime.Now.Year.ToString())\n                    .SetProperty(\u0022releasenotes\u0022, GetNuGetReleaseNotes(ChangelogFile, GitRepository))\n                    .EnableNoPackageAnalysis()));\n        });\n    \n    Target Changelog =\u003E _ =\u003E _\n        .Before(Pack)\n        .OnlyWhenStatic(() =\u003E !Version.Contains(\u0022-\u0022))\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, Version, GitRepository);\n            Git($\u0022add {ChangelogFile}\u0022);\n            Git($\u0022commit -m \\\u0022Finalize {Path.GetFileName(ChangelogFile)} for {Version}\\\u0022\u0022);\n            \n            Git($\u0022tag {Version}\u0022);\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack, Changelog)\n        .Requires(() =\u003E ExtractChangelogSectionNotes(ChangelogFile, Version).Any())\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022)\n                .ForEach(x =\u003E NuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)));\n        });\n\n    static string GetWaveVersion(string packagesConfigFile)\n    {\n        var fullWaveVersion = GetLocalInstalledPackages(packagesConfigFile)\n            .OrderByDescending(x =\u003E x.Version)\n            .FirstOrDefault(x =\u003E x.Id == \u0022Wave\u0022).NotNull(\u0022fullWaveVersion != null\u0022).Version.ToString();\n        return fullWaveVersion.Substring(startIndex: 0, length: fullWaveVersion.IndexOf(value: \u0027.\u0027));\n    }\n}"
  },
  {
    "Id": 66918170,
    "FirstIndexed": "2020-04-25T15:50:44.7356625+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627113+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434354+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "AirBender",
    "Owner": "ViGEm",
    "HtmlUrl": "https://github.com/ViGEm/AirBender",
    "Description": "Windows Bluetooth Host Driver for Sony DualShock Controllers",
    "Archived": true,
    "Stars": 38,
    "Watchers": 11,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 67038796,
    "FirstIndexed": "2020-04-25T15:50:44.7354713+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632347+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433552+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939327+02:00",
    "Name": "ReactiveHistory",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/ReactiveHistory",
    "Description": "Reactive undo/redo framework for .NET.",
    "Archived": false,
    "Stars": 52,
    "Watchers": 10,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/ReactiveHistory/blob/master/build/build/Build.cs",
    "BuildFileSize": 3744,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 68627303,
    "FirstIndexed": "2020-04-25T15:47:03.6114395+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631392+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430748+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936659+02:00",
    "Name": "Rogero.WpfNavigation",
    "Owner": "rog1039",
    "HtmlUrl": "https://github.com/rog1039/Rogero.WpfNavigation",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/rog1039/Rogero.WpfNavigation/blob/master/build/Build.cs",
    "BuildFileSize": 6096,
    "BuildFileContent": "using System;\nusing System.Globalization;\nusing System.Linq;\nusing _Build;\nusing JetBrains.Annotations;\nusing Microsoft.Build.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.CI.TeamCity;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    string PackagesDirectory  =\u003E Solution.Directory / \u0022packages\u0022;\n\n    [Parameter(\u0022Nuget API Key to push Nuget package to nuget.org\u0022)]\n    string NugetApiKey { get; set; }\n\n    [Parameter(\u0022Myget API Key to push Nuget package to myget.org public progero feed.\u0022)]\n    string MygetApiKey { get; set; }\n    \n    [Parameter(\u0022Perform a full nuget delete and reinstall\u0022)] readonly bool ReinstallAllPackages = false;\n\n\n    string MygetPushUrl { get; set; } = \u0022https://www.myget.org/F/progero/api/v2/package\u0022;\n    string MygetSymbolPushUrl { get; set; } = \u0022https://www.myget.org/F/progero/symbols/api/v2/package\u0022;\n\n    string[] NugetRestoreSources = new[] { \u0022https://www.myget.org/F/progero/api/v2/package\u0022, \u0022https://api.nuget.org/v3/index.json\u0022 };\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    private MyVersion GetVersionNumber()\n    {\n        var myVersion = new MyVersion(GitVersion);\n        return myVersion;\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target CleanArtifactsDirectoryOnly =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                        .SetTargetPath(Solution)\n                        .SetRestoreSources(NugetRestoreSources)\n                        .SetTargets(\u0022Restore\u0022));\n\n            NuGetTasks\n                .NuGetRestore(s =\u003E s\n                                  .SetSource(NugetRestoreSources)\n                                  .SetOutputDirectory(PackagesDirectory)\n                                  .SetTargetPath(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Warn(GitVersion);\n            var myVersion = GetVersionNumber();\n            TeamCity.Instance?.SetBuildNumber(myVersion.GetVersionNumber());\n\n            MSBuild(s =\u003E s\n                        .SetTargetPath(Solution)\n                        //.SetTargets(\u0022Rebuild\u0022)\n                        .SetConfiguration(Configuration)\n                        .SetAssemblyVersion(myVersion.GetAssemblyVersion())\n                        .SetFileVersion(myVersion.GetFileVersion())\n                        .SetInformationalVersion(myVersion.GetAssemblyVersion())\n                        .SetMaxCpuCount(Environment.ProcessorCount)\n                        .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target NugetPack =\u003E _ =\u003E _\n        .DependsOn(CleanArtifactsDirectoryOnly)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var version = GetVersionNumber();\n            var wpfNavigationProject = Solution.GetProject(\u0022Rogero.WpfNavigation\u0022);\n\n            NuGetTasks\n                .NuGetPack(s =\u003E s\n                               .SetVersion(version.GetAssemblyVersion())\n                               .SetOutputDirectory(ArtifactsDirectory)\n                               .EnableSymbols()\n                               .SetProperty(\u0022Configuration\u0022, Configuration.ToString())\n                               .SetSymbolPackageFormat(NuGetSymbolPackageFormat.symbols_nupkg)\n                               .SetTargetPath(wpfNavigationProject.Path)\n                );\n        });\n\n    Target NugetDotOrgPush =\u003E _ =\u003E _\n        .DependsOn(NugetPack)\n        .Executes(() =\u003E\n        {\n            //\n            //\n            NuGetTasks.NuGetPush(s =\u003E s\n                                     .SetNonInteractive(true)\n                                     .SetSymbolApiKey(NugetApiKey)\n                                     .DisableNoSymbols());\n        });\n\n    Target MygetPush =\u003E _ =\u003E _\n        .DependsOn(NugetPack)\n        .Executes(() =\u003E\n        {\n            var packages = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022);\n            //\n            NuGetTasks.NuGetPush(s =\u003E s\n                                     .SetNonInteractive(true)\n                                     .SetSource(MygetPushUrl)\n                                     .SetApiKey(MygetApiKey)\n                                     .SetSymbolSource(MygetSymbolPushUrl)\n                                     .SetSymbolApiKey(MygetApiKey)\n                                     .DisableNoSymbols()\n                                     .CombineWith(packages, (settings, path) =\u003E settings.SetTargetPath(path)));\n        });\n\n}\n"
  },
  {
    "Id": 69167356,
    "FirstIndexed": "2020-04-25T15:50:44.7356596+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631773+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434343+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940078+02:00",
    "Name": "Dangl.Calculator",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Dangl.Calculator",
    "Description": "C# library to evaluate formulas",
    "Archived": false,
    "Stars": 13,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Dangl.Calculator/blob/dev/build/Build.cs",
    "BuildFileSize": 16024,
    "BuildFileContent": "\uFEFFusing Nuke.Azure.KeyVault;\nusing Nuke.CoberturaConverter;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tooling;\nusing Nuke.DocFX;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.XmlTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing Nuke.Common.ProjectModel;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [KeyVault] readonly KeyVault KeyVault;\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [KeyVaultSecret] readonly string DocuBaseUrl;\n    [KeyVaultSecret] readonly string PublicMyGetSource;\n    [KeyVaultSecret] readonly string PublicMyGetApiKey;\n    [KeyVaultSecret] readonly string NuGetApiKey;\n    [KeyVaultSecret(\u0022DanglCalculator-DocuApiKey\u0022)] readonly string DocuApiKey;\n    [KeyVaultSecret] readonly string GitHubAuthenticationToken;\n\n    [Solution(\u0022Dangl.Calculator.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                GlobDirectories(RootDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore();\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(x =\u003E x\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore()\n                    .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion));\n            });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .SetTitle(\u0022Dangl.Calculator www.dangl-it.com\u0022)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n         .DependsOn(Compile)\n         .Executes(() =\u003E\n         {\n             var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022);\n             var testRun = 1;\n\n             try\n             {\n                 DotNetTest(x =\u003E x\n                     .SetNoBuild(true)\n                     .SetTestAdapterPath(\u0022.\u0022)\n                     .CombineWith(cc =\u003E testProjects\n                         .SelectMany(testProject =\u003E GetTestFrameworksForProjectFile(testProject)\n                             .Select(targetFramework =\u003E cc\n                                 .SetFramework(targetFramework)\n                                 .SetWorkingDirectory(Path.GetDirectoryName(testProject))\n                                 .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / $\u0022{testRun\u002B\u002B}_testresults-{targetFramework}.xml\u0022}\u0022)))),\n                                 degreeOfParallelism: Environment.ProcessorCount);\n             }\n             finally\n             {\n                 PrependFrameworkToTestresults();\n             }\n         });\n\n    Target LinuxTest =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            try\n            {\n                DotNetTest(x =\u003E x\n                   .SetWorkingDirectory(SolutionDirectory / \u0022test\u0022 / \u0022Dangl.Calculator.Tests\u0022)\n                   .SetTestAdapterPath(\u0022.\u0022)\n                   .SetFramework(\u0022netcoreapp2.2\u0022)\n                   .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / \u0022testresults-linux.xml\u0022}\u0022)\n                   // See here for more information:\n                   // https://github.com/dotnet/cli/issues/9397\n                   // There\u0027s a bug where the \u0027dotnet test\u0027 process hangs for 15 minutes after\n                   // test completion\n                   .SetArgumentConfigurator(ac =\u003E ac.Add(\u0022-nodereuse:false\u0022)));\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(async () =\u003E\n        {\n            var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022).ToList();\n            var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n\n            var snapshotIndex = 0;\n            try\n            {\n                DotCoverCover(c =\u003E c\n                    .SetTargetExecutable(dotnetPath)\n                    .SetFilters(\u0022\u002B:Dangl.Calculator\u0022)\n                    .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                    .CombineWith(cc =\u003E testProjects.SelectMany(testProject =\u003E {\n                        var projectDirectory = Path.GetDirectoryName(testProject);\n                        var targetFrameworks = GetTestFrameworksForProjectFile(testProject);\n                        return targetFrameworks.Select(targetFramework =\u003E\n                        {\n                            snapshotIndex\u002B\u002B;\n                            return cc\n                                .SetTargetWorkingDirectory(projectDirectory)\n                                .SetOutputFile(OutputDirectory / $\u0022coverage{snapshotIndex:00}.snapshot\u0022)\n                                .SetTargetArguments($\u0022test --no-build -f {targetFramework} --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={OutputDirectory}/{snapshotIndex}_testresults-{targetFramework}.xml\\\u0022\u0022);\n                        });\n                    })), degreeOfParallelism: System.Environment.ProcessorCount,\n                    completeOnFailure: true);\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n\n            var snapshots = GlobFiles(OutputDirectory, \u0022*.snapshot\u0022)\n               .Aggregate((c, n) =\u003E c \u002B \u0022;\u0022 \u002B n);\n\n            DotCoverMerge(c =\u003E c\n                .SetSource(snapshots)\n                .SetOutputFile(OutputDirectory / \u0022coverage.snapshot\u0022));\n\n            DotCoverReport(c =\u003E c\n                .SetSource(OutputDirectory / \u0022coverage.snapshot\u0022)\n                .SetOutputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            // This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                .SetReports(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            // This is the report in Cobertura format that integrates so nice in Jenkins\n            // dashboard and allows to extract more metrics and set build health based\n            // on coverage readings\n            await DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura_coverage.xml\u0022));\n        });\n\n    IEnumerable\u003Cstring\u003E GetTestFrameworksForProjectFile(string projectFile)\n    {\n        var targetFrameworks = XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFrameworks\u0022)\n            .Concat(XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFramework\u0022))\n            .Distinct()\n            .SelectMany(f =\u003E f.Split(\u0027;\u0027))\n            .Distinct();\n        return targetFrameworks;\n    }\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.SetProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(SolutionDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022api\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(nuGetPackages)\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken));\n        });\n\n    void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*testresults*.xml\u0022).ToList();\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n\n        // Merge all the results to a single file\n        // The \u0022run-time\u0022 attributes of the single assemblies is ensured to be unique for each single assembly by this test,\n        // since in Jenkins, the format is internally converted to JUnit. Aterwards, results with the same timestamps are\n        // ignored. See here for how the code is translated to JUnit format by the Jenkins plugin:\n        // https://github.com/jenkinsci/xunit-plugin/blob/d970c50a0501f59b303cffbfb9230ba977ce2d5a/src/main/resources/org/jenkinsci/plugins/xunit/types/xunitdotnet-2.0-to-junit.xsl#L75-L79\n        var firstXdoc = XDocument.Load(testResults[0]);\n        var runtime = DateTime.Now;\n        var firstAssemblyNodes = firstXdoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n        foreach (var assemblyNode in firstAssemblyNodes)\n        {\n            assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n            runtime = runtime.AddSeconds(1);\n        }\n        for (var i = 1; i \u003C testResults.Count; i\u002B\u002B)\n        {\n            var xDoc = XDocument.Load(testResults[i]);\n            var assemblyNodes = xDoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n            foreach (var assemblyNode in assemblyNodes)\n            {\n                assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n                runtime = runtime.AddSeconds(1);\n            }\n            firstXdoc.Root.Add(assemblyNodes);\n        }\n\n        firstXdoc.Save(OutputDirectory / \u0022testresults.xml\u0022);\n        testResults.ForEach(DeleteFile);\n    }\n\n    string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n}\n"
  },
  {
    "Id": 71038575,
    "FirstIndexed": "2020-04-25T15:50:44.7356574+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632069+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434337+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940067+02:00",
    "Name": "AsyncConverter",
    "Owner": "BigBabay",
    "HtmlUrl": "https://github.com/BigBabay/AsyncConverter",
    "Description": "Plugin for resharper, for converting code for async.",
    "Archived": false,
    "Stars": 129,
    "Watchers": 10,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BigBabay/AsyncConverter/blob/master/build/Build.cs",
    "BuildFileSize": 3410,
    "BuildFileContent": "using System.IO;\nusing System.IO.Compression;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Core;\nusing Nuke.Core.Utilities.Collections;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    public override AbsolutePath ArtifactsDirectory =\u003E SolutionDirectory / \u0022packages\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                EnsureCleanDirectory(ArtifactsDirectory);\n                var directories = GlobDirectories(SolutionDirectory / \u0022AsyncConverter\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022);\n                directories.ForEach(EnsureCleanDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(s =\u003E DefaultDotNetRestore.SetProjectFile(\u0022AsyncConverter/AsyncConverter.csproj\u0022));\n                DotNetRestore(s =\u003E DefaultDotNetRestore.SetProjectFile(\u0022AsyncConverter/AsyncConverter.Rider.csproj\u0022));\n                DotNetRestore(s =\u003E DefaultDotNetRestore.SetProjectFile(\u0022AsyncConverter.Tests/AsyncConverter.Tests.csproj\u0022));\n                DotNetRestore(s =\u003E DefaultDotNetRestore.SetProjectFile(\u0022AsyncConverter.Tests/AsyncConverter.Rider.Tests.csproj\u0022));\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E DefaultDotNetBuild);\n            });\n\n    Target Pack =\u003E _ =\u003E _\n                          .DependsOn(Compile)\n                          .Executes(() =\u003E\n                                    {\n                                    //TODO: DeleteDirectory not work, and move to Clean\n                                        if (Directory.Exists(ArtifactsDirectory))\n                                            Directory.Delete(ArtifactsDirectory, true);\n\n                                        DotNetPack(s =\u003E DefaultDotNetPack\n                                                       .SetOutputDirectory(ArtifactsDirectory)\n                                                       .DisableIncludeSymbols()\n                                                       .SetProject(\u0022AsyncConverter/AsyncConverter.csproj\u0022));\n\n                                        DotNetPack(s =\u003E DefaultDotNetPack\n                                                       .SetOutputDirectory(SolutionDirectory / \u0022Rider\u0022 / \u0022AsyncConverter.Rider\u0022)\n                                                       .DisableIncludeSymbols()\n                                                       .SetProject(\u0022AsyncConverter/AsyncConverter.Rider.csproj\u0022));\n\n                                        ZipFile.CreateFromDirectory(SolutionDirectory / \u0022Rider\u0022,\n                                            ArtifactsDirectory / $\u0022AsyncConverter.Rider.zip\u0022);\n                                    });\n}\n"
  },
  {
    "Id": 72932923,
    "FirstIndexed": "2020-04-25T15:47:03.6114674+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631403+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430759+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936671+02:00",
    "Name": "Rogero.Common",
    "Owner": "rog1039",
    "HtmlUrl": "https://github.com/rog1039/Rogero.Common",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/rog1039/Rogero.Common/blob/master/build/Build.cs",
    "BuildFileSize": 4979,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing _Build;\nusing Microsoft.Build.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Perform a full nuget delete and reinstall\u0022)] readonly bool ReinstallAllPackages = false;\n\n    [Solution]      readonly Solution      Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion]    readonly GitVersion    GitVersion;\n\n    AbsolutePath SourceDirectory          =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory       =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath NugetPackagesDirectory   =\u003E Solution.Directory / \u0022packages\u0022;\n    AbsolutePath NugetPackOutputDirectory =\u003E Solution.Directory / \u0022artifacts\u0022;\n\n    Project RogeroCommonProject =\u003E Solution.GetProject(\u0022Rogero.Common\u0022);\n    string  MyGetPrivateFeedUrl = \u0022https://www.myget.org/F/progerop/auth/08c5805d-ebbb-4edf-82f9-279dd8a6d16d/api/v3/index.json\u0022;\n    string  MyGetPublicFeedUrl  = \u0022https://www.myget.org/F/progero/api/v3/index.json\u0022;\n    string  ConfigurationString =\u003E Configuration == Configuration.Debug ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n            if (ReinstallAllPackages) EnsureCleanDirectory(NugetPackagesDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                        .SetTargetPath(Solution)\n                        .AddRestoreSources(MyGetPrivateFeedUrl, MyGetPublicFeedUrl)\n                        .SetTargets(\u0022Restore\u0022));\n\n            if (ReinstallAllPackages)\n                NuGetTasks\n                    .NuGetRestore(s =\u003E s\n                                      .SetTargetPath(Solution)\n                                      .SetSolutionDirectory(SourceDirectory)\n                                      .SetOutputDirectory(NugetPackagesDirectory));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            ;\n\n            MSBuild(s =\u003E s\n                        .SetTargetPath(Solution)\n                        //.SetTargets(\u0022Rebuild\u0022)\n                        .SetConfiguration(Configuration)\n                        .SetMaxCpuCount(Environment.ProcessorCount)\n                        .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            var version = new MyVersion(GitVersion);\n            //\n            //\n\n            //DotNetTasks\n            //    .DotNetPack(s =\u003E s\n            //                    .SetProject(RogeroCommonProject.Path)\n            //                    .SetConfiguration(Configuration.ToString())\n            //                    .SetIncludeSource(true)\n            //                    .SetIncludeSymbols(true)\n\n\n            //    );\n\n\n            NuGetTasks\n                .NuGetPack(s =\u003E s\n                               .SetVersion(version.GetAssemblyVersion())\n                               .SetOutputDirectory(ArtifactsDirectory)\n                               .EnableSymbols()\n                               .SetProperties(new Dictionary\u003Cstring, object\u003E\n                               {\n                                   {\u0022Configuration\u0022, Configuration.ToString()},\n                                   {\u0022Platform\u0022, \u0022AnyCPU\u0022}\n                               })\n                               .SetWorkingDirectory(Solution.Directory)\n                               .SetSymbolPackageFormat(NuGetSymbolPackageFormat.symbols_nupkg)\n                               .SetTargetPath(RogeroCommonProject.Path)\n                );\n        });\n}"
  },
  {
    "Id": 73080863,
    "FirstIndexed": "2020-04-25T15:50:44.7356551+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7363092+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434326+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940056+02:00",
    "Name": "easy-braille-edit",
    "Owner": "huanlin",
    "HtmlUrl": "https://github.com/huanlin/easy-braille-edit",
    "Description": "Easy Braille Edit is a text-to-braille tool for creating and printing text and braille documents.",
    "Archived": false,
    "Stars": 4,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/huanlin/easy-braille-edit/blob/master/build/Build.cs",
    "BuildFileSize": 2977,
    "BuildFileContent": "\uFEFFusing System;\nusing System.IO;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Core;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    Target Clean =\u003E _ =\u003E _\n            //.OnlyWhen(() =\u003E false) // Disabled for safety.\n            .Executes(() =\u003E\n            {\n                try\n                {\n                    // note: \u7576 Visual Studio \u5DF2\u7D93\u958B\u555F\u61C9\u7528\u7A0B\u5F0F\u5C08\u6848\uFF0C\u4EE5\u4E0B\u522A\u9664\u64CD\u4F5C\u6703\u56E0\u70BA\u76EE\u9304\u88AB\u9396\u4F4F\u800C\u5931\u6557\u3002\n                    DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                }\n                catch (Exception ex)\n                {\n                    Logger.Error($\u0022\u522A\u9664\u539F\u59CB\u78BC\u76EE\u9304\u4E0B\u7684 **/bin \u548C **/obj \u6642\u767C\u751F\u932F\u8AA4: {ex.Message}\u0022);\n                }\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Requires(() =\u003E GitVersion != null)\n            .Executes(() =\u003E\n            {\n                //GitVersionTasks.DefaultGitVersion.EnableUpdateAssemblyInfo();\n\n                MSBuild(s =\u003E DefaultMSBuildCompile);\n\n                string outputDir = OutputDirectory / \u0022net452\u0022;\n\n                if (GitRepository.Branch.Equals(Shared.ProductBranches.TaipeiForBlind, StringComparison.CurrentCultureIgnoreCase))\n                {\n                    string srcFileName = Path.Combine(outputDir, \u0022AppConfig.ForBlind.ini\u0022);\n                    string dstFileName = Path.Combine(outputDir, \u0022AppConfig.Default.ini\u0022);\n\n                    Logger.Info(Environment.NewLine \u002B \u0022**********\u003C\u003C\u003C \u984D\u5916\u8655\u7406 \u003E\u003E\u003E****************\u0022);\n                    Logger.Info($\u0022\u4F7F\u7528\u7279\u5B9A\u5206\u652F\u7248\u672C\u7684\u9810\u8A2D\u61C9\u7528\u7A0B\u5F0F\u7D44\u614B\u6A94\uFF1A\u0027{Shared.ProductBranches.TaipeiForBlind}\u0027\u0022);\n                    File.Copy(srcFileName, dstFileName, true);\n                    File.Delete(srcFileName);\n\n                    // Removing unnecessary files.\n                    var dir = new DirectoryInfo(outputDir);\n                    foreach (var file in dir.EnumerateFiles(\u0022*.pdb\u0022))\n                    {\n                        file.Delete();\n                    }\n                }\n            });\n}\n"
  },
  {
    "Id": 73963190,
    "FirstIndexed": "2020-04-25T15:50:44.7356528+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631733+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434314+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894005+02:00",
    "Name": "Dangl.Common",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Dangl.Common",
    "Description": "Utility library for common functionality",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Dangl.Common/blob/dev/build/Build.cs",
    "BuildFileSize": 16039,
    "BuildFileContent": "\uFEFFusing Nuke.CoberturaConverter;\nusing Nuke.Common.Git;\nusing Nuke.DocFX;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Linq;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing static Nuke.Common.IO.XmlTasks;\nusing System.Collections.Generic;\nusing Nuke.Azure.KeyVault;\nusing Nuke.Common.ProjectModel;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n    [KeyVault] KeyVault KeyVault;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n\n    private string _configuration;\n    [Parameter]\n    string Configuration\n    {\n        get =\u003E _configuration ?? (Host == HostType.Console ? \u0022Debug\u0022 : \u0022Release\u0022); // Defaults to \u0022Release\u0022 in CI server\n        set =\u003E _configuration = value;\n    }\n\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [Solution(\u0022Dangl.Common.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n    [KeyVaultSecret(\u0022DanglCommon-DocuApiKey\u0022)] string DocuApiKey;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                GlobDirectories(RootDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore();\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(x =\u003E x\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore()\n                    .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion));\n            });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022);\n            var testRun = 1;\n\n            try\n            {\n                DotNetTest(x =\u003E x\n                    .SetNoBuild(true)\n                    .SetTestAdapterPath(\u0022.\u0022)\n                    .CombineWith(cc =\u003E testProjects\n                        .SelectMany(testProject =\u003E GetTestFrameworksForProjectFile(testProject)\n                            .Select(targetFramework =\u003E cc\n                                .SetFramework(targetFramework)\n                                .SetWorkingDirectory(Path.GetDirectoryName(testProject))\n                                .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / $\u0022{testRun\u002B\u002B}_testresults-{targetFramework}.xml\u0022}\u0022)))),\n                                degreeOfParallelism: Environment.ProcessorCount);\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n        });\n\n    Target LinuxTest =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            try\n            {\n                DotNetTest(x =\u003E x\n                   .SetTestAdapterPath(\u0022.\u0022)\n                   .SetFramework(\u0022netcoreapp2.2\u0022)\n                   .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / $\u0022testresults-linux.xml\u0022}\u0022)\n                   // See here for more information:\n                   // https://github.com/dotnet/cli/issues/9397\n                   // There\u0027s a bug where the \u0027dotnet test\u0027 process hangs for 15 minutes after\n                   // test completion\n                   .SetArgumentConfigurator(ac =\u003E ac.Add(\u0022-nodereuse:false\u0022)));\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022).ToList();\n            var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n            var snapshotIndex = 0;\n            DotCoverCover(c =\u003E c\n                    .SetTargetExecutable(dotnetPath)\n                    .SetFilters(\u0022\u002B:Dangl.Common\u0022)\n                    .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                    .CombineWith(cc =\u003E testProjects.SelectMany(testProject =\u003E {\n                        var projectDirectory = Path.GetDirectoryName(testProject);\n                        var targetFrameworks = GetTestFrameworksForProjectFile(testProject);\n                        return targetFrameworks.Select(targetFramework =\u003E\n                        {\n                            snapshotIndex\u002B\u002B;\n                            return cc\n                                .SetTargetWorkingDirectory(projectDirectory)\n                                .SetOutputFile(OutputDirectory / $\u0022coverage{snapshotIndex:00}.snapshot\u0022)\n                                .SetTargetArguments($\u0022test --no-build -f {targetFramework} --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={OutputDirectory}/{snapshotIndex}_testresults-{targetFramework}.xml\\\u0022\u0022);\n                        });\n                    })), degreeOfParallelism: System.Environment.ProcessorCount);\n\n            PrependFrameworkToTestresults();\n\n            var snapshots = GlobFiles(OutputDirectory, \u0022*.snapshot\u0022)\n                .Aggregate((c, n) =\u003E c \u002B \u0022;\u0022 \u002B n);\n\n            DotCoverMerge(c =\u003E c\n                .SetSource(snapshots)\n                .SetOutputFile(OutputDirectory / \u0022coverage.snapshot\u0022));\n\n            DotCoverReport(c =\u003E c\n                .SetSource(OutputDirectory / \u0022coverage.snapshot\u0022)\n                .SetOutputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            // This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                .SetReports(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            // This is the report in Cobertura format that integrates so nice in Jenkins\n            // dashboard and allows to extract more metrics and set build health based\n            // on coverage readings\n            DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura_coverage.xml\u0022))\n                .ConfigureAwait(false)\n                .GetAwaiter()\n                .GetResult();\n        });\n\n    IEnumerable\u003Cstring\u003E GetTestFrameworksForProjectFile(string projectFile)\n    {\n        var targetFrameworks = XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFrameworks\u0022)\n            .Concat(XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFramework\u0022))\n            .Distinct()\n            .SelectMany(f =\u003E f.Split(\u0027;\u0027))\n            .Distinct();\n        return targetFrameworks;\n    }\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.SetProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(SolutionDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022api\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(nuGetPackages)\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken));\n        });\n\n    void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*testresults*.xml\u0022).ToList();\n        Logger.Log(LogLevel.Normal, $\u0022Found {testResults.Count} test result files on which to append the framework.\u0022);\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n\n        // Merge all the results to a single file\n        // The \u0022run-time\u0022 attributes of the single assemblies is ensured to be unique for each single assembly by this test,\n        // since in Jenkins, the format is internally converted to JUnit. Aterwards, results with the same timestamps are\n        // ignored. See here for how the code is translated to JUnit format by the Jenkins plugin:\n        // https://github.com/jenkinsci/xunit-plugin/blob/d970c50a0501f59b303cffbfb9230ba977ce2d5a/src/main/resources/org/jenkinsci/plugins/xunit/types/xunitdotnet-2.0-to-junit.xsl#L75-L79\n        Logger.Log(LogLevel.Normal, \u0022Updating \\\u0022run-time\\\u0022 attributes in assembly entries to prevent Jenkins to treat them as duplicates\u0022);\n        var firstXdoc = XDocument.Load(testResults[0]);\n        var runtime = DateTime.Now;\n        var firstAssemblyNodes = firstXdoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n        foreach (var assemblyNode in firstAssemblyNodes)\n        {\n            assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n            runtime = runtime.AddSeconds(1);\n        }\n        for (var i = 1; i \u003C testResults.Count; i\u002B\u002B)\n        {\n            var xDoc = XDocument.Load(testResults[i]);\n            var assemblyNodes = xDoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n            foreach (var assemblyNode in assemblyNodes)\n            {\n                assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n                runtime = runtime.AddSeconds(1);\n            }\n            firstXdoc.Root.Add(assemblyNodes);\n        }\n\n        firstXdoc.Save(OutputDirectory / \u0022testresults.xml\u0022);\n        testResults.ForEach(DeleteFile);\n    }\n\n    string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n}\n"
  },
  {
    "Id": 79031210,
    "FirstIndexed": "2020-04-25T15:50:44.7362273+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632677+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843494+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940653+02:00",
    "Name": "EffectiveTddDemo",
    "Owner": "dennisdoomen",
    "HtmlUrl": "https://github.com/dennisdoomen/EffectiveTddDemo",
    "Description": "Examples of how to refactor unit tests",
    "Archived": false,
    "Stars": 9,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/dennisdoomen/EffectiveTddDemo/blob/master/build/Build.cs",
    "BuildFileSize": 2162,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.Xunit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\npublic class Build : NukeBuild\n{\n    public static int Main()\n    {\n        return Execute\u003CBuild\u003E(x =\u003E x.UnitTests);\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022EffectiveTddDemo.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target UnitTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                );\n        });\n}"
  },
  {
    "Id": 80124443,
    "FirstIndexed": "2020-04-25T15:47:03.611489+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631528+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843077+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936682+02:00",
    "Name": "Pathfindax",
    "Owner": "Barsonax",
    "HtmlUrl": "https://github.com/Barsonax/Pathfindax",
    "Description": "Pathfinding framework",
    "Archived": false,
    "Stars": 16,
    "Watchers": 6,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Barsonax/Pathfindax/blob/master/build/Build.cs",
    "BuildFileSize": 8930,
    "BuildFileContent": "using System.Collections.Generic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.SonarScanner;\nusing Nuke.Common.Utilities;\nusing Nuke.DocFX;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.SonarScanner.SonarScannerTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing System;\nusing System.Threading.Tasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string ApiKey;\n    [Parameter] readonly bool CoberturaReport;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly AbsolutePath BaseBuildOutput = RootDirectory / \u0022BuildOutput\u0022;\n    AbsolutePath BuildOutput =\u003E BaseBuildOutput / Configuration;\n\n    [Parameter]\n    readonly string SonarCloudLogin;\n\n    AbsolutePath CoverageDirectory =\u003E RootDirectory / \u0022coverage\u0022;\n    AbsolutePath CoverageXml =\u003E CoverageDirectory / \u0022coverage.xml\u0022;\n    AbsolutePath CoverageHtml =\u003E CoverageDirectory / \u0022coverage.html\u0022;\n    AbsolutePath CoberturaReportPath =\u003E CoverageDirectory / \u0022Cobertura.xml\u0022;\n\n    AbsolutePath SrcPath =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath DocFXPath =\u003E SrcPath / \u0022Docs\u0022;\n    AbsolutePath DocFxOutput =\u003E DocFXPath / \u0022_site\u0022;\n    AbsolutePath DocFXJson =\u003E DocFXPath / \u0022docfx.json\u0022;\n    AbsolutePath DocsRepository =\u003E DocFXPath / \u0022repository\u0022;\n    AbsolutePath DocsRepositoryFolder =\u003E DocsRepository / \u0022docs\u0022;\n\n    [PathExecutable]\n    private static Tool Git;\n\n    [PathExecutable]\n    private static Tool Dotnet;\n\n    [PackageExecutable(\u0022dotnet-sonarscanner\u0022, @\u0022tools\\netcoreapp2.1\\any\\SonarScanner.MSBuild.dll\u0022)]\n    private static Tool SonarScanner;\n\n    private Dictionary\u003Cstring, object\u003E NoWarns = new Dictionary\u003Cstring, object\u003E { { \u0022NoWarn\u0022, \u0022NU1701\u0022 }, };\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(BuildOutput);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperties(NoWarns));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetProperties(NoWarns)\n                .SetProperty(\u0022BaseOutputPath\u0022, BaseBuildOutput \u002B \u0022/\u0022)\n                .SetProperty(\u0022GeneratePackageOnBuild\u0022, true)\n                .SetVersion(GitVersion.NuGetVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n            .SetOutput(BuildOutput / \u0022net472\u0022)\n            .SetWorkingDirectory(SrcPath)\n            .SetFramework(\u0022net472\u0022)\n            .SetConfiguration(Configuration)\n            .SetProperties(NoWarns)\n            .EnableNoBuild());\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n    {\n        string testdlls = GlobFiles(BuildOutput / \u0022net472\u0022, \u0022*.Test.dll\u0022).Join(\u0022 \u0022);\n        string targetArgs = $\u0022vstest {testdlls} /logger:trx;LogFileName=testresults.trx\u0022;\n        string dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n        AbsolutePath coverageSnapshot = CoverageDirectory / \u0022coverage.dcvr\u0022;\n        AbsolutePath coverageReport = CoverageDirectory / \u0022CoverageReport\u0022;\n\n        DotCoverCover(c =\u003E c\n             .SetTargetExecutable(dotnetPath)\n             .SetTargetWorkingDirectory(RootDirectory)\n             .SetTargetArguments(targetArgs)\n             .SetFilters(\u0022\u002B:Pathfindax*;-:*Test*;-:*Benchmark*\u0022)\n             .SetOutputFile(coverageSnapshot));\n\n        DotCoverReport(c =\u003E c\n            .SetSource(coverageSnapshot)\n            .SetOutputFile(CoverageXml)\n            .SetReportType(DotCoverReportType.DetailedXml));\n\n        DotCoverReport(c =\u003E c\n            .SetSource(coverageSnapshot)\n            .SetOutputFile(CoverageHtml)\n            .SetReportType(DotCoverReportType.Html));\n\n        if (CoberturaReport)\n        {\n            ReportGenerator(c =\u003E c\n                .SetReports(CoverageXml)\n                .SetTargetDirectory(CoverageDirectory)\n                .SetReportTypes(Nuke.Common.Tools.ReportGenerator.ReportTypes.Cobertura));\n        }\n    });\n\n    Target RunSonarScanner =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(SonarCloudLogin))\n        .Before(Compile)\n        .Triggers(SonarEnd)\n        .Executes(() =\u003E\n        {\n            var server = \u0022https://sonarcloud.io\u0022;\n            var projectKey = \u0022Barsonax_Pathfindax\u0022;\n            var organisation = \u0022barsonax-github\u0022;\n            var exclusions = \u0022src/Tests/**/*\u0022;\n            var branch = GitVersion.BranchName;\n            var version = GitVersion.GetNormalizedAssemblyVersion();\n            SonarScanner($\u0022begin /k:{projectKey} /o:{organisation} /v:{version} /d:sonar.login={SonarCloudLogin} /d:sonar.host.url={server} /d:sonar.exclusions={exclusions} /d:sonar.cs.dotcover.reportsPaths={CoverageHtml} /d:sonar.branch.name={branch}\u0022);\n        });\n\n    Target SonarEnd =\u003E _ =\u003E _\n    .After(RunSonarScanner, Test, Coverage, Compile)\n        .Executes(() =\u003E\n        {\n            SonarScannerEnd(s =\u003E s\n            .SetLogin(SonarCloudLogin));\n        });\n\n\n    Target Push =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(ApiKey))\n        .After(Test)\n        .After(Coverage)\n        .OnlyWhenDynamic(() =\u003E GitRepository.Branch == \u0022master\u0022)\n        .After(Compile)\n        .Executes(() =\u003E\n        {\n            var source = \u0022https://api.nuget.org/v3/index.json\u0022;\n            Parallel.ForEach(BuildOutput.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (nupkgFile) =\u003E\n            {\n                var errorIsWarning = false;\n                try\n                {\n                    Dotnet.Invoke($\u0022nuget push {nupkgFile} --source {source} --api-key {ApiKey}\u0022, customLogger: (type, output) =\u003E\n                    {\n                        if (output.StartsWith(\u0022error: Response status code does not indicate success: 409\u0022))\n                        {\n                            errorIsWarning = true;\n                            Nuke.Common.Logger.Log(LogLevel.Warning, $\u0022Ignoring {output}\u0022);\n                        }\n                        else\n                        {\n                            ProcessTasks.DefaultLogger(type, output);\n                        }\n                    });\n                }\n                catch (System.Exception e)\n                {\n                    if (errorIsWarning)\n                    {\n                        Logger.Warn(e.Message);\n                    }\n                    else\n                    {\n                        throw e;\n                    }\n                }\n            });\n        });\n\n    Target BuildDocs =\u003E _ =\u003E _\n    .Executes(() =\u003E\n    {\n        DocFXMetadata(s =\u003E s.SetProjects(DocFXJson).SetMSBuildProperty(\u0022SolutionDir\u0022, $\u0022{Solution.Directory}/\u0022));\n        DocFXBuild(s =\u003E s.SetConfigFile(DocFXJson));\n    });\n\n    Target PushDocs =\u003E _ =\u003E _\n        .DependsOn(BuildDocs)\n        .OnlyWhenDynamic(() =\u003E GitRepository.Branch == \u0022master\u0022)\n        .Executes(() =\u003E\n    {\n        EnsureCleanDirectory(DocsRepository);\n        Git($\u0022clone https://github.com/Barsonax/Pathfindax.Docs {DocsRepository}\u0022);\n        EnsureCleanDirectory(DocsRepositoryFolder);\n        CopyDirectoryRecursively(DocFxOutput, DocsRepositoryFolder, DirectoryExistsPolicy.Merge);\n        System.IO.Directory.SetCurrentDirectory(DocsRepository);\n        try\n        {\n            Git(\u0022add docs\u0022);\n            IgnoreError(() =\u003E Git(\u0022commit -m nuke_build_generated_commit\u0022));\n            Git(\u0022push\u0022);\n        }\n        finally\n        {\n            System.IO.Directory.SetCurrentDirectory(RootDirectory);\n        }\n    });\n\n    private void IgnoreError(Action action)\n    {\n        try\n        {\n            action.Invoke();\n        }\n        catch (System.Exception e)\n        {\n            Nuke.Common.Logger.Log(LogLevel.Warning, $\u0022Ignored error {e.Message}\u0022);\n        }\n    }\n}"
  },
  {
    "Id": 85151605,
    "FirstIndexed": "2020-04-25T15:47:03.610981+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622079+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430782+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936693+02:00",
    "Name": "csharp-language-server-protocol",
    "Owner": "OmniSharp",
    "HtmlUrl": "https://github.com/OmniSharp/csharp-language-server-protocol",
    "Description": "Language Server Protocol in C#",
    "Archived": false,
    "Stars": 167,
    "Watchers": 13,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/OmniSharp/csharp-language-server-protocol/blob/master/.build/Build.cs",
    "BuildFileSize": 1502,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 86790726,
    "FirstIndexed": "2020-04-25T15:47:03.6110686+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629759+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430793+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936705+02:00",
    "Name": "ReportDotNet",
    "Owner": "mifopen",
    "HtmlUrl": "https://github.com/mifopen/ReportDotNet",
    "Description": "Simple .NET library for complex reports \uD83D\uDDA8\uFE0F",
    "Archived": false,
    "Stars": 19,
    "Watchers": 4,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mifopen/ReportDotNet/blob/master/build/Build.cs",
    "BuildFileSize": 5949,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitHub;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\nclass Build: NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration =\n        IsLocalBuild\n            ? Configuration.Debug\n            : Configuration.Release;\n\n    [Parameter(\u0022NuGet api key\u0022)] readonly string ApiKey;\n    readonly string LicenseFile = RootDirectory / \u0022LICENSE\u0022;\n\n    [Parameter(\u0022Local nuget source\u0022)] readonly string LocalNugetSource;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean\n        =\u003E _ =\u003E _\n                .Before(Restore)\n                .Executes(() =\u003E\n                          {\n                              SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022)\n                                             .ToArray()\n                                             .ForEach(DeleteDirectory);\n                              TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022)\n                                            .ToArray()\n                                            .ForEach(DeleteDirectory);\n                              EnsureCleanDirectory(ArtifactsDirectory);\n                          });\n\n    Target Restore\n        =\u003E _ =\u003E _\n               .Executes(() =\u003E\n                         {\n                             DotNetRestore(s =\u003E s\n                                               .SetProjectFile(Solution));\n                         });\n\n    Target Compile\n        =\u003E _ =\u003E _\n                .DependsOn(Restore)\n                .Executes(() =\u003E\n                          {\n                              DotNetBuild(s =\u003E s\n                                               .SetProjectFile(Solution)\n                                               .SetConfiguration(Configuration)\n                                               .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                                               .SetFileVersion(GitVersion.AssemblySemFileVer)\n                                               .SetInformationalVersion(GitVersion.InformationalVersion)\n                                               .EnableNoRestore());\n                          });\n\n    Target Pack\n        =\u003E _ =\u003E _\n                .DependsOn(Clean, Compile)\n                .Executes(() =\u003E\n                          {\n                              var licenseUrl =\n                                  GitRepository.GetGitHubBrowseUrl(LicenseFile, \u0022master\u0022);\n                              DotNetPack(s =\u003E s\n                                              //.SetPackageReleaseNotes(changelogUrl)\n                                              .SetWorkingDirectory(RootDirectory)\n                                              .SetPackageLicenseUrl(licenseUrl)\n                                              .SetProject(Solution.Path)\n                                              .SetRepositoryUrl(\u0022https://github.com/mifopen/ReportDotNet\u0022)\n                                              .EnableNoBuild()\n                                              .SetConfiguration(Configuration)\n                                              .EnableIncludeSymbols()\n                                              .SetOutputDirectory(ArtifactsDirectory)\n                                              .SetDescription(\u0022Docx reports generator\u0022)\n                                              .SetAuthors(\u0022mif\u0022)\n                                              .SetPackageTags(\u0022reports\u0022, \u0022docx\u0022)\n                                              .SetVersion(GitVersion.NuGetVersionV2));\n                          });\n\n    Target Publish\n        =\u003E _ =\u003E _\n                .DependsOn(Pack)\n                .Requires(() =\u003E ApiKey)\n                .Requires(() =\u003E Equals(Configuration, Configuration.Release))\n                .Executes(() =\u003E\n                          {\n                              GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022)\n                                  .NotEmpty()\n                                  .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                                  .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                                                                     .SetTargetPath(x)\n                                                                     .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                                                                     .SetApiKey(ApiKey)));\n                          });\n\n    Target PublishLocal\n        =\u003E _ =\u003E _\n                .DependsOn(Pack)\n                .Requires(() =\u003E LocalNugetSource)\n                .Executes(() =\u003E\n                          {\n                              EnsureExistingDirectory(LocalNugetSource);\n                              GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022)\n                                  .NotEmpty()\n                                  .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                                  .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                                                                     .SetTargetPath(x)\n                                                                     .SetSource(LocalNugetSource)));\n                          });\n}\n"
  },
  {
    "Id": 87331350,
    "FirstIndexed": "2020-04-25T15:50:44.7363069+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7363081+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435082+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940801+02:00",
    "Name": "pwizard-deb",
    "Owner": "shze",
    "HtmlUrl": "https://github.com/shze/pwizard-deb",
    "Description": "Debian packaging for ProteoWizard",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileUrl": "https://github.com/shze/pwizard-deb/blob/master/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileSize": 7916,
    "BuildFileContent": "\uFEFF/*\r\n * Original author: Don Marsh \u003Cdonmarsh .at. u.washington.edu\u003E,\r\n *                  MacCoss Lab, Department of Genome Sciences, UW\r\n *\r\n * Copyright 2013 University of Washington - Seattle, WA\r\n * \r\n * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Windows.Forms;\r\nusing pwiz.Common.SystemUtil;\r\n\r\nnamespace SkylineTester\r\n{\r\n    public class TabBuild : TabBase\r\n    {\r\n        public TabBuild()\r\n        {\r\n            MainWindow.LabelSpecifyPath.Text =\r\n                \u0022(Specify absolute path or relative path from {0} folder)\u0022.With(Path.GetFileName(MainWindow.RootDir));\r\n        }\r\n\r\n        public override void Enter()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n            MainWindow.DefaultButton = MainWindow.RunBuild;\r\n        }\r\n\r\n        public override bool Run()\r\n        {\r\n            if (!MainWindow.HasBuildPrerequisites)\r\n                return false;\r\n            var architectures = GetArchitectures();\r\n            if (architectures.Count == 0)\r\n            {\r\n                MessageBox.Show(\u0022Select 32 or 64 bit architecture (or both).\u0022);\r\n                return false;\r\n            }\r\n\r\n            StartLog(\u0022Build\u0022, MainWindow.DefaultLogFile, true);\r\n            CreateBuildCommands(\r\n                GetBranchUrl(),\r\n                MainWindow.GetBuildRoot(), \r\n                architectures, \r\n                MainWindow.NukeBuild.Checked, \r\n                MainWindow.UpdateBuild.Checked,\r\n                MainWindow.RunBuildVerificationTests.Checked);\r\n            MainWindow.RunCommands();\r\n            return true;\r\n        }\r\n\r\n        public override bool Stop(bool success)\r\n        {\r\n            if (success \u0026\u0026 MainWindow.StartSln.Checked \u0026\u0026 MainWindow.Devenv != null)\r\n            {\r\n                var buildRoot = MainWindow.GetBuildRoot();\r\n                var slnDirectory = Path.Combine(buildRoot, @\u0022pwiz_tools\\Skyline\u0022);\r\n                var process = new Process\r\n                {\r\n                    StartInfo =\r\n                    {\r\n                        FileName = Path.Combine(slnDirectory, \u0022Skyline.sln\u0022),\r\n                        WorkingDirectory = slnDirectory,\r\n                        UseShellExecute = true,\r\n                    }\r\n                };\r\n                process.Start();\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public override int Find(string text, int position)\r\n        {\r\n            return VerifyFind(text, position, \u0022Build\u0022);\r\n        }\r\n\r\n        public static List\u003Cint\u003E GetArchitectures()\r\n        {\r\n            var architectures = new List\u003Cint\u003E();\r\n            if (MainWindow.Build32.Checked)\r\n                architectures.Add(32);\r\n            if (MainWindow.Build64.Checked)\r\n                architectures.Add(64);\r\n            return architectures;\r\n        }\r\n\r\n        public static string GetBranchUrl()\r\n        {\r\n            return MainWindow.BuildTrunk.Checked\r\n                ? @\u0022https://svn.code.sf.net/p/proteowizard/code/trunk/pwiz\u0022\r\n                : MainWindow.BranchUrl.Text;\r\n        }\r\n\r\n        public static void CreateBuildCommands(\r\n            string branchUrl, \r\n            string buildRoot, \r\n            IList\u003Cint\u003E architectures, \r\n            bool nukeBuild, \r\n            bool updateBuild,\r\n            bool runBuildTests)\r\n        {\r\n            var commandShell = MainWindow.CommandShell;\r\n            var branchParts = branchUrl.Split(\u0027/\u0027);\r\n            var branchName = \u0022Skyline ({0}/{1})\u0022.With(branchParts[branchParts.Length - 2], branchParts[branchParts.Length - 1]);\r\n            var subversion = MainWindow.Subversion;\r\n\r\n            var architectureList = string.Join(\u0022- and \u0022, architectures);\r\n            commandShell.Add(\u0022# Build {0} {1}-bit...\u0022, branchName, architectureList);\r\n\r\n            if (Directory.Exists(buildRoot))\r\n            {\r\n                if (nukeBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Deleting Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Deleting Build directory...\u0022);\r\n                    commandShell.Add(\u0022rmdir /s {0}\u0022, buildRoot.Quote());\r\n                }\r\n                else if (updateBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Updating Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Updating Build directory...\u0022);\r\n                    commandShell.Add(\u0022{0} cleanup {1}\u0022, subversion.Quote(), buildRoot.Quote());\r\n                    commandShell.Add(\u0022{0} update {1}\u0022, subversion.Quote(), buildRoot.Quote());\r\n                }\r\n            }\r\n\r\n            if (nukeBuild || updateBuild)\r\n            {\r\n                string tutorialsFolder = Path.Combine(PathEx.GetDownloadsPath(), \u0022Tutorials\u0022);\r\n                commandShell.Add(\u0022#@ Deleting Tutorials directory...\\n\u0022);\r\n                commandShell.Add(\u0022# Deleting Tutorials directory...\u0022);\r\n                commandShell.Add(\u0022rmdir /s {0}\u0022, tutorialsFolder);\r\n            }\r\n\r\n            if (nukeBuild)\r\n            {\r\n                commandShell.Add(\u0022#@ Checking out {0} source files...\\n\u0022, branchName);\r\n                commandShell.Add(\u0022# Checking out {0} source files...\u0022, branchName);\r\n                commandShell.Add(\u0022{0} checkout {1} {2}\u0022, subversion.Quote(), branchUrl.Quote(), buildRoot.Quote());\r\n            }\r\n\r\n            commandShell.Add(\u0022# Building Skyline...\u0022);\r\n            commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\r\n            foreach (int architecture in architectures)\r\n            {\r\n                commandShell.Add(\u0022#@ Building Skyline {0} bit...\\n\u0022, architecture);\r\n                commandShell.Add(\u0022{0} {1} {2} --i-agree-to-the-vendor-licenses toolset=msvc-12.0 nolog\u0022,\r\n                    Path.Combine(buildRoot, @\u0022pwiz_tools\\build-apps.bat\u0022).Quote(),\r\n                    architecture,\r\n                    runBuildTests ? \u0022pwiz_tools/Skyline\u0022 : \u0022pwiz_tools/Skyline//Skyline.exe\u0022);\r\n            }\r\n\r\n            commandShell.Add(\u0022# Build done.\u0022);\r\n        }\r\n\r\n        public void DeleteBuild()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            if (!Directory.Exists(buildRoot) ||\r\n                MessageBox.Show(MainWindow, \u0022Delete \\\u0022\u0022 \u002B buildRoot \u002B \u0022\\\u0022 folder?\u0022, \u0022Confirm delete\u0022,\r\n                    MessageBoxButtons.OKCancel) != DialogResult.OK)\r\n            {\r\n                return;\r\n            }\r\n\r\n            using (var deleteWindow = new DeleteWindow(buildRoot))\r\n            {\r\n                deleteWindow.ShowDialog();\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n        }\r\n\r\n        public void BrowseBuild()\r\n        {\r\n            using (var dlg = new FolderBrowserDialog\r\n            {\r\n                Description = \u0022Select or create a root folder for build source files.\u0022,\r\n                ShowNewFolderButton = true\r\n            })\r\n            {\r\n                if (dlg.ShowDialog(MainWindow) == DialogResult.OK)\r\n                    MainWindow.BuildRoot.Text = dlg.SelectedPath;\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(MainWindow.GetBuildRoot()); // MainWindow.GetBuildRoot() is the directory that actually gets deleted in DeleteBuild()\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 87346987,
    "FirstIndexed": "2020-04-25T15:50:44.735576+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631517+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433985+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939743+02:00",
    "Name": "XmlTools",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/XmlTools",
    "Description": "Tools for extracting information from Xml schemas and generating checking code",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/XmlTools/blob/master/build/Build.cs",
    "BuildFileSize": 11984,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Azure.KeyVault;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing System.IO;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing Nuke.Common.Utilities.Collections;\nusing System.Xml.Linq;\nusing System.Collections;\nusing System.Xml.XPath;\nusing Nuke.GitHub;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing Nuke.DocFX;\nusing Nuke.WebDocu;\nusing System.Collections.Generic;\nusing static Nuke.Common.IO.XmlTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret(\u0022XmlTools-DocuApiKey\u0022)] string DocuApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string DocFxFile =\u003E RootDirectory / \u0022docs\u0022 / \u0022docfx.json\u0022;\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(RootDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion($\u0022{GitVersion.Major}.{GitVersion.Minor}.{GitVersion.Patch}.0\u0022)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    private Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .EnableNoBuild()\n                .SetDescription(\u0022XmlTools - www.dangl-it.com\u0022)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(RootDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022);\n            var testRun = 1;\n\n            DotNetTest(c =\u003E c\n                .SetNoBuild(true)\n                .CombineWith(cc =\u003E testProjects.SelectMany(testProject =\u003E\n                {\n                    var projectDirectory = Path.GetDirectoryName(testProject);\n                    var targetFrameworks = GetTestFrameworksForProjectFile(testProject);\n                    return targetFrameworks.Select(targetFramework =\u003E\n                    {\n                        testRun\u002B\u002B;\n                        return cc\n                            .SetWorkingDirectory(projectDirectory)\n                            .SetFramework(targetFramework)\n                            .SetTestAdapterPath(\u0022.\u0022)\n                            .SetLogger($\u0022xunit;LogFilePath={OutputDirectory}/{testRun\u002B\u002B}_testresults-{targetFramework}.xml\u0022);\n                    });\n                })), degreeOfParallelism: System.Environment.ProcessorCount);\n\n\n\n            PrependFrameworkToTestresults();\n        });\n\n    IEnumerable\u003Cstring\u003E GetTestFrameworksForProjectFile(string projectFile)\n    {\n        var targetFrameworks = XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFrameworks\u0022)\n            .Concat(XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFramework\u0022))\n            .Distinct()\n            .SelectMany(f =\u003E f.Split(\u0027;\u0027))\n            .Distinct();\n        return targetFrameworks;\n    }\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(RootDirectory / \u0022docs\u0022 / \u0022index.md\u0022))\n            {\n                File.Delete(RootDirectory / \u0022docs\u0022 / \u0022index.md\u0022);\n            }\n\n            File.Copy(RootDirectory / \u0022README.md\u0022, RootDirectory / \u0022docs\u0022 / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(RootDirectory / \u0022docs\u0022 / \u0022index.md\u0022);\n            Directory.Delete(RootDirectory / \u0022docs\u0022 / \u0022api\u0022, true);\n            Directory.Delete(RootDirectory / \u0022docs\u0022 / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            await PublishRelease(x =\u003E x\n                .SetArtifactPaths(nuGetPackages)\n                .SetCommitSha(GitVersion.Sha)\n                .SetReleaseNotes(completeChangeLog)\n                .SetRepositoryName(repositoryInfo.repositoryName)\n                .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                .SetTag(releaseTag)\n                .SetToken(GitHubAuthenticationToken));\n        });\n\n    void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*testresults*.xml\u0022).ToList();\n        Logger.Log(LogLevel.Normal, $\u0022Found {testResults.Count} test result files on which to append the framework.\u0022);\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n\n        // Merge all the results to a single file\n        // The \u0022run-time\u0022 attributes of the single assemblies is ensured to be unique for each single assembly by this test,\n        // since in Jenkins, the format is internally converted to JUnit. Aterwards, results with the same timestamps are\n        // ignored. See here for how the code is translated to JUnit format by the Jenkins plugin:\n        // https://github.com/jenkinsci/xunit-plugin/blob/d970c50a0501f59b303cffbfb9230ba977ce2d5a/src/main/resources/org/jenkinsci/plugins/xunit/types/xunitdotnet-2.0-to-junit.xsl#L75-L79\n        Logger.Log(LogLevel.Normal, \u0022Updating \\\u0022run-time\\\u0022 attributes in assembly entries to prevent Jenkins to treat them as duplicates\u0022);\n        var firstXdoc = XDocument.Load(testResults[0]);\n        var runtime = DateTime.Now;\n        var firstAssemblyNodes = firstXdoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n        foreach (var assemblyNode in firstAssemblyNodes)\n        {\n            assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n            runtime = runtime.AddSeconds(1);\n        }\n        for (var i = 1; i \u003C testResults.Count; i\u002B\u002B)\n        {\n            var xDoc = XDocument.Load(testResults[i]);\n            var assemblyNodes = xDoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n            foreach (var assemblyNode in assemblyNodes)\n            {\n                assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n                runtime = runtime.AddSeconds(1);\n            }\n            firstXdoc.Root.Add(assemblyNodes);\n        }\n\n        firstXdoc.Save(OutputDirectory / \u0022testresults.xml\u0022);\n        testResults.ForEach(DeleteFile);\n    }\n\n    string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n}\n"
  },
  {
    "Id": 88773429,
    "FirstIndexed": "2020-04-25T15:50:44.7362535+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362546+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435043+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940755+02:00",
    "Name": ".NetStudy",
    "Owner": "WhistlerHusky",
    "HtmlUrl": "https://github.com/WhistlerHusky/.NetStudy",
    "Description": ".Net Study Project",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/WhistlerHusky/.NetStudy/blob/master/build/Build.cs",
    "BuildFileSize": 4492,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.OpenCover;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.Xunit;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.OpenCover.OpenCoverTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main()\n    {\n        Execute\u003CBuild\u003E(x =\u003E x.Test);\n        Console.ReadKey();\n\n        return 0;\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022.NetStudy.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory / \u0022Study\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(SourceDirectory / \u0022Nugets\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(SourceDirectory / \u0022Books\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(SourceDirectory / \u0022Tests\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols());\n        });\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            //xunit.runner.console\uC774 .net framework\uBC16\uC5D0 \uC9C0\uC6D0\uC548\uD574\uC11C \uC5B4\uCA54\uC218\uC5C6\uC774 net461\uB85C \uCF54\uB4DC \uD14C\uC2A4\uD2B8\n            var framework = \u0022net461\u0022;\n            var xunitSettings = new Xunit2Settings()\n                .SetFramework(framework)\n                .AddTargetAssemblies(GlobFiles(Solution.Directory / \u0022tests\u0022, $\u0022*/bin/{Configuration}/{framework}/*Test.dll\u0022).NotEmpty())\n                .AddResultReport(Xunit2ResultFormat.Xml, OutputDirectory / \u0022tests.xml\u0022);\n\n            if (IsWin)\n            {\n                OpenCover(s =\u003E s\n                    .SetTargetSettings(xunitSettings)\n                    .SetOutput(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetSearchDirectories(xunitSettings.TargetAssemblyWithConfigs.Select(x =\u003E Path.GetDirectoryName(x.Key)))\n                    .SetRegistration(RegistrationType.User)\n                    .SetTargetExitCodeOffset(targetExitCodeOffset: 0)\n                    .SetFilters(\n                        \u0022\u002B[*]*\u0022,\n                        \u0022-[xunit.*]*\u0022,\n                        \u0022-[FluentAssertions.*]*\u0022)\n                    .SetExcludeByAttributes(\u0022System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute\u0022));\n\n                ReportGenerator(s =\u003E s\n                    .AddReports(OutputDirectory / \u0022coverage.xml\u0022)\n                    .AddReportTypes(ReportTypes.Html)\n                    .SetTargetDirectory(OutputDirectory / \u0022coverage\u0022));\n            }\n            else\n                Xunit2(s =\u003E xunitSettings);\n        });\n}\n"
  },
  {
    "Id": 88865536,
    "FirstIndexed": "2020-04-25T15:50:44.7354759+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632365+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433575+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893935+02:00",
    "Name": "Math.Spatial",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/Math.Spatial",
    "Description": "A 2D spatial math primitives.",
    "Archived": false,
    "Stars": 13,
    "Watchers": 2,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/Math.Spatial/blob/master/build/build/Build.cs",
    "BuildFileSize": 3744,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 93804681,
    "FirstIndexed": "2020-04-25T15:47:03.6113695+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627665+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430804+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936716+02:00",
    "Name": "nuke",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/nuke",
    "Description": "The AKEless Build System for C#/.NET",
    "Archived": false,
    "Stars": 777,
    "Watchers": 35,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nuke-build/nuke/blob/develop/build/Build.cs",
    "BuildFileSize": 12912,
    "BuildFileContent": "// Copyright 2019 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/nuke/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.CI.TeamCity;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.InspectCode;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.Slack;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.ControlFlow;\nusing static Nuke.Common.Gitter.GitterTasks;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tools.InspectCode.InspectCodeTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.Slack.SlackTasks;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\n[ShutdownDotNetBuildServerOnFinish]\n[TeamCitySetDotCoverHomePath]\n[TeamCity(\n    TeamCityAgentPlatform.Windows,\n    Version = \u00222019.2\u0022,\n    VcsTriggeredTargets = new[] { nameof(Pack), nameof(Test) },\n    NightlyTriggeredTargets = new[] { nameof(Pack), nameof(Test) },\n    ManuallyTriggeredTargets = new[] { nameof(Publish) },\n    NonEntryTargets = new[] { nameof(Restore) },\n    ExcludedTargets = new[] { nameof(Clean) })]\n[GitHubActions(\n    \u0022continuous\u0022,\n    GitHubActionsImage.MacOs1014,\n    GitHubActionsImage.Ubuntu1604,\n    GitHubActionsImage.Ubuntu1804,\n    GitHubActionsImage.WindowsServer2016R2,\n    GitHubActionsImage.WindowsServer2019,\n    On = new[] { GitHubActionsTrigger.Push },\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) },\n    ImportGitHubTokenAs = nameof(GitHubToken),\n    ImportSecrets = new[] { nameof(SlackWebhook), nameof(GitterAuthToken) })]\n[AppVeyor(\n    AppVeyorImage.VisualStudio2019,\n    AppVeyorImage.Ubuntu1804,\n    SkipTags = true,\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) })]\n[AzurePipelines(\n    suffix: null,\n    AzurePipelinesImage.UbuntuLatest,\n    AzurePipelinesImage.WindowsLatest,\n    AzurePipelinesImage.MacOsLatest,\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) },\n    NonEntryTargets = new[] { nameof(Restore) },\n    ExcludedTargets = new[] { nameof(Clean), nameof(Coverage) })]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [CI] readonly TeamCity TeamCity;\n    [CI] readonly AzurePipelines AzurePipelines;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion(NoFetch = true)] readonly GitVersion GitVersion;\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\n    const string MasterBranch = \u0022master\u0022;\n    const string DevelopBranch = \u0022develop\u0022;\n    const string ReleaseBranchPrefix = \u0022release\u0022;\n    const string HotfixBranchPrefix = \u0022hotfix\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    [Parameter] bool IgnoreFailedSources;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetIgnoreFailedSources(IgnoreFailedSources));\n        });\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Project GlobalToolProject =\u003E Solution.GetProject(\u0022Nuke.GlobalTool\u0022);\n    Project MSBuildTasksProject =\u003E Solution.GetProject(\u0022Nuke.MSBuildTasks\u0022);\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n\n            var publishConfigurations =\n                from project in new[] { GlobalToolProject, MSBuildTasksProject }\n                from framework in project.GetTargetFrameworks()\n                select new { project, framework };\n\n            DotNetPublish(_ =\u003E _\n                    .SetNoRestore(InvokedTargets.Contains(Restore))\n                    .SetConfiguration(Configuration)\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                    .CombineWith(publishConfigurations, (_, v) =\u003E _\n                        .SetProject(v.project)\n                        .SetFramework(v.framework)),\n                degreeOfParallelism: 10);\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    AbsolutePath PackageDirectory =\u003E OutputDirectory / \u0022packages\u0022;\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(PackageDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackageDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    [Partition(2)] readonly Partition TestPartition;\n    AbsolutePath TestResultDirectory =\u003E OutputDirectory / \u0022test-results\u0022;\n    IEnumerable\u003CProject\u003E TestProjects =\u003E TestPartition.GetCurrent(Solution.GetProjects(\u0022*.Tests\u0022));\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Produces(TestResultDirectory / \u0022*.xml\u0022)\n        .Partition(() =\u003E TestPartition)\n        .Executes(() =\u003E\n        {\n            DotNetTest(_ =\u003E _\n                .SetConfiguration(Configuration)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .ResetVerbosity()\n                .SetResultsDirectory(TestResultDirectory)\n                .When(InvokedTargets.Contains(Coverage) || IsServerBuild, _ =\u003E _\n                    .EnableCollectCoverage()\n                    .SetCoverletOutputFormat(CoverletOutputFormat.cobertura)\n                    .SetExcludeByFile(\u0022*.Generated.cs\u0022)\n                    .When(IsServerBuild, _ =\u003E _\n                        .EnableUseSourceLink()))\n                .CombineWith(TestProjects, (_, v) =\u003E _\n                    .SetProjectFile(v)\n                    .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\n                    .When(InvokedTargets.Contains(Coverage) || IsServerBuild, _ =\u003E _\n                        .SetCoverletOutput(TestResultDirectory / $\u0022{v.Name}.xml\u0022))));\n\n            TestResultDirectory.GlobFiles(\u0022*.trx\u0022).ForEach(x =\u003E\n                AzurePipelines?.PublishTestResults(\n                    type: AzurePipelinesTestResultsType.VSTest,\n                    title: $\u0022{Path.GetFileNameWithoutExtension(x)} ({AzurePipelines.StageDisplayName})\u0022,\n                    files: new string[] { x }));\n        });\n\n    string CoverageReportDirectory =\u003E OutputDirectory / \u0022coverage-report\u0022;\n    string CoverageReportArchive =\u003E OutputDirectory / \u0022coverage-report.zip\u0022;\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .TriggeredBy(Test)\n        .Consumes(Test)\n        .Produces(CoverageReportArchive)\n        .Executes(() =\u003E\n        {\n            ReportGenerator(_ =\u003E _\n                .SetReports(TestResultDirectory / \u0022*.xml\u0022)\n                .SetReportTypes(ReportTypes.HtmlInline)\n                .SetTargetDirectory(CoverageReportDirectory)\n                .SetFramework(\u0022netcoreapp2.1\u0022));\n\n            TestResultDirectory.GlobFiles(\u0022*.xml\u0022).ForEach(x =\u003E\n                AzurePipelines?.PublishCodeCoverage(\n                    AzurePipelinesCodeCoverageToolType.Cobertura,\n                    x,\n                    CoverageReportDirectory));\n\n            CompressZip(\n                directory: CoverageReportDirectory,\n                archiveFile: CoverageReportArchive,\n                fileMode: FileMode.Create);\n        });\n\n    Target Analysis =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            InspectCode(_ =\u003E _\n                .SetTargetPath(Solution)\n                .SetOutput(OutputDirectory / \u0022inspectCode.xml\u0022)\n                .AddPlugin(\u0022EtherealCode.ReSpeller\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022PowerToys.CyclomaticComplexity\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022ReSharper.ImplicitNullability\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022ReSharper.SerializationInspections\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022ReSharper.XmlDocInspections\u0022, InspectCodePluginLatest));\n        });\n\n    [Parameter(\u0022NuGet Api Key\u0022)] readonly string ApiKey;\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Parameter(\u0022GitHub Token\u0022)] readonly string GitHubToken;\n    [Parameter(\u0022Gitter Auth Token\u0022)] readonly string GitterAuthToken;\n    [Parameter(\u0022Slack Webhook\u0022)] readonly string SlackWebhook;\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Test, Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E SlackWebhook)\n        .Requires(() =\u003E GitterAuthToken)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Requires(() =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch) ||\n                        GitRepository.Branch.EqualsOrdinalIgnoreCase(DevelopBranch) ||\n                        GitRepository.Branch.StartsWithOrdinalIgnoreCase(ReleaseBranchPrefix) ||\n                        GitRepository.Branch.StartsWithOrdinalIgnoreCase(HotfixBranchPrefix))\n        .Executes(() =\u003E\n        {\n            var packages = PackageDirectory.GlobFiles(\u0022*.nupkg\u0022);\n            Assert(packages.Count == 4, \u0022packages.Count == 4\u0022);\n\n            DotNetNuGetPush(_ =\u003E _\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(packages, (_, v) =\u003E _\n                        .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n        });\n\n    Target Announce =\u003E _ =\u003E _\n        .TriggeredBy(Publish)\n        .AssuredAfterFailure()\n        .OnlyWhenStatic(() =\u003E GitRepository.IsOnMasterBranch())\n        .Executes(() =\u003E\n        {\n            SendSlackMessage(_ =\u003E _\n                    .SetText(new StringBuilder()\n                        .AppendLine($\u0022\u003C!here\u003E :mega::shipit: *NUKE {GitVersion.SemVer} IS OUT!!!*\u0022)\n                        .AppendLine()\n                        .AppendLine(ChangelogSectionNotes.Select(x =\u003E x.Replace(\u0022- \u0022, \u0022\u2022 \u0022)).JoinNewLine()).ToString()),\n                SlackWebhook);\n\n            SendGitterMessage(new StringBuilder()\n                    .AppendLine($\u0022@/all :mega::shipit: **NUKE {GitVersion.SemVer} IS OUT!!!**\u0022)\n                    .AppendLine()\n                    .AppendLine(ChangelogSectionNotes.Select(x =\u003E x.Replace(\u0022- \u0022, \u0022* \u0022)).JoinNewLine()).ToString(),\n                \u0022593f3dadd73408ce4f66db89\u0022,\n                GitterAuthToken);\n        });\n\n    Target Install =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Executes(() =\u003E\n        {\n            SuppressErrors(() =\u003E DotNet($\u0022tool uninstall -g {GlobalToolProject.Name}\u0022));\n            DotNet($\u0022tool install -g {GlobalToolProject.Name} --add-source {OutputDirectory} --version {GitVersion.NuGetVersionV2}\u0022);\n        });\n}\n"
  },
  {
    "Id": 95213667,
    "FirstIndexed": "2020-04-25T15:50:44.7360811+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631363+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434747+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940471+02:00",
    "Name": "sitecore-docker",
    "Owner": "avivasolutionsnl",
    "HtmlUrl": "https://github.com/avivasolutionsnl/sitecore-docker",
    "Description": "Dockerized Sitecore 9 XP0 \u0026 XC",
    "Archived": false,
    "Stars": 31,
    "Watchers": 23,
    "BuildFilePath": "build/Build.Xc.cs",
    "BuildFileUrl": "https://github.com/avivasolutionsnl/sitecore-docker/blob/master/build/Build.Xc.cs",
    "BuildFileSize": 15704,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Docker.DockerTasks;\nusing Nuke.Docker;\nusing Nuke.Common.Tooling;\nusing System.Collections.Generic;\n\npartial class Build : NukeBuild\n{\n    [Parameter(\u0022Docker image sitecore version\u0022)]\n    public readonly string XcSitecoreVersion = \u00229.2.0\u0022;\n    // Docker image naming\n    [Parameter(\u0022Docker image prefix for Sitecore XC\u0022)]\n    readonly string XcImagePrefix = \u0022sitecore-xc-\u0022;\n\n    private string XcFullImageName(string name) =\u003E string.IsNullOrEmpty(BuildVersion) ? \n    $\u0022{RepoImagePrefix}/{XcImageName(name)}\u0022 : \n    $\u0022{RepoImagePrefix}/{XcImageName(name)}-{BuildVersion}\u0022;\n    private string XcImageName(string name) =\u003E $\u0022{XcNakedImageName(name)}:{XcSitecoreVersion}\u0022;\n    private string XcNakedImageName(string name) =\u003E $\u0022{XcImagePrefix}{name}\u0022;\n\n    private IEnumerable\u003Cstring\u003E XcRepositoryNames =\u003E XcNames\n        .Concat(XcJssNames)\n        .Concat(XcSxaNames)\n        .Select(XcNakedImageName);\n\n    // Packages\n    [Parameter(\u0022Sitecore BizFx package\u0022)]\n    readonly string SITECORE_BIZFX_PACKAGE = \u0022Sitecore.BizFx.OnPrem.3.0.7.scwdp.zip\u0022;\n\n    [Parameter(\u0022Commerce Engine package\u0022)]\n    readonly string COMMERCE_ENGINE_PACKAGE = \u0022Sitecore.Commerce.Engine.OnPrem.Solr.4.0.165.scwdp.zip\u0022;\n\n    [Parameter(\u0022Commerce Connect package\u0022)]\n    readonly string COMMERCE_CONNECT_PACKAGE = \u0022Sitecore Commerce Connect Core OnPrem 13.0.16.scwdp.zip\u0022;\n\n    [Parameter(\u0022Commerce Connect Engine package\u0022)]\n    readonly string COMMERCE_CONNECT_ENGINE_PACKAGE = \u0022Sitecore Commerce Engine Connect OnPrem 4.0.55.scwdp.zip\u0022;\n\n    [Parameter(\u0022Commerce SIF package\u0022)]\n    readonly string COMMERCE_SIF_PACKAGE = \u0022SIF.Sitecore.Commerce.3.0.28.zip\u0022;\n\n    [Parameter(\u0022Commerce Marketing Automation package\u0022)]\n    readonly string COMMERCE_MA_PACKAGE = \u0022Sitecore Commerce Marketing Automation Core OnPrem 13.0.16.scwdp.zip\u0022;\n\n    [Parameter(\u0022Commerce Marketing Automation for AutomationEngine package\u0022)]\n    readonly string COMMERCE_MA_FOR_AUTOMATION_ENGINE_PACKAGE = \u0022Sitecore Commerce Marketing Automation for AutomationEngine 13.0.16.zip\u0022;\n\n    [Parameter(\u0022Commerce XP Core package\u0022)]\n    readonly string COMMERCE_XPROFILES_PACKAGE = \u0022Sitecore Commerce ExperienceProfile Core OnPrem 13.0.16.scwdp.zip\u0022;\n\n    [Parameter(\u0022Commerce XP Analytics Core package\u0022)]\n    readonly string COMMERCE_XANALYTICS_PACKAGE = \u0022Sitecore Commerce ExperienceAnalytics Core OnPrem 13.0.16.scwdp.zip\u0022;\n\n    [Parameter(\u0022SXA Commerce package\u0022)]\n    readonly string SCXA_PACKAGE = \u0022Sitecore Commerce Experience Accelerator 3.0.108.scwdp.zip\u0022;\n\n    [Parameter(\u0022Web transform tool\u0022)]\n    readonly string WEB_TRANSFORM_TOOL = \u0022Microsoft.Web.XmlTransform.dll\u0022;\n\n    [Parameter(\u0022Plumber package\u0022)]\n    readonly string PLUMBER_FILE_NAME = \u0022plumber-sc.1.1.3.zip\u0022;\n\n    // Certificates\n    [Parameter(\u0022Commerce certificate file\u0022)]\n    readonly string COMMERCE_CERT_PATH = \u0022commerce.pfx\u0022;\n\n    [Parameter(\u0022Root certificate file\u0022)]\n    readonly string ROOT_CERT_PATH = \u0022root.pfx\u0022;\n\n    [Parameter(\u0022Sitecore certificate file\u0022)]\n    readonly string SITECORE_CERT_PATH = \u0022sitecore.pfx\u0022;\n\n    [Parameter(\u0022Xconnect certificate file\u0022)]\n    readonly string XCONNECT_CERT_PATH = \u0022xconnect-client.pfx\u0022;\n\n    [Parameter(\u0022Identity server certificate file\u0022)]\n    readonly string IDENTITY_CERT_PATH = \u0022identity.pfx\u0022;\n\n    // Build configuration parameters\n    [Parameter(\u0022Commerce shop name\u0022)]\n    readonly string SHOP_NAME = \u0022CommerceEngineDefaultStorefront\u0022;\n\n    [Parameter(\u0022Commerce environment name\u0022)]\n    readonly string ENVIRONMENT_NAME = \u0022HabitatAuthoring\u0022;\n\n    [Parameter(\u0022Commerce database prefix\u0022)]    \n    readonly string COMMERCE_DB_PREFIX = \u0022SitecoreCommerce9\u0022;\n\n    public AbsolutePath XcLicenseFile = RootDirectory / \u0022xc\u0022 / \u0022license\u0022 / \u0022license.xml\u0022;\n\n    private string[] XcNames = new string[]\n    {\n        \u0022commerce\u0022,\n        \u0022identity\u0022,\n        \u0022mssql\u0022,\n        \u0022sitecore\u0022,\n        \u0022solr\u0022,\n        \u0022xconnect\u0022\n    };\n\n    private string[] XcSxaNames = new string[]\n    {\n        \u0022mssql-sxa\u0022,\n        \u0022sitecore-sxa\u0022,\n        \u0022solr-sxa\u0022\n    };\n\n    private string[] XcJssNames = new string[]\n    {\n        \u0022mssql-jss\u0022,\n        \u0022sitecore-jss\u0022\n    };\n\n    Target XcCommerce =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_SIF_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / SITECORE_BIZFX_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_ENGINE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / PLUMBER_FILE_NAME))\n        .Executes(() =\u003E\n        {\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/commerce/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022commerce\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022SQL_SA_PASSWORD={SQL_SA_PASSWORD}\u0022,\n                    $\u0022SQL_DB_PREFIX={SQL_DB_PREFIX}\u0022,\n                    $\u0022SOLR_PORT={SOLR_PORT}\u0022,  \n                    $\u0022COMMERCE_SIF_PACKAGE={COMMERCE_SIF_PACKAGE}\u0022,\n                    $\u0022SITECORE_BIZFX_PACKAGE={SITECORE_BIZFX_PACKAGE}\u0022,\n                    $\u0022COMMERCE_ENGINE_PACKAGE={COMMERCE_ENGINE_PACKAGE}\u0022,\n                    $\u0022COMMERCE_CERT_PATH={COMMERCE_CERT_PATH}\u0022,\n                    $\u0022ROOT_CERT_PATH={ROOT_CERT_PATH}\u0022,\n                    $\u0022XCONNECT_CERT_PATH={XCONNECT_CERT_PATH}\u0022,\n                    $\u0022PLUMBER_FILE_NAME={PLUMBER_FILE_NAME}\u0022\n                })\n            );\n        });\n    \n    Target XcSolr =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_SIF_PACKAGE))\n        .DependsOn(BaseSolrBuilder, XpSolr)\n        .Executes(() =\u003E\n        {\n            var baseImage = XpImageName(\u0022solr\u0022);\n            var builderBaseImage = BaseImageName(\u0022solr-builder\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/solr/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022solr\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022BUILDER_BASE_IMAGE={builderBaseImage}\u0022,\n                    $\u0022SITECORE_CORE_PREFIX={SITECORE_SOLR_CORE_PREFIX}\u0022,\n                    $\u0022COMMERCE_SIF_PACKAGE={COMMERCE_SIF_PACKAGE}\u0022\n                })\n            );\n        });\n\n    Target XcXconnect =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_MA_FOR_AUTOMATION_ENGINE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_CONNECT_PACKAGE))\n        .DependsOn(XpXconnect)\n        .Executes(() =\u003E\n        {\n            var baseImage = XpImageName(\u0022xconnect\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/xconnect/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022xconnect\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022COMMERCE_MA_FOR_AUTOMATION_ENGINE_PACKAGE={COMMERCE_MA_FOR_AUTOMATION_ENGINE_PACKAGE}\u0022,\n                    $\u0022COMMERCE_CONNECT_PACKAGE={COMMERCE_CONNECT_PACKAGE}\u0022\n                })\n            );\n        });\n\n    Target XcIdentity =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_SIF_PACKAGE))\n        .DependsOn(XpIdentity)\n        .Executes(() =\u003E\n        {\n            var baseImage = XpImageName(\u0022identity\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/identityserver/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022identity\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022COMMERCE_SIF_PACKAGE={COMMERCE_SIF_PACKAGE}\u0022\n                })\n            );\n        });\n    \n    Target XcSitecoreSxa =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / PSE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / SXA_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / SCXA_PACKAGE))\n        .DependsOn(XcSitecore)\n        .Executes(() =\u003E {\n            var baseImage = XcImageName(\u0022sitecore\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/sitecore/sxa/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022sitecore-sxa\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022PSE_PACKAGE={PSE_PACKAGE}\u0022,\n                    $\u0022SXA_PACKAGE={SXA_PACKAGE}\u0022,\n                    $\u0022SCXA_PACKAGE={SCXA_PACKAGE}\u0022,\n                    $\u0022WEB_TRANSFORM_TOOL={WEB_TRANSFORM_TOOL}\u0022\n                })\n            );\n        });\n    \n    Target XcMssqlSxa =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / PSE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / SXA_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / SCXA_PACKAGE))\n        .DependsOn(XcMssql)\n        .Executes(() =\u003E {\n            var baseImage = XcImageName(\u0022mssql\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/mssql/sxa/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022mssql-sxa\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022PSE_PACKAGE={PSE_PACKAGE}\u0022,\n                    $\u0022SXA_PACKAGE={SXA_PACKAGE}\u0022,\n                    $\u0022SCXA_PACKAGE={SCXA_PACKAGE}\u0022\n                })\n            );\n        });\n\n    Target XcSolrSxa =\u003E _ =\u003E _\n        .DependsOn(BaseSolrBuilder, XcSolr)\n        .Executes(() =\u003E {\n            var baseImage = XcImageName(\u0022solr\u0022);\n            var builderBaseImage = BaseImageName(\u0022solr-builder\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022xc/solr/sxa\u0022)\n                .SetTag(XcImageName(\u0022solr-sxa\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022BUILDER_BASE_IMAGE={builderBaseImage}\u0022\n                })\n            );\n        });\n    \n    Target XcSitecoreJss =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / JSS_PACKAGE))\n        .DependsOn(XcSitecore)\n        .Executes(() =\u003E {\n            var baseImage = XcImageName(\u0022sitecore\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/sitecore/jss/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022sitecore-jss\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022JSS_PACKAGE={JSS_PACKAGE}\u0022\n                })\n            );\n        });\n    \n    Target XcMssqlJss =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / JSS_PACKAGE))\n        .DependsOn(XcMssql)\n        .Executes(() =\u003E {\n            var baseImage = XcImageName(\u0022mssql\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/mssql/jss/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022mssql-jss\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022JSS_PACKAGE={JSS_PACKAGE}\u0022\n                })\n            );\n        });\n\n    Target XcSitecore =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_CONNECT_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_CONNECT_ENGINE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_SIF_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_MA_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_XPROFILES_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_XANALYTICS_PACKAGE))\n        .DependsOn(XpSitecore)\n        .Executes(() =\u003E\n        {\n            var baseImage = XpImageName(\u0022sitecore\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/sitecore/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022sitecore\u0022))\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022COMMERCE_CERT_PATH={COMMERCE_CERT_PATH}\u0022,\n                    $\u0022COMMERCE_CONNECT_PACKAGE={COMMERCE_CONNECT_PACKAGE}\u0022,\n                    $\u0022COMMERCE_CONNECT_ENGINE_PACKAGE={COMMERCE_CONNECT_ENGINE_PACKAGE}\u0022,\n                    $\u0022COMMERCE_SIF_PACKAGE={COMMERCE_SIF_PACKAGE}\u0022,\n                    $\u0022COMMERCE_MA_PACKAGE={COMMERCE_MA_PACKAGE}\u0022,\n                    $\u0022COMMERCE_XPROFILES_PACKAGE={COMMERCE_XPROFILES_PACKAGE}\u0022,\n                    $\u0022COMMERCE_XANALYTICS_PACKAGE={COMMERCE_XANALYTICS_PACKAGE}\u0022,\n                    $\u0022WEB_TRANSFORM_TOOL={WEB_TRANSFORM_TOOL}\u0022,\n                })\n            );\n        });\n\n\n    Target XcMssql =\u003E _ =\u003E _\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_ENGINE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_CONNECT_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_CONNECT_ENGINE_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_MA_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_XPROFILES_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_XANALYTICS_PACKAGE))\n        .Requires(() =\u003E File.Exists(Files / COMMERCE_SIF_PACKAGE))\n        .DependsOn(XpMssql)\n        .Executes(() =\u003E {\n            var baseImage = XpImageName(\u0022mssql\u0022);\n\n            DockerBuild(x =\u003E x\n                .SetPath(\u0022.\u0022)\n                .SetFile(\u0022xc/mssql/Dockerfile\u0022)\n                .SetTag(XcImageName(\u0022mssql\u0022))\n                .SetMemory(4000000000) // 4GB, SQL needs some more memory\n                .SetBuildArg(new string[] {\n                    $\u0022BASE_IMAGE={baseImage}\u0022,\n                    $\u0022SQL_DB_PREFIX={SQL_DB_PREFIX}\u0022,                    \n                    $\u0022COMMERCE_DB_PREFIX={COMMERCE_DB_PREFIX}\u0022,\n                    $\u0022COMMERCE_CERT_PATH={COMMERCE_CERT_PATH}\u0022,\n                    $\u0022COMMERCE_ENGINE_PACKAGE={COMMERCE_ENGINE_PACKAGE}\u0022,\n                    $\u0022COMMERCE_CONNECT_PACKAGE={COMMERCE_CONNECT_PACKAGE}\u0022,\n                    $\u0022COMMERCE_CONNECT_ENGINE_PACKAGE={COMMERCE_CONNECT_ENGINE_PACKAGE}\u0022,\n                    $\u0022COMMERCE_MA_PACKAGE={COMMERCE_MA_PACKAGE}\u0022,\n                    $\u0022COMMERCE_XPROFILES_PACKAGE={COMMERCE_XPROFILES_PACKAGE}\u0022,\n                    $\u0022COMMERCE_XANALYTICS_PACKAGE={COMMERCE_XANALYTICS_PACKAGE}\u0022,\n                    $\u0022COMMERCE_SIF_PACKAGE={COMMERCE_SIF_PACKAGE}\u0022,\n                })\n            );\n        });\n\n    Target Xc =\u003E _ =\u003E _\n        .DependsOn(XcCommerce, XcSitecore, XcMssql, XcSolr, XcXconnect, XcIdentity, BaseRedis);\n\n    Target XcSxa =\u003E _ =\u003E _\n        .DependsOn(Xc, XcSitecoreSxa, XcMssqlSxa, XcSolrSxa);\n\n    Target XcJss =\u003E _ =\u003E _\n        .DependsOn(Xc, XcSitecoreJss, XcMssqlJss);        \n\n    Target PushXc =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(RepoImagePrefix))\n        .OnlyWhenDynamic(() =\u003E HasGitTag() || ForcePush)\n        .Executes(() =\u003E {\n            foreach(var name in XcNames)\n            {\n                PushXcImage(name);\n            }\n        });\n    \n    Target PushXcSxa =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(RepoImagePrefix))\n        .OnlyWhenDynamic(() =\u003E HasGitTag() || ForcePush)\n        .Executes(() =\u003E {\n            foreach (var name in XcSxaNames)\n            {\n                PushXcImage(name);\n            }\n        });\n\n    Target PushXcJss =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(RepoImagePrefix))\n        .OnlyWhenDynamic(() =\u003E HasGitTag() || ForcePush)\n        .Executes(() =\u003E {\n\n            foreach (var name in XcJssNames)\n            {\n                PushXcImage(name);\n            }\n        });\n\n    private void PushXcImage(string name)\n    {\n        var source = XcImageName(name);\n        var target = XcFullImageName(name);\n        DockerTasks.DockerImageTag(x =\u003E x\n        .SetSourceImage(source)\n        .SetTargetImage(target));\n\n        DockerTasks.DockerImagePush(x =\u003E x.SetName(target));\n    }\n}\n"
  },
  {
    "Id": 95994248,
    "FirstIndexed": "2020-04-25T15:50:44.7356699+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630999+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434383+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940113+02:00",
    "Name": "web",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/web",
    "Description": "Generation engine for website",
    "Archived": false,
    "Stars": 1,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nuke-build/web/blob/master/build/Build.cs",
    "BuildFileSize": 5767,
    "BuildFileContent": "\uFEFF// Copyright Matthias Koch 2018.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/web/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing FluentFTP;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DocFX;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static CustomTocWriter;\nusing static Disclaimer;\nusing static CustomDocFx;\nusing static Nuke.Common.IO.SerializationTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.FtpTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Logger;\nusing static Nuke.Common.Tools.DocFX.DocFXTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildSite);\n\n    [Parameter] readonly string FtpUsername;\n    [Parameter] readonly string FtpPassword;\n    [Parameter] readonly string FtpServer;\n\n    [Parameter] readonly bool PublishDocs;\n    [Parameter] readonly bool PublishImages;\n    [Parameter] readonly bool PublishApi;\n\n    new AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    new AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\n    AbsolutePath GenerationDirectory =\u003E TemporaryDirectory / \u0022packages\u0022;\n    AbsolutePath ApiDirectory =\u003E SourceDirectory / \u0022api\u0022;\n\n    string DocFxFile =\u003E RootDirectory / \u0022docfx.json\u0022;\n    AbsolutePath SiteDirectory =\u003E OutputDirectory / \u0022site\u0022;\n\n    [Solution] readonly Solution Solution;\n\n    IEnumerable\u003CApiProject\u003E Projects =\u003E YamlDeserializeFromFile\u003CList\u003CApiProject\u003E\u003E(RootDirectory / \u0022projects.yml\u0022)\n                                        ?? new List\u003CApiProject\u003E();\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/obj\u0022, \u0022*/bin\u0022).ForEach(DeleteDirectory);\n            DeleteDirectory(Solution.Directory / \u0022obj\u0022);\n            EnsureCleanDirectory(ApiDirectory);\n            EnsureCleanDirectory(GenerationDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target DownloadPackages =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .OnlyWhenStatic(() =\u003E PublishApi)\n        .WhenSkipped(DependencyBehavior.Skip)\n        .Executes(() =\u003E\n        {\n            var packages = Projects.Select(x =\u003E x.PackageId).Concat(\u0022System.ValueTuple\u0022);\n            packages.ForEach(x =\u003E NuGetTasks.NuGet($\u0022install {x} -OutputDirectory {GenerationDirectory} -ExcludeVersion -DependencyVersion Ignore -Verbosity detailed\u0022));\n        });\n\n    Target CustomDocFx =\u003E _ =\u003E _\n        .DependsOn(DownloadPackages)\n        .Executes(() =\u003E\n        {\n            WriteCustomDocFx(DocFxFile, BuildProjectDirectory / \u0022docfx.template.json\u0022, GenerationDirectory, ApiDirectory);\n        });\n\n    Target Disclaimer =\u003E _ =\u003E _\n        .DependsOn(DownloadPackages)\n        .OnlyWhenStatic(() =\u003E PublishApi)\n        .WhenSkipped(DependencyBehavior.Skip)\n        .Executes(() =\u003E\n        {\n            var disclaimerDirectory = SourceDirectory / \u0022disclaimers\u0022;\n            Directory.CreateDirectory(disclaimerDirectory);\n            Projects.Where(x =\u003E x.IsExternalRepository)\n                .ForEachLazy(x =\u003E Info($\u0022Writing disclaimer for {x.PackageId}...\u0022))\n                .ForEach(x =\u003E WriteDisclaimer(x,\n                    disclaimerDirectory / $\u0022{x.PackageId}.disclaimer.md\u0022,\n                    GlobFiles(GenerationDirectory / x.PackageId, \u0022lib/net4*/*.dll\u0022)));\n        });\n\n    Target Metadata =\u003E _ =\u003E _\n        .DependsOn(DownloadPackages, CustomDocFx)\n        .OnlyWhenStatic(() =\u003E PublishApi)\n        .WhenSkipped(DependencyBehavior.Skip)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(s =\u003E s\n                .SetProjects(DocFxFile)\n                .SetLogLevel(DocFXLogLevel.Verbose));\n        });\n\n    Target CustomToc =\u003E _ =\u003E _\n        .DependsOn(DownloadPackages)\n        .After(Metadata)\n        .Executes(() =\u003E\n        {\n            GlobFiles(ApiDirectory, \u0022**/toc.yml\u0022).ForEach(File.Delete);\n            WriteCustomTocs(ApiDirectory, BuildProjectDirectory, GlobFiles(GenerationDirectory, \u0022**/lib/net4*/*.dll\u0022));\n        });\n\n    Target BuildSite =\u003E _ =\u003E _\n        .DependsOn(Metadata, CustomToc, Disclaimer)\n        .Executes(() =\u003E\n        {\n            DocFXBuild(s =\u003E s\n                .SetConfigFile(DocFxFile)\n                .SetLogLevel(DocFXLogLevel.Verbose)\n                .SetServe(InvokedTargets.Contains(BuildSite)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(BuildSite)\n        .Requires(() =\u003E FtpUsername, () =\u003E FtpPassword, () =\u003E FtpServer)\n        .Executes(() =\u003E\n        {\n            FtpCredentials = new NetworkCredential(FtpUsername, FtpPassword);\n\n            if (PublishDocs)\n                FtpUploadDirectoryRecursively(SiteDirectory / \u0022docs\u0022, FtpServer \u002B \u0022/docs\u0022);\n            if (PublishImages)\n                FtpUploadDirectoryRecursively(SiteDirectory / \u0022images\u0022, FtpServer \u002B \u0022/images\u0022);\n            if (PublishApi)\n                FtpUploadDirectoryRecursively(SiteDirectory / \u0022api\u0022, FtpServer \u002B \u0022/api\u0022);\n\n\n            return;\n            var client = new FtpClient(FtpServer, new NetworkCredential(FtpUsername, FtpPassword));\n            client.Connect();\n\n            Directory.GetDirectories(SiteDirectory, \u0022*\u0022, SearchOption.AllDirectories)\n                .ForEach(directory =\u003E\n                {\n                    var files = GlobFiles(directory, \u0022*\u0022).ToArray();\n                    var relativePath = GetRelativePath(SiteDirectory, directory);\n                    var uploadedFiles = client.UploadFiles(files, relativePath, verifyOptions: FtpVerify.Retry);\n                    ControlFlow.Assert(uploadedFiles == files.Length, \u0022uploadedFiles == files.Length\u0022);\n                });\n        });\n}\n"
  },
  {
    "Id": 97044480,
    "FirstIndexed": "2020-04-25T15:50:44.7355601+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630567+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433911+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939663+02:00",
    "Name": "LightQuery",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/LightQuery",
    "Description": "Lightweight solution for sorting and paging Asp.Net Core API results",
    "Archived": false,
    "Stars": 51,
    "Watchers": 5,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/LightQuery/blob/dev/build/Build.cs",
    "BuildFileSize": 16107,
    "BuildFileContent": "using Nuke.Azure.KeyVault;\nusing Nuke.CoberturaConverter;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.XmlTasks;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\nusing Nuke.Common.ProjectModel;\nusing static Nuke.DocFX.DocFXTasks;\nusing Nuke.DocFX;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [KeyVault] readonly KeyVault KeyVault;\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [KeyVaultSecret] readonly string DocuBaseUrl;\n    [KeyVaultSecret] readonly string PublicMyGetSource;\n    [KeyVaultSecret] readonly string PublicMyGetApiKey;\n    [KeyVaultSecret] readonly string NuGetApiKey;\n    [KeyVaultSecret(\u0022LightQuery-DocuApiKey\u0022)] readonly string DocuApiKey;\n    [KeyVaultSecret] readonly string GitHubAuthenticationToken;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022LightQuery.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            GlobDirectories(SourceDirectory / \u0022LightQuery\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(SourceDirectory / \u0022LightQuery.Client\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(SourceDirectory / \u0022LightQuery.EntityFrameworkCore\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(SourceDirectory / \u0022LightQuery.Shared\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(RootDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion($\u0022{GitVersion.Major}.{GitVersion.Minor}.{GitVersion.Patch}.0\u0022)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    private Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(async () =\u003E\n        {\n            var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022)\n                .Where(t =\u003E !t.EndsWith(\u0022LightQuery.IntegrationTestsServer.csproj\u0022))\n                .ToList();\n\n            try\n            {\n                var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n                var snapshotIndex = 0;\n                DotCoverCover(c =\u003E c\n                        .SetTargetExecutable(dotnetPath)\n                        .SetFilters(\u0022\u002B:LightQuery\u0022)\n                        .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                        .CombineWith(cc =\u003E testProjects.SelectMany(testProject =\u003E\n                        {\n                            var projectDirectory = Path.GetDirectoryName(testProject);\n                            var targetFrameworks = GetTestFrameworksForProjectFile(testProject);\n                            return targetFrameworks.Select(targetFramework =\u003E\n                            {\n                                snapshotIndex\u002B\u002B;\n                                return cc\n                                    .SetTargetWorkingDirectory(projectDirectory)\n                                    .SetOutputFile(OutputDirectory / $\u0022coverage{snapshotIndex:00}.snapshot\u0022)\n                                    .SetTargetArguments($\u0022test --no-build -f {targetFramework} --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={OutputDirectory}/{snapshotIndex}_testresults-{targetFramework}.xml\\\u0022\u0022);\n                            });\n                        })), degreeOfParallelism: System.Environment.ProcessorCount);\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n\n            var snapshots = GlobFiles(OutputDirectory, \u0022*.snapshot\u0022)\n               .Aggregate((c, n) =\u003E c \u002B \u0022;\u0022 \u002B n);\n\n            DotCoverMerge(c =\u003E c\n                .SetSource(snapshots)\n                .SetOutputFile(OutputDirectory / \u0022coverage.snapshot\u0022));\n\n            DotCoverReport(c =\u003E c\n                .SetSource(OutputDirectory / \u0022coverage.snapshot\u0022)\n                .SetOutputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            // This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                 .SetReports(OutputDirectory / \u0022coverage.xml\u0022)\n                 .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            // This is the report in Cobertura format that integrates so nice in Jenkins\n            // dashboard and allows to extract more metrics and set build health based\n            // on coverage readings\n            await DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura_coverage.xml\u0022));\n        });\n\n    IEnumerable\u003Cstring\u003E GetTestFrameworksForProjectFile(string projectFile)\n    {\n        var targetFrameworks = XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFrameworks\u0022)\n            .Concat(XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFramework\u0022))\n            .Distinct()\n            .SelectMany(f =\u003E f.Split(\u0027;\u0027))\n            .Distinct();\n        return targetFrameworks;\n    }\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(SolutionDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022lightquery\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022client\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022shared\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022efcore\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n             var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(nuGetPackages)\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken));\n        });\n\n    void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*testresults*.xml\u0022).ToList();\n        Logger.Log(LogLevel.Normal, $\u0022Found {testResults.Count} test result files on which to append the framework.\u0022);\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n\n        // Merge all the results to a single file\n        // The \u0022run-time\u0022 attributes of the single assemblies is ensured to be unique for each single assembly by this test,\n        // since in Jenkins, the format is internally converted to JUnit. Aterwards, results with the same timestamps are\n        // ignored. See here for how the code is translated to JUnit format by the Jenkins plugin:\n        // https://github.com/jenkinsci/xunit-plugin/blob/d970c50a0501f59b303cffbfb9230ba977ce2d5a/src/main/resources/org/jenkinsci/plugins/xunit/types/xunitdotnet-2.0-to-junit.xsl#L75-L79\n        Logger.Log(LogLevel.Normal, \u0022Updating \\\u0022run-time\\\u0022 attributes in assembly entries to prevent Jenkins to treat them as duplicates\u0022);\n        var firstXdoc = XDocument.Load(testResults[0]);\n        var runtime = DateTime.Now;\n        var firstAssemblyNodes = firstXdoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n        foreach (var assemblyNode in firstAssemblyNodes)\n        {\n            assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n            runtime = runtime.AddSeconds(1);\n        }\n        for (var i = 1; i \u003C testResults.Count; i\u002B\u002B)\n        {\n            var xDoc = XDocument.Load(testResults[i]);\n            var assemblyNodes = xDoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n            foreach (var assemblyNode in assemblyNodes)\n            {\n                assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n                runtime = runtime.AddSeconds(1);\n            }\n            firstXdoc.Root.Add(assemblyNodes);\n        }\n\n        firstXdoc.Save(OutputDirectory / \u0022testresults.xml\u0022);\n        testResults.ForEach(DeleteFile);\n    }\n\n    string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n\n    Target NgLibraryTest =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var ngAppDir = SourceDirectory / \u0022ng-lightquery\u0022;\n            DeleteDirectory(ngAppDir / \u0022dist\u0022);\n            DeleteDirectory(ngAppDir / \u0022coverage\u0022);\n            DeleteFile(ngAppDir / \u0022karma-results.xml\u0022);\n\n            Npm(\u0022ci\u0022, ngAppDir);\n            Npm(\u0022run test\u0022, ngAppDir);\n        });\n\n    Target NgLibraryPublish =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var ngAppDir = SourceDirectory / \u0022ng-lightquery\u0022;\n            DeleteDirectory(ngAppDir / \u0022dist\u0022);\n\n            Npm(\u0022ci\u0022, ngAppDir);\n\n            Npm(\u0022run build\u0022, ngAppDir);\n\n            Npm($\u0022version {GitVersion.NuGetVersion}\u0022, ngAppDir);\n            var srcReadmePath = RootDirectory / \u0022README.md\u0022;\n            var destReadmePath = ngAppDir / \u0022README.md\u0022;\n            if (File.Exists(destReadmePath))\n            {\n                File.Delete(destReadmePath);\n            }\n            File.Copy(srcReadmePath, destReadmePath);\n\n            var npmTag = GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022)\n            ? \u0022latest\u0022\n            : \u0022next\u0022;\n\n            Npm($\u0022publish --tag={npmTag}\u0022, ngAppDir);\n        });\n}\n"
  },
  {
    "Id": 98062126,
    "FirstIndexed": "2020-04-25T15:50:44.7356483+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7363052+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434297+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940027+02:00",
    "Name": "powershell",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/powershell",
    "Description": "PowerShell tasks",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/matkoch/powershell/blob/master/build/Build.cs",
    "BuildFileSize": 1772,
    "BuildFileContent": "\uFEFF// Copyright Matthias Koch 2017.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/powershell/blob/master/LICENSE\n\nusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Core;\nusing Nuke.Core.Utilities.Collections;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\n\nclass Build : NukeBuild\n{\n    [Parameter] readonly string MyGetApiKey;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022)))\n            .Executes(() =\u003E EnsureCleanDirectory(OutputDirectory));\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E MSBuild(s =\u003E DefaultSettings.MSBuildRestore));\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E MSBuild(s =\u003E DefaultSettings.MSBuildCompileWithVersion));\n\n    Target Pack =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E MSBuild(s =\u003E DefaultSettings.MSBuildPack));\n\n    Target Push =\u003E _ =\u003E _\n            .DependsOn(Pack)\n            .Requires(() =\u003E MyGetApiKey)\n            .Executes(() =\u003E GlobFiles(OutputDirectory, \u0022*.nupkg\u0022)\n                    .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                    .ForEach(x =\u003E NuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://www.myget.org/F/nukebuild/api/v2/package\u0022)\n                            .SetApiKey(MyGetApiKey))));\n}\n"
  },
  {
    "Id": 98465842,
    "FirstIndexed": "2020-04-25T15:50:44.7355715+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631688+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433962+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893972+02:00",
    "Name": "UCR",
    "Owner": "Snoothy",
    "HtmlUrl": "https://github.com/Snoothy/UCR",
    "Description": "Universal Control Remapper [Alpha]",
    "Archived": false,
    "Stars": 217,
    "Watchers": 22,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Snoothy/UCR/blob/master/build/Build.cs",
    "BuildFileSize": 7968,
    "BuildFileContent": "using System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Tools.NUnit;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tooling;\n\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.GitVersion.GitVersionTasks;\nusing static Nuke.Common.Tools.NUnit.NUnitTasks;\nusing static Nuke.Common.IO.CompressionTasks;\n\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter] string Configuration { get; } = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n    [Parameter] string CodeAnalysis;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    string IoWrapper =\u003E \u0022IOWrapper\u0022;\n    AbsolutePath IoWrapperDirectory =\u003E RootDirectory / \u0022submodules\u0022 / IoWrapper;\n    AbsolutePath IoWrapperSolution =\u003E IoWrapperDirectory / (IoWrapper \u002B \u0022.sln\u0022);\n    AbsolutePath UcrOutputDirectory =\u003E RootDirectory / \u0022UCR\u0022 / \u0022bin\u0022 / Configuration;\n    AbsolutePath TestDirectory =\u003E RootDirectory / \u0022UCR.Tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath DependencyDirectory =\u003E Solution.Directory / \u0022dependencies\u0022;\n\n    Target CleanArtifacts =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(CleanArtifacts)\n        .Executes(() =\u003E\n        {\n            var outputDirectories = GlobDirectories(RootDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ToList();\n            outputDirectories.RemoveAll(s =\u003E s.StartsWith(RootDirectory / \u0022build\u0022));\n            outputDirectories.ForEach(DeleteDirectory);\n\n            EnsureExistingDirectory(RootDirectory / \u0022Providers\u0022);\n            EnsureExistingDirectory(RootDirectory / \u0022Plugins\u0022);\n        });\n\n    Target InitSubmodules =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Git(\u0022submodule init\u0022);\n            Git(\u0022submodule update\u0022);\n        });\n\n    Target RestoreSubmodules =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            NuGetTasks.NuGetRestore(s =\u003E s.SetTargetPath(IoWrapperSolution));\n        });\n\n    Target CompileSubmodules =\u003E _ =\u003E _\n        .DependsOn(RestoreSubmodules)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                    .SetWorkingDirectory(IoWrapperDirectory)\n                    .SetSolutionFile(IoWrapperSolution)\n                    .SetVerbosity(MSBuildVerbosity.Quiet)\n                    .SetTargets(\u0022Restore\u0022,\u0022Rebuild\u0022)\n                    .SetConfiguration(Configuration)\n            );\n\n            EnsureCleanDirectory(DependencyDirectory);\n            CopyDirectoryRecursively(IoWrapperDirectory / \u0022Artifacts\u0022, DependencyDirectory, DirectoryExistsPolicy.Merge);\n        });\n\n    Target InitProject =\u003E _ =\u003E _\n        .DependsOn(InitSubmodules)\n        .DependsOn(RestoreSubmodules)\n        .DependsOn(CompileSubmodules)\n        .Executes(() =\u003E\n        {\n            \n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            NuGetTasks.NuGetRestore(s =\u003E s.SetTargetPath(Solution));\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022)\n            );\n        });\n\n    Target StartCodeAnalysis =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !string.IsNullOrEmpty(CodeAnalysis))\n        .Executes(() =\u003E\n        {\n            var sonarScanner =\n                $\u0022sonarscanner begin /k:\\\u0022Snoothy_UCR\\\u0022 /o:\\\u0022snoothy-github\\\u0022 /d:sonar.host.url=\\\u0022https://sonarcloud.io\\\u0022 /d:sonar.login=\\\u0022cad188647aee521b62439577ebe235d6a61e750c\\\u0022 /v:\\\u0022{GetFullSemanticVersion()}\\\u0022 \u0022;\n            if (AppVeyor.Instance != null \u0026\u0026 AppVeyor.Instance.PullRequestNumber != 0)\n            {\n                DotNet(sonarScanner \u002B $\u0022/d:sonar.pullrequest.provider=GitHub /d:sonar.pullrequest.base=develop /d:sonar.pullrequest.github.repository=\\\u0022Snoothy/UCR\\\u0022 /d:sonar.pullrequest.branch=\\\u0022{GitRepository.Branch}\\\u0022 /d:sonar.pullrequest.key={AppVeyor.Instance.PullRequestNumber}\u0022);\n            }\n            else\n            {\n                if (GitRepository.Branch == \u0022master\u0022)\n                {\n                    DotNet(sonarScanner \u002B $\u0022/d:sonar.branch.name=\\\u0022{GitRepository.Branch}\\\u0022\u0022);\n                }\n                else\n                {\n                    DotNet(sonarScanner \u002B $\u0022/d:sonar.branch.name=\\\u0022{GitRepository.Branch}\\\u0022 /d:sonar.branch.target=\\\u0022develop\\\u0022\u0022);\n                }\n            }\n        });\n\n    Target Versioning =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            const string readmePath = \u0022./README.md\u0022;\n            File.WriteAllText(readmePath, Regex.Replace(File.ReadAllText(readmePath), @\u0022release-v([0-9]\u002B\\.[0-9]\u002B\\.[0-9]\u002B)-blue.svg\u0022, $\u0022release-v{GitVersion.MajorMinorPatch}-blue.svg\u0022));\n            File.WriteAllText(readmePath, Regex.Replace(File.ReadAllText(readmePath), @\u0022releases/tag/v([0-9]\u002B\\.[0-9]\u002B\\.[0-9]\u002B)\u0022, $\u0022releases/tag/v{GitVersion.MajorMinorPatch}\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(StartCodeAnalysis)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetVerbosity(MSBuildVerbosity.Normal)\n                // TODO This doesn\u0027t set all assembly versions\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GetFullSemanticVersion())\n            );\n        });\n\n    Target EndCodeAnalysis =\u003E _ =\u003E _ \n    .OnlyWhenStatic(() =\u003E !string.IsNullOrEmpty(CodeAnalysis))\n    .Executes(() =\u003E\n    {\n        DotNet($\u0022sonarscanner end /d:sonar.login=\\\u0022cad188647aee521b62439577ebe235d6a61e750c\\\u0022\u0022);\n    });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            NUnit3(s =\u003E s\n                .AddInputFiles(GlobFiles(TestDirectory, $\u0022**/bin/{Configuration}/UCR.Tests.dll\u0022).NotEmpty())\n                .EnableNoResults()\n            );\n        });\n    \n    Target Artifacts =\u003E _ =\u003E _\n        .DependsOn(CleanArtifacts)\n        .DependsOn(EndCodeAnalysis)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            EnsureDirectory(ArtifactsDirectory);\n            CopyDirectoryRecursively(UcrOutputDirectory, ArtifactsDirectory, DirectoryExistsPolicy.Merge);\n            \n            CompressZip(ArtifactsDirectory, $\u0022artifacts/UCR_{GetFullSemanticVersion()}.zip\u0022);\n        });\n    \n    Target Changelog =\u003E _ =\u003E _\n        .DependsOn(Versioning)\n        .Executes(() =\u003E\n        {\n            // TODO keep a change log update\n\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Versioning)\n        .DependsOn(Artifacts)\n        .DependsOn(Changelog)\n        .Executes(() =\u003E\n        {\n            // TODO\n        });\n\n    string GetCurrentVersion()\n    {\n        return GitVersion.MajorMinorPatch;\n    }\n\n    string GetFullSemanticVersion()\n    {\n        var additionalVersion = \u0022\u0022;\n        if (AppVeyor.Instance != null) additionalVersion = $\u0022\u002B{AppVeyor.Instance.BuildNumber}\u0022;\n\n        return $\u0022v{GetCurrentVersion()}-{GitRepository.Branch}{additionalVersion}\u0022.Replace(\u0027/\u0027, \u0027.\u0027);\n    }\n\n    void EnsureDirectory(AbsolutePath path)\n    {\n        if (!Directory.Exists(path)) Directory.CreateDirectory(path);\n    }\n}\n"
  },
  {
    "Id": 101605683,
    "FirstIndexed": "2020-04-25T15:47:03.6114628+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628302+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430816+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936728+02:00",
    "Name": "Ether",
    "Owner": "BerserkerDotNet",
    "HtmlUrl": "https://github.com/BerserkerDotNet/Ether",
    "Description": "Site to collect reports from VSTS",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BerserkerDotNet/Ether/blob/master/build/Build.cs",
    "BuildFileSize": 4611,
    "BuildFileContent": "using Colorful;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    const string Ether = \u0022Ether\u0022;\n    const string Api = \u0022Ether.Api\u0022;\n    const string EmailGenerator = \u0022Ether.EmailGenerator\u0022;\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Path to artifacts directory - Default is /artifacts\u0022)]\n    readonly AbsolutePath ArtifactsDirectory = RootDirectory / \u0022artifacts\u0022;\n\n    [Solution] readonly Solution Solution;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022Ether.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(PublishClient)\n        .DependsOn(PublishApi)\n        .DependsOn(PublishEmailGenerator)\n        .Executes();\n\n    Target PublishClient =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(Ether))\n                .SetConfiguration(Configuration)\n                .SetOutput(ArtifactsDirectory / Ether));\n        });\n\n    Target PublishApi =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(Api))\n                .SetConfiguration(Configuration)\n                .SetOutput(ArtifactsDirectory / Api));\n        });\n\n    Target PublishEmailGenerator =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(EmailGenerator))\n                .SetConfiguration(Configuration)\n                .SetOutput(ArtifactsDirectory / EmailGenerator));\n        });\n\n    Target Configure =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNet($\u0022user-secrets init --project \\\u0022{Solution.GetProject(\u0022Ether.Api\u0022)}\\\u0022\u0022);\n\n            var configureDb = ConsoleUtility.PromptForChoice(\u0022Do you want to configure database connection string?\u0022, (false, \u0022No\u0022), (true, \u0022Yes\u0022));\n            if (configureDb)\n            {\n                var host = ConsoleUtility.PromptForInput(\u0022What\u0027s the DB host name?\u0022, \u0022localhost\u0022);\n                var port = ConsoleUtility.PromptForInput(\u0022What\u0027s the DB port?\u0022, \u002227017\u0022);\n                var username = ConsoleUtility.PromptForInput(\u0022Username to use when connecting\u0022, \u0022\u0022);\n                Console.WriteLine(\u0022Password:\u0022);\n                var password = ConsoleUtility.ReadSecret();\n                SetSecret(\u0022DBConfig:ConnectionString\u0022, $\u0022mongodb://{username}:{password}@{host}:{port}\u0022);\n            }\n\n            var configureAD = ConsoleUtility.PromptForChoice(\u0022Do you want to configure AD?\u0022, (false, \u0022No\u0022), (true, \u0022Yes\u0022));\n            if (configureAD)\n            {\n                var adType = ConsoleUtility.PromptForChoice(\u0022Select AD type\u0022,\n                    (\u0022Machine\u0022, \u0022The computer store. This represents the SAM store.\u0022),\n                    (\u0022Domain\u0022, \u0022The domain store. This represents the AD DS store.\u0022),\n                    (\u0022ApplicationDirectory\u0022, \u0022The application directory store. This represents the AD LDS store.\u0022));\n                SetSecret(\u0022ADConfig:Type\u0022, adType);\n            }\n        });\n\n    private void SetSecret(string name, string value)\n    {\n        DotNet($\u0022user-secrets set \\\u0022{name}\\\u0022 \\\u0022{value}\\\u0022 --project \\\u0022{Solution.GetProject(\u0022Ether.Api\u0022)}\\\u0022\u0022);\n    }\n}\n"
  },
  {
    "Id": 102095107,
    "FirstIndexed": "2020-04-25T15:47:03.6114037+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631193+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430827+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936739+02:00",
    "Name": "Playground",
    "Owner": "iarovyi",
    "HtmlUrl": "https://github.com/iarovyi/Playground",
    "Description": "Nothing interesting, just personal playground",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "Build/nuke/build/Build.cs",
    "BuildFileUrl": "https://github.com/iarovyi/Playground/blob/master/Build/nuke/build/Build.cs",
    "BuildFileSize": 3089,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022.artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(o =\u003E o\n                .SetProjectFile(Solution));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetTasks.DotNetPack(s =\u003E s\n                //.SetWorkingDirectory(SolutionDirectory)\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n\n            // Or using default settings:\n         //   DotNetPack(s =\u003E DefaultDotNetPack\n           //     .SetPackageReleaseNotes(changelogUrl));\n        });\n\n}\n"
  },
  {
    "Id": 102390686,
    "FirstIndexed": "2020-04-25T15:50:44.7356437+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7363041+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434275+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "nuke-tools",
    "Owner": "arodus",
    "HtmlUrl": "https://github.com/arodus/nuke-tools",
    "Description": "Collection of tool metadata",
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 103032655,
    "FirstIndexed": "2020-04-25T15:50:44.7356414+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.736303+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434263+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894001+02:00",
    "Name": "columbus",
    "Owner": "lehmamic",
    "HtmlUrl": "https://github.com/lehmamic/columbus",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/lehmamic/columbus/blob/master/build/Build.cs",
    "BuildFileSize": 1508,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Core;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.EnvironmentInfo;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n    \n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    Target Clean =\u003E _ =\u003E _\n            .OnlyWhen(() =\u003E false) // Disabled for safety.\n            .Executes(() =\u003E\n            {\n                DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(s =\u003E DefaultDotNetRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E DefaultDotNetBuild);\n            });\n}\n"
  },
  {
    "Id": 103837213,
    "FirstIndexed": "2020-04-25T15:50:44.7356386+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627079+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434252+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939999+02:00",
    "Name": "telegram-jira-bot",
    "Owner": "KolibriGames",
    "HtmlUrl": "https://github.com/KolibriGames/telegram-jira-bot",
    "Description": "A Jira Telegram notification bot",
    "Archived": false,
    "Stars": 8,
    "Watchers": 5,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/KolibriGames/telegram-jira-bot/blob/master/build/Build.cs",
    "BuildFileSize": 2317,
    "BuildFileContent": "\uFEFFusing System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Core;\nusing Nuke.Core.Tooling;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.EnvironmentInfo;\n\nclass Build : NukeBuild\n{\n    // Auto-injection fields:\n    //  - [GitVersion] must have \u0027GitVersion.CommandLine\u0027 referenced\n    //  - [GitRepository] parses the origin from git config\n    //  - [Parameter] retrieves its value from command-line arguments or environment variables\n    //\n    //[GitVersion] readonly GitVersion GitVersion;\n    //[GitRepository] readonly GitRepository GitRepository;\n    //[Parameter] readonly string MyGetApiKey;\n\n\n    // This is the application entry point for the build.\n    // It also defines the default target to execute.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            //DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E { DotNetRestore(SolutionDirectory); });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E { DotNetBuild(SolutionDirectory); });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E DotNetPublish(conf =\u003E\n            conf.EnableNoRestore()\n                .SetToolPath(ToolPathResolver.TryGetEnvironmentExecutable(\u0022DOTNET_EXE\u0022)\n                             ?? ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022))\n                .SetProject(SourceDirectory / \u0022Telegram.Bot.Web\u0022)\n                .SetFramework(\u0022netcoreapp2.0\u0022)\n                .SetConfiguration(\u0022Release\u0022)\n                .SetOutput(OutputDirectory / \u0022Telegram.Bot.Web\u0022))\n        ).Executes(() =\u003E\n        {\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, OutputDirectory / \u0022Telegram.Bot.Web/README.md\u0022);\n            ZipFile.CreateFromDirectory(OutputDirectory / \u0022Telegram.Bot.Web\u0022, OutputDirectory / \u0022Telegram.Bot.Web.zip\u0022);\n        });\n}\n"
  },
  {
    "Id": 104385574,
    "FirstIndexed": "2020-04-25T15:50:44.7356363+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627068+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434246+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939987+02:00",
    "Name": "ManagedDevcon",
    "Owner": "nefarius",
    "HtmlUrl": "https://github.com/nefarius/ManagedDevcon",
    "Description": "Managed wrapper around various SetupAPI functions.",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nefarius/ManagedDevcon/blob/master/build/Build.cs",
    "BuildFileSize": 1603,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Core;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.EnvironmentInfo;\n\nclass Build : NukeBuild\n{\n    // This is the application entry point for the build.\n    // It also defines the default target to execute.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n    //  - [GitVersion] must have \u0027GitVersion.CommandLine\u0027 referenced\n    //  - [GitRepository] parses the origin from git config\n    //  - [Parameter] retrieves its value from command-line arguments or environment variables\n    //\n    //[GitVersion] readonly GitVersion GitVersion;\n    //[GitRepository] readonly GitRepository GitRepository;\n    //[Parameter] readonly string MyGetApiKey;\n\n    Target Clean =\u003E _ =\u003E _\n            .OnlyWhen(() =\u003E false) // Disabled for safety.\n            .Executes(() =\u003E\n            {\n                DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildCompile);\n            });\n}\n"
  },
  {
    "Id": 106745490,
    "FirstIndexed": "2020-04-25T15:50:44.7355692+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628206+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843395+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939709+02:00",
    "Name": "GCore",
    "Owner": "KillerGoldFisch",
    "HtmlUrl": "https://github.com/KillerGoldFisch/GCore",
    "Description": "Useful C# Stuff for .NET Core 2.0",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/KillerGoldFisch/GCore/blob/master/build/Build.cs",
    "BuildFileSize": 2624,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nusing GCore.Extensions.StringShEx;\nusing GCore.Extensions.ArrayEx;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    string Source =\u003E \u0022https://api.nuget.org/v3/index.json\u0022;\n\n\n    String GitVersion = \u00221.0.0\u0022;\n\n    string GitVersionSuffix = \u00220\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n\n    public Build() {\n\n        var version = \u0022git tag\u0022.Sh().Split(\u0027\\n\u0027).Get(-2).ExtractVersion();\n\n        var suffix = \u0022git rev-list --count HEAD\u0022.Sh().Replace(\u0022\\n\u0022, \u0022\u0022).Trim();\n\n\n\n        GitVersion = version.ToString(3);\n\n        GitVersionSuffix = GitVersion \u002B \u0022.\u0022 \u002B suffix;\n\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(SolutionFile));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(SolutionFile)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var version = GitVersionSuffix;\n\n            DotNetPack(s =\u003E s\n                .SetProject(SolutionFile)\n                .SetVersion(version)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E\n        {\n            GlobFiles(ArtifactsDirectory, \u0022GCore.*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                .ToList()\n                .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)));\n        });\n}\n"
  },
  {
    "Id": 106875909,
    "FirstIndexed": "2020-04-25T15:50:44.7359696+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630112+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434656+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940374+02:00",
    "Name": "LogExpert",
    "Owner": "zarunbal",
    "HtmlUrl": "https://github.com/zarunbal/LogExpert",
    "Description": "Windows tail program and log file analyzer.",
    "Archived": false,
    "Stars": 482,
    "Watchers": 54,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/zarunbal/LogExpert/blob/master/build/Build.cs",
    "BuildFileSize": 19097,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing JetBrains.Annotations;\nusing Microsoft.Build.Execution;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Tools.NUnit;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.TextTasks;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.Common.ControlFlow;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)] private readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath BinDirectory =\u003E RootDirectory / \u0022bin\u0022;\n\n    AbsolutePath OutputDirectory =\u003E BinDirectory / Configuration;\n\n    AbsolutePath PackageDirectory =\u003E BinDirectory / \u0022Package\u0022;\n\n    AbsolutePath ChocolateyDirectory =\u003E BinDirectory / \u0022chocolatey\u0022;\n\n    AbsolutePath ChocolateyTemplateFiles =\u003E RootDirectory / \u0022chocolatey\u0022;\n\n    AbsolutePath SftpFileSystemPackagex86 =\u003E BinDirectory / \u0022SftpFileSystemx86/\u0022;\n    AbsolutePath SftpFileSystemPackagex64 =\u003E BinDirectory / \u0022SftpFileSystemx64/\u0022;\n\n    AbsolutePath SetupDirectory =\u003E BinDirectory / \u0022SetupFiles\u0022;\n\n    AbsolutePath InnoSetupScript =\u003E SourceDirectory / \u0022setup\u0022 / \u0022LogExpertInstaller.iss\u0022;\n\n    string SetupCommandLineParameter =\u003E $\u0022/dAppVersion=\\\u0022{VersionString}\\\u0022 /O\\\u0022{BinDirectory}\\\u0022 /F\\\u0022LogExpert-Setup-{VersionString}\\\u0022\u0022;\n\n    Version Version\n    {\n        get\n        {\n            int patch = 0;\n\n            if (AppVeyor.Instance != null)\n            {\n                patch = AppVeyor.Instance.BuildNumber;\n            }\n\n            return new Version(1, 8, patch);\n        }\n    }\n\n    [Parameter(\u0022Version string\u0022)]\n    string VersionString =\u003E $\u0022{Version.Major}.{Version.Minor}.{Version.Build}\u0022;\n\n    [Parameter(\u0022Version Information string\u0022)]\n    string VersionInformationString =\u003E $\u0022{VersionString}.Branch.{GitVersion.BranchName}.{GitVersion.Sha} {Configuration}\u0022;\n\n    [Parameter(\u0022Version file string\u0022)]\n    string VersionFileString =\u003E $\u0022{Version.Major}.{Version.Minor}.0\u0022;\n\n    [Parameter(\u0022Exclude file globs\u0022)]\n    string[] ExcludeFileGlob =\u003E new[] {\u0022**/*.xml\u0022, \u0022**/*.XML\u0022, \u0022**/*.pdb\u0022, \u0022**/ChilkatDotNet4.dll\u0022, \u0022**/ChilkatDotNet47.dll\u0022, \u0022**/SftpFileSystem.dll\u0022};\n\n    [PathExecutable(\u0022choco.exe\u0022)] readonly Tool Chocolatey;\n\n    [Parameter(\u0022Exlcude directory glob\u0022)]\n    string[] ExcludeDirectoryGlob =\u003E new[] {\u0022**/pluginsx86\u0022};\n\n    [Parameter(\u0022My variable\u0022, Name = \u0022my_variable\u0022)] string MyVariable = null;\n\n    [Parameter(\u0022Nuget api key\u0022)] string NugetApiKey = null;\n\n    [Parameter(\u0022Chocolatey api key\u0022)] string ChocolateyApiKey = null;\n\n    [Parameter(\u0022GitHub Api key\u0022)] string GitHubApiKey = null;\n\n    AbsolutePath[] AppveyorArtifacts =\u003E new[]\n    {\n        (BinDirectory / $\u0022LogExpert-Setup-{VersionString}.exe\u0022),\n        BinDirectory / $\u0022LogExpert-CI-{VersionString}.zip\u0022,\n        BinDirectory / $\u0022LogExpert.{VersionString}.zip\u0022,\n        BinDirectory / $\u0022LogExpert.ColumnizerLib.{VersionString}.nupkg\u0022,\n        BinDirectory / $\u0022SftpFileSystem.x64.{VersionString}.zip\u0022,\n        BinDirectory / $\u0022SftpFileSystem.x86.{VersionString}.zip\u0022,\n        ChocolateyDirectory / $\u0022logexpert.{VersionString}.nupkg\u0022\n    };\n\n    protected override void OnBuildInitialized()\n    {\n        SetVariable(\u0022DOTNET_CLI_TELEMETRY_OPTOUT\u0022, \u00221\u0022);\n\n        base.OnBuildInitialized();\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Compile, Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\n            if (DirectoryExists(BinDirectory))\n            {\n                BinDirectory.GlobFiles(\u0022*\u0022, \u0022*.*\u0022, \u0022.*\u0022).ForEach(DeleteFile);\n                BinDirectory.GlobDirectories(\u0022*\u0022).ForEach(DeleteDirectory);\n\n                DeleteDirectory(BinDirectory);\n\n                EnsureCleanDirectory(BinDirectory);\n            }\n        });\n\n    Target CleanPackage =\u003E _ =\u003E _\n        .Before(Compile, Restore)\n        .OnlyWhenDynamic(() =\u003E DirectoryExists(BinDirectory))\n        .Executes(() =\u003E\n        {\n            BinDirectory.GlobFiles(\u0022**/*.zip\u0022, \u0022**/*.nupkg\u0022).ForEach(DeleteFile);\n\n            if (DirectoryExists(PackageDirectory))\n            {\n                DeleteDirectory(PackageDirectory);\n\n                EnsureCleanDirectory(PackageDirectory);\n            }\n\n            if (DirectoryExists(ChocolateyDirectory))\n            {\n                DeleteDirectory(ChocolateyDirectory);\n\n                EnsureCleanDirectory(ChocolateyDirectory);\n            }\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022Version: \u0027{VersionString}\u0027\u0022);\n\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetAssemblyVersion(VersionString)\n                .SetInformationalVersion(VersionInformationString)\n                .SetTargetPlatform(MSBuildTargetPlatform.MSIL)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(c =\u003Ec\n                    .SetConfiguration(Configuration)\n                    .EnableNoBuild()\n                    .CombineWith(SourceDirectory.GlobFiles(\u0022**/*Tests.csproj\u0022), (settings, path) =\u003E \n                        settings.SetProjectFile(path)), degreeOfParallelism: 4, completeOnFailure: true);\n        });\n\n    Target PrepareChocolateyTemplates =\u003E _ =\u003E _\n        .DependsOn(CleanPackage)\n        .Executes(() =\u003E\n        {\n            CopyDirectoryRecursively(ChocolateyTemplateFiles, ChocolateyDirectory, DirectoryExistsPolicy.Merge);\n\n            ChocolateyDirectory.GlobFiles(\u0022**/*.template\u0022).ForEach(path =\u003E TransformTemplateFile(path, true));\n        });\n\n    Target CopyOutputForChocolatey =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            CopyDirectoryRecursively(OutputDirectory, ChocolateyDirectory / \u0022tools\u0022, DirectoryExistsPolicy.Merge);\n            ChocolateyDirectory.GlobFiles(ExcludeFileGlob).ForEach(DeleteFile);\n            ChocolateyDirectory.GlobDirectories(ExcludeDirectoryGlob).ForEach(DeleteDirectory);\n        });\n\n    Target BuildChocolateyPackage =\u003E _ =\u003E _\n        .DependsOn(PrepareChocolateyTemplates, CopyOutputForChocolatey)\n        .Executes(() =\u003E\n        {\n            Chocolatey(\u0022pack\u0022, WorkingDirectory = ChocolateyDirectory);\n        });\n\n    Target CreatePackage =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            CopyDirectoryRecursively(OutputDirectory, PackageDirectory, DirectoryExistsPolicy.Merge);\n            PackageDirectory.GlobFiles(ExcludeFileGlob).ForEach(DeleteFile);\n\n            PackageDirectory.GlobDirectories(ExcludeDirectoryGlob).ForEach(DeleteDirectory);\n\n            Compress(PackageDirectory, BinDirectory / $\u0022LogExpert.{VersionString}.zip\u0022);\n        });\n\n    Target ChangeVersionNumber =\u003E _ =\u003E _\n        .Before(Compile)\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022AssemblyVersion {VersionString}\\r\\nAssemblyFileVersion {VersionFileString}\\r\\nAssemblyInformationalVersion {VersionInformationString}\u0022);\n\n            AbsolutePath assemblyVersion = SourceDirectory / \u0022Solution Items\u0022 / \u0022AssemblyVersion.cs\u0022;\n\n            string text = ReadAllText(assemblyVersion);\n            Regex configurationRegex = new Regex(@\u0022(\\[assembly: AssemblyConfiguration\\()(\u0022\u0022[^\u0022\u0022]*\u0022\u0022)(\\)\\])\u0022);\n            Regex assemblyVersionRegex = new Regex(@\u0022(\\[assembly: AssemblyVersion\\(\u0022\u0022)([^\u0022\u0022]*)(\u0022\u0022\\)\\])\u0022);\n            Regex assemblyFileVersionRegex = new Regex(@\u0022(\\[assembly: AssemblyFileVersion\\(\u0022\u0022)([^\u0022\u0022]*)(\u0022\u0022\\)\\])\u0022);\n            Regex assemblyInformationalVersionRegex = new Regex(@\u0022(\\[assembly: AssemblyInformationalVersion\\(\u0022\u0022)([^\u0022\u0022]*)(\u0022\u0022\\)\\])\u0022);\n\n            text = configurationRegex.Replace(text, (match) =\u003E ReplaceVersionMatch(match, $\u0022\\\u0022{Configuration}\\\u0022\u0022));\n            text = assemblyVersionRegex.Replace(text, (match) =\u003E ReplaceVersionMatch(match, VersionString));\n            text = assemblyFileVersionRegex.Replace(text, (match) =\u003E ReplaceVersionMatch(match, VersionFileString));\n            text = assemblyInformationalVersionRegex.Replace(text, (match) =\u003E ReplaceVersionMatch(match, VersionInformationString));\n\n            Logger.Trace(\u0022Content of AssemblyVersion file\u0022);\n            Logger.Trace(text);\n            Logger.Trace(\u0022End of Content\u0022);\n\n            WriteAllText(assemblyVersion, text);\n\n            SourceDirectory.GlobFiles(\u0022**sftp-plugin/*.cs\u0022).ForEach(file =\u003E\n            {\n                if (string.IsNullOrWhiteSpace(MyVariable))\n                {\n                    return;\n                }\n\n                string fileText = ReadAllText(file);\n\n                Regex reg = new Regex(@\u0022\\w\\w{2}[_]p?[tso]?[erzliasx]\u002B[_rhe]{5}\u0022, RegexOptions.IgnoreCase);\n\n                if (reg.IsMatch(fileText))\n                {\n                    fileText = reg.Replace(fileText, MyVariable);\n                    WriteAllText(file, fileText);\n                }\n            });\n        });\n\n    Target PackageSftpFileSystem =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            string[] files = new[] {\u0022SftpFileSystem.dll\u0022, \u0022ChilkatDotNet4.dll\u0022, \u0022ChilkatDotNet47.dll\u0022 };\n\n            OutputDirectory.GlobFiles(files.Select(a =\u003E $\u0022plugins/{a}\u0022).ToArray()).ForEach(file =\u003E CopyFileToDirectory(file, SftpFileSystemPackagex64, FileExistsPolicy.Overwrite));\n            OutputDirectory.GlobFiles(files.Select(a =\u003E $\u0022pluginsx86/{a}\u0022).ToArray()).ForEach(file =\u003E CopyFileToDirectory(file, SftpFileSystemPackagex86, FileExistsPolicy.Overwrite));\n\n            Compress(SftpFileSystemPackagex64, BinDirectory / $\u0022SftpFileSystem.x64.{VersionString}.zip\u0022);\n            Compress(SftpFileSystemPackagex86, BinDirectory / $\u0022SftpFileSystem.x86.{VersionString}.zip\u0022);\n        });\n\n    Target ColumnizerLibCreateNuget =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            var columnizerFolder = SourceDirectory / \u0022ColumnizerLib\u0022;\n\n            NuGetTasks.NuGetPack(s =\u003E\n            {\n                s = s.SetTargetPath(columnizerFolder / \u0022ColumnizerLib.csproj\u0022)\n                    .DisableBuild()\n                    .SetConfiguration(Configuration)\n                    .SetProperty(\u0022version\u0022, VersionString)\n                    .SetOutputDirectory(BinDirectory);\n\n                return s;\n            });\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(BuildChocolateyPackage, CreatePackage, PackageSftpFileSystem, ColumnizerLibCreateNuget);\n\n    Target CopyFilesForSetup =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .After(Test)\n        .Executes(() =\u003E\n        {\n            CopyDirectoryRecursively(OutputDirectory, SetupDirectory, DirectoryExistsPolicy.Merge);\n            SetupDirectory.GlobFiles(ExcludeFileGlob).ForEach(DeleteFile);\n\n            SetupDirectory.GlobDirectories(ExcludeDirectoryGlob).ForEach(DeleteDirectory);\n        });\n\n    Target CreateSetup =\u003E _ =\u003E _\n        .DependsOn(CopyFilesForSetup)\n        .Before(Publish)\n        .OnlyWhenStatic(() =\u003E Configuration == \u0022Release\u0022)\n        .Executes(() =\u003E\n        {\n            var publishCombinations =\n                from framework in new[] {(AbsolutePath) SpecialFolder(SpecialFolders.ProgramFilesX86), (AbsolutePath) SpecialFolder(SpecialFolders.LocalApplicationData) / \u0022Programs\u0022}\n                from version in new[] {\u00225\u0022, \u00226\u0022}\n                select framework / $\u0022Inno Setup {version}\u0022 / \u0022iscc.exe\u0022;\n            bool executed = false;\n            foreach (var setupCombinations in publishCombinations)\n            {\n                if (!FileExists(setupCombinations))\n                {\n                    //Search for next combination\n                    continue;\n                }\n\n                ExecuteInnoSetup(setupCombinations);\n                executed = true;\n                break;\n            }\n\n            if (!executed)\n            {\n                Fail(\u0022Inno setup was not found\u0022);\n            }\n        });\n\n    Target PublishColumnizerNuget =\u003E _ =\u003E _\n        .DependsOn(ColumnizerLibCreateNuget)\n        .Requires(() =\u003E NugetApiKey)\n        //.OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(() =\u003E\n        {\n            BinDirectory.GlobFiles(\u0022**/LogExpert.ColumnizerLib.*.nupkg\u0022).ForEach(file =\u003E\n            {\n                Logger.Normal($\u0022Publish nuget {file}\u0022);\n\n                NuGetTasks.NuGetPush(s =\u003E\n                {\n                    s = s.SetApiKey(NugetApiKey)\n                        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                        .SetApiKey(NugetApiKey)\n                        .SetTargetPath(file);\n\n                    return s;\n                });\n            });\n        });\n\n    Target PublishChocolatey =\u003E _ =\u003E _\n        .DependsOn(BuildChocolateyPackage)\n        .Requires(() =\u003E ChocolateyApiKey)\n        .Executes(() =\u003E\n        {\n            ChocolateyDirectory.GlobFiles(\u0022**/*.nupkg\u0022).ForEach(file =\u003E\n            {\n                Logger.Normal($\u0022Publish chocolatey package {file}\u0022);\n\n                Chocolatey($\u0022push {file} --key {ChocolateyApiKey} --source https://push.chocolatey.org/\u0022, WorkingDirectory = ChocolateyDirectory);\n            });\n        });\n\n    Target PublishGithub =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubApiKey)\n        .Executes(() =\u003E\n        {\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            Task task = PublishRelease(s =\u003E s\n                .SetArtifactPaths(BinDirectory.GlobFiles(\u0022**/*.zip\u0022, \u0022**/*.nupkg\u0022, \u0022**/LogExpert-Setup*.exe\u0022).Select(a =\u003E a.ToString()).ToArray())\n                .SetCommitSha(GitVersion.Sha)\n                .SetReleaseNotes($\u0022# Changes\\r\\n\u0022 \u002B\n                                 $\u0022# Bugfixes\\r\\n\u0022 \u002B\n                                 $\u0022# Contributors\\r\\n\u0022 \u002B\n                                 $\u0022Thanks to the contributors!\\r\\n\u0022 \u002B\n                                 $\u0022# Infos\\r\\n\u0022 \u002B\n                                 $\u0022It might be necessary to unblock the Executables / Dlls to get everything working, especially Plugins (see #55, #13, #8).\u0022)\n                .SetRepositoryName(repositoryInfo.repositoryName)\n                .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                .SetTag($\u0022v{VersionString}\u0022)\n                .SetToken(GitHubApiKey)\n                .SetName(VersionString)\n            );\n\n            task.Wait();\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(PublishChocolatey, PublishColumnizerNuget, PublishGithub);\n\n    Target PublishToAppveyor =\u003E _ =\u003E _\n        .After(Publish, CreateSetup)\n        .OnlyWhenDynamic(() =\u003E AppVeyor.Instance != null)\n        .Executes(() =\u003E\n        {\n            CompressZip(BinDirectory / Configuration, BinDirectory / $\u0022LogExpert-CI-{VersionString}.zip\u0022);\n\n            AppveyorArtifacts.ForEach((artifact) =\u003E\n            {\n                Process proc = new Process();\n                proc.StartInfo = new ProcessStartInfo(\u0022appveyor\u0022, $\u0022PushArtifact \\\u0022{artifact}\\\u0022\u0022);\n                if (!proc.Start())\n                {\n                    Fail(\u0022Failed to start appveyor pushartifact\u0022);\n                }\n\n                proc.WaitForExit();\n\n                if (proc.ExitCode != 0)\n                {\n                    Fail($\u0022Exit code is {proc.ExitCode}\u0022);\n                }\n            });\n        });\n\n    Target CleanupAppDataLogExpert =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            AbsolutePath logExpertApplicationData = ((AbsolutePath) SpecialFolder(SpecialFolders.ApplicationData)) / \u0022LogExpert\u0022;\n\n            DirectoryInfo info = new DirectoryInfo(logExpertApplicationData);\n            info.GetDirectories().ForEach(a =\u003E a.Delete(true));\n            DeleteDirectory(logExpertApplicationData);\n        });\n\n    Target CleanupDocumentsLogExpert =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            AbsolutePath logExpertDocuments = (AbsolutePath) SpecialFolder(SpecialFolders.UserProfile) / \u0022Documents\u0022 / \u0022LogExpert\u0022;\n\n            DirectoryInfo info = new DirectoryInfo(logExpertDocuments);\n            info.GetDirectories().ForEach(a =\u003E a.Delete(true));\n            DeleteDirectory(logExpertDocuments);\n        });\n\n    private void ExecuteInnoSetup(AbsolutePath innoPath)\n    {\n        Process proc = new Process();\n\n        Logger.Info($\u0022Start \u0027{innoPath}\u0027 {SetupCommandLineParameter} \\\u0022{InnoSetupScript}\\\u0022\u0022);\n\n        proc.StartInfo = new ProcessStartInfo(innoPath, $\u0022{SetupCommandLineParameter} \\\u0022{InnoSetupScript}\\\u0022\u0022);\n        if (!proc.Start())\n        {\n            Fail($\u0022Failed to start {innoPath} with \\\u0022{SetupCommandLineParameter}\\\u0022 \\\u0022{InnoSetupScript}\\\u0022\u0022);\n        }\n\n        proc.WaitForExit();\n\n        Logger.Info($\u0022Executed \u0027{innoPath}\u0027 with exit code {proc.ExitCode}\u0022);\n\n        if (proc.ExitCode != 0)\n        {\n            Fail($\u0022Error during execution of {innoPath}, exitcode {proc.ExitCode}\u0022);\n        }\n    }\n\n    private string ReplaceVersionMatch(Match match, string replacement)\n    {\n        return $\u0022{match.Groups[1]}{replacement}{match.Groups[3]}\u0022;\n    }\n\n    private void TransformTemplateFile(AbsolutePath path, bool deleteTemplate)\n    {\n        string text = ReadAllText(path);\n        text = text.Replace(\u0022##version##\u0022, VersionString);\n\n        WriteAllText($\u0022{Regex.Replace(path, \u0022\\\\.template$\u0022, \u0022\u0022)}\u0022, text);\n        if (deleteTemplate)\n        {\n            DeleteFile(path);\n        }\n    }\n}"
  },
  {
    "Id": 109654298,
    "FirstIndexed": "2020-04-25T15:47:03.6115994+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625441+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430839+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893675+02:00",
    "Name": "Build",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Build",
    "Description": "Build utilities for Rocket Surgeons",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Build/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 109919446,
    "FirstIndexed": "2020-04-25T15:47:03.6115948+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625412+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430844+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936762+02:00",
    "Name": "Conventions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Conventions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Conventions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 110116612,
    "FirstIndexed": "2020-04-25T15:47:03.6116204+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625486+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430856+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936773+02:00",
    "Name": "Autofac.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Autofac.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Autofac.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 110152958,
    "FirstIndexed": "2020-04-25T15:50:44.735485+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632376+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433615+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893939+02:00",
    "Name": "PackageReferenceEditor",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/PackageReferenceEditor",
    "Description": "MSBuild, csproj and props package reference editor.",
    "Archived": false,
    "Stars": 11,
    "Watchers": 1,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/PackageReferenceEditor/blob/master/build/build/Build.cs",
    "BuildFileSize": 3744,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 110300875,
    "FirstIndexed": "2020-04-25T15:50:44.735646+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631801+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434286+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940016+02:00",
    "Name": "Dangl.Data.Shared",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Dangl.Data.Shared",
    "Description": "Shared classes for Api Server \u0026 Clients and for reusable code",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Dangl.Data.Shared/blob/develop/build/Build.cs",
    "BuildFileSize": 15213,
    "BuildFileContent": "\uFEFFusing Nuke.CoberturaConverter;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Linq;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing Nuke.DocFX;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Azure.KeyVault;\nusing System.Collections.Generic;\nusing static Nuke.Common.IO.XmlTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n    [KeyVaultSecret(\u0022DanglDataShared-DocuApiKey\u0022)] string DocuApiKey;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022Dangl.Data.Shared.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(SolutionDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .SetDescription(\u0022Dangl.Data.Shared - www.dangl-it.com\u0022)\n                .SetTitle(\u0022Dangl.Data.Shared - www.dangl-it.com\u0022)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022);\n            var testRun = 1;\n\n            try\n            {\n                DotNetTest(x =\u003E x\n                    .SetNoBuild(true)\n                    .SetTestAdapterPath(\u0022.\u0022)\n                    .CombineWith(cc =\u003E testProjects\n                        .SelectMany(testProject =\u003E GetTestFrameworksForProjectFile(testProject)\n                            .Select(targetFramework =\u003E cc\n                                .SetFramework(targetFramework)\n                                .SetWorkingDirectory(Path.GetDirectoryName(testProject))\n                                .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / $\u0022{testRun\u002B\u002B}_testresults-{targetFramework}.xml\u0022}\u0022)))),\n                                degreeOfParallelism: Environment.ProcessorCount);\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n        });\n\n    IEnumerable\u003Cstring\u003E GetTestFrameworksForProjectFile(string projectFile)\n    {\n        var targetFrameworks = XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFrameworks\u0022)\n            .Concat(XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFramework\u0022))\n            .Distinct()\n            .SelectMany(f =\u003E f.Split(\u0027;\u0027))\n            .Distinct();\n        return targetFrameworks;\n    }\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(SolutionDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022).ToList();\n            var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n\n            var snapshotIndex = 0;\n            try\n            {\n                DotCoverCover(c =\u003E c\n                    .SetTargetExecutable(dotnetPath)\n                    .SetFilters(\u0022\u002B:Dangl.Data.Shared;\u002B:Dangl.Data.Shared.AspNetCore\u0022)\n                    .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                    .CombineWith(cc =\u003E testProjects.SelectMany(testProject =\u003E {\n                        var projectDirectory = Path.GetDirectoryName(testProject);\n                        var targetFrameworks = GetTestFrameworksForProjectFile(testProject);\n                        return targetFrameworks.Select(targetFramework =\u003E\n                        {\n                            snapshotIndex\u002B\u002B;\n                            return cc\n                                .SetTargetWorkingDirectory(projectDirectory)\n                                .SetOutputFile(OutputDirectory / $\u0022coverage{snapshotIndex:00}.snapshot\u0022)\n                                .SetTargetArguments($\u0022test --no-build -f {targetFramework} --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={OutputDirectory}/{snapshotIndex}_testresults-{targetFramework}.xml\\\u0022\u0022);\n                        });\n                    })), degreeOfParallelism: System.Environment.ProcessorCount,\n                    completeOnFailure: true);\n            }\n            finally\n            {\n                PrependFrameworkToTestresults();\n            }\n\n            var snapshots = GlobFiles(OutputDirectory, \u0022*.snapshot\u0022)\n                .Aggregate((c, n) =\u003E c \u002B \u0022;\u0022 \u002B n);\n\n            DotCoverMerge(c =\u003E c\n                .SetSource(snapshots)\n                .SetOutputFile(OutputDirectory / \u0022coverage.snapshot\u0022));\n\n            DotCoverReport(c =\u003E c\n                .SetSource(OutputDirectory / \u0022coverage.snapshot\u0022)\n                .SetOutputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            // This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                .SetReports(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            // This is the report in Cobertura format that integrates so nice in Jenkins\n            // dashboard and allows to extract more metrics and set build health based\n            // on coverage readings\n            DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura_coverage.xml\u0022))\n                .ConfigureAwait(false)\n                .GetAwaiter()\n                .GetResult();\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(SolutionDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022shared\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022shared-aspnetcore\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(nuGetPackages)\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken));\n        });\n\n    void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*testresults*.xml\u0022).ToList();\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n\n        // Merge all the results to a single file\n        // The \u0022run-time\u0022 attributes of the single assemblies is ensured to be unique for each single assembly by this test,\n        // since in Jenkins, the format is internally converted to JUnit. Aterwards, results with the same timestamps are\n        // ignored. See here for how the code is translated to JUnit format by the Jenkins plugin:\n        // https://github.com/jenkinsci/xunit-plugin/blob/d970c50a0501f59b303cffbfb9230ba977ce2d5a/src/main/resources/org/jenkinsci/plugins/xunit/types/xunitdotnet-2.0-to-junit.xsl#L75-L79\n        var firstXdoc = XDocument.Load(testResults[0]);\n        var runtime = DateTime.Now;\n        var firstAssemblyNodes = firstXdoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n        foreach (var assemblyNode in firstAssemblyNodes)\n        {\n            assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n            runtime = runtime.AddSeconds(1);\n        }\n        for (var i = 1; i \u003C testResults.Count; i\u002B\u002B)\n        {\n            var xDoc = XDocument.Load(testResults[i]);\n            var assemblyNodes = xDoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n            foreach (var assemblyNode in assemblyNodes)\n            {\n                assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n                runtime = runtime.AddSeconds(1);\n            }\n            firstXdoc.Root.Add(assemblyNodes);\n        }\n\n        firstXdoc.Save(OutputDirectory / \u0022testresults.xml\u0022);\n        testResults.ForEach(DeleteFile);\n    }\n\n    string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n}\n"
  },
  {
    "Id": 110354523,
    "FirstIndexed": "2020-04-25T15:47:03.6115851+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625355+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430867+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "Hosting",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Hosting",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 110381018,
    "FirstIndexed": "2020-04-25T15:47:03.6115755+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625298+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430878+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936785+02:00",
    "Name": "Serilog.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Serilog.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Serilog.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 110490515,
    "FirstIndexed": "2020-04-25T15:47:03.6115971+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625424+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843089+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "CommandLine.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/CommandLine.Extensions",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 110695654,
    "FirstIndexed": "2020-04-25T15:47:03.6115897+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625384+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430907+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936796+02:00",
    "Name": "Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 111333815,
    "FirstIndexed": "2020-04-25T15:50:44.7356318+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627039+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434223+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939965+02:00",
    "Name": "nuget-selenium-webdriver-phantomjs",
    "Owner": "lehmamic",
    "HtmlUrl": "https://github.com/lehmamic/nuget-selenium-webdriver-phantomjs",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/lehmamic/nuget-selenium-webdriver-phantomjs/blob/master/build/Build.cs",
    "BuildFileSize": 4675,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing System.Net;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Core;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.EnvironmentInfo;\nusing System.IO;\nusing System.IO.Compression;\nusing ICSharpCode.SharpZipLib.Zip;\nusing ICSharpCode.SharpZipLib.Tar;\nusing ICSharpCode.SharpZipLib.BZip2;\nusing Nuke.Common.Tools.NuGet;\n\nclass Build : NukeBuild\n{\n    private const string Version = \u00222.1.1\u0022;\n\n    private static readonly Uri BaseUri = new Uri(\u0022https://bitbucket.org/ariya/phantomjs/downloads/\u0022);\n    private static readonly Uri NuGetDownloadUri = new Uri(\u0022https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\u0022);\n\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n    \n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    DriverMetadata[] Drivers = new DriverMetadata[]{\n        new DriverMetadata { Platform = \u0022win32\u0022, FileName = $\u0022phantomjs-{Version}-windows.zip\u0022 },\n        new DriverMetadata { Platform = \u0022mac64\u0022, FileName = $\u0022phantomjs-{Version}-macosx.zip\u0022 },\n        new DriverMetadata { Platform = \u0022linux64\u0022, FileName = $\u0022phantomjs-{Version}-linux-x86_64.tar.bz2\u0022 },\n     };\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                EnsureCleanDirectory(RootDirectory / \u0022downloads\u0022);\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Download =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E {\n                using (var client = new WebClient())\n                {\n                  foreach(var driver in Drivers)\n                  {\n                    var downloadedFile = RootDirectory / \u0022downloads\u0022 / driver.Platform / driver.FileName;\n                    var downloadUrl = new Uri(BaseUri, driver.FileName);\n\n                    EnsureExistingDirectory(Path.GetDirectoryName(downloadedFile));\n\n                    Logger.Info($\u0022Downloading file from url {downloadUrl} to local file {downloadedFile}\u0022);\n                    client.DownloadFile(downloadUrl, downloadedFile);\n                  }\n                }\n            });\n            \n    Target Decompress =\u003E _ =\u003E _\n              .DependsOn(Download)\n              .Executes(() =\u003E\n              {\n                foreach (var driver in Drivers)\n                {\n                  var downloadedFile = RootDirectory / \u0022downloads\u0022 / driver.Platform / driver.FileName;\n                  var extractPath = RootDirectory / \u0022downloads\u0022 / driver.Platform;\n                \n                  Logger.Info($\u0022Unzip {downloadedFile} to directory {extractPath}\u0022);\n                  if (Path.GetExtension(downloadedFile) == \u0022.bz2\u0022)\n                  {\n                    ExtractTGZ(downloadedFile, extractPath);\n                  }\n                  else\n                  {\n                    FastZip fastZip = new FastZip();\n                    fastZip.ExtractZip(downloadedFile, extractPath, null);\n                  }\n                }\n              });\n\n    Target Pack =\u003E _ =\u003E _\n              .DependsOn(Decompress)\n              .Executes(() =\u003E\n              {\n                var nugetExe = TemporaryDirectory / \u0022nuget.exe\u0022;\n                if (!File.Exists(nugetExe))\n                {\n                    Logger.Info($\u0022Nuget.exe not found, downloading from {NuGetDownloadUri}\u0022);\t\n                    using (var client = new WebClient())\n                    {\n                        client.DownloadFile(NuGetDownloadUri, nugetExe);\n                    }\n                }\n\n                var nuspecPath = SourceDirectory / \u0022Selenium.WebDriver.PhantomJS.CrossPlatform.nuspec\u0022;\n                NuGetTasks.NuGetPack(nuspecPath, s =\u003E NuGetTasks.DefaultNuGetPack.SetBasePath(SourceDirectory).SetVersion(Version));\n              });\n\n    private static void ExtractTGZ(string gzArchiveName, string destFolder)\n    {\n        using (Stream inStream = File.OpenRead(gzArchiveName))\n        using (Stream bzip2Stream = new BZip2InputStream(inStream))\n        using(TarArchive tarArchive = TarArchive.CreateInputTarArchive(bzip2Stream))\n        {\n            tarArchive.ExtractContents(destFolder);\n        }\n    }\n}\n"
  },
  {
    "Id": 111386254,
    "FirstIndexed": "2020-04-25T15:47:03.611522+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631631+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430918+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "LanguageEditor",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/LanguageEditor",
    "Description": " A dedicated xml language translation files editor.",
    "Archived": true,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 111977740,
    "FirstIndexed": "2020-04-25T15:47:03.6115732+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625281+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843093+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936807+02:00",
    "Name": "Testing",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Testing",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Testing/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 112088095,
    "FirstIndexed": "2020-04-25T15:47:03.6116153+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625452+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430941+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936819+02:00",
    "Name": "Azure",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Azure",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Azure/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 114053378,
    "FirstIndexed": "2020-04-25T15:50:44.7361698+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632154+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434855+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940579+02:00",
    "Name": "Nancy.Serilog",
    "Owner": "Zaid-Ajaj",
    "HtmlUrl": "https://github.com/Zaid-Ajaj/Nancy.Serilog",
    "Description": "Nancy plugin for application-wide logging using Serilog",
    "Archived": false,
    "Stars": 10,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Zaid-Ajaj/Nancy.Serilog/blob/master/build/Build.cs",
    "BuildFileSize": 3686,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tooling.ProcessTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    static AbsolutePath Source =\u003E RootDirectory / \u0022src\u0022;\n    static AbsolutePath Tests =\u003E RootDirectory / \u0022tests\u0022;\n    static AbsolutePath PublishDir =\u003E RootDirectory / \u0022publish\u0022;\n    static AbsolutePath Example =\u003E RootDirectory / \u0022example\u0022;\n    static readonly string DOTNET = \u0022dotnet\u0022;\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Target Clean =\u003E task =\u003E \n      task  \n        .Executes(() =\u003E\n        {\n            var directories = new List\u003Cstring\u003E {\n                Source / \u0022bin\u0022,\n                Source / \u0022obj\u0022, \n                Tests / \u0022bin\u0022,\n                Tests / \u0022obj\u0022,\n                Example / \u0022bin\u0022,\n                Example / \u0022obj\u0022,\n                PublishDir\n            };\n\n            foreach(var dir in directories) {\n                DeleteDirectory(dir);\n            }\n        });\n\n    Target Compile =\u003E task =\u003E\n      task\n        .DependsOn(Clean)\n        .Executes(() =\u003E {\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, Source).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, Source).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, Example).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, Example).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, Tests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, Tests).AssertZeroExitCode();\n        });\n\n    Target Test =\u003E task =\u003E \n      task\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            StartProcess(DOTNET, \u0022restore\u0022, Tests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, Tests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022run\u0022, Tests).AssertZeroExitCode();\n        });\n\n    Target Pack =\u003E task =\u003E\n      task \n        .DependsOn(Clean)\n        .Executes(() =\u003E \n        {\n            var packCmd = $\u0022pack -c Release -o {PublishDir}\u0022;\n            StartProcess(DOTNET, packCmd, Source).AssertZeroExitCode();\n        });\n\n    Target Publish =\u003E task =\u003E\n      task\n        .DependsOn(Pack) \n        .Executes(() =\u003E \n        {\n            var nugetFile = Directory.GetFiles(PublishDir).FirstOrDefault() ?? \u0022\u0022;\n            if (!nugetFile.EndsWith(\u0022.nupkg\u0022))\n            {\n                Logger.Error(\u0022No nuget package found\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            Logger.Info($\u0022About to publish nuget package: {nugetFile}\u0022);\n            var nugetApiKey = EnsureVariable(\u0022NUGET_KEY\u0022) ?? \u0022\u0022;\n\n            if (string.IsNullOrWhiteSpace(nugetApiKey))\n            {\n                Logger.Error(\u0022Nuget API Key was not setup on your local machine, missing environment variable NUGET_KEY\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            var nugetFileName = new FileInfo(nugetFile).Name;\n            StartProcess(DOTNET, $\u0022nuget push {nugetFileName} -s https://api.nuget.org/v3/index.json -k {nugetApiKey}\u0022, PublishDir).AssertZeroExitCode();\n        });\n}\n"
  },
  {
    "Id": 116178423,
    "FirstIndexed": "2020-04-25T15:50:44.7355481+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632706+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433859+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939612+02:00",
    "Name": "ToDo-ToBuy",
    "Owner": "RouR",
    "HtmlUrl": "https://github.com/RouR/ToDo-ToBuy",
    "Description": "My test project",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/RouR/ToDo-ToBuy/blob/master/build/Build.cs",
    "BuildFileSize": 5116,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.EnvironmentInfo;\n\n//https://github.com/nuke-build/nuke\npartial class Build : NukeBuild\n{\n    //powershell -ExecutionPolicy ByPass -File ./build.ps1 -target AllCustom\n    //powershell -ExecutionPolicy ByPass -File ./build.ps1\n    \n    //or just run (force rebuild this project and F5) this project to debug Build Targets\n\n    /// \u003Csummary\u003E\n    ///  Console application entry point. Also defines the default target.\n    /// \u003C/summary\u003E\n    /// \u003Creturns\u003E\u003C/returns\u003E\n    public static int Main()\n    {\n        return Execute\u003CBuild\u003E(x =\u003E x.AllCustom);\n    }\n\n    // Auto-injection fields:\n\n    // require Mono, don\u0060t work in TravisCI [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    /// Provides access to the structure of the solution.\n    [Solution(MySolutionFile)] readonly Solution Solution;\n\n    const string MySolutionFile = \u0022ExampleTDTB.sln\u0022;\n    AbsolutePath MySolutionDirectory =\u003E RootDirectory;\n    AbsolutePath MySourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath AngularSrcDir =\u003E RootDirectory / \u0022src\u0022 / \u0022ngApp\u0022 ;\n    AbsolutePath MyOutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath[] MyTsModelsDirectories =\u003E new []\n    {\n        RootDirectory / \u0022_tsModels\u0022,\n        RootDirectory / \u0022src\u0022/ \u0022ngApp\u0022 / \u0022src\u0022/ \u0022_tsModels\u0022,\n    };\n    AbsolutePath MyRestClientsDirectory =\u003E RootDirectory / \u0022_csREST\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        //.OnlyWhen(() =\u003E false) // Disabled for safety.\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(MySourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(MyOutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetWorkingDirectory(MySolutionDirectory)\n                .SetProjectFile(MySolutionFile));\n        });\n\n    Target CompileDotNet =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {            \n            Console.WriteLine(\u0022Solution CompileDotNet\u0022);\n\n\n\n            var oldVersion = GetVersion();\n            var newVersion = oldVersion.Copy();\n            newVersion.IncreaseBuild();\n            newVersion.SetSha(GitVersion?.Sha);\n            SetVersion(oldVersion, newVersion);\n\n            DotNetTasks.DotNetBuild(s =\u003E s\n                .SetWorkingDirectory(MySolutionDirectory)\n                .SetProjectFile(MySolutionFile)\n                .EnableNoRestore()\n                //.SetConfiguration(Configuration)\n                .SetAssemblyVersion(newVersion.ToAssemblyVersion())\n                .SetFileVersion(newVersion.ToFileVersion())\n                .SetInformationalVersion(GitVersion?.InformationalVersion)\n                );\n        });\n\n    Target Debug =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            void TraceItem(string key, string value) =\u003E Console.WriteLine($\u0022  - {key} = {value}\u0022);\n\n            Logger.Trace(\u0022Environment variables:\u0022);\n            char[] pathSeparators = { EnvironmentInfo.IsWin ? \u0027;\u0027 : \u0027:\u0027 }; \n            foreach (var pair in EnvironmentInfo.Variables.OrderBy(x =\u003E x.Key, StringComparer.OrdinalIgnoreCase))\n            {\n                if (pair.Key.EqualsOrdinalIgnoreCase(\u0022path\u0022))\n                {\n                    TraceItem(pair.Key, pair.Value);\n\n                    var paths = pair.Value.Split(pathSeparators);\n                    var padding = paths.Length.ToString().Length;\n\n                    for (var i = 0; i \u003C paths.Length; i\u002B\u002B)\n                        TraceItem($\u0022{pair.Key}[{i.ToString().PadLeft(padding, paddingChar: \u00270\u0027)}]\u0022, paths[i]);\n                }\n                else\n                {\n                    TraceItem(pair.Key, pair.Value);\n                }\n            } \n        });\n\n    Target AllCustom =\u003E _ =\u003E _\n        .DependsOn(CompileDotNet)\n        .DependsOn(TsGen)\n        .DependsOn(Microdocum)\n        .DependsOn(RunTemplate)\n        .DependsOn(Ng)\n        //.DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            Console.WriteLine(\u0022Custom targets finished\u0022);\n            Console.WriteLine(\u0022IsWin \u0022 \u002B IsWin);\n            Console.WriteLine(\u0022IsUnix \u0022 \u002B IsUnix);\n            Console.WriteLine(\u0022build server \u0022 \u002B Host);\n\n            if (AppVeyor.Instance != null)\n                Console.WriteLine(\u0022Run inside AppVeyor build server.\u0022);\n\n            if (Travis.Instance != null)\n                Console.WriteLine(\u0022Run inside Travis build server.\u0022);\n\n           \n        });\n\n  \n\n   \n\n}"
  },
  {
    "Id": 116201129,
    "FirstIndexed": "2020-04-25T15:50:44.7356295+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632564+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434212+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939953+02:00",
    "Name": "ObjectRepository",
    "Owner": "DiverOfDark",
    "HtmlUrl": "https://github.com/DiverOfDark/ObjectRepository",
    "Description": "EscapeTeams In-Memory Object Database",
    "Archived": false,
    "Stars": 18,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/DiverOfDark/ObjectRepository/blob/master/build/Build.cs",
    "BuildFileSize": 2666,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    Target Clean =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E false) // Disabled for safety.\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E DefaultDotNetRestore);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E DefaultDotNetBuild\n//                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n//                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n//                .SetInformationalVersion(GitVersion.InformationalVersion)\n            );\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(x =\u003E\n                x.SetNoRestore(true).SetNoBuild(true).SetTestAdapterPath(\u0022.\u0022).SetLogger(\u0022Appveyor\u0022).SetProjectFile(\n                    SolutionDirectory / \u0022OutCode.EscapeTeams.ObjectRepository.Tests\u0022 /\n                    \u0022OutCode.EscapeTeams.ObjectRepository.Tests.csproj\u0022));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E DefaultDotNetPack.SetAuthors(\u0022Kirill Orlov\u0022).SetNoRestore(true));\n\n            var apikey = Environment.GetEnvironmentVariable(\u0022NUGET\u0022);\n            if (!String.IsNullOrWhiteSpace(apikey))\n            {\n                GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                    .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s.SetApiKey(apikey).SetTargetPath(x).SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)));\n            }\n        });\n}"
  },
  {
    "Id": 117551196,
    "FirstIndexed": "2020-04-25T15:50:44.7362216+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632632+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434917+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "sitecore-commerce-docker",
    "Owner": "avivasolutionsnl",
    "HtmlUrl": "https://github.com/avivasolutionsnl/sitecore-commerce-docker",
    "Description": "Dockerized Sitecore Commerce 9",
    "Archived": true,
    "Stars": 10,
    "Watchers": 9,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 119267967,
    "FirstIndexed": "2020-04-25T15:50:44.7356272+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632177+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434201+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939948+02:00",
    "Name": "Nuke.WebDeploy",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Nuke.WebDeploy",
    "Description": "WebDeploy AddIn for NUKE Build",
    "Archived": false,
    "Stars": 3,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Nuke.WebDeploy/blob/dev/build/Build.cs",
    "BuildFileSize": 8330,
    "BuildFileContent": "\uFEFFusing System.IO;\nusing System.Linq;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common;\nusing Nuke.WebDocu;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\nusing Nuke.Common.Tools.Xunit;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing System;\nusing System.Threading.Tasks;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.GitHub;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing Nuke.Azure.KeyVault;\nusing static Nuke.DocFX.DocFXTasks;\nusing Nuke.Common.ProjectModel;\nusing Nuke.DocFX;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [Parameter] readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret(\u0022NukeWebDeploy-DocuApiKey\u0022)] string DocuApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n\n    [Solution(\u0022Nuke.WebDeploy.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E SolutionDirectory / \u0022test\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Generate)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .SetTitle(\u0022WebDeploy for NUKE Build - www.dangl-it.com\u0022)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(PublicMyGetSource))\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(PublicMyGetApiKey))\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(PublicMyGetSource)\n                    .SetApiKey(PublicMyGetApiKey)));\n\n            if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n            {\n                // Stable releases are published to NuGet\n                GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                    .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                        .SetApiKey(NuGetApiKey)));\n            }\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(x =\u003E x\n                .SetNoBuild(true)\n                .SetProjectFile(RootDirectory / \u0022test\u0022 / \u0022Nuke.WebDeploy.Tests\u0022)\n                .SetTestAdapterPath(\u0022.\u0022)\n                .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / \u0022tests.xml\u0022}\u0022));\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022api\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(DocuApiKey))\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(DocuBaseUrl))\n        .Executes(() =\u003E\n        {\n            WebDocu(s =\u003E s.SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(GitHubAuthenticationToken))\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(() =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            PublishRelease(x =\u003E x\n                    .SetArtifactPaths(GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray())\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken)\n                )\n                .ConfigureAwait(false)\n                .GetAwaiter()\n                .GetResult();\n        });\n\n    Target Generate =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            GenerateCode(\n                specificationDirectory: RootDirectory / \u0022src\u0022 / \u0022Nuke.WebDeploy\u0022 / \u0022MetaData\u0022,\n                namespaceProvider: x =\u003E \u0022Nuke.WebDeploy\u0022,\n                outputFileProvider: x =\u003E RootDirectory / \u0022src\u0022 / \u0022Nuke.WebDeploy\u0022 / \u0022WebDeploySettings.Generated.cs\u0022\n            );\n        });\n}\n"
  },
  {
    "Id": 119286776,
    "FirstIndexed": "2020-04-25T15:50:44.7356505+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630026+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434303+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940039+02:00",
    "Name": "ViGEm.NET",
    "Owner": "ViGEm",
    "HtmlUrl": "https://github.com/ViGEm/ViGEm.NET",
    "Description": ".NET bindings for the ViGEmClient library.",
    "Archived": false,
    "Stars": 25,
    "Watchers": 10,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ViGEm/ViGEm.NET/blob/master/build/Build.cs",
    "BuildFileSize": 3570,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022ViGEm.NET.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022bin\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    private Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            var url64 = \u0022https://ci.appveyor.com/api/projects/nefarius/vigemclient/artifacts/bin/release/x64/ViGEmClient.dll?job=Platform%3A%20x64\u0022;\n            var costura64 = Path.Combine(WorkingDirectory, @\u0022ViGEmClient\\costura64\u0022);\n            var dll64 = Path.Combine(costura64, \u0022ViGEmClient.dll\u0022);\n            var url32 = \u0022https://ci.appveyor.com/api/projects/nefarius/vigemclient/artifacts/bin/release/x86/ViGEmClient.dll?job=Platform%3A%20x86\u0022;\n            var costura32 = Path.Combine(WorkingDirectory, @\u0022ViGEmClient\\costura32\u0022);\n            var dll32 = Path.Combine(costura32, \u0022ViGEmClient.dll\u0022);\n\n            if (!Directory.Exists(costura64))\n                Directory.CreateDirectory(costura64);\n            if (!Directory.Exists(costura32))\n                Directory.CreateDirectory(costura32);\n\n            using (var wc = new WebClient())\n            {\n                Console.ForegroundColor = ConsoleColor.Green;\n                Console.WriteLine(\u0022\u003E\u003E Downloading native x64 DLL\u0022);\n                wc.DownloadFile(url64, dll64);\n                Console.WriteLine(\u0022\u003E\u003E Downloading native x86 DLL\u0022);\n                wc.DownloadFile(url32, dll32);\n                Console.ResetColor();\n            }\n\n            //\n            // Build .NET assembly\n            // \n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetMaxCpuCount(1)\n                .SetNodeReuse(IsLocalBuild)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(AppVeyor.Instance?.BuildVersion)\n                .SetFileVersion(AppVeyor.Instance?.BuildVersion)\n                .SetInformationalVersion(AppVeyor.Instance?.BuildVersion)\n                .SetPackageVersion(AppVeyor.Instance?.BuildVersion));\n        });\n\n    private Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022, \u0022Pack\u0022)\n                .SetPackageOutputPath(ArtifactsDirectory)\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols());\n        });\n}\n"
  },
  {
    "Id": 119288949,
    "FirstIndexed": "2020-04-25T15:50:44.735555+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626567+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433893+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939646+02:00",
    "Name": "HidGuardian",
    "Owner": "ViGEm",
    "HtmlUrl": "https://github.com/ViGEm/HidGuardian",
    "Description": "Windows kernel-mode driver for controlling access to various input devices.",
    "Archived": false,
    "Stars": 98,
    "Watchers": 13,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ViGEm/HidGuardian/blob/master/build/Build.cs",
    "BuildFileSize": 3153,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing RP = Nuke.Common.IO.PathConstruction.RelativePath;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n    [Solution(\u0022HidGuardian.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild)\n                .SetTargetPlatform(MSBuildTargetPlatform.x64));\n\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild)\n                .SetTargetPlatform(MSBuildTargetPlatform.x86));\n\n            #region Transfer all files into common directory for makecab to work\n\n            EnsureExistingDirectory(ArtifactsDirectory / \u0022x64\u0022);\n            EnsureExistingDirectory(ArtifactsDirectory / \u0022x86\u0022);\n\n            new Dictionary\u003CRP, RP\u003E\n            {\n                { (RP)\u0022driver\u0022 / \u0022x64\u0022 / \u0022HidGuardian.inf\u0022, /* =\u003E */ (RP)\u0022HidGuardian.inf\u0022 },\n                { (RP)\u0022driver\u0022 / \u0022x64\u0022 / \u0022HidGuardian.pdb\u0022, /* =\u003E */ (RP)\u0022x64\u0022 / \u0022HidGuardian.pdb\u0022 },\n                { (RP)\u0022driver\u0022 / \u0022x64\u0022 / \u0022HidGuardian\u0022 / \u0022HidGuardian.sys\u0022, /* =\u003E */ (RP)\u0022x64\u0022 / \u0022HidGuardian.sys\u0022 },\n                { (RP)\u0022driver\u0022 / \u0022x64\u0022 / \u0022HidGuardian\u0022 / \u0022WdfCoinstaller01011.dll\u0022, /* =\u003E */ (RP)\u0022x64\u0022 / \u0022WdfCoinstaller01011.dll\u0022 },\n                { (RP)\u0022driver\u0022 / \u0022x86\u0022 / \u0022HidGuardian.pdb\u0022, /* =\u003E */ (RP)\u0022x86\u0022 / \u0022HidGuardian.pdb\u0022 },\n                { (RP)\u0022driver\u0022 / \u0022x86\u0022 / \u0022HidGuardian\u0022 / \u0022HidGuardian.sys\u0022, /* =\u003E */ (RP)\u0022x86\u0022 / \u0022HidGuardian.sys\u0022 },\n                { (RP)\u0022driver\u0022 / \u0022x86\u0022 / \u0022HidGuardian\u0022 / \u0022WdfCoinstaller01011.dll\u0022, /* =\u003E */ (RP)\u0022x86\u0022 / \u0022WdfCoinstaller01011.dll\u0022 }\n            }.ForEach((pair, i) =\u003E File.Copy(Solution.Directory / pair.Key, ArtifactsDirectory / pair.Value));\n\n            #endregion\n        });\n}\n"
  },
  {
    "Id": 119298781,
    "FirstIndexed": "2020-04-25T15:50:44.7356249+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629901+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434195+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939936+02:00",
    "Name": "Nuke.WebDocu",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Nuke.WebDocu",
    "Description": "WebDocu AddIn for NUKE Build",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Nuke.WebDocu/blob/develop/build/Build.cs",
    "BuildFileSize": 8045,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.WebDocu;\nusing System.IO;\nusing Nuke.Common.Git;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\nusing Nuke.Common.Tools.Xunit;\nusing static Nuke.Common.Tools.DocFX.DocFXTasks;\nusing Nuke.Common.Tools.DocFX;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Tooling;\nusing Nuke.GitHub;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing Nuke.Common.Tools.AzureKeyVault.Attributes;\nusing Nuke.Common.IO;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret(\u0022NukeWebDocu-DocuApiKey\u0022)] string DocuApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n\n    string DocFxFile =\u003E RootDirectory / \u0022docfx.json\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022test\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .SetTitle(\u0022WebDocu for NUKE Build - www.dangl-it.com\u0022)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(PublicMyGetSource))\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(PublicMyGetApiKey))\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(PublicMyGetSource)\n                    .SetApiKey(PublicMyGetApiKey)));\n\n            if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n            {\n                // Stable releases are published to NuGet\n                GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                    .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                        .SetApiKey(NuGetApiKey)));\n            }\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(x =\u003E x\n                .SetNoBuild(true)\n                .SetProjectFile(RootDirectory / \u0022test\u0022 / \u0022Nuke.WebDocu.Tests\u0022)\n                .SetTestAdapterPath(\u0022.\u0022)\n                .CombineWith(c =\u003E new[] {\u0022netcoreapp3.0\u0022, \u0022net472\u0022}\n                    .Select(framework =\u003E c.SetFramework(framework).SetLogger($\u0022xunit;LogFilePath={OutputDirectory / $\u0022tests-{framework}.xml\u0022}\u0022))\n                ), degreeOfParallelism: Environment.ProcessorCount, completeOnFailure: true);\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(RootDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(RootDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(RootDirectory / \u0022README.md\u0022, RootDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(RootDirectory / \u0022index.md\u0022);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(DocuApiKey))\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(DocuBaseUrl))\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocuTasks.WebDocu(s =\u003E s.SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E !string.IsNullOrWhiteSpace(GitHubAuthenticationToken))\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray())\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken)\n                );\n        });\n}\n"
  },
  {
    "Id": 120298192,
    "FirstIndexed": "2020-04-25T15:50:44.7356227+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626982+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434184+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "PSeq",
    "Owner": "Liminiens",
    "HtmlUrl": "https://github.com/Liminiens/PSeq",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 121940262,
    "FirstIndexed": "2020-04-25T15:50:44.735634+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630868+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434235+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939976+02:00",
    "Name": "HuanlinLib",
    "Owner": "huanlin",
    "HtmlUrl": "https://github.com/huanlin/HuanlinLib",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/huanlin/HuanlinLib/blob/master/build/Build.cs",
    "BuildFileSize": 3461,
    "BuildFileContent": "\uFEFFusing System.Collections.Generic;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.InspectCode;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\r\n\r\ninternal class Build : NukeBuild\r\n{\r\n    // Console application entry. Also defines the default target.\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    // Auto-injection fields:\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    private readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\r\n\r\n    [Solution(\u0022src/HuanlinLib.sln\u0022)] private readonly Solution TheSolution;\r\n    [GitRepository] private readonly GitRepository GitRepository;\r\n    [GitVersion] private readonly GitVersion GitVersion;\r\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\r\n\r\n    // Parses origin, branch name and head from git config.\r\n\r\n    // [Parameter] readonly string MyGetApiKey;\r\n    // Returns command-line arguments and environment variables.\r\n\r\n    private AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    private AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    private AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\r\n\r\n    private Target Clean =\u003E _ =\u003E _             \r\n             .Executes(() =\u003E\r\n             {\r\n                 GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n                 GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n                 EnsureCleanDirectory(OutputDirectory);\r\n             });\r\n\r\n    private Target Restore =\u003E _ =\u003E _\r\n             .DependsOn(Clean)\r\n             .Executes(() =\u003E\r\n             {\r\n                 DotNetRestore(s =\u003E s.SetProjectFile(TheSolution));\r\n             });\r\n\r\n    private Target Compile =\u003E _ =\u003E _\r\n             .DependsOn(Restore)\r\n             .Executes(() =\u003E\r\n             {\r\n                 DotNetBuild(s =\u003E s\r\n                     .SetProjectFile(TheSolution)\r\n                     .EnableNoRestore()\r\n                     .SetConfiguration(Configuration)\r\n                     .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                     .SetFileVersion(GitVersion.AssemblySemVer)\r\n                     .SetInformationalVersion(GitVersion.InformationalVersion));\r\n             });\r\n\r\n    private string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\r\n\r\n    private IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\r\n\r\n    private Target Pack =\u003E _ =\u003E _\r\n             .DependsOn(Compile)\r\n             .Executes(() =\u003E\r\n             {\r\n\r\n                 DotNetPack(s =\u003E s\r\n                     .SetProject(TheSolution)\r\n                     .EnableNoBuild()\r\n                     .SetConfiguration(Configuration)\r\n                     .EnableIncludeSymbols()\r\n                     .SetOutputDirectory(OutputDirectory)\r\n                     .SetVersion(GitVersion.NuGetVersionV2)\r\n                     .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\r\n             });\r\n}"
  },
  {
    "Id": 122058741,
    "FirstIndexed": "2020-04-25T15:50:44.7354247+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630334+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433404+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893918+02:00",
    "Name": "net-vips",
    "Owner": "kleisauke",
    "HtmlUrl": "https://github.com/kleisauke/net-vips",
    "Description": ".NET binding for libvips",
    "Archived": false,
    "Stars": 115,
    "Watchers": 10,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/kleisauke/net-vips/blob/master/build/Build.cs",
    "BuildFileSize": 7481,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Net.Http;\nusing System.Runtime.InteropServices;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\npartial class Build : NukeBuild\n{\n    BuildParameters Parameters { get; set; }\n\n    protected override void OnBuildInitialized()\n    {\n        Parameters = new BuildParameters(this);\n        Information(\u0022Building version {0} of NetVips ({1}).\u0022,\n            Parameters.Version,\n            Parameters.Configuration);\n        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n        {\n            Information(\u0022OS: Windows\u0022);\n        }\n        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\n        {\n            Information(\u0022OS: Linux\u0022);\n        }\n        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n        {\n            Information(\u0022OS: macOS\u0022);\n        }\n\n        Information(\u0022Bitness: \u0022 \u002B (Environment.Is64BitProcess ? \u002264 bit\u0022 : \u002232 bit\u0022));\n        Information(\u0022Host type: \u0022 \u002B Host);\n        Information(\u0022Version of libvips: \u0022 \u002B Parameters.VipsVersion);\n        Information(\u0022Configuration: \u0022 \u002B Parameters.Configuration);\n\n        void ExecWait(string preamble, string command, string args)\n        {\n            Console.WriteLine(preamble);\n            Process.Start(new ProcessStartInfo(command, args) { UseShellExecute = false })?.WaitForExit();\n        }\n\n        ExecWait(\u0022dotnet version:\u0022, \u0022dotnet\u0022, \u0022--version\u0022);\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(RootDirectory / \u0022src/NetVips/bin\u0022 / Parameters.Configuration);\n            EnsureCleanDirectory(RootDirectory / \u0022src/NetVips.Extensions/bin\u0022 / Parameters.Configuration);\n            EnsureCleanDirectory(RootDirectory / \u0022tests/NetVips.Tests/bin\u0022 / Parameters.Configuration);\n            EnsureCleanDirectory(Parameters.ArtifactsDir);\n            EnsureCleanDirectory(Parameters.PackDir);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(c =\u003E c\n                .SetProjectFile(Parameters.BuildSolution)\n                .SetConfiguration(Parameters.Configuration)\n            );\n        });\n\n    Target RunTests =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !Parameters.SkipTests)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            // Only test with the precompiled NuGet binaries if we\u0027re not on Travis.\n            DotNetTest(c =\u003E c\n                .SetProjectFile(Parameters.TestSolution)\n                .SetConfiguration(Parameters.Configuration)\n                .AddProperty(\u0022TestWithNuGetBinaries\u0022, Host != HostType.Travis));\n        });\n\n    Target DownloadBinaries =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E Parameters.Package)\n        .After(RunTests)\n        .Executes(async () =\u003E\n        {\n            var client = new HttpClient();\n\n            foreach (var architecture in Parameters.NuGetArchitectures)\n            {\n                var fileName = $\u0022libvips-{Parameters.VipsVersion}-{architecture}.tar.gz\u0022;\n                var tarball =\n                    new Uri(\n                        $\u0022https://github.com/kleisauke/libvips-packaging/releases/download/v{Parameters.VipsVersion}/{fileName}\u0022);\n\n                var filePath = Parameters.DownloadDir / fileName;\n                if (!File.Exists(filePath))\n                {\n                    Information(filePath \u002B \u0022 not in download directory. Downloading now ...\u0022);\n                    EnsureExistingDirectory(Parameters.DownloadDir);\n                    var response = await client.GetAsync(tarball);\n                    using (var fs = new FileStream(filePath, FileMode.CreateNew))\n                    {\n                        await response.Content.CopyToAsync(fs);\n                    }\n                }\n\n                var tempDir = Parameters.PackDir / \u0022temp\u0022;\n\n                Information($\u0022Uncompressing {fileName} ...\u0022);\n                ExtractTarball(filePath, tempDir);\n\n                var dllPackDir = Parameters.PackDir / architecture;\n                EnsureExistingDirectory(dllPackDir);\n\n                tempDir.GlobFiles(\u0022lib/*.dll\u0022, \u0022lib/*.so.*\u0022, \u0022lib/*.dylib\u0022, \u0022THIRD-PARTY-NOTICES.md\u0022, \u0022versions.json\u0022)\n                    .ForEach(f =\u003E CopyFileToDirectory(f, dllPackDir));\n\n                DeleteDirectory(tempDir);\n            }\n        });\n\n    Target CreateNetVipsNugetPackage =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E Parameters.Package)\n        .After(RunTests)\n        .Executes(() =\u003E\n        {\n            // Need to build the OSX and Linux DLL first.\n            DotNetBuild(c =\u003E c\n                .SetProjectFile(Parameters.BuildSolution)\n                .SetConfiguration(Parameters.Configuration)\n                .SetFramework(\u0022netstandard2.0\u0022)\n                .AddProperty(\u0022Platform\u0022, \u0022AnyCPU\u0022)\n                .AddProperty(\u0022TargetOS\u0022, \u0022OSX\u0022)\n            );\n\n            DotNetBuild(c =\u003E c\n                .SetProjectFile(Parameters.BuildSolution)\n                .SetConfiguration(Parameters.Configuration)\n                .SetFramework(\u0022netstandard2.0\u0022)\n                .AddProperty(\u0022Platform\u0022, \u0022AnyCPU\u0022)\n                .AddProperty(\u0022TargetOS\u0022, \u0022Linux\u0022)\n            );\n\n            DotNetPack(c =\u003E c\n                .SetProject(Parameters.BuildSolution)\n                .SetConfiguration(Parameters.Configuration)\n                .SetOutputDirectory(Parameters.ArtifactsDir)\n                .AddProperty(\u0022TargetOS\u0022, \u0022Windows\u0022)\n            );\n        });\n\n    Target CreateNetVipsExtensionsNugetPackage =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E Parameters.Package)\n        .After(RunTests)\n        .Executes(() =\u003E\n        {\n            DotNetPack(c =\u003E c\n                .SetProject(Parameters.BuildSolutionExtensions)\n                .SetConfiguration(Parameters.Configuration)\n                .SetOutputDirectory(Parameters.ArtifactsDir)\n            );\n        });\n\n    Target CreateNativeNuGetPackages =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E Parameters.Package)\n        .DependsOn(DownloadBinaries)\n        .Executes(() =\u003E\n        {\n            // Build the architecture specific packages.\n            foreach (var architecture in Parameters.NuGetArchitectures)\n            {\n                NuGetPack(c =\u003E c\n                    .SetTargetPath(RootDirectory / \u0022build/native/NetVips.Native.\u0022 \u002B architecture \u002B \u0022.nuspec\u0022)\n                    .SetVersion(Parameters.VipsVersion)\n                    .SetOutputDirectory(Parameters.ArtifactsDir)\n                    .AddProperty(\u0022NoWarn\u0022, \u0022NU5128\u0022));\n            }\n\n            // Build the all-in-one package, which depends on the previous packages.\n            NuGetPack(c =\u003E c\n                .SetTargetPath(RootDirectory / \u0022build/native/NetVips.Native.nuspec\u0022)\n                .SetVersion(Parameters.VipsVersion)\n                .SetOutputDirectory(Parameters.ArtifactsDir)\n                .AddProperty(\u0022NoWarn\u0022, \u0022NU5128\u0022));\n        });\n\n    Target All =\u003E _ =\u003E _\n        .DependsOn(RunTests)\n        .DependsOn(CreateNetVipsNugetPackage)\n        .DependsOn(CreateNetVipsExtensionsNugetPackage)\n        .DependsOn(CreateNativeNuGetPackages);\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.All);\n}"
  },
  {
    "Id": 122828382,
    "FirstIndexed": "2020-04-25T15:47:03.6108427+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628012+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430947+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893683+02:00",
    "Name": "NetTemplateRepository",
    "Owner": "reegeek",
    "HtmlUrl": "https://github.com/reegeek/NetTemplateRepository",
    "Description": "Skeleton of .net repository.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "Build/nuke/Build.cs",
    "BuildFileUrl": "https://github.com/reegeek/NetTemplateRepository/blob/master/Build/nuke/Build.cs",
    "BuildFileSize": 8025,
    "BuildFileContent": "using System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\n    \u0022continuous\u0022,\n    GitHubActionsImage.WindowsLatest,\n    On = new[] { GitHubActionsTrigger.Push },\n    ImportGitHubTokenAs = nameof(GitHubToken),\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) })]\n[GitHubActions(\n    \u0022continuousCore\u0022,\n    GitHubActionsImage.UbuntuLatest,\n    GitHubActionsImage.MacOsLatest,\n    On = new[] { GitHubActionsTrigger.Push },\n    ImportGitHubTokenAs = nameof(GitHubToken),\n    InvokedTargets = new[] { nameof(TestCoreOnly) })]\n[AppVeyor(\n    AppVeyorImage.VisualStudio2019,\n    SkipTags = true,\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) })]\n[AzurePipelines(\n    suffix: null,\n    AzurePipelinesImage.WindowsLatest,\n    AzurePipelinesImage.UbuntuLatest,\n    AzurePipelinesImage.MacOsLatest,\n    InvokedTargets = new[] { nameof(Test), nameof(TestCoreOnly), nameof(Pack), nameof(PackCoreOnly) },\n    NonEntryTargets = new[] { nameof(Restore) },\n    ExcludedTargets = new[] { nameof(Clean)})]\n\npartial class Build : Nuke.Common.NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [CI] readonly AzurePipelines AzurePipelines;\n    [Parameter(\u0022GitHub Token\u0022)] readonly string GitHubToken;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ResultDirectory =\u003E RootDirectory / \u0022.result\u0022;\n    AbsolutePath PackagesDirectory =\u003E ResultDirectory / \u0022packages\u0022;\n    AbsolutePath TestResultDirectory =\u003E ResultDirectory / \u0022test-results\u0022;\n    IEnumerable\u003CProject\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n    IEnumerable\u003CProject\u003E AllProjects =\u003E Solution.AllProjects.Where(x=\u003E SourceDirectory.Contains(x.Path));\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ResultDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E ExecutesCompile(false));\n    void ExecutesCompile(bool excludeNetFramework)\n    {\n        Logger.Info(excludeNetFramework ? \u0022Exclude net framework\u0022 : \u0022Include net framework\u0022);\n        if (excludeNetFramework)\n        {\n            var frameworks =\n                from project in AllProjects\n                from framework in project.GetTargetFrameworks(true)\n                select new {project, framework};\n\n\n            DotNetBuild(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .CombineWith(frameworks, (s, f) =\u003E s\n                    .SetFramework(f.framework)\n                    .SetProjectFile(f.project)));\n        }\n        else\n        {\n            DotNetBuild(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        }\n    }\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Executes(() =\u003E ExecutesTest(false));\n    void ExecutesTest(bool excludeNetFramework)\n    {\n        Logger.Info(excludeNetFramework ? \u0022Exclude net framework\u0022 : \u0022Include net framework\u0022);\n\n        var testConfigurations =\n            from project in TestProjects\n            from framework in project.GetTargetFrameworks(excludeNetFramework)\n            select new {project, framework};\n\n        DotNetTest(_ =\u003E\n            {\n                return _\n                    .SetConfiguration(Configuration)\n                    .SetNoRestore(InvokedTargets.Contains(Restore))\n                    .SetNoBuild(InvokedTargets.Contains(Compile))\n                    .ResetVerbosity()\n                    .SetResultsDirectory(TestResultDirectory)\n                    .CombineWith(testConfigurations, (_, v) =\u003E _\n                        .SetProjectFile(v.project)\n                        .SetFramework(v.framework)\n                        .SetLogger($\u0022trx;LogFileName={v.project.Name}.trx\u0022));\n            });\n\n        TestResultDirectory.GlobFiles(\u0022*.trx\u0022).ForEach(x =\u003E\n            AzurePipelines?.PublishTestResults(\n                type: AzurePipelinesTestResultsType.VSTest,\n                title: $\u0022{Path.GetFileNameWithoutExtension(x)} ({AzurePipelines.StageDisplayName})\u0022,\n                files: new string[] {x}));\n    }\n\n    Target CompileCoreOnly =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            var excludeNetFramework = AllProjects.SelectMany(x =\u003E x.GetTargetFrameworks()).Distinct()\n                .Any(x =\u003E !x.Contains(\u0022standard\u0022) || !x.Contains(\u0022core\u0022));\n            ExecutesCompile(excludeNetFramework);\n        });\n\n    Target TestCoreOnly =\u003E _ =\u003E _\n        .DependsOn(CompileCoreOnly)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Executes(() =\u003E\n        {\n            var excludeNetFramework = AllProjects.SelectMany(x =\u003E x.GetTargetFrameworks()).Distinct()\n                .Any(x =\u003E !x.Contains(\u0022standard\u0022) || !x.Contains(\u0022core\u0022));\n            ExecutesTest(excludeNetFramework);\n        });\n\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n        .Executes(ExecutesPack);\n\n    Target PackCoreOnly =\u003E _ =\u003E _\n        .DependsOn(CompileCoreOnly)\n        .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n        .Executes(ExecutesPack);\n\n\n    void ExecutesPack() =\u003E\n        DotNetPack(_ =\u003E\n        {\n            var repositoryUrl = $\u0022https://{GitRepository.Endpoint}/{GitRepository.Identifier}/\u0022;\n\n            return _    \n                .SetProject(Solution)\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackagesDirectory)\n                .DisablePackageRequireLicenseAcceptance()\n                .SetRepositoryType(\u0022git\u0022)\n                .SetRepositoryUrl(repositoryUrl)\n                .SetProperty(\u0022RepositoryCommit\u0022, GitVersion.Sha)\n                .SetPackageReleaseNotes($\u0022{repositoryUrl}releases/v{GitVersion.MajorMinorPatch}\u0022)\n                .SetAuthors(\u0022Reegeek\u0022)\n                .SetProperty(\u0022Owners\u0022, \u0022Reegeek\u0022)\n                .SetPackageProjectUrl(repositoryUrl)\n                .SetVersion(GitVersion.NuGetVersionV2);\n        });\n}"
  },
  {
    "Id": 123034643,
    "FirstIndexed": "2020-04-25T15:50:44.7356204+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629884+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434172+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939925+02:00",
    "Name": "Nuke.GitHub",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Nuke.GitHub",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Nuke.GitHub/blob/develop/build/Build.cs",
    "BuildFileSize": 8407,
    "BuildFileContent": "\uFEFFusing Nuke.Common.Git;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing Nuke.Common.Tools.AzureKeyVault.Attributes;\nusing static Nuke.Common.Tools.DocFX.DocFXTasks;\nusing Nuke.Common.Tools.DocFX;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.IO;\nusing static Nuke.CodeGeneration.CodeGenerator;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [Parameter] readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret(\u0022NukeGitHub-DocuApiKey\u0022)] string DocuApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n\n    [Solution(\u0022Nuke.GitHub.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .SetTitle(\u0022GitHub for NUKE Build - www.dangl-it.com\u0022)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            if (string.IsNullOrWhiteSpace(PublicMyGetSource))\n            {\n                ControlFlow.Fail(nameof(PublicMyGetSource) \u002B \u0022 is required\u0022);\n            }\n            \n            if (string.IsNullOrWhiteSpace(PublicMyGetApiKey))\n            {\n                ControlFlow.Fail(nameof(PublicMyGetApiKey) \u002B \u0022 is required\u0022);\n            }\n\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n                });\n\n            if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n            {\n                // Stable releases are published to NuGet\n                GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                    .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                        .SetApiKey(NuGetApiKey)));\n            }\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(SolutionDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022api\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Executes(() =\u003E\n        {\n            if (string.IsNullOrWhiteSpace(DocuApiKey))\n            {\n                ControlFlow.Fail(nameof(DocuApiKey) \u002B \u0022 is required\u0022);\n            }\n\n            if (string.IsNullOrWhiteSpace(DocuBaseUrl))\n            {\n                ControlFlow.Fail(nameof(DocuBaseUrl) \u002B \u0022 is required\u0022);\n            }\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            if (string.IsNullOrWhiteSpace(GitHubAuthenticationToken))\n            {\n                ControlFlow.Fail(nameof(GitHubAuthenticationToken) \u002B \u0022 is required\u0022);\n            }\n\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray())\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken)\n                );\n        });\n\n    Target Generate =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            GenerateCode(\n                specificationDirectory: RootDirectory / \u0022src\u0022 / \u0022Nuke.GitHub\u0022 / \u0022MetaData\u0022,\n                namespaceProvider: x =\u003E \u0022Nuke.GitHub\u0022,\n                outputFileProvider: x =\u003E RootDirectory / \u0022src\u0022 / \u0022Nuke.GitHub\u0022 / \u0022GitHubTasks.Generated.cs\u0022\n            );\n        });\n}\n"
  },
  {
    "Id": 123498163,
    "FirstIndexed": "2020-04-25T15:50:44.7356181+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632165+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434161+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939913+02:00",
    "Name": "CoberturaConverter",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/CoberturaConverter",
    "Description": "Transforms multiple code coverage formats to Cobertura. With CLI tool and NUKE build integration.",
    "Archived": false,
    "Stars": 8,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/CoberturaConverter/blob/develop/build/Build.cs",
    "BuildFileSize": 12536,
    "BuildFileContent": "\uFEFFusing Nuke.CoberturaConverter;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing Nuke.DocFX;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing Nuke.Azure.KeyVault;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [KeyVaultSecret] string DocuBaseUrl;\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n    [KeyVaultSecret] string PublicMyGetSource;\n    [KeyVaultSecret] string PublicMyGetApiKey;\n    [KeyVaultSecret(\u0022CoberturaConverter-DocuApiKey\u0022)] string DocuApiKey;\n    [KeyVaultSecret] string NuGetApiKey;\n\n    string DocFxFile =\u003E RootDirectory / \u0022docfx.json\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022test\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(x =\u003E x\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(changeLog)\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(RootDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022);\n            var testRun = 1;\n            foreach (var testProject in testProjects)\n            {\n                var projectDirectory = Path.GetDirectoryName(testProject);\n\n\n                DotNetTest(x =\u003E x\n                .SetNoBuild(true)\n                .SetProjectFile(testProject)\n                .SetTestAdapterPath(\u0022.\u0022)\n                .SetLogger($\u0022xunit;LogFilePath={OutputDirectory / $\u0022test_{testRun\u002B\u002B}.testresults.xml\u0022}\u0022));\n            }\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(RootDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022).ToList();\n            for (var i = 0; i \u003C testProjects.Count; i\u002B\u002B)\n            {\n                var testProject = testProjects[i];\n                var projectDirectory = Path.GetDirectoryName(testProject);\n                // This is so that the global dotnet is used instead of the one that comes with NUKE\n                var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n                var snapshotIndex = i;\n\n                string xUnitOutputDirectory = OutputDirectory / $\u0022test_{snapshotIndex:00}.testresults.xml\u0022;\n                DotCoverCover(c =\u003E c\n                    .SetTargetExecutable(dotnetPath)\n                    .SetTargetWorkingDirectory(projectDirectory)\n                    .SetTargetArguments($\u0022test --no-build --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={xUnitOutputDirectory}\\\u0022\u0022)\n                    .SetFilters(\u0022\u002B:CoberturaConverter.Core\u0022)\n                    .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                    .SetOutputFile(OutputDirectory / $\u0022coverage{snapshotIndex:00}.snapshot\u0022));\n            }\n\n            var snapshots = testProjects.Select((t, i) =\u003E OutputDirectory / $\u0022coverage{i:00}.snapshot\u0022)\n                .Select(p =\u003E p.ToString())\n                .Aggregate((c, n) =\u003E c \u002B \u0022;\u0022 \u002B n);\n\n            DotCoverMerge(c =\u003E c\n                .SetSource(snapshots)\n                .SetOutputFile(OutputDirectory / \u0022coverage.snapshot\u0022));\n\n            DotCoverReport(c =\u003E c\n                .SetSource(OutputDirectory / \u0022coverage.snapshot\u0022)\n                .SetOutputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            // This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                .SetReports(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            // This is the report in Cobertura format that integrates so nice in Jenkins\n            // dashboard and allows to extract more metrics and set build health based\n            // on coverage readings\n            DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura_coverage.xml\u0022))\n                .ConfigureAwait(false)\n                .GetAwaiter()\n                .GetResult();\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.AddProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(RootDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(RootDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(RootDirectory / \u0022README.md\u0022, RootDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(RootDirectory / \u0022index.md\u0022);\n            Directory.Delete(RootDirectory / \u0022core\u0022, true);\n            Directory.Delete(RootDirectory / \u0022cli\u0022, true);\n            Directory.Delete(RootDirectory / \u0022nuke\u0022, true);\n            Directory.Delete(RootDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetSourceDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes\u003CTask\u003E(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            await PublishRelease(x =\u003E x\n                .SetArtifactPaths(nuGetPackages)\n                .SetCommitSha(GitVersion.Sha)\n                .SetReleaseNotes(completeChangeLog)\n                .SetRepositoryName(repositoryInfo.repositoryName)\n                .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                .SetTag(releaseTag)\n                .SetToken(GitHubAuthenticationToken));\n        });\n\n    Target Generate =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            GenerateCode(\n                specificationDirectory: RootDirectory / \u0022src\u0022 / \u0022Nuke.CoberturaConverter\u0022,\n                namespaceProvider: x =\u003E \u0022Nuke.CoberturaConverter\u0022,\n                outputFileProvider: x =\u003E RootDirectory / \u0022src\u0022 / \u0022Nuke.CoberturaConverter\u0022 / \u0022CoberturaConverterTasks.Generated.cs\u0022\n            );\n        });\n\n    void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*.testresults*.xml\u0022);\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable) xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable) xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n    }\n\n    string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n}\n"
  },
  {
    "Id": 123838470,
    "FirstIndexed": "2020-04-25T15:50:44.7360219+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630789+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434718+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940437+02:00",
    "Name": "CreateAndFake",
    "Owner": "CreateAndFake",
    "HtmlUrl": "https://github.com/CreateAndFake/CreateAndFake",
    "Description": "A C# class library that handles mocking, test data generation, and validation.",
    "Archived": false,
    "Stars": 9,
    "Watchers": 2,
    "BuildFilePath": "build/nuke/Build.cs",
    "BuildFileUrl": "https://github.com/CreateAndFake/CreateAndFake/blob/master/build/nuke/Build.cs",
    "BuildFileSize": 5976,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.OpenCover;\nusing Nuke.Common.Tools.ReportGenerator;\nusing static Nuke.Common.IO.PathConstruction;\n\n/// \u003Csummary\u003EManages build behavior for the solution.\u003C/summary\u003E\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\ninternal class Build : NukeBuild\n{\n    /// \u003Csummary\u003EOutput folder for the solution.\u003C/summary\u003E\n    private AbsolutePath ArtifactDir =\u003E _solution.Directory / \u0022artifacts\u0022;\n\n    /// \u003Csummary\u003EArtifact output folder for tests.\u003C/summary\u003E\n    private AbsolutePath TestingDir =\u003E ArtifactDir / \u0022testing\u0022;\n\n    /// \u003Csummary\u003EArtifact output folder for packages.\u003C/summary\u003E\n    private AbsolutePath PackageDir =\u003E ArtifactDir / \u0022releases\u0022;\n\n    /// \u003Csummary\u003EArtifact output folder for test coverage.\u003C/summary\u003E\n    private AbsolutePath CoverageDir =\u003E ArtifactDir / \u0022coverage\u0022;\n\n    /// \u003Csummary\u003ETarget file for raw test coverage data.\u003C/summary\u003E\n    private AbsolutePath RawCoverageFile =\u003E CoverageDir / \u0022CoverageRaw.xml\u0022;\n\n    /// \u003Csummary\u003ESettings file used for testing.\u003C/summary\u003E\n    private AbsolutePath TestSettingsFile =\u003E _solution.Directory / \u0022tests\u0022 / \u0022TestSettings.runsettings\u0022;\n\n    /// \u003Csummary\u003EProvides access to the structure of the solution.\u003C/summary\u003E\n    [Solution]\n    private readonly Solution _solution;\n\n    /// \u003Csummary\u003EControls pack versioning.\u003C/summary\u003E\n    [GitVersion]\n    private readonly GitVersion _gitVersion;\n\n    // Console application entry point. Also defines the default target.\n    public static int Main()\n    {\n        return Execute\u003CBuild\u003E(x =\u003E x.Compile);\n    }\n\n    /// \u003Csummary\u003EDeletes output folders.\u003C/summary\u003E\n    internal Target Clean =\u003E _ =\u003E _\n        .Before(Compile)\n        .Executes(() =\u003E\n        {\n            FileSystemTasks.EnsureCleanDirectory(ArtifactDir / \u0022obj\u0022);\n            FileSystemTasks.EnsureCleanDirectory(ArtifactDir / \u0022bin\u0022);\n            FileSystemTasks.EnsureCleanDirectory(TestingDir);\n            FileSystemTasks.EnsureCleanDirectory(PackageDir);\n            FileSystemTasks.EnsureCleanDirectory(CoverageDir);\n        });\n\n    /// \u003Csummary\u003EBuilds the solution.\u003C/summary\u003E\n    internal Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetBuildSettings Set(DotNetBuildSettings s)\n            {\n                return s.SetProjectFile(_solution)\n                    .SetFileVersion(_gitVersion.GetNormalizedFileVersion())\n                    .SetInformationalVersion(_gitVersion.InformationalVersion)\n                    .SetAssemblyVersion(_gitVersion.GetNormalizedAssemblyVersion());\n            }\n\n            DotNetTasks.DotNetBuild(s =\u003E Set(s).SetConfiguration(\u0022Debug\u0022));\n            DotNetTasks.DotNetBuild(s =\u003E Set(s).SetConfiguration(\u0022Release\u0022));\n        });\n\n    /// \u003Csummary\u003EBuilds and packs the solution.\u003C/summary\u003E\n    internal Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTasks.DotNetPack(s =\u003E s\n                .SetVersion(_gitVersion.NuGetVersionV2)\n                .SetOutputDirectory(PackageDir)\n                .SetConfiguration(\u0022Release\u0022)\n                .SetProject(_solution)\n                .EnableNoRestore()\n                .EnableNoBuild());\n        });\n\n    /// \u003Csummary\u003EBuilds and tests the solution.\u003C/summary\u003E\n    internal Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTestSettings Set(DotNetTestSettings s)\n            {\n                return s.SetProjectFile(_solution)\n                    .SetSettingsFile(TestSettingsFile)\n                    .SetNoBuild(true);\n            }\n\n            DotNetTasks.DotNetTest(s =\u003E Set(s).SetConfiguration(\u0022Debug\u0022));\n            DotNetTasks.DotNetTest(s =\u003E Set(s).SetConfiguration(\u0022Release\u0022));\n        });\n\n    /// \u003Csummary\u003EBuilds and analyzes test code coverage.\u003C/summary\u003E\n    internal Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .After(Test)\n        .Executes(() =\u003E\n        {\n            FileSystemTasks.EnsureCleanDirectory(CoverageDir);\n\n            CoverletSettings Set(CoverletSettings s, string testAssembly)\n            {\n                return s.SetAssembly(testAssembly)\n                    .SetExclude(\u0022[xunit*]*\u0022)\n                    .SetOutput(RawCoverageFile)\n                    .SetMergeWith(RawCoverageFile)\n                    .SetTargetSettings(new DotNetTestSettings()\n                        .SetProjectFile(_solution)\n                        .SetSettingsFile(TestSettingsFile)\n                        .SetNoBuild(true));\n            }\n\n            AbsolutePath[] testAssemblies = TestingDir.GlobFiles(\u0022Debug/**/*Tests.dll\u0022).ToArray();\n            for (int i = testAssemblies.Length - 1; i \u003E 0; i--)\n            {\n                CoverletTasks.Coverlet(s =\u003E Set(s, testAssemblies[i]));\n            }\n            CoverletTasks.Coverlet(s =\u003E Set(s, testAssemblies[0])\n                .SetFormat(CoverletOutputFormat.opencover));\n\n            ReportGeneratorTasks.ReportGenerator(s =\u003E s\n                .SetTargetDirectory(CoverageDir / \u0022report\u0022)\n                .SetReports(RawCoverageFile));\n        });\n\n    /// \u003Csummary\u003EBuild process for AppVeyor.\u003C/summary\u003E\n    internal Target OnAppVeyor =\u003E _ =\u003E _\n        .Requires(() =\u003E IsServerBuild)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        .DependsOn(Coverage);\n\n    /// \u003Csummary\u003EBuild process for Travis.\u003C/summary\u003E\n    internal Target OnTravis =\u003E _ =\u003E _\n        .Requires(() =\u003E IsServerBuild)\n        .Executes(() =\u003E\n        {\n            DotNetTasks.DotNetBuild(s =\u003E s\n                .SetProjectFile(_solution)\n                .SetFramework(\u0022netcoreapp3.0\u0022));\n\n            DotNetTasks.DotNetTest(s =\u003E s\n                .SetProjectFile(_solution)\n                .SetFramework(\u0022netcoreapp3.0\u0022)\n                .SetNoBuild(true));\n        });\n}\n"
  },
  {
    "Id": 124952577,
    "FirstIndexed": "2020-04-25T15:50:44.7359867+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630482+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434667+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940386+02:00",
    "Name": "pwiz",
    "Owner": "ProteoWizard",
    "HtmlUrl": "https://github.com/ProteoWizard/pwiz",
    "Description": "The ProteoWizard Library is a set of software libraries and tools for rapid development of mass spectrometry and proteomic data analysis software. ",
    "Archived": false,
    "Stars": 75,
    "Watchers": 12,
    "BuildFilePath": "pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileUrl": "https://github.com/ProteoWizard/pwiz/blob/master/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileSize": 11032,
    "BuildFileContent": "\uFEFF/*\r\n * Original author: Don Marsh \u003Cdonmarsh .at. u.washington.edu\u003E,\r\n *                  MacCoss Lab, Department of Genome Sciences, UW\r\n *\r\n * Copyright 2013 University of Washington - Seattle, WA\r\n * \r\n * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Net;\r\nusing System.Windows.Forms;\r\n\r\nnamespace SkylineTester\r\n{\r\n    public class TabBuild : TabBase\r\n    {\r\n        public TabBuild()\r\n        {\r\n            MainWindow.LabelSpecifyPath.Text =\r\n                \u0022(Specify absolute path or relative path from {0} folder)\u0022.With(Path.GetFileName(MainWindow.RootDir));\r\n        }\r\n\r\n        public override void Enter()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n            MainWindow.DefaultButton = MainWindow.RunBuild;\r\n        }\r\n\r\n        public override bool Run()\r\n        {\r\n            if (!MainWindow.HasBuildPrerequisites)\r\n                return false;\r\n            var architectures = GetArchitectures();\r\n            if (architectures.Count == 0)\r\n            {\r\n                MessageBox.Show(\u0022Select 32 or 64 bit architecture (or both).\u0022);\r\n                return false;\r\n            }\r\n\r\n            StartLog(\u0022Build\u0022, MainWindow.DefaultLogFile, true);\r\n            CreateBuildCommands(\r\n                GetBranchUrl(),\r\n                MainWindow.GetBuildRoot(), \r\n                architectures, \r\n                MainWindow.NukeBuild.Checked, \r\n                MainWindow.UpdateBuild.Checked,\r\n                MainWindow.RunBuildVerificationTests.Checked);\r\n            MainWindow.RunCommands();\r\n            return true;\r\n        }\r\n\r\n        public override bool Stop(bool success)\r\n        {\r\n            if (success \u0026\u0026 MainWindow.StartSln.Checked \u0026\u0026 MainWindow.Devenv != null)\r\n            {\r\n                var buildRoot = MainWindow.GetBuildRoot();\r\n                var slnDirectory = Path.Combine(buildRoot, @\u0022pwiz_tools\\Skyline\u0022);\r\n                var process = new Process\r\n                {\r\n                    StartInfo =\r\n                    {\r\n                        FileName = Path.Combine(slnDirectory, \u0022Skyline.sln\u0022),\r\n                        WorkingDirectory = slnDirectory,\r\n                        UseShellExecute = true,\r\n                    }\r\n                };\r\n                process.Start();\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public override int Find(string text, int position)\r\n        {\r\n            return VerifyFind(text, position, \u0022Build\u0022);\r\n        }\r\n\r\n        public static List\u003Cint\u003E GetArchitectures()\r\n        {\r\n            var architectures = new List\u003Cint\u003E();\r\n            if (MainWindow.Build32.Checked)\r\n                architectures.Add(32);\r\n            if (MainWindow.Build64.Checked)\r\n                architectures.Add(64);\r\n            return architectures;\r\n        }\r\n\r\n        public static string GetMasterUrl()\r\n        {\r\n            return @\u0022https://github.com/ProteoWizard/pwiz\u0022;\r\n        }\r\n\r\n        public static string GetBranchUrl()\r\n        {\r\n            return MainWindow.BuildTrunk.Checked\r\n                ? GetMasterUrl()\r\n                : MainWindow.BranchUrl.Text;\r\n        }\r\n\r\n        public static bool CreateBuildCommands(\r\n            string branchUrl, \r\n            string buildRoot, \r\n            IList\u003Cint\u003E architectures, \r\n            bool nukeBuild, \r\n            bool updateBuild,\r\n            bool runBuildTests)\r\n        {\r\n            var commandShell = MainWindow.CommandShell;\r\n            var branchParts = branchUrl.Split(\u0027/\u0027);\r\n            var branchName = branchParts[branchParts.Length - 1].Equals(\u0022pwiz\u0022)\r\n                ? \u0022Skyline (master)\u0022\r\n                : \u0022Skyline ({0}/{1})\u0022.With(branchParts[branchParts.Length - 2], branchParts[branchParts.Length - 1]);\r\n            var git = MainWindow.Git;\r\n\r\n            // Determine toolset requirement based on .Net usage\r\n            // Pull a file like\r\n            // https://raw.githubusercontent.com/ProteoWizard/pwiz/master/pwiz_tools/Skyline/Skyline.csproj\r\n            // or\r\n            // https://raw.githubusercontent.com/ProteoWizard/pwiz/feature/VS2017-update/pwiz_tools/Skyline/Skyline.csproj\r\n            var toolset = \u0022msvc-14.1\u0022; // VS2017\r\n            for (var retry = 60; retry-- \u003E0;)\r\n            {\r\n                var csProjFileUrl = \u0022[unknown]\u0022;\r\n                try\r\n                {\r\n                     csProjFileUrl = GetMasterUrl().Equals(branchUrl)\r\n                        ? \u0022https://raw.githubusercontent.com/ProteoWizard/pwiz/master/pwiz_tools/Skyline/Skyline.csproj\u0022\r\n                        : \u0022https://raw.githubusercontent.com/ProteoWizard/pwiz/\u0022 \u002B GetBranchPath(branchUrl) \u002B \u0022/pwiz_tools/Skyline/Skyline.csproj\u0022;\r\n                    var csProjText = (new WebClient()).DownloadString(csProjFileUrl);\r\n                    var dotNetVersion = csProjText.Split(new[] {\u0022TargetFrameworkVersion\u0022}, StringSplitOptions.None)[1].Split(\u0027v\u0027)[1].Split(new []{\u0027.\u0027});\r\n                    if ((int.Parse(dotNetVersion[0]) \u003E= 4) \u0026\u0026 (int.Parse(dotNetVersion[1]) \u003E= 7))\r\n                    {\r\n                        toolset = \u0022msvc-14.1\u0022; // VS2017 for .Net 4.7.x or greater\r\n                    }\r\n                    break;\r\n                }\r\n                catch (Exception e)\r\n                {\r\n\r\n                    commandShell.AddImmediate(\u0022Trouble fetching {0} for .Net version inspection ({1})\u0022, csProjFileUrl, e.Message);\r\n                    if (retry == 0)\r\n                        throw;\r\n                    commandShell.AddImmediate(\u0022retrying...\u0022);\r\n                    commandShell.IsWaiting = true;\r\n                    // CONSIDER: Wait for up to 60 seconds while pumping messages for UI. Kind of a hack, but better than\r\n                    //           blocking the UI thread completely while trying.\r\n                    var watch = new Stopwatch();\r\n                    watch.Start();\r\n                    while (watch.Elapsed.TotalSeconds \u003C 60)\r\n                    {\r\n                        if (!commandShell.IsWaiting)\r\n                            return false;   // Cancelled\r\n                        Application.DoEvents();\r\n                    }\r\n                    commandShell.IsWaiting = false;\r\n                }\r\n            }\r\n\r\n            var architectureList = string.Join(\u0022- and \u0022, architectures);\r\n            commandShell.Add(\u0022# Build {0} {1}-bit...\u0022, branchName, architectureList);\r\n\r\n            if (Directory.Exists(buildRoot))\r\n            {\r\n                if (nukeBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Deleting Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Deleting Build directory...\u0022);\r\n                    commandShell.Add(\u0022rmdir /s {0}\u0022, buildRoot.Quote());\r\n                }\r\n                else if (updateBuild)\r\n                {\r\n                    commandShell.Add(\u0022#@ Updating Build directory...\\n\u0022);\r\n                    commandShell.Add(\u0022# Updating Build directory...\u0022);\r\n                    commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\r\n                    commandShell.Add(\u0022{0} pull\u0022, git.Quote());\r\n                }\r\n            }\r\n\r\n            if (nukeBuild)\r\n            {\r\n                commandShell.Add(\u0022#@ Checking out {0} source files...\\n\u0022, branchName);\r\n                commandShell.Add(\u0022# Checking out {0} source files...\u0022, branchName);\r\n                if (branchName.Contains(\u0022master\u0022))\r\n                {\r\n                    commandShell.Add(\u0022{0} clone {1} {2}\u0022, git.Quote(), branchUrl.Quote(), buildRoot.Quote());\r\n                }\r\n                else\r\n                {\r\n                    var branch = branchUrl.Split(new[] {\u0022tree/\u0022}, StringSplitOptions.None)[1];\r\n                    commandShell.Add(\u0022{0} clone {1} -b {2} {3}\u0022, git.Quote(), GetMasterUrl().Quote(), branch.Quote(), buildRoot.Quote());\r\n                }\r\n            }\r\n\r\n            commandShell.Add(\u0022# Building Skyline...\u0022);\r\n            commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\r\n            foreach (int architecture in architectures)\r\n            {\r\n                commandShell.Add(\u0022#@ Building Skyline {0} bit...\\n\u0022, architecture);\r\n                commandShell.Add(\u0022{0} {1} {2} --i-agree-to-the-vendor-licenses toolset={3} nolog\u0022,\r\n                    Path.Combine(buildRoot, @\u0022pwiz_tools\\build-apps.bat\u0022).Quote(),\r\n                    architecture,\r\n                    runBuildTests ? \u0022pwiz_tools/Skyline\u0022 : \u0022pwiz_tools/Skyline//Skyline.exe\u0022,\r\n                    toolset);\r\n            }\r\n\r\n            commandShell.Add(\u0022# Build done.\u0022);\r\n            return true;\r\n        }\r\n\r\n        private static string GetBranchPath(string branchUrl)\r\n        {\r\n            const string splitString = \u0022/pwiz/tree/\u0022;\r\n            var branchHalves = branchUrl.Split(new[] { splitString }, StringSplitOptions.None);\r\n            if (branchHalves.Length == 1)\r\n                throw new ArgumentException(string.Format(\u0022The branch URL {0} must contain the branch prefix {1}\u0022, branchUrl, splitString));\r\n            // Return the part after the split string\r\n            return branchHalves[1];\r\n        }\r\n\r\n        public void DeleteBuild()\r\n        {\r\n            var buildRoot = MainWindow.GetBuildRoot();\r\n            if (!Directory.Exists(buildRoot) ||\r\n                MessageBox.Show(MainWindow, \u0022Delete \\\u0022\u0022 \u002B buildRoot \u002B \u0022\\\u0022 folder?\u0022, \u0022Confirm delete\u0022,\r\n                    MessageBoxButtons.OKCancel) != DialogResult.OK)\r\n            {\r\n                return;\r\n            }\r\n\r\n            using (var deleteWindow = new DeleteWindow(buildRoot))\r\n            {\r\n                deleteWindow.ShowDialog();\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\r\n        }\r\n\r\n        public void BrowseBuild()\r\n        {\r\n            using (var dlg = new FolderBrowserDialog\r\n            {\r\n                Description = \u0022Select or create a root folder for build source files.\u0022,\r\n                ShowNewFolderButton = true\r\n            })\r\n            {\r\n                if (dlg.ShowDialog(MainWindow) == DialogResult.OK)\r\n                    MainWindow.BuildRoot.Text = dlg.SelectedPath;\r\n            }\r\n\r\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(MainWindow.GetBuildRoot()); // MainWindow.GetBuildRoot() is the directory that actually gets deleted in DeleteBuild()\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 125592389,
    "FirstIndexed": "2020-04-25T15:47:03.6114327+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631323+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430964+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936841+02:00",
    "Name": "CaptureRenderTagHelper",
    "Owner": "BerserkerDotNet",
    "HtmlUrl": "https://github.com/BerserkerDotNet/CaptureRenderTagHelper",
    "Description": "A set of Tag Helpers that can capture a script block and render it later in another place.",
    "Archived": false,
    "Stars": 2,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BerserkerDotNet/CaptureRenderTagHelper/blob/master/build/Build.cs",
    "BuildFileSize": 3022,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022ApiKey for the specified source\u0022)]\n    readonly string ApiKey;\n\n    [Parameter] \n    readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022CaptureRenderTagHelper.UnitTests\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022CaptureRenderTagHelper\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .EnableIncludeSource()\n                .EnableIncludeSymbols()\n                .SetOutputDirectory(ArtifactsDirectory));\n        });\n}\n"
  },
  {
    "Id": 125635095,
    "FirstIndexed": "2020-04-25T15:50:44.7355925+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630635+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434053+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939811+02:00",
    "Name": "angular-material-shared",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/angular-material-shared",
    "Description": "Shared components to be used in Angular Material apps",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/angular-material-shared/blob/develop/build/Build.cs",
    "BuildFileSize": 5193,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing System.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing Nuke.Azure.KeyVault;\nusing System.Linq;\nusing Nuke.GitHub;\nusing System;\nusing Nuke.Common.ProjectModel;\nusing System.Threading.Tasks;\nusing Nuke.Common.Utilities.Collections;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Clean);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [KeyVaultSecret] string GitHubAuthenticationToken;\n\n    [Solution(\u0022angular-material-shared.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n    AbsolutePath TinyMceLanguagesDirectory =\u003E NgAppDir / \u0022dist\u0022 / \u0022angular-material-shared\u0022 / \u0022tinymce-langs\u0022;\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                GlobDirectories(SourceDirectory, \u0022angular-material-shared-demo/dist\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(OutputDirectory);\n                EnsureCleanDirectory(TinyMceLanguagesDirectory);\n            });\n\n    AbsolutePath NgAppDir =\u003E SourceDirectory / \u0022angular-material-shared-demo\u0022;\n\n    private async Task CopyTinyMceLanguagesToDestination()\n    {\n        EnsureCleanDirectory(TinyMceLanguagesDirectory);\n        var languageFiles = GlobFiles(NgAppDir / \u0022node_modules\u0022 / \u0022tinymce-i18n\u0022 / \u0022langs5\u0022, \u0022*.js\u0022).NotEmpty();\n        foreach (var languageFile in languageFiles)\n        {\n            var fileName = Path.GetFileName(languageFile);\n            var destinationPath = Path.Combine(TinyMceLanguagesDirectory, fileName);\n            using (var sourceStream = File.OpenRead(languageFile))\n            {\n                using (var destinationFileStream = System.IO.File.Create(destinationPath))\n                {\n                    await sourceStream.CopyToAsync(destinationFileStream);\n                }\n            }\n        }\n    }\n\n    Target NgLibraryBuild =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(async () =\u003E\n        {\n            if (IsLocalBuild)\n            {\n                Npm(\u0022i\u0022, NgAppDir);\n            }\n            else\n            {\n                Npm(\u0022ci\u0022, NgAppDir);\n            }\n            Npm(\u0022run build:library\u0022, NgAppDir);\n            Npm($\u0022version {GitVersion.NuGetVersion}\u0022, NgAppDir / \u0022dist\u0022 / \u0022angular-material-shared\u0022);\n            await CopyTinyMceLanguagesToDestination();\n\n            var srcReadmePath = SolutionDirectory / \u0022README.md\u0022;\n            var destReadmePath = NgAppDir / \u0022dist\u0022 / \u0022angular-material-shared\u0022 / \u0022README.md\u0022;\n            if (File.Exists(destReadmePath))\n            {\n                File.Delete(destReadmePath);\n            }\n            File.Copy(srcReadmePath, destReadmePath);\n        });\n\n    Target NgLibraryTest =\u003E _ =\u003E _\n        .DependsOn(NgLibraryBuild)\n        .Executes(() =\u003E\n        {\n            Npm(\u0022run test:ci\u0022, NgAppDir);\n        });\n\n    Target NgLibraryPublish =\u003E _ =\u003E _\n        .DependsOn(NgLibraryBuild)\n        .Executes(() =\u003E\n        {\n            var npmTag = GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022)\n            ? \u0022latest\u0022\n            : \u0022next\u0022;\n            Npm($\u0022publish --access=public --tag={npmTag}\u0022, NgAppDir / \u0022dist\u0022 / \u0022angular-material-shared\u0022);\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            await PublishRelease(x =\u003E x\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken));\n        });\n}\n"
  },
  {
    "Id": 125648470,
    "FirstIndexed": "2020-04-25T15:50:44.7360185+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163076+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434707+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940425+02:00",
    "Name": "resharper",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/resharper",
    "Description": "Rider and ReSharper extension",
    "Archived": false,
    "Stars": 6,
    "Watchers": 2,
    "BuildFilePath": "src/dotnet/ReSharper.Nuke/Extensions.cs",
    "BuildFileUrl": "https://github.com/nuke-build/resharper/blob/master/src/dotnet/ReSharper.Nuke/Extensions.cs",
    "BuildFileSize": 9346,
    "BuildFileContent": "// Copyright 2019 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/resharper/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing JetBrains.Annotations;\nusing JetBrains.Application.Progress;\nusing JetBrains.ProjectModel;\nusing JetBrains.ReSharper.Psi;\nusing JetBrains.ReSharper.Psi.CSharp.Tree;\nusing JetBrains.ReSharper.Psi.Modules;\nusing JetBrains.ReSharper.Psi.Resolve;\nusing JetBrains.ReSharper.Psi.Search;\nusing JetBrains.ReSharper.Psi.Tree;\nusing JetBrains.Util.Reflection;\nusing Nuke.Common;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities;\n#if RIDER\nusing ReSharper.Nuke.Rider;\n\n#endif\n\nnamespace ReSharper.Nuke\n{\n    public static class Extensions\n    {\n        private static readonly string s_commonAssemblyName = typeof(NukeBuild).Assembly.GetName().Name.NotNull();\n        private static readonly string s_nukeBuildType = typeof(NukeBuild).FullName.NotNull();\n        private static readonly string s_targetType = typeof(Target).FullName.NotNull();\n        private static readonly string s_parameterAttributeType = typeof(ParameterAttribute).FullName.NotNull();\n\n        public static IEnumerable\u003CIClass\u003E FindNukeBuildClasses(this IFinder finder, params IPsiModule[] modules)\n        {\n            var nukeBuildClasses = new List\u003CIClass\u003E();\n\n            using (CompilationContextCookie.GetExplicitUniversalContextIfNotSet())\n            {\n                foreach (var module in modules)\n                {\n                    var nukeBuildDeclaredType = TypeFactory.CreateTypeByCLRName(s_nukeBuildType, module).GetTypeElement();\n                    if (nukeBuildDeclaredType == null)\n                        continue;\n\n                    finder.FindInheritors(\n                        nukeBuildDeclaredType,\n                        new FindResultConsumer(x =\u003E\n                        {\n                            var clazz = (x as FindResultDeclaredElement)?.DeclaredElement as IClass;\n                            if (clazz == null)\n                                return FindExecution.Continue;\n\n                            if (clazz.GetDeclarations().FirstOrDefault()?.GetProject()?.Name.EndsWith(\u0022Tests\u0022) ?? true)\n                                return FindExecution.Continue;\n\n                            nukeBuildClasses.Add(clazz);\n\n                            return FindExecution.Continue;\n                        }),\n                        NullProgressIndicator.Create());\n                }\n            }\n\n            return nukeBuildClasses;\n        }\n\n        public static bool IsNukeProject(this IProject project)\n        {\n            return ReferencedAssembliesService.IsProjectReferencingAssemblyByName(\n                project,\n                project.GetCurrentTargetFrameworkId(),\n                AssemblyNameInfoFactory.Create2(s_commonAssemblyName, version: null),\n                out _);\n\n            // var packages = nugetPackageReferenceTracker.GetInstalledPackages(project);\n            // return packages.Any(x =\u003E x.PackageIdentity.Id == \u0022Nuke.Common\u0022);\n        }\n\n        public static bool IsNukeClass(this ITypeElement clazz)\n        {\n            var nukeBuildDeclaredType = TypeFactory.CreateTypeByCLRName(s_nukeBuildType, clazz.Module).GetTypeElement();\n            return clazz.IsDescendantOf(nukeBuildDeclaredType);\n            // return clazz.GetAllSuperClasses().Any(x =\u003E x.GetClrName().FullName == \u0022Nuke.Common.NukeBuild\u0022);\n        }\n\n        public static NukeTarget GetNukeTarget(this ITypeMember member)\n        {\n            var targetDeclaredType = TypeFactory.CreateTypeByCLRName(s_targetType, member.Module);\n            var targetProperty = member as IProperty;\n            if (!targetProperty?.Type.Equals(targetDeclaredType) ?? true)\n                return null;\n\n            var declaration = targetProperty.GetDeclarations().FirstOrDefault() as IPropertyDeclaration;\n            var lambdaExpression = declaration?.ArrowClause.Expression as ILambdaExpression;\n            var invocationExpression = lambdaExpression?.BodyExpression as IInvocationExpression;\n\n            var lookupTable = new LookupTable\u003Cstring, string\u003E();\n            var description = default(string);\n            while (invocationExpression != null)\n            {\n                var invokedExpression = invocationExpression.InvokedExpression as IReferenceExpression;\n                var invokedMethodName = invokedExpression?.NameIdentifier.Name;\n\n                if (new[]\n                    {\n                        nameof(ITargetDefinition.DependsOn),\n                        nameof(ITargetDefinition.DependentFor),\n                        nameof(ITargetDefinition.Before),\n                        nameof(ITargetDefinition.After),\n                        nameof(ITargetDefinition.Triggers),\n                        nameof(ITargetDefinition.TriggeredBy)\n                    }.Contains(invokedMethodName))\n                {\n                    var referencedSymbols = invocationExpression.Arguments\n                        .Select(x =\u003E x.Expression)\n                        .OfType\u003CIReferenceExpression\u003E()\n                        .Where(x =\u003E x.Reference.Resolve().ResolveErrorType == ResolveErrorType.OK)\n                        .Select(x =\u003E x.NameIdentifier.Name).ToList();\n                    lookupTable.AddRange(invokedMethodName, referencedSymbols);\n                }\n                else if (invokedMethodName == nameof(ITargetDefinition.Description))\n                {\n                    var descriptionArgument = invocationExpression.Arguments\n                        .Select(x =\u003E x.Expression)\n                        .OfType\u003CILiteralExpression\u003E()\n                        .SingleOrDefault();\n\n                    if (descriptionArgument != null \u0026\u0026 descriptionArgument.IsConstantValue())\n                        description = descriptionArgument.ConstantValue.Value?.ToString();\n                }\n\n                invocationExpression = invokedExpression?.QualifierExpression as IInvocationExpression;\n            }\n\n            return new NukeTarget(\n                member.ShortName,\n                description,\n                lookupTable[nameof(ITargetDefinition.DependsOn)].ToArray(),\n                lookupTable[nameof(ITargetDefinition.DependentFor)].ToArray(),\n                lookupTable[nameof(ITargetDefinition.Before)].ToArray(),\n                lookupTable[nameof(ITargetDefinition.After)].ToArray(),\n                lookupTable[nameof(ITargetDefinition.Triggers)].ToArray(),\n                lookupTable[nameof(ITargetDefinition.TriggeredBy)].ToArray());\n        }\n\n        [CanBeNull]\n        public static NukeParameter GetNukeParameter(this ITypeMember member)\n        {\n            var parameterAttributeDeclaredType = TypeFactory.CreateTypeByCLRName(s_parameterAttributeType, member.Module);\n            // TODO: check derived types from ParameterAttribute\n            var attribute = member.GetAttributeInstances(parameterAttributeDeclaredType.GetClrName(), inherit: true).SingleOrDefault();\n            if (attribute == null)\n                return null;\n\n            var (_, attributeNameValue) = attribute.NamedParameters().SingleOrDefault(x =\u003E x.First == nameof(ParameterAttribute.Name));\n            var name = attributeNameValue != null \u0026\u0026 attributeNameValue.IsConstant\n                ? attributeNameValue.ConstantValue.Value?.ToString() ?? member.ShortName\n                : member.ShortName;\n\n            var descriptionValue = attribute.PositionParameters().FirstOrDefault();\n            var description = descriptionValue != null \u0026\u0026 descriptionValue.IsConstant\n                ? descriptionValue.ConstantValue.Value?.ToString()\n                : null;\n\n            var declaration = member.GetDeclarations().FirstOrDefault() as IInitializerOwnerDeclaration;\n            var defaultValue = declaration?.Initializer?.GetText().TrimMatchingDoubleQuotes();\n\n            return new NukeParameter(name, description, defaultValue);\n        }\n    }\n\n#if RESHARPER\n    public class NukeParameter\n    {\n        public NukeParameter(string name, string description, string defaultValue)\n        {\n            Name = name;\n            Description = description;\n            DefaultValue = defaultValue;\n        }\n\n        public string Name { get; }\n        public string Description { get; }\n        public string DefaultValue { get; }\n    }\n\n    public class NukeTarget\n    {\n        public NukeTarget(\n            string name,\n            string description,\n            string[] dependsOn,\n            string[] dependentFor,\n            string[] before,\n            string[] after,\n            string[] triggers,\n            string[] triggeredBy)\n        {\n            Name = name;\n            Description = description;\n            DependsOn = dependsOn;\n            DependentFor = dependentFor;\n            Before = before;\n            After = after;\n            Triggers = triggers;\n            TriggeredBy = triggeredBy;\n        }\n\n        public string Name { get; }\n        public string Description { get; }\n        public string[] DependsOn { get; }\n        public string[] DependentFor { get; }\n        public string[] Before { get; }\n        public string[] After { get; }\n        public string[] Triggers { get; }\n        public string[] TriggeredBy { get; }\n    }\n#endif\n}"
  },
  {
    "Id": 125862912,
    "FirstIndexed": "2020-04-25T15:50:44.7356153+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626937+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434155+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939902+02:00",
    "Name": "DateTimeExtension",
    "Owner": "johanssonm",
    "HtmlUrl": "https://github.com/johanssonm/DateTimeExtension",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/johanssonm/DateTimeExtension/blob/master/build/Build.cs",
    "BuildFileSize": 2310,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Core;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.EnvironmentInfo;\nusing System.IO;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Core.BuildServers;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    // Auto-injection fields:\n    // [GitVersion] readonly GitVersion GitVersion;\n    //  - Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n    // [GitRepository] readonly GitRepository GitRepository;\n    //  - Parses origin, branch name and head from git config.\n    // [Parameter] readonly string MyGetApiKey;\n    //  - Returns command-line arguments and environment variables.\n\n    public bool IsTagged =\u003E AppVeyor.Instance?.RepositoryTag ?? false;\n\n    int Revision =\u003E AppVeyor.Instance?.BuildNumber ?? 1;\n\n    public string RevisionString =\u003E IsTagged ? null : $\u0022rev{Revision:D4}\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                EnsureCleanDirectory(OutputDirectory);\n                EnsureCleanDirectory(ArtifactsDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(s =\u003E DefaultDotNetRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E DefaultDotNetBuild\n                    .SetVersionSuffix(RevisionString));\n            });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E DefaultDotNetPack\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetProject(RootDirectory / \u0022src\u0022 / \u0022DateTimeExtensions\u0022)\n                .SetVersionSuffix(RevisionString));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(RootDirectory / \u0022tests\u0022 / \u0022DateTimeExtensions.Tests\u0022));\n        });\n}\n"
  },
  {
    "Id": 128427335,
    "FirstIndexed": "2020-04-25T15:50:44.735613+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630885+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434144+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939896+02:00",
    "Name": "nchinese",
    "Owner": "huanlin",
    "HtmlUrl": "https://github.com/huanlin/nchinese",
    "Description": "C# library for handling Chinese characters.",
    "Archived": false,
    "Stars": 15,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/huanlin/nchinese/blob/master/build/Build.cs",
    "BuildFileSize": 2162,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022src/NChinese.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols());\n        });\n}\n"
  },
  {
    "Id": 128933475,
    "FirstIndexed": "2020-04-25T15:50:44.7355038+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163245+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433694+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939464+02:00",
    "Name": "nuke-docker",
    "Owner": "arodus",
    "HtmlUrl": "https://github.com/arodus/nuke-docker",
    "Description": "Docker CLI addon",
    "Archived": false,
    "Stars": 7,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/arodus/nuke-docker/blob/master/build/Build.cs",
    "BuildFileSize": 6915,
    "BuildFileContent": "// Copyright 2018 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/nuke/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Octokit;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.GitHub.GitHubTasks;\n\n// ReSharper disable HeapView.DelegateAllocation\n\npartial class Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] readonly string SymbolSource = \u0022https://nuget.smbsrc.net/\u0022;\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter] readonly string GitHubToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    // [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly string SemanticVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    IEnumerable\u003Cstring\u003E SpecificationFiles =\u003E GlobFiles(SourceDirectory, \u0022*/*.json\u0022);\n\n    Target Generate =\u003E _ =\u003E _\n        .OnlyWhenDynamic(() =\u003E SpecificationFiles.Any())\n        .Executes(() =\u003E\n        {\n            string GetNamespace(string specificationFile)\n                =\u003E Solution.Projects.Single(x =\u003E IsDescendantPath(x.Directory, specificationFile)).Name;\n\n            GenerateCode(\n                SpecificationFiles.ToList(),\n                outputFileProvider: x =\u003E x.DefaultOutputFile,\n                namespaceProvider: x =\u003E GetNamespace(x.SpecificationFile),\n                sourceFileProvider: x =\u003E GitRepository.GetGitHubBrowseUrl(x.SpecificationFile));\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, Generate)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    IEnumerable\u003CNuke.Common.ProjectModel.Project\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E TestProjects.Any())\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(OutputDirectory)\n                .CombineWith(\n                    TestProjects, (cs, v) =\u003E cs\n                        .SetProjectFile(v)));\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Changelog =\u003E _ =\u003E _\n        .After(Test)\n        .Before(Pack)\n        .OnlyWhenDynamic(() =\u003E\n            GitRepository.IsOnMasterBranch() ||\n            GitRepository.IsOnReleaseBranch() ||\n            GitRepository.IsOnHotfixBranch())\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, SemanticVersion, GitRepository);\n            Git($\u0022add {ChangelogFile}\u0022);\n            Git($\u0022commit -m \\\u0022Finalize {Path.GetFileName(ChangelogFile)} for v{SemanticVersion}\\\u0022\u0022);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(SemanticVersion)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Changelog)\n        .DependsOn(Pack)\n        .Requires(() =\u003E SemanticVersion)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(async () =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetSource(Source)\n                    .SetSymbolSource(SymbolSource)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(\n                        OutputDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E cs\n                            .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n\n            Git($\u0022tag {SemanticVersion}\u0022);\n            Git($\u0022push origin {GitRepository.Branch} {SemanticVersion}\u0022);\n\n            return;\n\n            await PublishRelease(s =\u003E s\n                .SetToken(GitHubToken)\n                .SetRepositoryOwner(GitRepository.GetGitHubOwner())\n                .SetRepositoryName(GitRepository.GetGitHubName())\n                .SetCommitSha(GitRepository.Branch)\n                .SetTag($\u0022{SemanticVersion}\u0022)\n                .SetName($\u0022v{SemanticVersion}\u0022)\n                .SetReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    bool GitHubMilestoneClosed(bool mustExist) =\u003E GetMilestone().Result?.State.Value == ItemState.Closed;\n\n    async Task\u003CMilestone\u003E GetMilestone()\n    {\n        var client = new GitHubClient(new ProductHeaderValue(nameof(NukeBuild))) { Credentials = new Credentials(GitHubToken) };\n        var milestones = await client.Issue.Milestone.GetAllForRepository(\n            GitRepository.GetGitHubOwner(),\n            GitRepository.GetGitHubName());\n        return milestones.FirstOrDefault(x =\u003E x.Title == $\u0022v{SemanticVersion}\u0022);\n    }\n}\n"
  },
  {
    "Id": 129320134,
    "FirstIndexed": "2020-04-25T15:50:44.7356107+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626908+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434132+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939885+02:00",
    "Name": "Genderize.Net",
    "Owner": "joaomatossilva",
    "HtmlUrl": "https://github.com/joaomatossilva/Genderize.Net",
    "Description": "A client wrapper for the genderize.io API",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/joaomatossilva/Genderize.Net/blob/master/build/Build.cs",
    "BuildFileSize": 2282,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Core;\nusing Nuke.Core.BuildServers;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.EnvironmentInfo;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    public bool IsTagged =\u003E AppVeyor.Instance?.RepositoryTag ?? false;\n\n    int Revision =\u003E AppVeyor.Instance?.BuildNumber ?? 1;\n\n    public string RevisionString =\u003E IsTagged ? null : $\u0022rev{Revision:D4}\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .OnlyWhen(() =\u003E false) // Disabled for safety.\n            .Executes(() =\u003E\n            {\n                DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(s =\u003E DefaultDotNetRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E DefaultDotNetBuild);\n            });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E DefaultDotNetPack\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetProject(RootDirectory / \u0022src\u0022 / \u0022Genderize\u0022)\n                .SetVersionSuffix(RevisionString));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(RootDirectory / \u0022tests\u0022 / \u0022Genderize.Tests\u0022));\n        });\n}\n"
  },
  {
    "Id": 130168612,
    "FirstIndexed": "2020-04-25T15:50:44.7358809+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629486+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434576+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940295+02:00",
    "Name": "vlingo-net-platform",
    "Owner": "vlingo-net",
    "HtmlUrl": "https://github.com/vlingo-net/vlingo-net-platform",
    "Description": "Provides vlingo/platform for .NET central \u0022build all\u0022 and other control.",
    "Archived": false,
    "Stars": 4,
    "Watchers": 4,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/vlingo-net/vlingo-net-platform/blob/master/build/Build.cs",
    "BuildFileSize": 2259,
    "BuildFileContent": "// Copyright (c) 2012-2020 VLINGO LABS. All rights reserved.\n//\n// This Source Code Form is subject to the terms of the\n// Mozilla Public License, v. 2.0. If a copy of the MPL\n// was not distributed with this file, You can obtain\n// one at https://mozilla.org/MPL/2.0/.\n\nusing System.Linq;\nusing System.Threading;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Logger;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n        });\n\n        public const string ALL_IN_ONE_SLN = \u0022Vlingo.Platform\u0022;\n        public virtual Target CreateAllInOneSolution =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                var allInOneSln = RootDirectory / (ALL_IN_ONE_SLN \u002B \u0022.sln\u0022);\n                if (FileExists(allInOneSln))\n                    DeleteFile(allInOneSln);\n                DotNet($\u0022new sln --name {ALL_IN_ONE_SLN}\u0022);\n                var projects = GlobFiles(RootDirectory, $\u0022**/*.csproj\u0022).NotEmpty().OrderBy(p =\u003E p);\n                var count = 1;\n                foreach (var proj in projects)\n                {\n                    Info($\u0022Adding project #{count\u002B\u002B} : {proj}\u0022);\n                    DotNet($\u0022sln {allInOneSln} add \\\u0022{proj}\\\u0022\u0022);\n                    Thread.Sleep(200);\n                }\n            });\n\n\n\n}\n"
  },
  {
    "Id": 131514789,
    "FirstIndexed": "2020-04-25T15:50:44.7354548+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631153+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433484+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939265+02:00",
    "Name": "Singularity",
    "Owner": "Barsonax",
    "HtmlUrl": "https://github.com/Barsonax/Singularity",
    "Description": "A extremely fast ioc container for high performance applications",
    "Archived": false,
    "Stars": 46,
    "Watchers": 2,
    "BuildFilePath": "_build/Build.cs",
    "BuildFileUrl": "https://github.com/Barsonax/Singularity/blob/master/_build/Build.cs",
    "BuildFileSize": 9005,
    "BuildFileContent": "using System.Collections.Generic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.SonarScanner;\nusing Nuke.Common.Utilities;\nusing Nuke.DocFX;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.SonarScanner.SonarScannerTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing System;\nusing System.Threading.Tasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string ApiKey;\n    [Parameter] readonly bool CoberturaReport;\n\n    [Solution(\u0022src/Singularity.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly AbsolutePath BaseBuildOutput = RootDirectory / \u0022BuildOutput\u0022;\n    AbsolutePath BuildOutput =\u003E BaseBuildOutput / Configuration;\n\n    [Parameter]\n    readonly string SonarCloudLogin;\n\n    AbsolutePath CoverageDirectory =\u003E RootDirectory / \u0022coverage\u0022;\n    AbsolutePath CoverageXml =\u003E CoverageDirectory / \u0022coverage.xml\u0022;\n    AbsolutePath CoverageHtml =\u003E CoverageDirectory / \u0022coverage.html\u0022;\n    AbsolutePath CoberturaReportPath =\u003E CoverageDirectory / \u0022Cobertura.xml\u0022;\n\n    AbsolutePath SrcPath =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath DocFXPath =\u003E SrcPath / \u0022Docs\u0022;\n    AbsolutePath DocFxOutput =\u003E DocFXPath / \u0022_site\u0022;\n    AbsolutePath DocFXJson =\u003E DocFXPath / \u0022docfx.json\u0022;\n    AbsolutePath DocsRepository =\u003E DocFXPath / \u0022repository\u0022;\n    AbsolutePath DocsRepositoryFolder =\u003E DocsRepository / \u0022docs\u0022;\n\n    [PathExecutable]\n    private static Tool Git;\n\n    [PathExecutable]\n    private static Tool Dotnet;\n\n    [PackageExecutable(\u0022dotnet-sonarscanner\u0022, @\u0022tools\\netcoreapp2.1\\any\\SonarScanner.MSBuild.dll\u0022)]\n    private static Tool SonarScanner;\n\n    private Dictionary\u003Cstring, object\u003E NoWarns = new Dictionary\u003Cstring, object\u003E { { \u0022NoWarn\u0022, \u0022NU1701\u0022 }, };\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(BuildOutput);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperties(NoWarns));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetProperties(NoWarns)\n                .SetProperty(\u0022BaseOutputPath\u0022, BaseBuildOutput \u002B \u0022/\u0022)\n                .SetProperty(\u0022GeneratePackageOnBuild\u0022, true)\n                .SetVersion(GitVersion.NuGetVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n            .SetOutput(BuildOutput / \u0022netcoreapp3.0\u0022)\n            .SetWorkingDirectory(SrcPath)\n            .SetFramework(\u0022netcoreapp3.0\u0022)\n            .SetConfiguration(Configuration)\n            .SetProperties(NoWarns)\n            .EnableNoBuild());\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n    {\n        string testdlls = GlobFiles(BuildOutput / \u0022netcoreapp3.0\u0022, \u0022*.Test.dll\u0022).Join(\u0022 \u0022);\n        string targetArgs = $\u0022vstest {testdlls} /logger:trx;LogFileName=testresults.trx\u0022;\n        string dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n        AbsolutePath coverageSnapshot = CoverageDirectory / \u0022coverage.dcvr\u0022;\n        AbsolutePath coverageReport = CoverageDirectory / \u0022CoverageReport\u0022;\n\n        DotCoverCover(c =\u003E c\n             .SetTargetExecutable(dotnetPath)\n             .SetTargetWorkingDirectory(RootDirectory)\n             .SetTargetArguments(targetArgs)\n             .SetFilters(\u0022\u002B:Singularity*;-:Class=Singularity.FastExpressionCompiler*;-:*Test*;-:*Example*;-:*Benchmark*\u0022)\n             .SetOutputFile(coverageSnapshot));\n\n        DotCoverReport(c =\u003E c\n            .SetSource(coverageSnapshot)\n            .SetOutputFile(CoverageXml)\n            .SetReportType(DotCoverReportType.DetailedXml));\n\n        DotCoverReport(c =\u003E c\n            .SetSource(coverageSnapshot)\n            .SetOutputFile(CoverageHtml)\n            .SetReportType(DotCoverReportType.Html));\n\n        if (CoberturaReport)\n        {\n            ReportGenerator(c =\u003E c\n                .SetReports(CoverageXml)\n                .SetTargetDirectory(CoverageDirectory)\n                .SetReportTypes(Nuke.Common.Tools.ReportGenerator.ReportTypes.Cobertura));\n        }\n    });\n\n    Target RunSonarScanner =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(SonarCloudLogin))\n        .Before(Compile)\n        .Triggers(SonarEnd)\n        .Executes(() =\u003E\n        {\n            var server = \u0022https://sonarcloud.io\u0022;\n            var projectKey = \u0022Barsonax_Singularity\u0022;\n            var organisation = \u0022barsonax-github\u0022;\n            var exclusions = \u0022src/Singularity/FastExpressionCompiler/*,src/Tests/Singularity.TestClasses/**/*,src/Examples/**/*\u0022;\n            var branch = GitVersion.BranchName;\n            var version = GitVersion.AssemblySemVer;\n            SonarScanner($\u0022begin /k:{projectKey} /o:{organisation} /v:{version} /d:sonar.login={SonarCloudLogin} /d:sonar.host.url={server} /d:sonar.exclusions={exclusions} /d:sonar.cs.dotcover.reportsPaths={CoverageHtml} /d:sonar.branch.name={branch}\u0022);\n        });\n\n    Target SonarEnd =\u003E _ =\u003E _\n    .After(RunSonarScanner, Test, Coverage, Compile)\n        .Executes(() =\u003E\n        {\n            SonarScannerEnd(s =\u003E s\n            .SetLogin(SonarCloudLogin));\n        });\n\n\n    Target Push =\u003E _ =\u003E _\n        .Requires(() =\u003E !string.IsNullOrEmpty(ApiKey))\n        .After(Test, Coverage, Compile)\n        .Executes(() =\u003E\n        {\n            var source = \u0022https://api.nuget.org/v3/index.json\u0022;\n            Parallel.ForEach(BuildOutput.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (nupkgFile) =\u003E\n            {\n                var errorIsWarning = false;\n                try\n                {\n                    Dotnet.Invoke($\u0022nuget push {nupkgFile} --source {source} --api-key {ApiKey}\u0022, customLogger: (type, output) =\u003E\n                    {\n                        if (output.StartsWith(\u0022error: Response status code does not indicate success: 409\u0022))\n                        {\n                            errorIsWarning = true;\n                            Nuke.Common.Logger.Log(LogLevel.Warning, $\u0022Ignoring {output}\u0022);\n                        }\n                        else\n                        {\n                            ProcessTasks.DefaultLogger(type, output);\n                        }\n                    });\n                }\n                catch (System.Exception e)\n                {\n                    if (errorIsWarning)\n                    {\n                        Logger.Warn(e.Message);\n                    }\n                    else\n                    {\n                        throw e;\n                    }\n                }\n            });\n        });\n\n    Target BuildDocs =\u003E _ =\u003E _\n    .Executes(() =\u003E\n    {\n        DocFXMetadata(s =\u003E s.SetProjects(DocFXJson).SetMSBuildProperty(\u0022SolutionDir\u0022, $\u0022{Solution.Directory}/\u0022));\n        DocFXBuild(s =\u003E s.SetConfigFile(DocFXJson));\n    });\n\n    Target PushDocs =\u003E _ =\u003E _\n        .DependsOn(BuildDocs)\n        .OnlyWhenDynamic(() =\u003E GitRepository.Branch == \u0022master\u0022)\n        .Executes(() =\u003E\n    {\n        EnsureCleanDirectory(DocsRepository);\n        Git($\u0022clone https://github.com/Barsonax/Singularity.Docs {DocsRepository}\u0022);\n        EnsureCleanDirectory(DocsRepositoryFolder);\n        CopyDirectoryRecursively(DocFxOutput, DocsRepositoryFolder, DirectoryExistsPolicy.Merge);\n        System.IO.Directory.SetCurrentDirectory(DocsRepository);\n        try\n        {\n            Git(\u0022add docs\u0022);\n            IgnoreError(() =\u003E Git(\u0022commit -m nuke_build_generated_commit\u0022));\n            Git(\u0022push\u0022);\n        }\n        finally\n        {\n            System.IO.Directory.SetCurrentDirectory(RootDirectory);\n        }\n    });\n\n    private void IgnoreError(Action action)\n    {\n        try\n        {\n            action.Invoke();\n        }\n        catch (System.Exception e)\n        {\n            Nuke.Common.Logger.Log(LogLevel.Warning, $\u0022Ignored error {e.Message}\u0022);\n        }\n    }\n}"
  },
  {
    "Id": 132164390,
    "FirstIndexed": "2020-04-25T15:47:03.6114651+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624809+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430969+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936853+02:00",
    "Name": "LucidCode",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/LucidCode",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/LucidCode/blob/master/build/Build.cs",
    "BuildFileSize": 253,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 132750816,
    "FirstIndexed": "2020-04-25T15:50:44.7356084+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631875+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434121+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939874+02:00",
    "Name": "nuke-azure",
    "Owner": "arodus",
    "HtmlUrl": "https://github.com/arodus/nuke-azure",
    "Description": "Azure CLI addon",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/arodus/nuke-azure/blob/master/build/Build.cs",
    "BuildFileSize": 17941,
    "BuildFileContent": "\uFEFF// Copyright Sebastian Karasek, Matthias Koch 2018.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/azure/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Nuke.Azure.Generator;\nusing Nuke.CodeGeneration;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.OpenCover;\nusing Nuke.Common.Tools.Xunit;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Octokit;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.OpenCover.OpenCoverTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static RegenerateTasks;\nusing static Nuke.GitHub.GitHubTasks;\n\nclass Build : NukeBuild\n{\n\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n\tconst string c_addonRepoOwner = \u0022nuke-build\u0022;\n\tconst string c_addonRepoName = \u0022azure\u0022;\n\tconst string c_addonName = \u0022Azure CLI\u0022;\n\tconst string c_azureRepoOwner = \u0022Azure\u0022;\n\tconst string c_azureCliRepo = \u0022azure-cli\u0022;\n\tconst string c_azureCliDocsRepo = \u0022azure-docs-cli-python\u0022;\n\tconst string c_documentationBranch = \u0022live\u0022;\n\tconst string c_toolNamespace = \u0022Nuke.Azure\u0022;\n\tconst string c_azureCliDocsRepository = \u0022https://github.com/\u0022 \u002B c_azureRepoOwner \u002B \u0022/\u0022 \u002B c_azureCliDocsRepo \u002B \u0022.git\u0022;\n\n\tpublic Build()\n\t{\n\t\tLatestCliReleases = new Lazy\u003CIReadOnlyList\u003CRelease\u003E\u003E(() =\u003E\n\t\t\tGetReleases(x =\u003E x.SetRepositoryName(c_azureCliRepo)\n\t\t\t\t\t.SetRepositoryOwner(c_azureRepoOwner)\n\t\t\t\t\t.SetToken(GitHubApiKey), numberOfReleases: 10)\n\t\t\t\t.GetAwaiter().GetResult()\n\t\t\t\t.Where(x =\u003E !x.Prerelease \u0026\u0026 x.TagName.StartsWith(\u0022azure-cli\u0022))\n\t\t\t\t.ToArray());\n\t}\n\n\treadonly Lazy\u003CIReadOnlyList\u003CRelease\u003E\u003E LatestCliReleases;\n\n\t[GitVersion] readonly GitVersion GitVersion;\n\t[GitRepository] readonly GitRepository GitRepository;\n\t[Solution] readonly Solution Solution;\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Parameter(\u0022Api key to push packages to nuget.org.\u0022)] readonly string NugetApiKey;\n\t[Parameter(\u0022Api key to access the github.\u0022)] readonly string GitHubApiKey;\n\tAbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\tAbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n\tAbsolutePath SpecificationPath =\u003E AddonProject.Directory / \u0022specifications\u0022;\n\tAbsolutePath GenerationBaseDirectory =\u003E AddonProject.Directory / \u0022Generated\u0022;\n\tAbsolutePath DefinitionRepositoryPath =\u003E TemporaryDirectory / \u0022definition-repository\u0022;\n\tRelease LatestCliRelease =\u003E LatestCliReleases.Value[index: 0];\n\n\tNuke.Common.ProjectModel.Project AddonProject =\u003E Solution.GetProject(c_toolNamespace);\n\tstring ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tEnsureCleanDirectory(OutputDirectory);\n\t\t\tLogger.Info(\u0022Deleting generated files ...\u0022);\n\t\t});\n\n\tTarget CleanGeneratedFiles =\u003E _ =\u003E _\n\t.Executes(() =\u003E\n\t{\n\t\tDeleteDirectory(DefinitionRepositoryPath);\n\t\tDeleteDirectory(SpecificationPath);\n\t\tDeleteDirectory(GenerationBaseDirectory);\n\t});\n\n\n\n\tTarget Restore =\u003E _ =\u003E _\n\t\t.DependsOn(Clean)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t\t.SetWorkingDirectory(Solution.Directory)\n\t\t\t\t.SetProjectFile(Solution));\n\t\t});\n\n\tTarget Compile =\u003E _ =\u003E _\n\t\t.DependsOn(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetBuild(x =\u003E x\n\t\t\t\t.SetWorkingDirectory(Solution.Directory)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion?.GetNormalizedAssemblyVersion())\n\t\t\t\t.SetFileVersion(GitVersion?.GetNormalizedFileVersion())\n\t\t\t\t.SetInformationalVersion(GitVersion?.InformationalVersion)\n\t\t\t\t.SetProjectFile(Solution)\n\t\t\t\t.EnableNoRestore());\n\t\t});\n\n\tTarget Test =\u003E _ =\u003E _\n\t\t.DependsOn(Compile)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tvar xUnitSettings = new Xunit2Settings()\n\t\t\t\t.SetFramework(\u0022net461\u0022)\n\t\t\t\t.AddTargetAssemblies(TestsDirectory.GlobFiles($\u0022*/bin/{Configuration}/net4*/Nuke.*.Tests.dll\u0022).NotEmpty().Select(t =\u003E t.ToString()))\n\t\t\t\t.AddResultReport(Xunit2ResultFormat.Xml, OutputDirectory / \u0022tests.xml\u0022);\n\n\t\t\tif (IsWin)\n\t\t\t{\n\t\t\t\tOpenCover(s =\u003E s\n\t\t\t\t\t\t.SetWorkingDirectory(RootDirectory)\n\t\t\t\t\t\t.SetRegistration(RegistrationType.User)\n\t\t\t\t\t\t.SetTargetExitCodeOffset(targetExitCodeOffset: 0)\n\t\t\t\t\t\t.SetFilters(\n\t\t\t\t\t\t\t\u0022\u002B[*]*\u0022,\n\t\t\t\t\t\t\t\u0022-[xunit.*]*\u0022,\n\t\t\t\t\t\t\t\u0022-[NUnit.*]*\u0022,\n\t\t\t\t\t\t\t\u0022-[FluentAssertions.*]*\u0022,\n\t\t\t\t\t\t\t\u0022-[Machine.Specifications.*]*\u0022)\n\t\t\t\t\t\t.SetExcludeByAttributes(\n\t\t\t\t\t\t\t\u0022*.Explicit*\u0022,\n\t\t\t\t\t\t\t\u0022*.Ignore*\u0022,\n\t\t\t\t\t\t\t\u0022System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute\u0022)\n\t\t\t\t\t\t.SetExcludeByFile(\n\t\t\t\t\t\t\t\u0022*/*.Generated.cs\u0022,\n\t\t\t\t\t\t\t\u0022*/*.Designer.cs\u0022,\n\t\t\t\t\t\t\t\u0022*/*.g.cs\u0022,\n\t\t\t\t\t\t\t\u0022*/*.g.i.cs\u0022)\n\t\t\t\t\t.SetOutput(OutputDirectory / \u0022coverage.xml\u0022)\n\t\t\t\t\t.SetTargetSettings(xUnitSettings));\n\t\t\t}\n\t\t\telse\n\t\t\t\tXunit2(s =\u003E xUnitSettings);\n\t\t});\n\n\tTarget Clone =\u003E _ =\u003E _\n\t\t.DependsOn(CleanGeneratedFiles)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tGit($\u0022clone {c_azureCliDocsRepository} {DefinitionRepositoryPath}\u0022);\n\t\t\tGit($\u0022checkout {c_documentationBranch}\u0022, DefinitionRepositoryPath);\n\n\t\t\t// Fix for broken yml definition of az sql vm show\u0027s --expand parameter\n\t\t\t// which is adding an empty collection for values, which breaks code generation\n\t\t\tvar filePath = DefinitionRepositoryPath / \u0022latest\u0022 / \u0022docs-ref-autogen\u0022 / \u0022sql\u0022 / \u0022vm.yml\u0022;\n\n\t\t\tvar tmpFilePath = TemporaryDirectory / (Path.GetFileName(\u0022vm.yml\u0022) \u002B \u0022.tmp\u0022);\n\n\t\t\tusing (var reader = new StreamReader(filePath))\n\t\t\tusing (var writer = new StreamWriter(tmpFilePath))\n\t\t\t{\n\t\t\t\twhile (!reader.EndOfStream)\n\t\t\t\t{\n\t\t\t\t\tvar line = reader.ReadLine();\n\t\t\t\t\tif (line == null) continue;\n\n\t\t\t\t\tif (line.IndexOf(\u0022parameterValueGroup: \u0027\u0027\u0022, StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\tcontinue; //We just skip that line\n\n\t\t\t\t\twriter.WriteLine(line);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFile.Copy(tmpFilePath, filePath, overwrite: true);\n\t\t\tFile.Delete(tmpFilePath);\n\t\t});\n\n\tTarget GenerateSpecifications =\u003E _ =\u003E _\n\t\t.DependentFor(GenerateAddon)\n\t\t.DependsOn(Clone)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tvar reference = Git($\u0022rev-parse --short {c_documentationBranch}\u0022, DefinitionRepositoryPath).Single();\n\t\t\tLogger.Log(LogLevel.Normal, $\u0022Generating specifications for {reference}\u0022);\n\t\t\tvar generationSettings = new SpecificationGeneratorSettings\n\t\t\t{\n\t\t\t\tBaseNamespace = AddonProject.Name,\n\t\t\t\tDefinitionFolder = DefinitionRepositoryPath / \u0022latest\u0022 / \u0022docs-ref-autogen\u0022,\n\t\t\t\tOutputFolder = SpecificationPath,\n\t\t\t\tGenerateExtension = false,\n\t\t\t\tMaxDepth = 1,\n\t\t\t\tMinDepthForCategory = 1,\n\t\t\t\tMinSubTasksForCategory = 0,\n\t\t\t\tSingleNamespace = true,\n\t\t\t\tReference = reference.Text\n\t\t\t};\n\t\t\tSpecificationGenerator.GenerateSpecifications(generationSettings);\n\t\t});\n\n\tIEnumerable\u003Cstring\u003E SpecificationFiles =\u003E GlobFiles(SpecificationPath, \u0022*.json\u0022);\n\n\tTarget GenerateAddon =\u003E _ =\u003E _\n\t\t.OnlyWhenDynamic(() =\u003E SpecificationFiles.Any())\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tstring GetNamespace(string specificationFile)\n\t\t\t\t=\u003E Solution.Projects.Single(x =\u003E IsDescendantPath(x.Directory, specificationFile)).Name;\n\n\t\t\tCodeGenerator.GenerateCode(\n\t\t\t\tSpecificationFiles.ToList(),\n\t\t\t\toutputFileProvider: x =\u003E GenerationBaseDirectory / Path.ChangeExtension(Path.GetFileName(x.SpecificationFile), \u0022Generated.cs\u0022),\n\t\t\t\tnamespaceProvider: x =\u003E GetNamespace(x.SpecificationFile),\n\t\t\t\tsourceFileProvider: x =\u003E GitRepository.GetGitHubBrowseUrl(x.SpecificationFile));\n\n\t\t\tGlobFiles(GenerationBaseDirectory, \u0022AzureMonitor*.Generated.cs\u0022, \u0022AzureNetwork*.Generated.cs\u0022, \u0022AzureStorage*.Generated.cs\u0022).ForEach(\n\t\t\t\tfilePath =\u003E\n\t\t\t\t{\n\t\t\t\t\tvar tmpFilePath = TemporaryDirectory / (Path.GetFileName(filePath) \u002B \u0022.tmp\u0022);\n\t\t\t\t\tusing (var reader = new StreamReader(filePath))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (var writer = new StreamWriter(tmpFilePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (!reader.EndOfStream)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar line = reader.ReadLine();\n\t\t\t\t\t\t\t\tif (line == null) continue;\n\n\t\t\t\t\t\t\t\tif (line.IndexOf(\u0022public static NetworkNsgRuleProtocol __ = new NetworkNsgRuleProtocol { Value = \\\u0022*\\\u0022 };\u0022,\n\t\t\t\t\t\t\t\t\t    StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022__\u0022, \u0022any\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\n\t\t\t\t\t\t\t\t\t         \u0022public static MonitorAlertUpdateOperator __ = new MonitorAlertUpdateOperator { Value = \\\u0022\u003C\\\u0022 };\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022__\u0022, \u0022SmallerThan\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\n\t\t\t\t\t\t\t\t\t         \u0022public static MonitorAlertUpdateOperator ___ = new MonitorAlertUpdateOperator { Value = \\\u0022\u003C=\\\u0022 };\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022___\u0022, \u0022SmallerThanOrEqualTo\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\n\t\t\t\t\t\t\t\t\t         \u0022public static MonitorAlertUpdateOperator __ = new MonitorAlertUpdateOperator { Value = \\\u0022\u003E\\\u0022 };\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022__\u0022, \u0022GreaterThan\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\n\t\t\t\t\t\t\t\t\t         \u0022public static MonitorAlertUpdateOperator ___ = new MonitorAlertUpdateOperator { Value = \\\u0022\u003E=\\\u0022 };\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022___\u0022, \u0022GreatherThanOrEqualTo\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022.Add(\\\u0022--404-document {value}\\\u0022, 404Document)\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022404Document\u0022, \u0022PathTo404Document\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022public virtual string 404Document { get; internal set; }\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022404Document\u0022, \u0022PathTo404Document\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022AzureStorageBlobServicePropertiesUpdateSettings.404Document\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022404Document\u0022, \u0022PathTo404Document\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022#region 404Document\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022404Document\u0022, \u0022PathTo404Document\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\n\t\t\t\t\t\t\t\t\t         \u0022Set404Document(this AzureStorageBlobServicePropertiesUpdateSettings toolSettings, string 404Document)\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\n\t\t\t\t\t\t\t\t\t\t\u0022Set404Document(this AzureStorageBlobServicePropertiesUpdateSettings toolSettings, string 404Document)\u0022,\n\t\t\t\t\t\t\t\t\t\t\u0022SetPathTo404Document(this AzureStorageBlobServicePropertiesUpdateSettings toolSettings, string pathTo404Document)\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022toolSettings.404Document = 404Document;\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022toolSettings.404Document = 404Document;\u0022,\n\t\t\t\t\t\t\t\t\t\t\u0022toolSettings.PathTo404Document = pathTo404Document;\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022Reset404Document(this AzureStorageBlobServicePropertiesUpdateSettings toolSettings)\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022Reset404Document\u0022, \u0022ResetPathTo404Document\u0022);\n\t\t\t\t\t\t\t\telse if (line.IndexOf(\u0022toolSettings.404Document = null;\u0022,\n\t\t\t\t\t\t\t\t\t         StringComparison.Ordinal) \u003E -1)\n\t\t\t\t\t\t\t\t\tline = line.Replace(\u0022toolSettings.404Document = null;\u0022, \u0022toolSettings.PathTo404Document = null;\u0022);\n\n\t\t\t\t\t\t\t\twriter.WriteLine(line);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tFile.Copy(tmpFilePath, filePath, overwrite: true);\n\t\t\t\t\tFile.Delete(tmpFilePath);\n\t\t\t\t});\n\t\t});\n\n\tTarget CompileAddon =\u003E _ =\u003E _\n\t\t.DependsOn(GenerateAddon, Clean)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t\t.SetWorkingDirectory(Solution.Directory)\n\t\t\t\t.SetProjectFile(AddonProject));\n\n\t\t\tDotNetBuild(x =\u003E x\n\t\t\t\t.SetWorkingDirectory(Solution.Directory)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion?.GetNormalizedAssemblyVersion())\n\t\t\t\t.SetFileVersion(GitVersion?.GetNormalizedFileVersion())\n\t\t\t\t.SetInformationalVersion(GitVersion?.InformationalVersion)\n\t\t\t\t.SetProjectFile(AddonProject)\n\t\t\t\t.EnableNoRestore());\n\t\t});\n\n\tTarget Pack =\u003E _ =\u003E _\n\t\t.DependsOn(CompileAddon)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tvar releaseNotes = ExtractChangelogSectionNotes(ChangelogFile)\n\t\t\t\t.Select(x =\u003E x.Replace(\u0022- \u0022, \u0022\\u2022 \u0022).Replace(\u0022\u0060\u0022, string.Empty).Replace(\u0022,\u0022, \u0022%2C\u0022))\n\t\t\t\t.Concat(string.Empty)\n\t\t\t\t.Concat($\u0022Full changelog at {GitRepository.SetBranch(\u0022master\u0022).GetGitHubBrowseUrl(ChangelogFile)}\u0022)\n\t\t\t\t.JoinNewLine();\n\n\t\t\tDotNetPack(s =\u003E s\n\t\t\t\t.SetWorkingDirectory(Solution.Directory)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.EnableIncludeSymbols()\n\t\t\t\t.SetOutputDirectory(OutputDirectory)\n\t\t\t\t.SetProject(AddonProject)\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t\t\t.SetPackageReleaseNotes(releaseNotes));\n\t\t});\n\n\tTarget Changelog =\u003E _ =\u003E _\n\t\t.OnlyWhenDynamic(() =\u003E ShouldUpdateChangelog())\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tFinalizeChangelog(ChangelogFile, GitVersion.MajorMinorPatch, GitRepository);\n\t\t});\n\n\tTarget Push =\u003E _ =\u003E _\n\t\t.DependsOn(Pack)\n\t\t.Requires(() =\u003E NugetApiKey)\n\t\t.Requires(() =\u003E GitHasCleanWorkingCopy())\n\t\t.Requires(() =\u003E Configuration.Equals(Configuration.Release))\n\t\t.Requires(() =\u003E IsReleaseBranch || IsMasterBranch)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tGlobFiles(OutputDirectory, \u0022*.nupkg\u0022)\n\t\t\t\t.Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022)).NotEmpty()\n\t\t\t\t.ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n\t\t\t\t\t.SetTargetPath(x)\n\t\t\t\t\t.SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n\t\t\t\t\t.SetSymbolSource(\u0022https://nuget.smbsrc.net/\u0022)\n\t\t\t\t\t.SetApiKey(NugetApiKey)));\n\t\t});\n\n\tTarget Regenerate =\u003E _ =\u003E _\n\t\t.Requires(() =\u003E GitHubApiKey)\n\t\t.Requires(() =\u003E LatestCliRelease != null)\n\t\t.OnlyWhenDynamic(() =\u003E IsUpdateAvailable($\u0022{c_addonName} v{ParseVersion(LatestCliRelease)}\u0022, ChangelogFile))\n\t\t.WhenSkipped(DependencyBehavior.Skip)\n\t\t.DependsOn(CompileAddon, GenerateSpecifications)\n\t\t.Executes(async () =\u003E\n\t\t{\n\t\t\tvar release = GetReleaseInformation(LatestCliReleases.Value, ParseVersion);\n\t\t\tvar branch = $\u0022{c_addonRepoName}-update-{release.Version}\u0022;\n\t\t\tvar versionName = $\u0022{c_addonName} v{release.Version}\u0022;\n\t\t\tvar message = $\u0022Regenerate for {versionName}\u0022;\n\t\t\tvar latestReleaseDate = LatestCliRelease.PublishedAt?.ToString(\u0022MMMM-d-yyyy\u0022);\n\t\t\tvar changelogUrl = $\u0022https://docs.microsoft.com/cli/azure/release-notes-azure-cli?view=azure-cli-latest#{latestReleaseDate}\u0022;\n\n\t\t\tvar commitMessage = new List\u003Cstring\u003E { message };\n\t\t\tif (release.Bump != Bump.Patch) commitMessage.Add($\u0022\u002Bsemver: {release.Bump.ToString().ToLowerInvariant()}\u0022);\n\t\t\tvar prBody = $\u0022Regenerate for [{versionName}]({LatestCliRelease.HtmlUrl}).\\n[Changelog]({changelogUrl})\u0022;\n\n\t\t\tCheckoutBranchOrCreateNewFrom(branch, \u0022master\u0022);\n\t\t\tUpdateChangeLog(ChangelogFile, versionName, changelogUrl);\n\t\t\tAddAndCommitChanges(commitMessage.ToArray(), new[] { AddonProject.Directory, ChangelogFile }, addUntracked: true);\n\n\t\t\tGit($\u0022push --force --set-upstream origin {branch}\u0022);\n\n\t\t\tawait CreatePullRequest(x =\u003E x\n\t\t\t\t.SetRepositoryName(c_addonRepoName)\n\t\t\t\t.SetRepositoryOwner(c_addonRepoOwner)\n\t\t\t\t.SetBase(\u0022master\u0022)\n\t\t\t\t.SetHead(branch)\n\t\t\t\t.SetTitle(message)\n\t\t\t\t.SetBody(prBody)\n\t\t\t\t.SetToken(GitHubApiKey));\n\t\t});\n\n\tTarget Release =\u003E _ =\u003E _\n\t\t.Requires(() =\u003E GitHubApiKey)\n\t\t.DependsOn(Push)\n\t\t.After(PrepareRelease)\n\t\t.Executes(async () =\u003E\n\t\t{\n\t\t\tvar releaseNotes = new[]\n\t\t\t\t\t\t\t   {\n\t\t\t\t\t\t\t\t   $\u0022- [Nuget](https://www.nuget.org/packages/{c_toolNamespace}/{GitVersion.SemVer})\u0022,\n\t\t\t\t\t\t\t\t   $\u0022- [Changelog](https://github.com/{c_addonRepoOwner}/{c_addonRepoName}/blob/{GitVersion.SemVer}/CHANGELOG.md)\u0022\n\t\t\t\t\t\t\t   };\n\n\t\t\tawait PublishRelease(x =\u003E x.SetToken(GitHubApiKey)\n\t\t\t\t.SetArtifactPaths(GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).ToArray())\n\t\t\t\t.SetRepositoryName(c_addonRepoName)\n\t\t\t\t.SetRepositoryOwner(c_addonRepoOwner)\n\t\t\t\t.SetCommitSha(\u0022master\u0022)\n\t\t\t\t.SetName($\u0022NUKE {c_addonName} Addon v{GitVersion.MajorMinorPatch}\u0022)\n\t\t\t\t.SetTag($\u0022{GitVersion.MajorMinorPatch}\u0022)\n\t\t\t\t.SetReleaseNotes(releaseNotes.Join(\u0022\\n\u0022))\n\t\t\t);\n\t\t});\n\n\tTarget PrepareRelease =\u003E _ =\u003E _\n\t\t.Before(CompileAddon)\n\t\t.DependsOn(Changelog, Clean)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tvar releaseBranch = IsReleaseBranch ? GitRepository.Branch : $\u0022release/v{GitVersion.MajorMinorPatch}\u0022;\n\t\t\tvar isMasterBranch = IsMasterBranch;\n\t\t\tvar pushMaster = false;\n\t\t\tif (!isMasterBranch \u0026\u0026 !IsReleaseBranch) Git($\u0022checkout -b {releaseBranch}\u0022);\n\n\t\t\tif (!GitHasCleanWorkingCopy())\n\t\t\t{\n\t\t\t\tGit($\u0022add {ChangelogFile}\u0022);\n\t\t\t\tGit($\u0022commit -m \\\u0022Finalize v{GitVersion.MajorMinorPatch}\\\u0022\u0022);\n\t\t\t\tpushMaster = true;\n\t\t\t}\n\n\t\t\tif (!isMasterBranch)\n\t\t\t{\n\t\t\t\tGit(\u0022checkout master\u0022);\n\t\t\t\tGit($\u0022merge --no-ff --no-edit {releaseBranch}\u0022);\n\t\t\t\tGit($\u0022branch -D {releaseBranch}\u0022);\n\t\t\t\tpushMaster = true;\n\t\t\t}\n\n\t\t\tif (IsReleaseBranch) Git($\u0022push origin --delete {releaseBranch}\u0022);\n\t\t\tif (pushMaster) Git(\u0022push origin master\u0022);\n\t\t});\n\n\tbool IsReleaseBranch =\u003E GitRepository?.Branch?.StartsWith(\u0022release/\u0022) ?? false;\n\tbool IsMasterBranch =\u003E GitRepository.Branch == \u0022master\u0022;\n\n\tbool ShouldUpdateChangelog()\n\t{\n\t\tbool TryGetChangelogSectionNotes(string tag, out string[] sectionNotes)\n\t\t{\n\t\t\tsectionNotes = new string[0];\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsectionNotes = ExtractChangelogSectionNotes(ChangelogFile, tag).ToArray();\n\t\t\t\treturn sectionNotes.Length \u003E 0;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar nextSectionAvailable = TryGetChangelogSectionNotes(\u0022vNext\u0022, out _);\n\t\tvar semVerSectionAvailable = TryGetChangelogSectionNotes(GitVersion.MajorMinorPatch, out _);\n\t\tif (semVerSectionAvailable)\n\t\t{\n\t\t\tControlFlow.Assert(!nextSectionAvailable, $\u0022{GitVersion.MajorMinorPatch} is already in changelog.\u0022);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn nextSectionAvailable;\n\t}\n\n\tVersion ParseVersion(Release release) =\u003E Version.Parse(Regex.Match(release.TagName, @\u0022^azure-cli-(\\d\u002B(?\u003E\\.\\d\u002B){0,2})\u0022).Groups[groupnum: 1].Value);\n}"
  },
  {
    "Id": 132809763,
    "FirstIndexed": "2020-04-25T15:50:44.7356062+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162688+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434115+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939862+02:00",
    "Name": "neptune",
    "Owner": "skyne98",
    "HtmlUrl": "https://github.com/skyne98/neptune",
    "Description": "cross-platform \uD83C\uDFAE game engine for .NET Core",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "Neptune.Build/Build.cs",
    "BuildFileUrl": "https://github.com/skyne98/neptune/blob/master/Neptune.Build/Build.cs",
    "BuildFileSize": 2382,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    // [Solution] readonly Solution Solution;\n    // Provides access to the structure of the solution.\n\n    Target CheckSystem =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Console.WriteLine(\n                $\u0022Your system is: {Environment.NewLine}{EnvironmentInfo.Platform}{Environment.NewLine}{(EnvironmentInfo.Is64Bit ? \u0022x64\u0022 : \u0022x86\u0022)}\u0022);\n            \n            if (EnvironmentInfo.IsUnix == false)\n            {\n                throw new Exception(\u0022Sorry, for now building is supported only on Linux machines\u0022);\n            }\n        });\n    \n    Target Clean =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E false) // Disabled for safety.\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E DefaultDotNetRestore);\n        });\n\n    Target BuildShaders =\u003E _ =\u003E _\n        .DependsOn(CheckSystem)\n        .Executes(() =\u003E\n        {\n            var process = StartProcess(SolutionDirectory / \u0022Neptune\u0022 / \u0022build-shaders.sh\u0022, workingDirectory: SolutionDirectory / \u0022Neptune\u0022);\n            process.WaitForExit();\n        });\n\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, BuildShaders, CheckSystem)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E DefaultDotNetBuild);\n        });\n}"
  },
  {
    "Id": 133854577,
    "FirstIndexed": "2020-04-25T15:50:44.7356039+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626863+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434104+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939857+02:00",
    "Name": "SampleReactApp",
    "Owner": "rc6886",
    "HtmlUrl": "https://github.com/rc6886/SampleReactApp",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/rc6886/SampleReactApp/blob/master/build/Build.cs",
    "BuildFileSize": 1603,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.Npm;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n    \n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n    \n    // [Solution] readonly Solution Solution;\n    // Provides access to the structure of the solution.\n\n    Target Clean =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E false) // Disabled for safety.\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E DefaultDotNetRestore);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E DefaultDotNetBuild);\n        });\n}\n"
  },
  {
    "Id": 133996573,
    "FirstIndexed": "2020-04-25T15:50:44.7356016+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626852+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434093+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "ViGEm.Management",
    "Owner": "ViGEm",
    "HtmlUrl": "https://github.com/ViGEm/ViGEm.Management",
    "Description": "Tools for distribution, installation and management of the ViGEm framework drivers.",
    "Archived": true,
    "Stars": 2,
    "Watchers": 3,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 134182879,
    "FirstIndexed": "2020-04-25T15:50:44.7354782+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629287+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433586+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939356+02:00",
    "Name": "Dock",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/Dock",
    "Description": "A docking layout system.",
    "Archived": false,
    "Stars": 115,
    "Watchers": 9,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/Dock/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 134330962,
    "FirstIndexed": "2020-04-25T15:50:44.7362671+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362683+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435071+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940789+02:00",
    "Name": "vscode",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/vscode",
    "Description": "VSCode extension",
    "Archived": false,
    "Stars": 0,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nuke-build/vscode/blob/master/build/Build.cs",
    "BuildFileSize": 7022,
    "BuildFileContent": "\uFEFF// Copyright Matthias Koch, Sebastian Karasek 2018.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/vscode/blob/master/LICENSE\n\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.GitHub;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Nuke.Common.IO;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\nusing static Nuke.Common.IO.PathConstruction;\n\nclass Build : NukeBuild\n{\n    const string c_repoName = \u0022vscode\u0022;\n    const string c_repoOwner = \u0022nuke-build\u0022;\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter] readonly string GitHubAccessToken;\n    [Parameter] readonly string VSTSAccessToken;\n\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    string PackageFile =\u003E OutputDirectory / $\u0022nuke.support-v{GitVersion.SemVer}.vsix\u0022;\n    string VscePath =\u003E NodeModulesPath / \u0022vsce\u0022 / \u0022out\u0022 / \u0022vsce\u0022;\n    string TSLintPath =\u003E NodeModulesPath / \u0022tslint\u0022 / \u0022bin\u0022 / \u0022tslint\u0022;\n    string NodePath =\u003E ToolPathResolver.GetPathExecutable(\u0022node\u0022);\n    AbsolutePath NodeModulesPath =\u003E RootDirectory / \u0022node_modules\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectory(RootDirectory / \u0022node_modules\u0022);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Install =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            Npm(\u0022install\u0022);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Install)\n        .Executes(() =\u003E\n        {\n            Npm(\u0022run compile\u0022);\n        });\n\n    Target CheckStyle =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var tsLintCommand = $\u0022{TSLintPath} --project {RootDirectory}\u0022;\n            if (IsServerBuild)\n            {\n                tsLintCommand \u002B= $\u0022 --format checkstyle --out {OutputDirectory / \u0022checkstyle.xml\u0022}\u0022;\n            }\n\n            StartProcess(NodePath, tsLintCommand).AssertZeroExitCode();\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Changelog =\u003E _ =\u003E _\n        .OnlyWhen(ShouldUpdateChangelog)\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, GitVersion.MajorMinorPatch, GitRepository);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .After(Changelog)\n        .Executes(() =\u003E\n        {\n            UpdateVersion(GitVersion.SemVer);\n            StartProcess(NodePath, $\u0022{VscePath} package --out {PackageFile}\u0022).AssertZeroExitCode();\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E VSTSAccessToken)\n        .Requires(() =\u003E GitRepository.Branch == \u0022master\u0022)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .Executes(() =\u003E\n        {\n            StartProcess(NodePath, $\u0022{VscePath} publish --pat {VSTSAccessToken} --packagePath {PackageFile}\u0022).AssertZeroExitCode();\n        });\n\n    bool IsReleaseBranch =\u003E GitRepository.Branch.StartsWith(\u0022release/\u0022);\n\n    Target PrepareRelease =\u003E _ =\u003E _\n        .Before(Install)\n        .DependsOn(Changelog, Clean)\n        .Executes(() =\u003E\n        {\n            UpdateVersion(GitVersion.MajorMinorPatch);\n            var releaseBranch = IsReleaseBranch ? GitRepository.Branch : $\u0022release/v{GitVersion.MajorMinorPatch}\u0022;\n            var isMasterBranch = GitRepository.Branch == \u0022master\u0022;\n\n            if (!isMasterBranch \u0026\u0026 !IsReleaseBranch)\n            {\n                Git($\u0022checkout -b {releaseBranch}\u0022);\n            }\n\n            if (!GitHasCleanWorkingCopy())\n            {\n                Git($\u0022add {ChangelogFile} package.json package-lock.json\u0022);\n                var commitCommand = $\u0022commit -m \\\u0022Finalize v{GitVersion.MajorMinorPatch}\\\u0022\u0022;\n                if (isMasterBranch) commitCommand \u002B= \u0022 -m \\\u0022\u002Bsemver: skip\\\u0022\u0022;\n                Git(commitCommand);\n            }\n\n            if (!isMasterBranch)\n            {\n                Git(\u0022checkout master\u0022);\n                Git($\u0022merge --no-ff --no-edit {releaseBranch}\u0022);\n                Git($\u0022branch -D {releaseBranch}\u0022);\n            }\n            if (IsReleaseBranch)\n            {\n                Git($\u0022push origin --delete {releaseBranch}\u0022);\n            }\n            Git($\u0022push origin master\u0022);\n        });\n\n    Target Release =\u003E _ =\u003E _\n        .DependsOn(Push, PrepareRelease)\n        .Requires(() =\u003E GitRepository.Branch == \u0022master\u0022)\n        .Requires(() =\u003E GitHubAccessToken)\n        .Executes(async () =\u003E\n        {;\n            await GitHubTasks.PublishRelease(x =\u003E x\n                .SetToken(GitHubAccessToken)\n                .SetArtifactPaths(new[] { PackageFile })\n                .SetRepositoryName(\u0022vscode\u0022)\n                .SetRepositoryOwner(\u0022nuke-build\u0022)\n                .SetCommitSha(\u0022master\u0022)\n                .SetName($\u0022NUKE VSCode Extension v{GitVersion.MajorMinorPatch}\u0022)\n                .SetTag($\u0022{GitVersion.MajorMinorPatch}\u0022)\n                .SetReleaseNotes($\u0022[Changelog](https://github.com/{c_repoOwner}/{c_repoName}/blob/{GitVersion.MajorMinorPatch}/CHANGELOG.md)\u0022));\n        });\n\n    void UpdateVersion(string version)\n    {\n        void UpdateVersion(string filePath)\n        {\n            var packageJson = TextTasks.ReadAllText(filePath);\n            var package = JObject.Parse(packageJson);\n            var packageVersion = package.Value\u003Cstring\u003E(\u0022version\u0022);\n            if (version == packageVersion)\n            {\n                return;\n            }\n            package[\u0022version\u0022] = new JValue(version);\n            TextTasks.WriteAllText(filePath, package.ToString(Formatting.Indented) \u002B EnvironmentInfo.NewLine);\n        }\n        UpdateVersion(RootDirectory / \u0022package.json\u0022);\n        UpdateVersion(RootDirectory / \u0022package-lock.json\u0022);\n    }\n\n    bool ShouldUpdateChangelog()\n    {\n        bool TryGetChangelogSectionNotes(string tag, out string[] sectionNotes)\n        {\n            sectionNotes = new string[0];\n            try\n            {\n                sectionNotes = ExtractChangelogSectionNotes(ChangelogFile, tag).ToArray();\n                return sectionNotes.Length \u003E 0;\n            }\n            catch (System.Exception)\n            {\n                return false;\n            }\n        }\n\n        var nextSectionAvailable = TryGetChangelogSectionNotes(\u0022vNext\u0022, out var vNextSection);\n        var semVerSectionAvailable = TryGetChangelogSectionNotes(GitVersion.MajorMinorPatch, out var semVerSection);\n        if (semVerSectionAvailable)\n        {\n            ControlFlow.Assert(!nextSectionAvailable, $\u0022{GitVersion.MajorMinorPatch} is already in changelog.\u0022);\n            return false;\n        }\n\n        return nextSectionAvailable;\n    }\n}"
  },
  {
    "Id": 134334062,
    "FirstIndexed": "2020-04-25T15:50:44.7355106+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632478+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433729+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "azure-keyvault",
    "Owner": "arodus",
    "HtmlUrl": "https://github.com/arodus/azure-keyvault",
    "Description": "Azure Keyvault addon",
    "Archived": true,
    "Stars": 1,
    "Watchers": 3,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 134452951,
    "FirstIndexed": "2020-04-25T15:50:44.7354895+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632421+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433637+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939413+02:00",
    "Name": "nswag",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/nswag",
    "Description": "NSwag Addon.",
    "Archived": false,
    "Stars": 4,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/matkoch/nswag/blob/master/build/Build.cs",
    "BuildFileSize": 6915,
    "BuildFileContent": "// Copyright 2018 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/nuke/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Octokit;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.GitHub.GitHubTasks;\n\n// ReSharper disable HeapView.DelegateAllocation\n\npartial class Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] readonly string SymbolSource = \u0022https://nuget.smbsrc.net/\u0022;\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter] readonly string GitHubToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    // [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly string SemanticVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    IEnumerable\u003Cstring\u003E SpecificationFiles =\u003E GlobFiles(SourceDirectory, \u0022*/*.json\u0022);\n\n    Target Generate =\u003E _ =\u003E _\n        .OnlyWhenDynamic(() =\u003E SpecificationFiles.Any())\n        .Executes(() =\u003E\n        {\n            string GetNamespace(string specificationFile)\n                =\u003E Solution.Projects.Single(x =\u003E IsDescendantPath(x.Directory, specificationFile)).Name;\n\n            GenerateCode(\n                SpecificationFiles.ToList(),\n                outputFileProvider: x =\u003E x.DefaultOutputFile,\n                namespaceProvider: x =\u003E GetNamespace(x.SpecificationFile),\n                sourceFileProvider: x =\u003E GitRepository.GetGitHubBrowseUrl(x.SpecificationFile));\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, Generate)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    IEnumerable\u003CNuke.Common.ProjectModel.Project\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E TestProjects.Any())\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(OutputDirectory)\n                .CombineWith(\n                    TestProjects, (cs, v) =\u003E cs\n                        .SetProjectFile(v)));\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Changelog =\u003E _ =\u003E _\n        .After(Test)\n        .Before(Pack)\n        .OnlyWhenDynamic(() =\u003E\n            GitRepository.IsOnMasterBranch() ||\n            GitRepository.IsOnReleaseBranch() ||\n            GitRepository.IsOnHotfixBranch())\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, SemanticVersion, GitRepository);\n            Git($\u0022add {ChangelogFile}\u0022);\n            Git($\u0022commit -m \\\u0022Finalize {Path.GetFileName(ChangelogFile)} for v{SemanticVersion}\\\u0022\u0022);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(SemanticVersion)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Changelog)\n        .DependsOn(Pack)\n        .Requires(() =\u003E SemanticVersion)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(async () =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetSource(Source)\n                    .SetSymbolSource(SymbolSource)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(\n                        OutputDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E cs\n                            .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n\n            Git($\u0022tag {SemanticVersion}\u0022);\n            Git($\u0022push origin {GitRepository.Branch} {SemanticVersion}\u0022);\n\n            return;\n\n            await PublishRelease(s =\u003E s\n                .SetToken(GitHubToken)\n                .SetRepositoryOwner(GitRepository.GetGitHubOwner())\n                .SetRepositoryName(GitRepository.GetGitHubName())\n                .SetCommitSha(GitRepository.Branch)\n                .SetTag($\u0022{SemanticVersion}\u0022)\n                .SetName($\u0022v{SemanticVersion}\u0022)\n                .SetReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    bool GitHubMilestoneClosed(bool mustExist) =\u003E GetMilestone().Result?.State.Value == ItemState.Closed;\n\n    async Task\u003CMilestone\u003E GetMilestone()\n    {\n        var client = new GitHubClient(new ProductHeaderValue(nameof(NukeBuild))) { Credentials = new Credentials(GitHubToken) };\n        var milestones = await client.Issue.Milestone.GetAllForRepository(\n            GitRepository.GetGitHubOwner(),\n            GitRepository.GetGitHubName());\n        return milestones.FirstOrDefault(x =\u003E x.Title == $\u0022v{SemanticVersion}\u0022);\n    }\n}\n"
  },
  {
    "Id": 134475077,
    "FirstIndexed": "2020-04-25T15:50:44.7356864+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632603+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434457+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940175+02:00",
    "Name": "WebGAEB.Docs",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/WebGAEB.Docs",
    "Description": "Documentation for WebGAEB",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/WebGAEB.Docs/blob/master/build/Build.cs",
    "BuildFileSize": 2158,
    "BuildFileContent": "\uFEFFusing Nuke.Azure.KeyVault;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.DocFX;\nusing Nuke.WebDocu;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.DocFX.DocFXTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildDocumentation);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Solution(\u0022WebGAEB.Docs.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docs\u0022 / \u0022docfx.json\u0022;\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [KeyVaultSecret] readonly string DocuBaseUrl;\n    [KeyVaultSecret(\u0022DanglWebGaebDocs-DocuApiKey\u0022)] readonly string DocuApiKey;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Docs version: \u0022 \u002B GitVersion.NuGetVersion);\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetSourceDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n}\n"
  },
  {
    "Id": 134587940,
    "FirstIndexed": "2020-04-25T15:50:44.7355993+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626834+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434081+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939845+02:00",
    "Name": "log2html",
    "Owner": "dnknitro",
    "HtmlUrl": "https://github.com/dnknitro/log2html",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/log2html.Build.cs",
    "BuildFileUrl": "https://github.com/dnknitro/log2html/blob/master/build/log2html.Build.cs",
    "BuildFileSize": 4959,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing dnk.log2html.build.Helpers;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\n\nnamespace dnk.log2html.build\n{\n\tclass Build : NukeBuild\n\t{\n\t\t// Console application entry point. Also defines the default target.\n\t\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n\t\t// Auto-injection fields:\n\n\t\t[GitVersion] readonly GitVersion GitVersion;\n\t\t// Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n\t\t// [GitRepository] readonly GitRepository GitRepository;\n\t\t// Parses origin, branch name and head from git config.\n\n\t\t// [Parameter] readonly string MyGetApiKey;\n\t\t// Returns command-line arguments and environment variables.\n\n\t\t// [Solution] readonly Solution Solution;\n\t\t// Provides access to the structure of the solution.\n\n\t\tTarget Clean =\u003E _ =\u003E _\n\t\t\t.OnlyWhen(() =\u003E false) // Disabled for safety.\n\t\t\t.Executes(() =\u003E\n\t\t\t{\n\t\t\t\tFileSystemTasks.DeleteDirectories(PathConstruction.GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n\t\t\t\tFileSystemTasks.EnsureCleanDirectory(OutputDirectory);\n\t\t\t});\n\n\t\tTarget Compile =\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E\n\t\t\t{\n\t\t\t\tNuGetTasks.NuGetRestore(SolutionFile, config =\u003E config.SetToolPath(ToolsLocationHelper.NuGetPath));\n\n\t\t\t\tMSBuildTasks.MSBuild(s =\u003E\n\t\t\t\t\tMSBuildTasks.DefaultMSBuildCompile\n\t\t\t\t\t\t.SetVerbosity(MSBuildVerbosity.Minimal)\n\t\t\t\t\t\t.SetTargets(\u0022Build\u0022)\n\t\t\t\t\t\t.SetNodeReuse(true)\n\t\t\t\t\t\t.SetMaxCpuCount(4));\n\t\t\t});\n\n\t\tTarget SetAssemblyVersion =\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E\n\t\t\t{\n\t\t\t\tvar assemblyInfos = new[]\n\t\t\t\t{\n\t\t\t\t\t@\u0022log2html\\Properties\\AssemblyInfo.cs\u0022,\n\t\t\t\t\t@\u0022log2html.Support\\Properties\\AssemblyInfo.cs\u0022\n\t\t\t\t};\n\n\t\t\t\tforeach(var assemblyInfo in assemblyInfos)\n\t\t\t\t{\n\t\t\t\t\tvar assemblyInfoFile = RootDirectory / assemblyInfo;\n\t\t\t\t\tvar content = File.ReadAllText(assemblyInfoFile);\n\t\t\t\t\tcontent = Regex.Replace(content, @\u0022AssemblyVersion\\(\\s*\u0022\u0022.\u002B\u0022\u0022\\s*\\)\u0022, $@\u0022AssemblyVersion(\u0022\u0022{GitVersion.GetNormalizedAssemblyVersion()}\u0022\u0022)\u0022);\n\t\t\t\t\tcontent = Regex.Replace(content, @\u0022AssemblyFileVersion\\(\\s*\u0022\u0022.\u002B\u0022\u0022\\s*\\)\u0022, $@\u0022AssemblyFileVersion(\u0022\u0022{GitVersion.GetNormalizedFileVersion()}\u0022\u0022)\u0022);\n\t\t\t\t\tcontent = Regex.Replace(content, @\u0022AssemblyInformationalVersion\\(\\s*\u0022\u0022.\u002B\u0022\u0022\\s*\\)\u0022, $@\u0022AssemblyInformationalVersion(\u0022\u0022{GitVersion.InformationalVersion}\u0022\u0022)\u0022);\n\t\t\t\t\tFile.WriteAllText(assemblyInfoFile, content);\n\t\t\t\t}\n\t\t\t});\n\n\t\t[Parameter]\n\t\tpublic string Version\n\t\t{\n\t\t\tget; set;\n\t\t}\n\n\t\tprivate void NugetPack(string projectRelativeFolder)\n\t\t{\n\t\t\tEnvironment.CurrentDirectory = RootDirectory;\n\t\t\tvar projectFolder = RootDirectory / projectRelativeFolder;\n\t\t\tvar nupkgFiles = Directory.GetFiles(projectFolder, \u0022*.nupkg\u0022).ToList();\n\t\t\tvar versionWasNull = Version == null;\n\t\t\tif (versionWasNull)\n\t\t\t{\n\t\t\t\tvar highestVersion = nupkgFiles.Select(x =\u003E Regex.Replace(x, @\u0022.\u002B\\.(\\d\u002B\\.\\d\u002B\\.\\d\u002B\\.\\d\u002B)\\.nupkg\u0022, \u0022$1\u0022)).OrderBy(x =\u003E x).LastOrDefault();\n\t\t\t\tvar versionParts = highestVersion.Split(\u0027.\u0027).ToList();\n\t\t\t\tvar bumpedVersion = int.Parse(versionParts.Last());\n\t\t\t\tbumpedVersion\u002B\u002B;\n\t\t\t\tVersion = string.Join(\u0022.\u0022, versionParts.Take(versionParts.Count - 1).Concat(new List\u003Cstring\u003E {bumpedVersion.ToString()}));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnupkgFiles.ForEach(x =\u003E File.Delete(x));\n\t\t\t}\n\t\t\tProcessHelper.StartProcess(ToolsLocationHelper.NuGetPath, $\u0022pack -Version {Version}\u0022, projectFolder);\n\t\t\tif (versionWasNull)\n\t\t\t\tnupkgFiles.ForEach(x =\u003E File.Delete(x));\n\t\t}\n\n\t    const string localNugetApiKey = \u0022123453\u0022;\n\t    const string localNugetSource = \u0022http://localhost/NuGet/api/v2/package\u0022;\n\t    const string remoteNugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n\t\tprivate void NugetPushLocal(string projectRelativeFolder, string source, string apiKey = null)\n\t\t{\n\t\t\tEnvironment.CurrentDirectory = RootDirectory;\n\t\t\tvar projectFolder = RootDirectory / projectRelativeFolder;\n\t\t\tvar nupkgFile = Directory.GetFiles(projectFolder, \u0022*.nupkg\u0022).Single();\n\t\t    var apiKeyPart = string.IsNullOrEmpty(apiKey) ? string.Empty : apiKey;\n\t\t\tProcessHelper.StartProcess(ToolsLocationHelper.NuGetPath, $\u0022push {nupkgFile} {apiKeyPart} -Source {source}\u0022, projectFolder);\n\t\t}\n\n\t\tTarget Pack =\u003E _ =\u003E _\n\t\t\t.DependsOn(Compile)\n\t\t\t.Executes(() =\u003E\n\t\t\t{\n\t\t\t\tNugetPack(@\u0022src\\log2html\u0022);\n\t\t\t\tNugetPack(@\u0022src\\log2html.Support\u0022);\n\t\t\t});\n\n\t\tTarget PushLocal =\u003E _ =\u003E _\n\t\t\t.DependsOn(Pack)\n\t\t\t.Executes(() =\u003E\n\t\t\t{\n\t\t\t\tNugetPushLocal(@\u0022src\\log2html\u0022, localNugetSource, localNugetApiKey);\n\t\t\t\tNugetPushLocal(@\u0022src\\log2html.Support\u0022, localNugetSource, localNugetApiKey);\n\t\t\t});\n\n\t\tTarget PushRemote =\u003E _ =\u003E _\n\t\t\t.DependsOn(Pack)\n\t\t\t.Executes(() =\u003E\n\t\t    {\n\t\t        Logger.Info($\u0022don\u0027t forget to run \u0027nuget setApiKey secret_key\u0027 (key can be generated @ nuget.org)\u0022);\n\t\t\t    NugetPushLocal(@\u0022src\\log2html\u0022, remoteNugetSource);\n\t\t\t    NugetPushLocal(@\u0022src\\log2html.Support\u0022, remoteNugetSource);\n\t\t\t});\n\t}\n}\n"
  },
  {
    "Id": 135240825,
    "FirstIndexed": "2020-04-25T15:50:44.7355971+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626823+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434076+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939834+02:00",
    "Name": "TacticalNuclearSitecore",
    "Owner": "gravypower",
    "HtmlUrl": "https://github.com/gravypower/TacticalNuclearSitecore",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/gravypower/TacticalNuclearSitecore/blob/master/build/Build.cs",
    "BuildFileSize": 1760,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n    \n    // [Solution] readonly Solution Solution;\n    // Provides access to the structure of the solution.\n\n    Target Develop =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(\n            );\n\n    Target Clean =\u003E _ =\u003E _\n            .OnlyWhen(() =\u003E false) // Disabled for safety.\n            .Executes(() =\u003E\n            {\n                DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildCompile);\n            });\n}\n"
  },
  {
    "Id": 135740200,
    "FirstIndexed": "2020-04-25T15:50:44.7355572+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626578+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433899+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939657+02:00",
    "Name": "Dangl.AspNetCore.FileHandling",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Dangl.AspNetCore.FileHandling",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Dangl.AspNetCore.FileHandling/blob/develop/build/Build.cs",
    "BuildFileSize": 14867,
    "BuildFileContent": "\uFEFFusing Nuke.Azure.KeyVault;\nusing Nuke.CoberturaConverter;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.DocFX;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing static Nuke.CoberturaConverter.CoberturaConverterTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.XmlTasks;\nusing static Nuke.Common.Tools.DotCover.DotCoverTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n    [KeyVault] readonly KeyVault KeyVault;\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    private readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [KeyVaultSecret] private readonly string DocuBaseUrl;\n    [KeyVaultSecret] readonly string GitHubAuthenticationToken;\n    [KeyVaultSecret] readonly string PublicMyGetSource;\n    [KeyVaultSecret] readonly string PublicMyGetApiKey;\n    [KeyVaultSecret] readonly string NuGetApiKey;\n    [KeyVaultSecret(\u0022DanglAspNetCoreFileHandling-DocuApiKey\u0022)] readonly string DocuApiKey;\n\n    [Solution(\u0022Dangl.AspNetCore.FileHandling.sln\u0022)] readonly Solution Solution;\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath SourceDirectory =\u003E SolutionDirectory / \u0022src\u0022;\n\n    string DocFxFile =\u003E SolutionDirectory / \u0022docfx.json\u0022;\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    readonly string DocFxDotNetSdkVersion = \u00222.1.4\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                GlobDirectories(SolutionDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore();\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(x =\u003E x\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore()\n                    .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion));\n            });\n\n    Target Pack =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                    .EscapeStringPropertyForMsBuild();\n\n                DotNetPack(x =\u003E x\n                    .SetConfiguration(Configuration)\n                    .SetPackageReleaseNotes(changeLog)\n                    .SetDescription(\u0022Dangl.AspNetCore.FileHandling www.dangl-it.com\u0022)\n                    .SetTitle(\u0022Dangl.AspNetCore.FileHandling www.dangl-it.com\u0022)\n                    .EnableNoBuild()\n                    .SetOutputDirectory(OutputDirectory)\n                    .SetVersion(GitVersion.NuGetVersion));\n            });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(async () =\u003E\n        {\n            var testProjects = GlobFiles(RootDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022).ToList();\n            var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n            var snapshotIndex = 0;\n\n            DotCoverCover(c =\u003E c\n                    .SetTargetExecutable(dotnetPath)\n                    .SetFilters(\u0022\u002B:Dangl.AspNetCore.FileHandling\u0022)\n                    .SetAttributeFilters(\u0022System.CodeDom.Compiler.GeneratedCodeAttribute\u0022)\n                    .CombineWith(cc =\u003E testProjects.SelectMany(testProject =\u003E\n                    {\n                        var projectDirectory = Path.GetDirectoryName(testProject);\n                        var targetFrameworks = GetTestFrameworksForProjectFile(testProject);\n                        return targetFrameworks.Select(targetFramework =\u003E\n                        {\n                            snapshotIndex\u002B\u002B;\n                            return cc\n                                .SetTargetWorkingDirectory(projectDirectory)\n                                .SetOutputFile(OutputDirectory / $\u0022coverage{snapshotIndex:00}.snapshot\u0022)\n                                .SetTargetArguments($\u0022test --no-build -f {targetFramework} --test-adapter-path:. \\\u0022--logger:xunit;LogFilePath={OutputDirectory}/{snapshotIndex}_testresults-{targetFramework}.xml\\\u0022\u0022);\n                        });\n                    })), degreeOfParallelism: System.Environment.ProcessorCount);\n\n            PrependFrameworkToTestresults();\n\n            var snapshots = GlobFiles(OutputDirectory, \u0022*.snapshot\u0022)\n               .Aggregate((c, n) =\u003E c \u002B \u0022;\u0022 \u002B n);\n\n            DotCoverMerge(c =\u003E c\n                .SetSource(snapshots)\n                .SetOutputFile(OutputDirectory / \u0022coverage.snapshot\u0022));\n\n            DotCoverReport(c =\u003E c\n                .SetSource(OutputDirectory / \u0022coverage.snapshot\u0022)\n                .SetOutputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetReportType(DotCoverReportType.DetailedXml));\n\n            // This is the report that\u0027s pretty and visualized in Jenkins\n            ReportGenerator(c =\u003E c\n                .SetReports(OutputDirectory / \u0022coverage.xml\u0022)\n                .SetTargetDirectory(OutputDirectory / \u0022CoverageReport\u0022));\n\n            // This is the report in Cobertura format that integrates so nice in Jenkins\n            // dashboard and allows to extract more metrics and set build health based\n            // on coverage readings\n            await DotCoverToCobertura(s =\u003E s\n                    .SetInputFile(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetOutputFile(OutputDirectory / \u0022cobertura_coverage.xml\u0022))\n                .ConfigureAwait(false);\n        });\n\n    private IEnumerable\u003Cstring\u003E GetTestFrameworksForProjectFile(string projectFile)\n    {\n        var targetFrameworks = XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFrameworks\u0022)\n            .Concat(XmlPeek(projectFile, \u0022//Project/PropertyGroup//TargetFramework\u0022))\n            .Distinct()\n            .SelectMany(f =\u003E f.Split(\u0027;\u0027))\n            .Distinct();\n        return targetFrameworks;\n    }\n\n    private void PrependFrameworkToTestresults()\n    {\n        var testResults = GlobFiles(OutputDirectory, \u0022*testresults*.xml\u0022).ToList();\n        Logger.Log(LogLevel.Normal, $\u0022Found {testResults.Count} test result files on which to append the framework.\u0022);\n        foreach (var testResultFile in testResults)\n        {\n            var frameworkName = GetFrameworkNameFromFilename(testResultFile);\n            var xDoc = XDocument.Load(testResultFile);\n\n            foreach (var testType in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@type\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testType.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testType.Value;\n            }\n\n            foreach (var testName in ((IEnumerable)xDoc.XPathEvaluate(\u0022//test/@name\u0022)).OfType\u003CXAttribute\u003E())\n            {\n                testName.Value = frameworkName \u002B \u0022\u002B\u0022 \u002B testName.Value;\n            }\n\n            xDoc.Save(testResultFile);\n        }\n\n        // Merge all the results to a single file\n        // The \u0022run-time\u0022 attributes of the single assemblies is ensured to be unique for each single assembly by this test,\n        // since in Jenkins, the format is internally converted to JUnit. Aterwards, results with the same timestamps are\n        // ignored. See here for how the code is translated to JUnit format by the Jenkins plugin:\n        // https://github.com/jenkinsci/xunit-plugin/blob/d970c50a0501f59b303cffbfb9230ba977ce2d5a/src/main/resources/org/jenkinsci/plugins/xunit/types/xunitdotnet-2.0-to-junit.xsl#L75-L79\n        Logger.Log(LogLevel.Normal, \u0022Updating \\\u0022run-time\\\u0022 attributes in assembly entries to prevent Jenkins to treat them as duplicates\u0022);\n        var firstXdoc = XDocument.Load(testResults[0]);\n        var runtime = DateTime.Now;\n        var firstAssemblyNodes = firstXdoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n        foreach (var assemblyNode in firstAssemblyNodes)\n        {\n            assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n            runtime = runtime.AddSeconds(1);\n        }\n        for (var i = 1; i \u003C testResults.Count; i\u002B\u002B)\n        {\n            var xDoc = XDocument.Load(testResults[i]);\n            var assemblyNodes = xDoc.Root.Elements().Where(e =\u003E e.Name.LocalName == \u0022assembly\u0022);\n            foreach (var assemblyNode in assemblyNodes)\n            {\n                assemblyNode.SetAttributeValue(\u0022run-time\u0022, $\u0022{runtime:HH:mm:ss}\u0022);\n                runtime = runtime.AddSeconds(1);\n            }\n            firstXdoc.Root.Add(assemblyNodes);\n        }\n\n        firstXdoc.Save(OutputDirectory / \u0022testresults.xml\u0022);\n        testResults.ForEach(DeleteFile);\n    }\n\n    private string GetFrameworkNameFromFilename(string filename)\n    {\n        var name = Path.GetFileName(filename);\n        name = name.Substring(0, name.Length - \u0022.xml\u0022.Length);\n        var startIndex = name.LastIndexOf(\u0027-\u0027);\n        name = name.Substring(startIndex \u002B 1);\n        return name;\n    }\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E PublicMyGetSource)\n        .Requires(() =\u003E PublicMyGetApiKey)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        // Need to set it here, otherwise it takes the one from NUKEs .tmp directory\n                        .SetToolPath(ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022))\n                        .SetTargetPath(x)\n                        .SetSource(PublicMyGetSource)\n                        .SetApiKey(PublicMyGetApiKey));\n\n                    if (GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n                    {\n                        // Stable releases are published to NuGet\n                        DotNetNuGetPush(s =\u003E s\n                            // Need to set it here, otherwise it takes the one from NUKEs .tmp directory\n                            .SetToolPath(ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022))\n                            .SetTargetPath(x)\n                            .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                            .SetApiKey(NuGetApiKey));\n                    }\n                });\n        });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x.SetProjects(DocFxFile));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(SolutionDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(SolutionDirectory / \u0022README.md\u0022, SolutionDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x.SetConfigFile(DocFxFile));\n\n            File.Delete(SolutionDirectory / \u0022index.md\u0022);\n            Directory.Delete(SolutionDirectory / \u0022api\u0022, true);\n            Directory.Delete(SolutionDirectory / \u0022obj\u0022, true);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(Push) // To have a relation between pushed package version and published docs version\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            var changeLog = GetCompleteChangeLog(ChangeLogFile);\n\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetMarkdownChangelog(changeLog)\n                .SetSourceDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion)\n            );\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(() =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var nuGetPackages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty().ToArray();\n\n            PublishRelease(x =\u003E x\n                .SetArtifactPaths(nuGetPackages)\n                .SetCommitSha(GitVersion.Sha)\n                .SetReleaseNotes(completeChangeLog)\n                .SetRepositoryName(repositoryInfo.repositoryName)\n                .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                .SetTag(releaseTag)\n                .SetToken(GitHubAuthenticationToken))\n                .ConfigureAwait(false)\n                .GetAwaiter()\n                .GetResult();\n        });\n}\n"
  },
  {
    "Id": 135971595,
    "FirstIndexed": "2020-04-25T15:47:03.611423+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630578+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430981+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936858+02:00",
    "Name": "rocketsurgeonsguild.github.io",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/rocketsurgeonsguild.github.io",
    "Description": "Rocket Surgeons Documentation Website",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/rocketsurgeonsguild.github.io/blob/dev/.build/Build.cs",
    "BuildFileSize": 9500,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Utilities.Collections;\nusing Wyam.Core.Execution;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Octokit.Reactive;\nusing Octokit;\nusing System.Reactive.Linq;\nusing System.IO;\nusing Buildalyzer;\nusing System.Reactive.Concurrency;\nusing YamlDotNet.Serialization;\nusing System.Collections.Generic;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Nuke.Common.Tooling;\nusing Wyam.Common.Meta;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.Git;\nusing static Nuke.Common.Tools.Git.GitTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022Branch to deploy to\u0022)]\n    public readonly string DeployToBranch = \u0022local\u0022;\n\n    public IEnumerable\u003CPackageSpec\u003E PackageSpecs =\u003E GlobFiles(RootDirectory / \u0022packages\u0022, \u0022*.yml\u0022, \u0022*.yaml\u0022)\n        .Select(File.ReadAllText)\n        .Select(x =\u003E new DeserializerBuilder().Build().Deserialize\u003CPackageSpec\u003E(x))\n        .ToArray();\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(RefreshPackages)\n        .Executes(() =\u003E\n        {\n            var projectDirectory = TemporaryDirectory / \u0022_project\u0022;\n            var packagesDirectory = TemporaryDirectory / \u0022_packages\u0022;\n            var project = projectDirectory / \u0022project.csproj\u0022;\n            EnsureExistingDirectory(projectDirectory);\n            EnsureExistingDirectory(packagesDirectory);\n            if (!FileExists(project))\n            {\n                System.IO.File.WriteAllText(\n                    project,\n                    @\u0022\n                    \u003CProject Sdk=\u0022\u0022Microsoft.NET.Sdk\u0022\u0022\u003E\n                        \u003CPropertyGroup\u003E\n                            \u003CTargetFramework\u003Enetcoreapp3.1\u003C/TargetFramework\u003E\n                        \u003C/PropertyGroup\u003E\n                    \u003C/Project\u003E\u0022\n                );\n\n                foreach (var packageSpec in PackageSpecs)\n                {\n                    DotNet($\u0022add package {packageSpec.Name} --no-restore\u0022, projectDirectory);\n                }\n            }\n\n            try\n            {\n                DotNetRestore(x =\u003E x\n                    .EnableNoDependencies()\n                    .SetPackageDirectory(packagesDirectory)\n                    .SetWorkingDirectory(projectDirectory)\n                );\n            }\n            catch { }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Wyam.Common.Tracing.Trace.AddListener(new NukeTraceListener());\n            Wyam.Common.Tracing.Trace.Level = SourceLevels.All;\n            var engine = new Engine();\n            new WyamConfiguration(engine, this);\n            engine.Execute();\n        });\n\n    Target Preview =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Wyam.Common.Tracing.Trace.AddListener(new NukeTraceListener());\n            Wyam.Common.Tracing.Trace.Level = SourceLevels.All;\n            PreviewServer.Preview(() =\u003E\n            {\n                var engine = new Engine();\n                engine.Settings[Keys.CleanOutputPath] = false;\n                new WyamConfiguration(engine, this);\n                return engine;\n            }, this);\n        });\n\n    [Parameter(\u0022Github Token - To use when syncing packages\u0022)]\n    readonly string GithubToken = EnvironmentInfo.GetVariable\u003Cstring\u003E(\u0022GITHUB_TOKEN\u0022) ?? string.Empty;\n\n    Target RefreshPackages =\u003E _ =\u003E _\n        .Executes(async () =\u003E\n        {\n            var client = string.IsNullOrWhiteSpace(GithubToken)\n                ? new ObservableGitHubClient(new ProductHeaderValue(\u0022internaltooling.to.update.repo\u0022))\n                : new ObservableGitHubClient(new ProductHeaderValue(\u0022internaltooling.to.update.repo\u0022), new Octokit.Internal.InMemoryCredentialStore(new Credentials(GithubToken)));\n            var repos = client.Repository.GetAllForOrg(\u0022RocketSurgeonsGuild\u0022)\n                .Where(repo =\u003E !repo.Archived)\n                .Where(repo =\u003E IsLocalBuild \u0026\u0026 !DirectoryExists(TemporaryDirectory / repo.Name) || !IsLocalBuild);\n\n            await repos\n                .Select(repo =\u003E\n                {\n                    var path = TemporaryDirectory / repo.Name;\n                    Git($\u0022clone --depth 1 --single-branch {repo.CloneUrl} {path}\u0022, logOutput: false);\n                    return (path, repo);\n                })\n                .ForEachAsync(x =\u003E { });\n\n            var solutions = repos\n                .Select(repo =\u003E (path: TemporaryDirectory / repo.Name, repo))\n                .SelectMany(x =\u003E\n                    Directory.EnumerateFiles(x.path, \u0022*.sln\u0022)\n                        .ToObservable()\n                        .Select(solutionFilePath =\u003E (x.path, x.repo, solutionFilePath))\n                );\n\n            var projects = solutions\n                .Select(x =\u003E (x.path, x.repo, x.solutionFilePath, new AnalyzerManager(x.solutionFilePath)))\n                .SelectMany(x =\u003E\n                {\n                    var (path, repo, solutionFilePath, analyzerManager) = x;\n                    return analyzerManager.Projects\n                        .Where(z =\u003E z.Key.Contains(\u0022/src/\u0022) || z.Key.Contains(@\u0022\\src\\\u0022))\n                        .Select(project =\u003E\n                        {\n                            return (path, repo, solutionFilePath, analyzerManager, projectFilePath: project.Key, project: project.Value, projectBuild: project.Value.Build().First());\n                        })\n                        .ToObservable();\n                })\n                .Distinct(x =\u003E x.projectFilePath);\n\n            await projects\n            .SubscribeOn(TaskPoolScheduler.Default)\n            .ForEachAsync(x =\u003E\n            {\n                var assemblyTitle = x.projectBuild.GetProperty(\u0022AssemblyTitle\u0022);\n                var projectUrl = x.projectBuild.GetProperty(\u0022PackageProjectUrl\u0022);\n                var authors = (x.projectBuild.GetProperty(\u0022Authors\u0022) ?? \u0022\u0022).Split(\u0027,\u0027);\n                var copyright = x.projectBuild.GetProperty(\u0022Copyright\u0022);\n\n                var assemblyName = x.projectBuild.GetProperty(\u0022AssemblyName\u0022);\n                var tags = (x.projectBuild.GetProperty(\u0022PackageTags\u0022) ?? \u0022\u0022).Split(\u0027;\u0027);\n                var targetFrameworks = (x.projectBuild.GetProperty(\u0022TargetFrameworks\u0022) ?? x.projectBuild.GetProperty(\u0022TargetFramework\u0022)).Split(\u0027;\u0027);\n                var description = x.projectBuild.GetProperty(\u0022PackageDescription\u0022);\n\n                var serializer = new SerializerBuilder().Build();\n                var categories = new List\u003Cstring\u003E();\n                if (x.repo.Name.Contains(\u0022.Extensions\u0022))\n                {\n                    categories.Add(\u0022Extensions\u0022);\n                }\n                if (assemblyName.Contains(\u0022.Extensions\u0022))\n                {\n                    categories.Add(\u0022Extensions\u0022);\n                }\n                if (assemblyName.Contains(\u0022.Abstractions\u0022))\n                {\n                    categories.Add(\u0022Abstractions\u0022);\n                }\n                if (assemblyName.Contains(\u0022.AspNetCore\u0022))\n                {\n                    categories.Add(\u0022AspNetCore\u0022);\n                }\n                if (assemblyName.Contains(\u0022.Hosting\u0022))\n                {\n                    categories.Add(\u0022Hosting\u0022);\n                }\n                var yaml = serializer.Serialize(new\n                {\n                    Name = assemblyName,\n                    NuGet = assemblyName,\n                    Assemblies = new[] { $\u0022/{assemblyName.ToLowerInvariant()}/**/{assemblyName}.dll\u0022 },\n                    Repository = x.repo.HtmlUrl,\n                    GitName = x.repo.Name,\n                    GitUrl = x.repo.CloneUrl,\n                    Author = x.projectBuild.GetProperty(\u0022Authors\u0022) ?? \u0022\u0022,\n                    Description = description,\n                    Categories = categories.Concat(new[] {\n                        x.repo.Name.Replace(\u0022.Extensions\u0022, \u0022\u0022).Replace(\u0022.Abstractions\u0022, \u0022\u0022),\n                        assemblyName.Replace(\u0022.Extensions\u0022, \u0022\u0022).Replace(\u0022.Abstractions\u0022, \u0022\u0022).Split(\u0027.\u0027).Last()\n                    }).Distinct().OrderBy(z =\u003E z)\n                });\n\n                EnsureExistingDirectory(RootDirectory / \u0022packages\u0022);\n                File.WriteAllText(Path.Combine(RootDirectory / \u0022packages\u0022, assemblyName.ToLower() \u002B \u0022.yml\u0022), yaml);\n            });\n        });\n}\n\nclass PackageSpec\n{\n    public string Name { get; set; }\n    public string NuGet { get; set; }\n    public bool Prerelease { get; set; }\n    public List\u003Cstring\u003E Assemblies { get; set; }\n    public string Repository { get; set; }\n    public string GitName { get; set; }\n    public string GitUrl { get; set; }\n    public string Author { get; set; }\n    public string Description { get; set; }\n    public List\u003Cstring\u003E Categories { get; set; }\n}\n"
  },
  {
    "Id": 137139682,
    "FirstIndexed": "2020-04-25T15:50:44.7355948+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626806+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434064+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939822+02:00",
    "Name": "WorkflowDemo",
    "Owner": "joaomatossilva",
    "HtmlUrl": "https://github.com/joaomatossilva/WorkflowDemo",
    "Description": "Demo for presentation",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/joaomatossilva/WorkflowDemo/blob/master/build/Build.cs",
    "BuildFileSize": 1636,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n    \n    // [Solution] readonly Solution Solution;\n    // Provides access to the structure of the solution.\n\n    Target Clean =\u003E _ =\u003E _\n            .OnlyWhen(() =\u003E false) // Disabled for safety.\n            .Executes(() =\u003E\n            {\n                DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                MSBuild(s =\u003E DefaultMSBuildCompile);\n            });\n}\n"
  },
  {
    "Id": 137937290,
    "FirstIndexed": "2020-04-25T15:50:44.7362358+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.736237+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434969+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940681+02:00",
    "Name": "json-provider",
    "Owner": "Liminiens",
    "HtmlUrl": "https://github.com/Liminiens/json-provider",
    "Description": "Generative json type provider",
    "Archived": false,
    "Stars": 12,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Liminiens/json-provider/blob/master/build/Build.cs",
    "BuildFileSize": 2932,
    "BuildFileContent": "using System;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.Paket;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n    static Build()\n    {\n        Environment.SetEnvironmentVariable(\u0022GITVERSION_EXE\u0022, RootDirectory / \u0022packages\u0022 / \u0022nukebuild\u0022 / \u0022GitVersion.CommandLine.DotNetCore\u0022 / \u0022tools\u0022 / \u0022GitVersion.dll\u0022);\n        Environment.SetEnvironmentVariable(\u0022PAKET_EXE\u0022, RootDirectory / \u0022.paket\u0022 / \u0022paket.exe\u0022);\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022JsonProvider.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetResultsDirectory(OutputDirectory / \u0022tests\u0022));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            PaketTasks.PaketPack(s =\u003E s\n                .SetTemplateFile(RootDirectory / \u0022src\u0022 / \u0022JsonProvider.Runtime\u0022 / \u0022paket.template\u0022)\n                .SetBuildConfiguration(Configuration)\n                .EnableSymbols()\n                .SetOutputDirectory(OutputDirectory)\n                .SetPackageVersion(GitVersion.NuGetVersionV2));\n        });\n}\n"
  },
  {
    "Id": 138009154,
    "FirstIndexed": "2020-04-25T15:47:03.6116653+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632012+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8430992+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936876+02:00",
    "Name": "AvalonStudio.Shell",
    "Owner": "VitalElement",
    "HtmlUrl": "https://github.com/VitalElement/AvalonStudio.Shell",
    "Description": "Reusable Shell components from AvalonStudio.",
    "Archived": false,
    "Stars": 33,
    "Watchers": 8,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/VitalElement/AvalonStudio.Shell/blob/master/build/Build.cs",
    "BuildFileSize": 4868,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.CreateNugetPackages);\n\n\tBuildParameters Parameters { get; set; }\n\n\t[Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n\tprotected override void OnBuildInitialized()\n\t{\n\t\tbase.OnBuildInitialized();\n\n\t\tParameters = new BuildParameters(this);\n\t\tInformation(\u0022Building version {0} of AvalonStudio.Shell ({1}) using version {2} of Nuke.\u0022,\n\t\t\tParameters.Version,\n\t\t\tParameters.Configuration,\n\t\t\ttypeof(NukeBuild).Assembly.GetName().Version.ToString());\n\n\t\tif (Parameters.IsLocalBuild)\n\t\t{\n\t\t\tInformation(\u0022Repository Name: \u0022 \u002B Parameters.RepositoryName);\n\t\t\tInformation(\u0022Repository Branch: \u0022 \u002B Parameters.RepositoryBranch);\n\t\t}\n\t\tInformation(\u0022Configuration: \u0022 \u002B Parameters.Configuration);\n\t\tInformation(\u0022IsLocalBuild: \u0022 \u002B Parameters.IsLocalBuild);\n\t\tInformation(\u0022IsRunningOnUnix: \u0022 \u002B Parameters.IsRunningOnUnix);\n\t\tInformation(\u0022IsRunningOnWindows: \u0022 \u002B Parameters.IsRunningOnWindows);\n\t\tInformation(\u0022IsRunningOnAzure:\u0022 \u002B Parameters.IsRunningOnAzure);\n\t\tInformation(\u0022IsPullRequest: \u0022 \u002B Parameters.IsPullRequest);\n\t\tInformation(\u0022IsMainRepo: \u0022 \u002B Parameters.IsMainRepo);\n\t\tInformation(\u0022IsMasterBranch: \u0022 \u002B Parameters.IsMasterBranch);\n\t\tInformation(\u0022IsReleaseBranch: \u0022 \u002B Parameters.IsReleaseBranch);\n\t\tInformation(\u0022IsReleasable: \u0022 \u002B Parameters.IsReleasable);\n\t\tInformation(\u0022IsMyGetRelease: \u0022 \u002B Parameters.IsMyGetRelease);\n\t\tInformation(\u0022IsNuGetRelease: \u0022 \u002B Parameters.IsNuGetRelease);\n\n\t\tvoid ExecWait(string preamble, string command, string args)\n\t\t{\n\t\t\tConsole.WriteLine(preamble);\n\t\t\tProcess.Start(new ProcessStartInfo(command, args) { UseShellExecute = false }).WaitForExit();\n\t\t}\n\t\tExecWait(\u0022dotnet version:\u0022, \u0022dotnet\u0022, \u0022--version\u0022);\n\t\tif (Parameters.IsRunningOnUnix)\n\t\t\tExecWait(\u0022Mono version:\u0022, \u0022mono\u0022, \u0022--version\u0022);\n\t}\n\n\tTarget Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n\t\t\tDeleteDirectories(Parameters.BuildDirs);\n\t\t\tEnsureCleanDirectories(Parameters.BuildDirs);\n\t\t\tEnsureCleanDirectory(Parameters.ArtifactsDir);\n\t\t\tEnsureCleanDirectory(Parameters.NugetIntermediateRoot);\n\t\t\tEnsureCleanDirectory(Parameters.NugetRoot);\n\t\t\tEnsureCleanDirectory(Parameters.ZipRoot);\n\t\t\tEnsureCleanDirectory(Parameters.TestResultsRoot);\n\t\t\tEnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n\tTarget CreateIntermediateNugetPackages =\u003E _ =\u003E _\n\t.DependsOn(Compile)\n\t.Executes(() =\u003E\n\t{\n\t\tEnsureCleanDirectory(Parameters.NugetIntermediateRoot);\n\n\t\tDotNetPack(Solution, x =\u003E\n\t\tx.SetConfiguration(Configuration)\n\t\t.SetOutputDirectory(Parameters.NugetIntermediateRoot)\n\t\t.AddProperty(\u0022PackageVersion\u0022, Parameters.Version));\n\t});\n\n\tTarget CreateNugetPackages =\u003E _ =\u003E _\n\t\t.DependsOn(CreateIntermediateNugetPackages)\n\t\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tvar logger = new NumergeNukeLogger();\n\t\t\tvar config = Numerge.MergeConfiguration.LoadFile(RootDirectory / \u0022build\u0022 / \u0022numerge.config\u0022);\n\t\t\tEnsureCleanDirectory(Parameters.NugetRoot);\n\t\t\tif (!Numerge.NugetPackageMerger.Merge(Parameters.NugetIntermediateRoot, Parameters.NugetRoot, config,\n\t\t\t\tlogger))\n\t\t\t\tthrow new Exception(\u0022Package merge failed\u0022);\n\t\t});\n\n\tTarget CiAzureWindows =\u003E _ =\u003E _\n\t\t.DependsOn(CreateNugetPackages);\n}\n"
  },
  {
    "Id": 138096230,
    "FirstIndexed": "2020-04-25T15:50:44.7359212+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629685+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434616+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940334+02:00",
    "Name": "LibHac",
    "Owner": "Thealexbarney",
    "HtmlUrl": "https://github.com/Thealexbarney/LibHac",
    "Description": "A library for reading file formats used by the Nintendo Switch OS",
    "Archived": false,
    "Stars": 111,
    "Watchers": 9,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Thealexbarney/LibHac/blob/master/build/Build.cs",
    "BuildFileSize": 23405,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing ICSharpCode.SharpZipLib.Zip;\nusing LibHacBuild.CodeGen;\nusing Nuke.Common;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.SignTool;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nnamespace LibHacBuild\n{\n    partial class Build : NukeBuild\n    {\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Standard);\n\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        public readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n        [Parameter(\u0022Don\u0027t enable any size-reducing settings on native builds.\u0022)]\n        public readonly bool Untrimmed;\n\n        [Solution(\u0022LibHac.sln\u0022)] readonly Solution _solution;\n\n        AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n        AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n        AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n        AbsolutePath SignedArtifactsDirectory =\u003E ArtifactsDirectory / \u0022signed\u0022;\n        AbsolutePath TempDirectory =\u003E RootDirectory / \u0022.tmp\u0022;\n        AbsolutePath CliCoreDir =\u003E TempDirectory / \u0022hactoolnet_netcoreapp3.1\u0022;\n        AbsolutePath CliNativeDir =\u003E TempDirectory / $\u0022hactoolnet_{HostOsName}\u0022;\n        AbsolutePath CliNativeExe =\u003E CliNativeDir / $\u0022hactoolnet{NativeProgramExtension}\u0022;\n        AbsolutePath CliCoreZip =\u003E ArtifactsDirectory / $\u0022hactoolnet-{VersionString}-netcore.zip\u0022;\n        AbsolutePath CliNativeZip =\u003E ArtifactsDirectory / $\u0022hactoolnet-{VersionString}-{HostOsName}.zip\u0022;\n\n        Project LibHacProject =\u003E _solution.GetProject(\u0022LibHac\u0022).NotNull();\n        Project LibHacTestProject =\u003E _solution.GetProject(\u0022LibHac.Tests\u0022).NotNull();\n        Project HactoolnetProject =\u003E _solution.GetProject(\u0022hactoolnet\u0022).NotNull();\n\n        private bool HasGitDir { get; set; }\n\n        private string NativeRuntime { get; set; }\n        private string HostOsName { get; set; }\n        private string NativeProgramExtension { get; set; }\n\n        string VersionString { get; set; }\n        Dictionary\u003Cstring, object\u003E VersionProps { get; set; } = new Dictionary\u003Cstring, object\u003E();\n\n        const string CertFileName = \u0022cert.pfx\u0022;\n\n        public Build()\n        {\n            if (EnvironmentInfo.IsWin)\n            {\n                NativeRuntime = \u0022win-x64\u0022;\n                NativeProgramExtension = \u0022.exe\u0022;\n                HostOsName = \u0022win\u0022;\n            }\n            else if (EnvironmentInfo.IsLinux)\n            {\n                NativeRuntime = \u0022linux-x64\u0022;\n                NativeProgramExtension = \u0022\u0022;\n                HostOsName = \u0022linux\u0022;\n            }\n            else if (EnvironmentInfo.IsOsx)\n            {\n                NativeRuntime = \u0022osx-x64\u0022;\n                NativeProgramExtension = \u0022\u0022;\n                HostOsName = \u0022macos\u0022;\n            }\n        }\n\n        Target SetVersion =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                GitRepository gitRepository = null;\n                GitVersion gitVersion = null;\n\n                try\n                {\n                    gitRepository = (GitRepository)new GitRepositoryAttribute().GetValue(null, null);\n\n                    gitVersion = GitVersionTasks.GitVersion(s =\u003E s\n                            .SetFramework(\u0022netcoreapp3.1\u0022)\n                            .DisableLogOutput())\n                        .Result;\n                }\n                catch (Exception e)\n                {\n                    Logger.Error(e);\n                }\n\n                if (gitRepository == null || gitVersion == null)\n                {\n                    Logger.Normal(\u0022Unable to read Git version.\u0022);\n                    return;\n                }\n\n                HasGitDir = true;\n\n                VersionString = $\u0022{gitVersion.MajorMinorPatch}\u0022;\n                if (!string.IsNullOrWhiteSpace(gitVersion.PreReleaseTag))\n                {\n                    VersionString \u002B= $\u0022-{gitVersion.PreReleaseTag}\u002B{gitVersion.Sha.Substring(0, 8)}\u0022;\n                }\n\n                string suffix = gitVersion.PreReleaseTag;\n\n                if (!string.IsNullOrWhiteSpace(suffix))\n                {\n                    if (!gitRepository.IsOnMasterBranch())\n                    {\n                        suffix = $\u0022-{suffix}\u0022;\n                    }\n\n                    suffix \u002B= $\u0022\u002B{gitVersion.Sha.Substring(0, 8)}\u0022;\n                }\n\n                if (Host == HostType.AppVeyor)\n                {\n                    // Workaround GitVersion issue by getting PR info manually https://github.com/GitTools/GitVersion/issues/1927\n                    string prNumber = Environment.GetEnvironmentVariable(\u0022APPVEYOR_PULL_REQUEST_NUMBER\u0022);\n                    string branchName = Environment.GetEnvironmentVariable(\u0022APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH\u0022);\n\n                    if (int.TryParse(prNumber, out int prInt) \u0026\u0026 branchName != null)\n                    {\n                        string prString = $\u0022PullRequest{prInt:D4}\u0022;\n\n                        VersionString = VersionString.Replace(branchName, prString);\n                        suffix = suffix.Replace(branchName, prString);\n                    }\n\n                    SetAppVeyorVersion(VersionString);\n                }\n\n                VersionProps = new Dictionary\u003Cstring, object\u003E\n                {\n                    [\u0022VersionPrefix\u0022] = gitVersion.AssemblySemVer,\n                    [\u0022VersionSuffix\u0022] = suffix\n                };\n\n                Logger.Normal($\u0022Building version {VersionString}\u0022);\n            });\n\n        Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                List\u003Cstring\u003E toDelete = GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022)\n                    .Concat(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022)).ToList();\n\n                foreach (string dir in toDelete)\n                {\n                    DeleteDirectory(dir);\n                }\n\n                EnsureCleanDirectory(ArtifactsDirectory);\n                EnsureCleanDirectory(CliCoreDir);\n                EnsureCleanDirectory(CliNativeDir);\n            });\n\n        Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestoreSettings settings = new DotNetRestoreSettings()\n                    .SetProjectFile(_solution);\n\n                DotNetRestore(s =\u003E settings);\n            });\n\n        Target Codegen =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                ResultCodeGen.Run();\n            });\n\n        Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore, SetVersion, Codegen)\n            .Executes(() =\u003E\n            {\n                DotNetBuildSettings buildSettings = new DotNetBuildSettings()\n                    .SetProjectFile(_solution)\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration)\n                    .SetProperties(VersionProps)\n                    .SetProperty(\u0022BuildType\u0022, \u0022Release\u0022)\n                    .SetProperty(\u0022HasGitDir\u0022, HasGitDir);\n\n                DotNetBuild(s =\u003E buildSettings);\n\n                DotNetPublishSettings publishSettings = new DotNetPublishSettings()\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration);\n\n                DotNetPublish(s =\u003E publishSettings\n                    .SetProject(HactoolnetProject)\n                    .SetFramework(\u0022netcoreapp3.1\u0022)\n                    .SetOutput(CliCoreDir)\n                    .SetNoBuild(true)\n                    .SetProperties(VersionProps));\n\n                // Hack around OS newline differences\n                if (EnvironmentInfo.IsUnix)\n                {\n                    foreach (string filename in Directory.EnumerateFiles(CliCoreDir, \u0022*.json\u0022))\n                    {\n                        ReplaceLineEndings(filename);\n                    }\n                }\n            });\n\n        Target Pack =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                DotNetPackSettings settings = new DotNetPackSettings()\n                    .SetProject(LibHacProject)\n                    .EnableNoBuild()\n                    .SetConfiguration(Configuration)\n                    .EnableIncludeSymbols()\n                    .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                    .SetOutputDirectory(ArtifactsDirectory)\n                    .SetProperties(VersionProps);\n\n                DotNetPack(s =\u003E settings);\n\n                foreach (string filename in Directory.EnumerateFiles(ArtifactsDirectory, \u0022*.*nupkg\u0022))\n                {\n                    RepackNugetPackage(filename);\n                }\n\n                if (Host != HostType.AppVeyor) return;\n\n                foreach (string filename in Directory.EnumerateFiles(ArtifactsDirectory, \u0022*.*nupkg\u0022))\n                {\n                    PushArtifact(filename);\n                }\n            });\n\n        Target Test =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                DotNetTestSettings settings = new DotNetTestSettings()\n                    .SetProjectFile(LibHacTestProject)\n                    .EnableNoBuild()\n                    .SetConfiguration(Configuration);\n\n                if (EnvironmentInfo.IsUnix) settings = settings.SetProperty(\u0022TargetFramework\u0022, \u0022netcoreapp3.1\u0022);\n\n                DotNetTest(s =\u003E settings);\n            });\n\n        Target Zip =\u003E _ =\u003E _\n            .DependsOn(Pack)\n            .After(Native)\n            .Executes(() =\u003E\n            {\n                string[] namesCore = Directory.EnumerateFiles(CliCoreDir, \u0022*.json\u0022)\n                    .Concat(Directory.EnumerateFiles(CliCoreDir, \u0022*.dll\u0022))\n                    .ToArray();\n\n                EnsureExistingDirectory(ArtifactsDirectory);\n\n                ZipFiles(CliCoreZip, namesCore);\n                Logger.Normal($\u0022Created {CliCoreZip}\u0022);\n\n                if (Host == HostType.AppVeyor)\n                {\n                    PushArtifact(CliCoreZip);\n                }\n            });\n\n        Target Publish =\u003E _ =\u003E _\n            .DependsOn(Test, Pack)\n            .OnlyWhenStatic(() =\u003E AppVeyor.Instance != null \u0026\u0026 AppVeyor.Instance.PullRequestTitle == null)\n            .Executes(() =\u003E\n            {\n                AbsolutePath nupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).Single();\n                AbsolutePath snupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.snupkg\u0022).Single();\n\n                string apiKey = EnvironmentInfo.GetVariable\u003Cstring\u003E(\u0022myget_api_key\u0022);\n                DotNetNuGetPushSettings settings = new DotNetNuGetPushSettings()\n                    .SetApiKey(apiKey)\n                    .SetSymbolApiKey(apiKey)\n                    .SetSource(\u0022https://www.myget.org/F/libhac/api/v2/package\u0022)\n                    .SetSymbolSource(\u0022https://www.myget.org/F/libhac/symbols/api/v2/package\u0022);\n\n                DotNetNuGetPush(settings.SetTargetPath(nupkgFile));\n                DotNetNuGetPush(settings.SetTargetPath(snupkgFile));\n            });\n\n        Target Sign =\u003E _ =\u003E _\n            .DependsOn(Test, Zip)\n            .OnlyWhenStatic(() =\u003E File.Exists(CertFileName))\n            .OnlyWhenStatic(() =\u003E EnvironmentInfo.IsWin)\n            .Executes(() =\u003E\n            {\n                string pwd = ReadPassword();\n\n                if (pwd == string.Empty)\n                {\n                    Logger.Normal(\u0022Skipping sign task\u0022);\n                    return;\n                }\n\n                SignAndReZip(pwd);\n            });\n\n        Target Native =\u003E _ =\u003E _\n            .DependsOn(SetVersion)\n            .After(Compile)\n            .Executes(BuildNative);\n\n        // ReSharper disable once UnusedMember.Local\n        Target AppVeyorBuild =\u003E _ =\u003E _\n            .DependsOn(Zip, Native, Publish)\n            .Unlisted()\n            .Executes(PrintResults);\n\n        Target Standard =\u003E _ =\u003E _\n            .DependsOn(Test, Zip)\n            .Executes(PrintResults);\n\n        // ReSharper disable once UnusedMember.Local\n        Target Full =\u003E _ =\u003E _\n            .DependsOn(Sign, Native)\n            .Executes(PrintResults);\n\n        public void PrintResults()\n        {\n            Logger.Normal(\u0022SHA-1:\u0022);\n            using (var sha = SHA1.Create())\n            {\n                foreach (string filename in Directory.EnumerateFiles(ArtifactsDirectory))\n                {\n                    using (var stream = new FileStream(filename, FileMode.Open))\n                    {\n                        string hash = BitConverter.ToString(sha.ComputeHash(stream)).Replace(\u0022-\u0022, \u0022\u0022);\n                        Logger.Normal($\u0022{hash} - {Path.GetFileName(filename)}\u0022);\n                    }\n                }\n            }\n        }\n\n        [SuppressMessage(\u0022ReSharper\u0022, \u0022PossibleNullReferenceException\u0022)]\n        public void BuildNative()\n        {\n            string buildType = Untrimmed ? \u0022native-untrimmed\u0022 : \u0022native\u0022;\n\n            DotNetPublishSettings publishSettings = new DotNetPublishSettings()\n                .SetConfiguration(Configuration)\n                .SetProject(HactoolnetProject)\n                .SetRuntime(NativeRuntime)\n                .SetOutput(CliNativeDir)\n                .SetProperties(VersionProps)\n                .AddProperty(\u0022BuildType\u0022, buildType);\n\n            DotNetPublish(publishSettings);\n\n            if (EnvironmentInfo.IsUnix \u0026\u0026 !Untrimmed)\n            {\n                File.Copy(CliNativeExe, CliNativeExe \u002B \u0022_unstripped\u0022, true);\n                ProcessTasks.StartProcess(\u0022strip\u0022, CliNativeExe).AssertZeroExitCode();\n            }\n\n            EnsureExistingDirectory(ArtifactsDirectory);\n\n            ZipFile(CliNativeZip, CliNativeExe, $\u0022hactoolnet{NativeProgramExtension}\u0022);\n            Logger.Normal($\u0022Created {CliNativeZip}\u0022);\n\n            if (Host == HostType.AppVeyor)\n            {\n                PushArtifact(CliNativeZip);\n            }\n        }\n\n        public static void ZipFiles(string outFile, IEnumerable\u003Cstring\u003E files)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                foreach (string file in files)\n                {\n                    var entry = new ZipEntry(Path.GetFileName(file));\n                    entry.DateTime = DateTime.UnixEpoch;\n\n                    using (FileStream fs = File.OpenRead(file))\n                    {\n                        entry.Size = fs.Length;\n                        s.PutNextEntry(entry);\n                        fs.CopyTo(s);\n                    }\n                }\n            }\n        }\n\n        public static void ZipFile(string outFile, string file, string nameInsideZip)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                var entry = new ZipEntry(nameInsideZip);\n                entry.DateTime = DateTime.UnixEpoch;\n\n                using (FileStream fs = File.OpenRead(file))\n                {\n                    entry.Size = fs.Length;\n                    s.PutNextEntry(entry);\n                    fs.CopyTo(s);\n                }\n            }\n        }\n\n        public static void ZipDirectory(string outFile, string directory)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                foreach (string filePath in Directory.EnumerateFiles(directory, \u0022*\u0022, SearchOption.AllDirectories))\n                {\n                    string relativePath = Path.GetRelativePath(directory, filePath);\n\n                    var entry = new ZipEntry(relativePath);\n                    entry.DateTime = DateTime.UnixEpoch;\n\n                    using (FileStream fs = File.OpenRead(filePath))\n                    {\n                        entry.Size = fs.Length;\n                        s.PutNextEntry(entry);\n                        fs.CopyTo(s);\n                    }\n                }\n            }\n        }\n\n        public static void ZipDirectory(string outFile, string directory, IEnumerable\u003Cstring\u003E files)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                foreach (string filePath in files)\n                {\n                    string absolutePath = Path.Combine(directory, filePath);\n\n                    var entry = new ZipEntry(filePath);\n                    entry.DateTime = DateTime.UnixEpoch;\n\n                    using (FileStream fs = File.OpenRead(absolutePath))\n                    {\n                        entry.Size = fs.Length;\n                        s.PutNextEntry(entry);\n                        fs.CopyTo(s);\n                    }\n                }\n            }\n        }\n\n        public static void UnzipFiles(string zipFile, string outDir)\n        {\n            using (var s = new ZipInputStream(File.OpenRead(zipFile)))\n            {\n                ZipEntry entry;\n                while ((entry = s.GetNextEntry()) != null)\n                {\n                    string outPath = Path.Combine(outDir, entry.Name);\n\n                    string directoryName = Path.GetDirectoryName(outPath);\n                    string fileName = Path.GetFileName(outPath);\n\n                    if (!string.IsNullOrWhiteSpace(directoryName))\n                    {\n                        Directory.CreateDirectory(directoryName);\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(fileName))\n                    {\n                        using (FileStream outFile = File.Create(outPath))\n                        {\n                            s.CopyTo(outFile);\n                        }\n                    }\n                }\n            }\n        }\n\n        public static void PushArtifact(string path)\n        {\n            if (!File.Exists(path))\n            {\n                Logger.Warn($\u0022Unable to add artifact {path}\u0022);\n            }\n\n            var psi = new ProcessStartInfo\n            {\n                FileName = \u0022appveyor\u0022,\n                Arguments = $\u0022PushArtifact \\\u0022{path}\\\u0022\u0022,\n                UseShellExecute = false,\n                RedirectStandardOutput = true,\n                RedirectStandardError = true\n            };\n\n            var proc = new Process\n            {\n                StartInfo = psi\n            };\n\n            proc.Start();\n\n            proc.WaitForExit();\n\n            Logger.Normal($\u0022Added AppVeyor artifact {path}\u0022);\n        }\n\n        public static void SetAppVeyorVersion(string version)\n        {\n            var psi = new ProcessStartInfo\n            {\n                FileName = \u0022appveyor\u0022,\n                Arguments = $\u0022UpdateBuild -Version \\\u0022{version}\\\u0022\u0022,\n                UseShellExecute = false,\n                RedirectStandardOutput = true,\n                RedirectStandardError = true\n            };\n\n            var proc = new Process\n            {\n                StartInfo = psi\n            };\n\n            proc.Start();\n\n            proc.WaitForExit();\n        }\n\n        public static void ReplaceLineEndings(string filename)\n        {\n            string text = File.ReadAllText(filename);\n            File.WriteAllText(filename, Regex.Replace(text, @\u0022\\r\\n|\\n\\r|\\n|\\r\u0022, \u0022\\r\\n\u0022));\n        }\n\n        public static void SignAssemblies(string password, params string[] fileNames)\n        {\n            SignToolSettings settings = new SignToolSettings()\n                .SetFileDigestAlgorithm(\u0022SHA256\u0022)\n                .SetFile(CertFileName)\n                .SetFiles(fileNames)\n                .SetPassword(password)\n                .SetTimestampServerDigestAlgorithm(\u0022SHA256\u0022)\n                .SetRfc3161TimestampServerUrl(\u0022http://timestamp.digicert.com\u0022);\n\n            SignToolTasks.SignTool(settings);\n        }\n\n        public void SignAndReZip(string password)\n        {\n            AbsolutePath nupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).Single();\n            AbsolutePath snupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.snupkg\u0022).Single();\n            AbsolutePath nupkgDir = TempDirectory / (\u0022sign_\u0022 \u002B Path.GetFileName(nupkgFile));\n            AbsolutePath coreFxDir = TempDirectory / (\u0022sign_\u0022 \u002B Path.GetFileName(CliCoreZip));\n            AbsolutePath nativeZipDir = TempDirectory / (\u0022sign_\u0022 \u002B Path.GetFileName(CliNativeZip));\n\n            bool signNative = FileExists(CliNativeExe);\n\n            try\n            {\n                UnzipFiles(CliCoreZip, coreFxDir);\n                List\u003Cstring\u003E pkgFileList = UnzipPackage(nupkgFile, nupkgDir);\n\n                var toSign = new List\u003CAbsolutePath\u003E();\n                toSign.AddRange(nupkgDir.GlobFiles(\u0022**/LibHac.dll\u0022));\n                toSign.Add(coreFxDir / \u0022hactoolnet.dll\u0022);\n\n                if (signNative)\n                {\n                    UnzipFiles(CliNativeZip, nativeZipDir);\n                    toSign.Add(nativeZipDir / \u0022hactoolnet.exe\u0022);\n                }\n\n                Directory.CreateDirectory(SignedArtifactsDirectory);\n\n                SignAssemblies(password, toSign.Select(x =\u003E x.ToString()).ToArray());\n\n                // Avoid having multiple signed versions of the same file\n                File.Copy(nupkgDir / \u0022lib\u0022 / \u0022netcoreapp3.0\u0022 / \u0022LibHac.dll\u0022, coreFxDir / \u0022LibHac.dll\u0022, true);\n\n                ZipDirectory(SignedArtifactsDirectory / Path.GetFileName(nupkgFile), nupkgDir, pkgFileList);\n                ZipDirectory(SignedArtifactsDirectory / Path.GetFileName(CliCoreZip), coreFxDir);\n\n                if (signNative)\n                {\n                    ZipDirectory(SignedArtifactsDirectory / Path.GetFileName(CliNativeZip), nativeZipDir);\n                }\n\n                File.Copy(snupkgFile, SignedArtifactsDirectory / Path.GetFileName(snupkgFile));\n\n                SignNupkg(SignedArtifactsDirectory / Path.GetFileName(nupkgFile), password);\n                SignNupkg(SignedArtifactsDirectory / Path.GetFileName(snupkgFile), password);\n            }\n            catch (Exception)\n            {\n                Directory.Delete(SignedArtifactsDirectory, true);\n                throw;\n            }\n            finally\n            {\n                Directory.Delete(nupkgDir, true);\n                Directory.Delete(coreFxDir, true);\n            }\n        }\n\n        public static string ReadPassword()\n        {\n            var pwd = new StringBuilder();\n            ConsoleKeyInfo key;\n\n            Console.Write(\u0022Enter certificate password (Empty password to skip): \u0022);\n            do\n            {\n                key = Console.ReadKey(true);\n\n                // Ignore any key out of range.\n                if (((int)key.Key) \u003E= \u0027!\u0027 \u0026\u0026 ((int)key.Key \u003C= \u0027~\u0027))\n                {\n                    // Append the character to the password.\n                    pwd.Append(key.KeyChar);\n                    Console.Write(\u0022*\u0022);\n                }\n\n                // Exit if Enter key is pressed.\n            } while (key.Key != ConsoleKey.Enter);\n\n            Console.WriteLine();\n\n            return pwd.ToString();\n        }\n    }\n}\n"
  },
  {
    "Id": 138688087,
    "FirstIndexed": "2020-04-25T15:50:44.7356886+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627255+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434462+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940181+02:00",
    "Name": "StyleCop",
    "Owner": "longzai2651",
    "HtmlUrl": "https://github.com/longzai2651/StyleCop",
    "Description": "\u4EE3\u7801\u5BA1\u67E5",
    "Archived": false,
    "Stars": 1,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/longzai2651/StyleCop/blob/master/build/Build.cs",
    "BuildFileSize": 5097,
    "BuildFileContent": "\uFEFF// /*\n//  * Copyright 2007-2015 JetBrains\n//  *\n//  * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n//  * you may not use this file except in compliance with the License.\n//  * You may obtain a copy of the License at\n//  *\n//  * http://www.apache.org/licenses/LICENSE-2.0\n//  *\n//  * Unless required by applicable law or agreed to in writing, software\n//  * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  * See the License for the specific language governing permissions and\n//  * limitations under the License.\n//  */\n\nusing System;\nusing System.IO;\nusing System.Linq;\n\nusing Newtonsoft.Json.Linq;\n\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Core;\nusing Nuke.Core.Tooling;\nusing Nuke.Core.Utilities;\nusing Nuke.Core.Utilities.Collections;\n\nusing static Nuke.Core.IO.HttpTasks;\nusing static Nuke.Core.IO.SerializationTasks;\nusing static Nuke.Core.IO.TextTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Core.Tooling.NuGetPackageResolver;\nusing static Nuke.Core.IO.FileSystemTasks;\nusing static Nuke.Core.IO.PathConstruction;\nusing static Nuke.Core.Logger;\nusing static Nuke.Core.Tooling.ProcessTasks;\n\n// ReSharper disable ArrangeThisQualifier\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter] readonly string Source = \u0022https://resharper-plugins.jetbrains.com/api/v2/package\u0022;\n    [Parameter] readonly string ApiKey;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    string ProjectFile =\u003E GlobFiles(SolutionDirectory, \u0022**/*.csproj\u0022).Single();\n    string PackagesConfigFile =\u003E GlobFiles(SolutionDirectory, \u0022**/packages.config\u0022).Single();\n\n    Target InstallHive =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var jsonResponse =\n                HttpDownloadString(\u0022https://data.services.jetbrains.com/products/releases?code=RSU\u0026latest=true\u0022);\n            var downloadUrl = JsonDeserialize\u003CJObject\u003E(jsonResponse)[\u0022RSU\u0022].First[\u0022downloads\u0022][\u0022windows\u0022][\u0022link\u0022]\n                .ToString();\n            var installer = TemporaryDirectory / new Uri(downloadUrl).Segments.Last();\n            var installationHive = MSBuildParseProject(ProjectFile).Properties[\u0022InstallationHive\u0022];\n\n            if (!File.Exists(installer)) HttpDownloadFile(downloadUrl, installer);\n\n            Info($\u0022Installing \u0027{Path.GetFileNameWithoutExtension(installer)}\u0027 into \u0027{installationHive}\u0027 hive...\u0022);\n            StartProcess(installer,\n                    $\u0022/VsVersion=12.0;14.0;15.0 /SpecificProductNames=ReSharper /Hive={installationHive} /Silent=True\u0022)\n                .AssertZeroExitCode();\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            NuGetRestore(s =\u003E DefaultNuGetRestore);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E DefaultMSBuildCompile);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var releaseNotes = ReadAllLines(RootDirectory / \u0022CHANGELOG.md\u0022)\n                .SkipWhile(x =\u003E !x.StartsWith(\u0022##\u0022))\n                .Skip(count: 1)\n                .TakeWhile(x =\u003E !string.IsNullOrWhiteSpace(x))\n                .Select(x =\u003E $\u0022\\u2022{x.TrimStart(\u0027-\u0027)}\u0022)\n                .JoinNewLine();\n\n            GlobFiles(RootDirectory / \u0022install\u0022, \u0022*.nuspec\u0022)\n                .ForEach(x =\u003E NuGetPack(s =\u003E DefaultNuGetPack\n                    .SetTargetPath(x)\n                    .SetBasePath(RootDirectory / \u0022install\u0022)\n                    .SetProperty(\u0022wave\u0022, GetWaveVersion(PackagesConfigFile) \u002B \u0022.0\u0022)\n                    .SetProperty(\u0022currentyear\u0022, DateTime.Now.Year.ToString())\n                    .SetProperty(\u0022releasenotes\u0022, releaseNotes)\n                    .EnableNoPackageAnalysis()));\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022Release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022)\n                .ForEach(x =\u003E NuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)));\n        });\n\n    static string GetWaveVersion(string packagesConfigFile)\n    {\n        var fullWaveVersion = GetLocalInstalledPackages(packagesConfigFile, includeDependencies: true)\n            .SingleOrDefault(x =\u003E x.Id == \u0022Wave\u0022).NotNull(\u0022fullWaveVersion != null\u0022).Version.ToString();\n        return fullWaveVersion.Substring(startIndex: 0, length: fullWaveVersion.IndexOf(value: \u0027.\u0027));\n    }\n}"
  },
  {
    "Id": 138924462,
    "FirstIndexed": "2020-04-25T15:47:03.6114372+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631375+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431004+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936887+02:00",
    "Name": "pcf-ers-dotnetcore-demo",
    "Owner": "Pivotal-Field-Engineering",
    "HtmlUrl": "https://github.com/Pivotal-Field-Engineering/pcf-ers-dotnetcore-demo",
    "Description": null,
    "Archived": false,
    "Stars": 5,
    "Watchers": 30,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Pivotal-Field-Engineering/pcf-ers-dotnetcore-demo/blob/master/build/Build.cs",
    "BuildFileSize": 9860,
    "BuildFileContent": "using System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.CloudFoundry;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.Git;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.CloudFoundry.CloudFoundryTasks;\r\n\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n//[AzureDevopsConfigurationGenerator(\r\n//    VcsTriggeredTargets = new[]{\u0022Pack\u0022}\r\n//)]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E();\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    string Runtime =\u003E \u0022netcoreapp2.2\u0022;\r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    [Solution] readonly Solution Solution;\r\n\r\n    [GitRepository] GitRepository GitRepository;\r\n//    [GitVersion] public GitVersion GitVersion { get; set; }\r\n\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n    [Parameter(\u0022Cloud Foundry Username\u0022)]\r\n    readonly string CfUsername;\r\n    [Parameter(\u0022Cloud Foundry Password\u0022)]\r\n    readonly string CfPassword;\r\n    [Parameter(\u0022Cloud Foundry Endpoint\u0022)]\r\n    readonly string CfApiEndpoint;\r\n    [Parameter(\u0022Cloud Foundry Org\u0022)]\r\n    readonly string CfOrg;\r\n    [Parameter(\u0022Cloud Foundry Space\u0022)]\r\n    readonly string CfSpace;\r\n    [Parameter(\u0022Number of apps (for distributed tracing)\u0022)]\r\n    readonly int AppsCount = 3;    \r\n    [Parameter(\u0022Type of database plan (default: db-small)\u0022)]\r\n    readonly string DbPlan = \u0022db-small\u0022;\r\n\r\n    [Parameter(\u0022Skip logging in Cloud Foundry and use the current logged in session\u0022)] \r\n    readonly bool CfSkipLogin;\r\n\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    AbsolutePath PublishDirectory =\u003E RootDirectory / \u0022src\u0022 / \u0022bin\u0022 / Configuration / \u0022netcoreapp2.2\u0022 / \u0022publish\u0022;\r\n    string PackageZipName =\u003E $\u0022articulate-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    // Target Serialize =\u003E _ =\u003E _\r\n    //     .Executes(() =\u003E File.WriteAllText(ArtifactsDirectory / \u0022state.json\u0022, JsonConvert.SerializeObject(this, Formatting.Indented, new JsonSerializerSettings(){ ContractResolver = new MyContractResolver()})));\r\n    \r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Publishes the project to a folder which is ready to be deployed to target machines\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            Logger.Info(GitVersion == null);\r\n            Logger.Info(GitVersion.NuGetVersionV2);\r\n            DotNetPublish(s =\u003E s\r\n                .SetProject(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion));\r\n        });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Publish)\r\n        .Description(\u0022Publishes the project and creates a zip package in artfiacts folder\u0022)\r\n        .Produces(ArtifactsDirectory)\r\n        .Executes(() =\u003E\r\n        {\r\n            Directory.CreateDirectory(ArtifactsDirectory);\r\n            DeleteFile(ArtifactsDirectory / PackageZipName);\r\n            ZipFile.CreateFromDirectory(PublishDirectory, ArtifactsDirectory / PackageZipName);\r\n            Logger.Block(ArtifactsDirectory / PackageZipName);\r\n        });\r\n\r\n    Target CfLogin =\u003E _ =\u003E _\r\n        .OnlyWhenStatic(() =\u003E !CfSkipLogin)\r\n        .Requires(() =\u003E CfUsername, () =\u003E CfPassword, () =\u003E CfApiEndpoint)\r\n        .Unlisted()\r\n        .Executes(() =\u003E\r\n        {\r\n            CloudFoundryApi(c =\u003E c.SetUrl(CfApiEndpoint));\r\n            CloudFoundryAuth(c =\u003E c\r\n                .SetUsername(CfUsername)\r\n                .SetPassword(CfPassword));\r\n        });\r\n    \r\n    Target Deploy =\u003E _ =\u003E _\r\n        .DependsOn(CfLogin)\r\n        .After(Pack)\r\n        .Requires(() =\u003E CfSpace, () =\u003E CfOrg)\r\n        .Description(\u0022Deploys to Cloud Foundry\u0022)\r\n        .Executes(async () =\u003E\r\n        {\r\n            string appName = \u0022ers1\u0022;\r\n            \r\n            var names = Enumerable.Range(1, AppsCount).Select(x =\u003E $\u0022ers{x}\u0022).ToArray();;\r\n            CloudFoundryCreateSpace(c =\u003E c\r\n                .SetOrg(CfOrg)\r\n                .SetSpace(CfSpace));\r\n            CloudFoundryTarget(c =\u003E c\r\n                .SetSpace(CfSpace)\r\n                .SetOrg(CfOrg));\r\n            CloudFoundryCreateService(c =\u003E c\r\n                .SetService(\u0022p-service-registry\u0022)\r\n                .SetPlan(CfApiEndpoint?.Contains(\u0022api.run.pivotal.io\u0022) ?? false ? \u0022trial\u0022 : \u0022standard\u0022)\r\n                .SetInstanceName(\u0022eureka\u0022));\r\n            CloudFoundryCreateService(c =\u003E c\r\n                .SetService(\u0022p.mysql\u0022)\r\n                .SetPlan(DbPlan)\r\n                .SetInstanceName(\u0022mysql\u0022));\r\n            CloudFoundryPush(c =\u003E c\r\n                .SetRandomRoute(true)\r\n                .SetPath(ArtifactsDirectory / PackageZipName)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 1);\r\n            await CloudFoundryEnsureServiceReady(\u0022eureka\u0022);\r\n            await CloudFoundryEnsureServiceReady(\u0022mysql\u0022);\r\n            CloudFoundryBindService(c =\u003E c\r\n                .SetServiceInstance(\u0022eureka\u0022)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 5);\r\n            CloudFoundryBindService(c =\u003E c\r\n                .SetServiceInstance(\u0022mysql\u0022)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 5);\r\n            CloudFoundryRestart(c =\u003E c\r\n                .SetAppName(appName)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 5);\r\n        });\r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads the artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            if (!GitRepository.IsGitHubRepository())\r\n                ControlFlow.Fail(\u0022Only supported when git repo remote is github\u0022);\r\n            if(!IsGitPushedToRemote)\r\n                ControlFlow.Fail(\u0022Your local git repo has not been pushed to remote. Can\u0027t create release until source is upload\u0022);\r\n            var client = new GitHubClient(new ProductHeaderValue(\u0022nuke-build\u0022))\r\n            {\r\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n            };\r\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n            var owner = gitIdParts[0];\r\n            var repoName = gitIdParts[1];\r\n            \r\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n            Release release;\r\n            try\r\n            {\r\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n            }\r\n            catch (NotFoundException)\r\n            {\r\n                var newRelease = new NewRelease(releaseName)\r\n                {\r\n                    Name = releaseName, \r\n                    Draft = false, \r\n                    Prerelease = false\r\n                };\r\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n            }\r\n\r\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\r\n            if (existingAsset != null)\r\n            {\r\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n            }\r\n            \r\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\r\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\r\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n            \r\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n        });\r\n    \r\n    \r\n    \r\n    bool IsGitPushedToRemote =\u003E GitTasks\r\n        .Git(\u0022status\u0022)\r\n        .Select(x =\u003E x.Text)\r\n        .Count(x =\u003E x.Contains(\u0022nothing to commit, working tree clean\u0022) || x.StartsWith(\u0022Your branch is up to date with\u0022)) == 2;\r\n}\r\n"
  },
  {
    "Id": 138951204,
    "FirstIndexed": "2020-04-25T15:50:44.7352057+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630447+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433353+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939123+02:00",
    "Name": "AspNetCore.Client",
    "Owner": "Beffyman",
    "HtmlUrl": "https://github.com/Beffyman/AspNetCore.Client",
    "Description": "On Build client generator for asp.net core projects",
    "Archived": false,
    "Stars": 14,
    "Watchers": 3,
    "BuildFilePath": "build/BuildScripts.cs",
    "BuildFileUrl": "https://github.com/Beffyman/AspNetCore.Client/blob/master/build/BuildScripts.cs",
    "BuildFileSize": 5103,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations(TimeoutInMilliseconds = 5000)]\n[UnsetVisualStudioEnvironmentVariables]\npublic class BuildScripts : NukeBuild\n{\n\tpublic static int Main() =\u003E Execute\u003CBuildScripts\u003E(x =\u003E x.Build);\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Solution] readonly Solution Solution;\n\t[GitRepository] readonly GitRepository GitRepository;\n\t[GitVersion] readonly GitVersion GitVersion;\n\t[CI] readonly AzurePipelines AzurePipelines;\n\n\tconst string SourceFolder = \u0022src\u0022;\n\tconst string TestsFolder = \u0022tests\u0022;\n\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / SourceFolder;\n\tAbsolutePath TestsDirectory =\u003E RootDirectory / TestsFolder;\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\tAbsolutePath TestArtifactsDirectory =\u003E ArtifactsDirectory / \u0022tests\u0022;\n\tAbsolutePath NugetDirectory =\u003E ArtifactsDirectory / \u0022nuget\u0022;\n\tAbsolutePath CodeCoverageReportOutput =\u003E TestArtifactsDirectory / \u0022Reports\u0022;\n\tAbsolutePath CodeCoverageFile =\u003E TestArtifactsDirectory / \u0022coverage.cobertura.xml\u0022;\n\n\n\tRelativePath TestGeneratorProject =\u003E (RelativePath)TestsFolder / \u0022Beffyman.AspNetCore.Client.Test.Generator\u0022 / \u0022Beffyman.AspNetCore.Client.Test.Generator.csproj\u0022;\n\tRelativePath GeneratorProject =\u003E (RelativePath)SourceFolder / \u0022Beffyman.AspNetCore.Client.Generator\u0022 / \u0022Beffyman.AspNetCore.Client.Generator.csproj\u0022;\n\n\tconst string TestGeneratorFramework = \u0022netcoreapp3.1\u0022;\n\n\tprivate void CleanArtifacts(bool packages = true)\n\t{\n\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\tTestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\n\t\tif (packages)\n\t\t{\n\t\t\tEnsureCleanDirectory(ArtifactsDirectory);\n\t\t}\n\t}\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Before(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCleanArtifacts();\n\t\t});\n\n\tTarget Restore =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t.SetProjectFile(Solution));\n\t\t});\n\n\tTarget Build =\u003E _ =\u003E _\n\t\t.DependsOn(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetBuild(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t.EnableNoRestore());\n\t\t});\n\n\tprivate void RunTests()\n\t{\n\t\tDotNetTest(s =\u003E s.SetConfiguration(Configuration)\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.SetLogger(\u0022trx\u0022)\n\t\t\t\t.SetResultsDirectory(TestArtifactsDirectory)\n\t\t\t\t.SetLogOutput(true)\n\t\t\t\t.SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t.Add(\u0022/p:CoverletOutput={0}/\u0022, TestArtifactsDirectory)\n\t\t\t\t\t//.Add(\u0022/p:Threshold={0}\u0022, 90)\n\t\t\t\t\t.Add(\u0022/p:Exclude=\\\u0022[xunit*]*%2c[*.Tests]*\\\u0022\u0022)\n\t\t\t\t\t.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t.Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n\t\t\t\t.SetProjectFile(Solution));\n\n\t\tFileExists(CodeCoverageFile);\n\t}\n\n\tTarget Test =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tRunTests();\n\t\t});\n\n\n\tTarget Pack =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.After(Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetPack(s =\u003E s.SetProject(Solution)\n\t\t\t\t\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t\t.SetOutputDirectory(NugetDirectory));\n\t\t});\n\n\tTarget GenerateTestProjectClients =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Before(Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRun(s =\u003E s.SetProjectFile(TestGeneratorProject)\n\t\t\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t\t\t.SetFramework(TestGeneratorFramework)\n\t\t\t\t\t\t\t.EnableNoBuild());\n\t\t});\n\n\tTarget BuildWithGenerator =\u003E _ =\u003E _\n\t\t.After(Pack)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCleanArtifacts(false);\n\n\t\t\tDotNetBuild(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t.EnableNoCache()\n\t\t\t\t.AddProperty(\u0022GenerateWithNuget\u0022, \u0022true\u0022)\n\t\t\t\t.AddProperty(\u0022GeneratorVersion\u0022, GitVersion.NuGetVersionV2)\n\t\t\t\t.AddSources(NugetDirectory));\n\n\t\t\tRunTests();\n\t\t});\n\n\tTarget CI =\u003E _ =\u003E _\n\t\t.DependsOn(Clean)\n\t\t.DependsOn(Build)\n\t\t.DependsOn(GenerateTestProjectClients)\n\t\t.DependsOn(Test)\n\t\t.DependsOn(Pack)\n\t\t.DependsOn(BuildWithGenerator)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tAzurePipelines?.UpdateBuildNumber(GitVersion.NuGetVersionV2);\n\t\t});\n\n\n}\n"
  },
  {
    "Id": 139005752,
    "FirstIndexed": "2020-04-25T15:50:44.735675+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162717+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434405+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940124+02:00",
    "Name": "PersonalAssistance",
    "Owner": "maze0417",
    "HtmlUrl": "https://github.com/maze0417/PersonalAssistance",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/maze0417/PersonalAssistance/blob/master/build/Build.cs",
    "BuildFileSize": 2268,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    // Console application entry point. Also defines the default target.\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.CreateService);\n\n    const string PunchCardService = \u0022PunchCardService\u0022;\n    // Auto-injection fields:\n\n    // [GitVersion] readonly GitVersion GitVersion;\n    // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n    // [GitRepository] readonly GitRepository GitRepository;\n    // Parses origin, branch name and head from git config.\n\n    // [Parameter] readonly string MyGetApiKey;\n    // Returns command-line arguments and environment variables.\n\n    // [Solution] readonly Solution Solution;\n    // Provides access to the structure of the solution.\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                ProcessTasks.StartProcess(\u0022sc\u0022, $\u0022stop {PunchCardService}\u0022);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(s =\u003E DefaultDotNetRestore);\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E DefaultDotNetBuild);\n            });\n\n    Target Publish =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                DotNetPublish(s =\u003E DefaultDotNetPublish.SetRuntime(\u0022win10-x64\u0022));\n            });\n\n    Target CreateService =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n            var path = $@\u0022{SolutionDirectory}\\PunchCard\\bin\\Release\\netcoreapp2.0\\win10-x64\\PunchCard.exe\u0022;\n\n            ProcessTasks.StartProcess(\u0022sc\u0022, $\u0022create {PunchCardService} binPath= {path} \u0022);\n            ProcessTasks.StartProcess(\u0022sc\u0022, $\u0022start {PunchCardService}\u0022);\n        });\n\n    Target SetupBat =\u003E _ =\u003E _\n       //.DependsOn(CreateService)\n       .Executes(() =\u003E\n       {\n           FileSystemTasks.CopyRecursively($@\u0022{SolutionDirectory}\\build\\Scripts\\\u0022, $@\u0022C:\\Windows\\System32\\GroupPolicy\\User\\Scripts\\\u0022, FileSystemTasks.FileExistsPolicy.Overwrite);\n       });\n}"
  },
  {
    "Id": 139244319,
    "FirstIndexed": "2020-04-25T15:50:44.7356721+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627159+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434394+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "CleanApi",
    "Owner": "ElijahReva",
    "HtmlUrl": "https://github.com/ElijahReva/CleanApi",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 139520977,
    "FirstIndexed": "2020-04-25T15:47:03.6116682+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632023+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431015+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936898+02:00",
    "Name": "seed-github",
    "Owner": "nullforce-public",
    "HtmlUrl": "https://github.com/nullforce-public/seed-github",
    "Description": "Seeds a github repository for a .NET project",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nullforce-public/seed-github/blob/master/build/Build.cs",
    "BuildFileSize": 2784,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022NuGet API key for push - Default is empty string\u0022)]\n    readonly string NuGetApiKey;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    readonly string NuGetSource = IsLocalBuild ? \u0022Local\u0022 : \u0022nuget.org\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .After(Clean)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info(GitVersion.NuGetVersionV2);\n\n            DotNetPack(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022Version\u0022, GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .EnableNoBuild()\n            );\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Package)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            if (!IsLocalBuild \u0026\u0026 string.IsNullOrEmpty(NuGetApiKey))\n            {\n                Logger.Error(\u0022NuGet API key was not provided. Unable to push NuGet package.\u0022);\n                return;\n            }\n\n            var nugetPackage = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).First();\n\n            DotNetNuGetPush(s =\u003E s\n                .SetSource(NuGetSource)\n                .SetTargetPath(nugetPackage)\n                .SetApiKey(NuGetApiKey)\n            );\n        });\n\n}\n"
  },
  {
    "Id": 140714385,
    "FirstIndexed": "2020-04-25T15:47:03.6111266+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630408+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431026+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893691+02:00",
    "Name": "dinkum-coin-api-serverless",
    "Owner": "dipjyotimetia",
    "HtmlUrl": "https://github.com/dipjyotimetia/dinkum-coin-api-serverless",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Targets/Build.cs",
    "BuildFileUrl": "https://github.com/dipjyotimetia/dinkum-coin-api-serverless/blob/master/build/Targets/Build.cs",
    "BuildFileSize": 6974,
    "BuildFileContent": "\uFEFFusing System.IO;\nusing System.IO.Compression;\nusing Amazon.SecurityToken.Model;\nusing Build.Settings;\nusing CrownBet.Build;\nusing CrownBet.Build.Aws;\nusing Nuke.Core;\nusing Nuke.Core.IO;\nusing Nuke.Core.Tooling;\nusing Nuke.Common.Tools.DotNet;\n\n           \n\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace Build.Targets\n{\n    public partial class Build : NukeBuild\n    {\n        [Parameter(\u0022The file to write the build version to (\u0022 \u002B nameof(Export_Build_Version) \u002B \u0022 target only)\u0022)] public string BuildVersionFilePath;\n\n        private string _buildVersion;\n        private GlobalSettings _globalSettings;\n\n        public Target Clean =\u003E _ =\u003E _\n              .Description(\u0022Remove previous build output\u0022)\n              .Executes(() =\u003E FileSystemTasks.DeleteDirectory(Settings.BuildOutputDirectory));\n\n        public Target Compile =\u003E _ =\u003E _\n             .DependsOn(Clean)\n             .Description(\u0022Build all projects in the solution\u0022)\n             .Executes(() =\u003E DotNetBuild(SolutionDirectory));\n\n        public Target Export_Build_Version =\u003E _ =\u003E _\n             .Description(\u0022Outputs the build version to a file\u0022)\n             .Requires(() =\u003E BuildVersionFilePath)\n             .Executes(() =\u003E File.WriteAllText(BuildVersionFilePath, GetBuildVersion()));\n\n        public Target Package =\u003E _ =\u003E _\n             .Description(\u0022Package the application\u0022)\n             .DependsOn(Test)\n             .Executes(() =\u003E\n             {\n                 ProcessTasks.StartProcess(\n                     DotnetPath, $\u0022publish src/DinkumCoin.Wallet.Lambda/DinkumCoin.Wallet.Lambda.csproj -c Release /p:Version=\\\u0022{GetBuildVersion()}\\\u0022 -o \\\u0022{Settings.PublishDirectory}\\\u0022\u0022, RootDirectory).AssertZeroExitCode();\n                 Directory.CreateDirectory(Settings.PackageDirectory);\n\n                 if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n                 {\n                     ZipFile.CreateFromDirectory(Settings.PublishDirectory, Settings.PackageDirectory / $\u0022DinkumCoin.Api.Wallet.Lambda_{GetBuildVersion()}.zip\u0022);\n                 }\n                 else\n                 {\n                    BundleWithZipCLI(\u0022zip\u0022, Settings.PackageDirectory / $\u0022DinkumCoin.Api.Wallet.Lambda_{GetBuildVersion()}.zip\u0022, Settings.PublishDirectory, false);\n\n                 }\n\n             });\n\n        public Target Test =\u003E _ =\u003E _\n             .Description(\u0022Perform all unit tests\u0022)\n             .DependsOn(Compile)\n             .Executes(() =\u003E\n             {\r\n                 //DotNetTest(settings =\u003E settings\r\n                 //      .SetProjectFile(Settings.TestDirectory / \u0022DinkumCoin.Data.Tests\u0022)\r\n                 //.SetNoBuild(true));\r\n                 DotNetTest(settings =\u003E settings\r\n                            .SetProjectFile(Settings.TestDirectory / \u0022DinkumCoin.Wallet.Lambda.Tests\u0022)\r\n                            .SetLogger(\u0022xunit;LogFilePath=TestResults.xml\u0022)\r\n                         .SetNoBuild(true));\r\n                 \r\n\n             });\n\n        public Target Upload =\u003E _ =\u003E _\n             .Description(\u0022Upload application package to S3\u0022)\n             .DependsOn(Package)\n             .Executes(() =\u003E\n             {\n                 Credentials credentials = Sts.AssumeRole(GlobalSettings.BucketWriteRoleArn, \u0022ci-build\u0022).Result;\n                 S3.UploadDirectory(Settings.PackageDirectory, GlobalSettings.BucketName, GetBuildVersion(), credentials: credentials).Wait();\n             });\n\n\n        private string DotnetPath { get; } = new DotNetSettings().ToolPath;\n\n        private GlobalSettings Settings =\u003E _globalSettings = _globalSettings ?? new GlobalSettings(RootDirectory);\n\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n        private string GetBuildVersion()\n        {\n            if (_buildVersion != null) { return _buildVersion; }\n\n            string branch = Git.GetBranchName(RootDirectory);\n\n            branch = branch == \u0022master\u0022 ? \u0022\u0022 : \u0022-\u0022 \u002B branch.Replace(\u0022/\u0022, \u0022-\u0022);\n\n            return _buildVersion = GetSemanticBuildVersion() \u002B branch;\n        }\n\n        private string GetSemanticBuildVersion()\n        {\n            return $\u00221.0.{Git.GetCommitCount(RootDirectory)}\u0022;\n        }\n\n\n\n        private static void BundleWithZipCLI(string zipCLI, string zipArchivePath, string publishLocation, bool flattenRuntime)\n        {\n            var args = new StringBuilder(\u0022\\\u0022\u0022 \u002B zipArchivePath \u002B \u0022\\\u0022\u0022);\n\n            // so that we can archive content in subfolders, take the length of the\n            // path to the root publish location and we\u0027ll just substring the\n            // found files so the subpaths are retained\n            var publishRootLength = publishLocation.Length;\n            if (publishLocation[publishRootLength - 1] != Path.DirectorySeparatorChar)\n                publishRootLength\u002B\u002B;\n\n            var allFiles = GetFilesToIncludeInArchive(publishLocation, flattenRuntime);\n            foreach (var kvp in allFiles)\n            {\n                args.AppendFormat(\u0022 \\\u0022{0}\\\u0022\u0022, kvp.Key);\n            }\n\n            var psiZip = new ProcessStartInfo\n            {\n                FileName = zipCLI,\n                Arguments = args.ToString(),\n                WorkingDirectory = publishLocation,\n                RedirectStandardOutput = true,\n                RedirectStandardError = true,\n                UseShellExecute = false,\n                CreateNoWindow = true\n            };\n\n            var handler = (DataReceivedEventHandler)((o, e) =\u003E\n            {\n                if (string.IsNullOrEmpty(e.Data))\n                    return;\n            });\n\n            using (var proc = new Process())\n            {\n                proc.StartInfo = psiZip;\n                proc.Start();\n\n                proc.ErrorDataReceived \u002B= handler;\n                proc.OutputDataReceived \u002B= handler;\n                proc.BeginOutputReadLine();\n                proc.BeginErrorReadLine();\n\n                proc.EnableRaisingEvents = true;\n                proc.WaitForExit();\n\n            }\n        }\n\n\n        private static IDictionary\u003Cstring, string\u003E GetFilesToIncludeInArchive(string publishLocation, bool flattenRuntime)\n        {\n            string RUNTIME_FOLDER_PREFIX = \u0022runtimes\u0022 \u002B Path.DirectorySeparatorChar;\n\n            var includedFiles = new Dictionary\u003Cstring, string\u003E();\n            var allFiles = Directory.GetFiles(publishLocation, \u0022*.*\u0022, SearchOption.AllDirectories);\n            foreach (var file in allFiles)\n            {\n                var relativePath = file.Substring(publishLocation.Length);\n                if (relativePath[0] == Path.DirectorySeparatorChar)\n                    relativePath = relativePath.Substring(1);\n\n                if (flattenRuntime \u0026\u0026 relativePath.StartsWith(RUNTIME_FOLDER_PREFIX))\n                    continue;\n\n                includedFiles[relativePath] = file;\n            }\n\n            return includedFiles;\n        }\n    }\n}"
  },
  {
    "Id": 140714517,
    "FirstIndexed": "2020-04-25T15:47:03.611146+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630436+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431038+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936921+02:00",
    "Name": "dinkum-coin-api-client",
    "Owner": "dipjyotimetia",
    "HtmlUrl": "https://github.com/dipjyotimetia/dinkum-coin-api-client",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "Build/Build.cs",
    "BuildFileUrl": "https://github.com/dipjyotimetia/dinkum-coin-api-client/blob/master/Build/Build.cs",
    "BuildFileSize": 3983,
    "BuildFileContent": "\uFEFFusing Nuke.Core;\r\nusing System.IO;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Core.IO.PathConstruction;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Core.Tooling;\n\nnamespace Build\r\n{\r\n    public partial class Build : NukeBuild\r\n    {\r\n        [Parameter(\u0022Nuget access key\u0022, Name = \u0022NugetKey\u0022)] public string NugetKey;\r\n\r\n\r\n       private string OpenCoverPath = \u0022C:/Tools/OpenCover/OpenCover.Console.exe\u0022;\r\n\r\n        public Target Compile =\u003E _ =\u003E _\r\n            .Executes(() =\u003E\r\n                DotNetBuild(\r\n                    RootDirectory,\r\n                    settings =\u003E settings\r\n                    .SetConfiguration(\u0022Release\u0022)\r\n                         ));\r\n        \r\n\r\n        public Target UnitTest =\u003E _ =\u003E _\r\n            .DependsOn(Compile)\r\n            .Executes(() =\u003E \r\n             DotNetTest(settings =\u003E settings\r\n                        .SetProjectFile(RootDirectory / \u0022DinkumCoin.Api.Client.Tests\u0022)\r\n\t\t\t\t\t\t\t.SetConfiguration(\u0022Release\u0022)\r\n                            .SetLogger(\u0022xunit;LogFilePath=TestResults.xml\u0022)\r\n                         .SetNoBuild(true))\r\n            );\r\n\r\n\r\n        public Target CodeCoverage =\u003E _ =\u003E _\r\n            .Description(\u0022Perform all unit tests\u0022)\r\n            .DependsOn(Compile)\r\n            .Executes(() =\u003E\r\n            {\r\n            string[] testProjects = { \u0022DinkumCoin.Api.Client\u0022 };\r\n                foreach (var testProject in testProjects)\r\n                {\r\n                    string opencoverParams = $\u0022-register:user \u0022 \u002B\r\n                    $\u0022-target:dotnet.exe \u0022 \u002B\r\n                    $\u0022\\\u0022-targetdir:{ testProject}\\\u0022 \u0022 \u002B\r\n                    $\u0022\\\u0022-targetargs:test\\\u0022 \u0022 \u002B\r\n                    $\u0022\\\u0022-output:{RootDirectory}/OpenCover.coverageresults\\\u0022 \u0022 \u002B\r\n                    $\u0022-mergeoutput \u0022 \u002B\r\n                    $\u0022-oldStyle \u0022 \u002B\r\n                    $\u0022-excludebyattribute:System.CodeDom.Compiler.GeneratedCodeAttribute \u0022 \u002B\r\n                    $\u0022\\\u0022-filter:\u002B[DinkumCoin*]* -[*Tests]*\\\u0022 \u0022;\r\n\r\n                    ProcessTasks.StartProcess(\r\n                                 OpenCoverPath, opencoverParams, RootDirectory).AssertZeroExitCode();\r\n                }\r\n\r\n            });\r\n\r\n\r\n        public Target Package =\u003E _ =\u003E _\r\n            .DependsOn(Compile)\r\n            .Executes(() =\u003E {\r\n\r\n\r\n                DotNetPack(settings =\u003E settings.SetConfiguration(\u0022Release\u0022)\r\n                                                .SetNoBuild(true)\r\n                                                .SetOutputDirectory(LibrarySourceDirectory / \u0022bin/Release\u0022)\r\n                                                .SetProject(LibrarySourceDirectory)\r\n                                                .SetAuthors(\u0022DinkumCoin QA\u0022)\r\n                                                .SetDescription(\u0022DinkumCoin QA\u0022)\r\n                                                .SetPackageTags(\u0022QA\u0022)\r\n                                                .SetCopyright(\u0022Copyright 2017\u0022)\r\n                                                .SetPackageId(\u0022DinkumCoin.Api.Client\u0022)\r\n                );\r\n            });\r\n\r\n\r\n        public Target Publish =\u003E _ =\u003E _\r\n            .DependsOn(Package)\r\n            .Requires(() =\u003E NugetKey)\r\n            .Executes(() =\u003E {\r\n\r\n                DotNetNuGetPush(settings =\u003E settings\r\n                                .SetTargetPath(LibrarySourceDirectory / \u0022bin/Release\u0022 / (LibraryName \u002B $\u0022.1.0.0.nupkg\u0022))\r\n                                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                                    .SetApiKey(NugetKey)\r\n                               );\r\n                    });\r\n\r\n        private string LibraryName =\u003E Path.GetFileNameWithoutExtension(SolutionFile);\r\n\r\n        private AbsolutePath LibrarySourceDirectory =\u003E RootDirectory / LibraryName;\r\n\r\n        private GlobalSettings Settings =\u003E  new GlobalSettings();\r\n\r\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    }\r\n}"
  },
  {
    "Id": 140714549,
    "FirstIndexed": "2020-04-25T15:47:03.6111295+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630425+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431049+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936932+02:00",
    "Name": "dinkum-coin-api-ec2",
    "Owner": "dipjyotimetia",
    "HtmlUrl": "https://github.com/dipjyotimetia/dinkum-coin-api-ec2",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Targets/Build.cs",
    "BuildFileUrl": "https://github.com/dipjyotimetia/dinkum-coin-api-ec2/blob/master/build/Targets/Build.cs",
    "BuildFileSize": 4764,
    "BuildFileContent": "\uFEFFusing Build.Settings;\nusing Build;\nusing Build.Aws;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Core;\nusing Nuke.Core.IO;\nusing Nuke.Core.Tooling;\nusing System.IO;\nusing System.IO.Compression;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System;\nusing Amazon.SecurityToken.Model;\n\nnamespace Build.Targets\n{\n    public partial class Build : NukeBuild\n    {\n        [Parameter(\u0022The file to write the build version to (\u0022 \u002B nameof(Export_Build_Version) \u002B \u0022 target only)\u0022)] public string BuildVersionFilePath;\n\n        private string _buildVersion;\n        private GlobalSettings Settings =\u003E _globalSettings = _globalSettings ?? new GlobalSettings(RootDirectory);\n\n        private GlobalSettings _globalSettings;\n\n        public Target Export_Build_Version =\u003E _ =\u003E _\n             .Description(\u0022Outputs the build version to a file\u0022)\n             .Requires(() =\u003E BuildVersionFilePath)\n             .Executes(() =\u003E File.WriteAllText(BuildVersionFilePath, GetBuildVersion()));\n        \n        public Target Clean =\u003E _ =\u003E _\n             .Description(\u0022Remove previous build output\u0022)\n             .Executes(() =\u003E FileSystemTasks.DeleteDirectory(Settings.BuildOutputDirectory));\n\n        public Target Compile =\u003E _ =\u003E _\n             .DependsOn(Clean)\n             .Description(\u0022Build all projects in the solution\u0022)\n            .Executes(() =\u003E DotNetBuild(settings =\u003E settings\n                                        .SetConfiguration(\u0022Release\u0022)\n                                        .SetProjectFile(SolutionDirectory)\n                                       ));\n\n        public Target Unit_Test =\u003E _ =\u003E _\n             .Description(\u0022Perform all unit tests\u0022)\n             .DependsOn(Compile)\n             .Executes(() =\u003E\n            {\n            DotNetTest(\n                settings =\u003E settings\n                    .SetProjectFile(Settings.TestDirectory / \u0022DinkumCoin.Data.Tests\u0022)\n                .SetConfiguration(\u0022Release\u0022)\n                    .SetLogger(\u0022xunit;LogFilePath=TestResults.xml\u0022)\n                    .SetNoBuild(true));\n            \n            DotNetTest(\n        settings =\u003E settings\n            .SetProjectFile(Settings.TestDirectory / \u0022DinkumCoin.Services.Tests\u0022)\n                .SetConfiguration(\u0022Release\u0022)\n            .SetLogger(\u0022xunit;LogFilePath=TestResults.xml\u0022)\n            .SetNoBuild(true));\n\n            });\n\n        public Target Verify_Pacts =\u003E _ =\u003E _\n             .Description(\u0022Verify pacts\u0022)\n             .DependsOn(Compile)\n             .Executes(() =\u003E DotNetTest(\n                 settings =\u003E settings\n                .SetConfiguration(\u0022Release\u0022)\n                .SetProjectFile(Settings.TestDirectory / \u0022DinkumCoin.Api.PactVerify\u0022)\n                .SetNoBuild(true))\n            );\n\n        public Target Upload =\u003E _ =\u003E _\n             .Description(\u0022Upload application package to S3\u0022)\n             .DependsOn(Package)\n             .Executes(() =\u003E\n             {\n                 Credentials credentials = Sts.AssumeRole(GlobalSettings.BucketWriteRoleArn, \u0022ci-build\u0022).Result;\n                 S3.UploadDirectory(Settings.PackageDirectory, GlobalSettings.BucketName, GetBuildVersion(), credentials: credentials).Wait();\n                 S3.UploadDirectory(Settings.Ec2ScriptsDirectory, GlobalSettings.BucketName, $\u0022{GetBuildVersion()}/ec2\u0022, true, credentials).Wait();\n\n             });\n\n        public Target Package =\u003E _ =\u003E _\n             .Description(\u0022Package the application\u0022)\n            .DependsOn(Unit_Test)\n             .Executes(() =\u003E\n             {\n                ProcessTasks.StartProcess(\n                DotnetPath, $\u0022publish -c Release -r linux-x64 /p:Version=\\\u0022{GetBuildVersion()}\\\u0022 -o \\\u0022{Settings.PublishDirectory}\\\u0022\u0022, Settings.SourceDirectory / \u0022DinkumCoin.Api\u0022).AssertZeroExitCode();\n\n                 Directory.CreateDirectory(Settings.PackageDirectory);\n                 ZipFile.CreateFromDirectory(Settings.PublishDirectory, Settings.PackageDirectory / $\u0022DinkumCoin.Api_{GetBuildVersion()}.zip\u0022);\n             });\n\n        private string DotnetPath { get; } = new DotNetSettings().ToolPath;\n\n\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n        private string GetBuildVersion()\n        {\n            if (_buildVersion != null) { return _buildVersion; }\n\n            string branch = Git.GetBranchName(RootDirectory);\n\n            branch = branch == \u0022master\u0022 ? \u0022\u0022 : \u0022-\u0022 \u002B branch.Replace(\u0022/\u0022, \u0022-\u0022).Substring(0,14);\n\n            return _buildVersion = GetSemanticBuildVersion() \u002B branch;\n        }\n\n        private string GetSemanticBuildVersion()\n        {\n            return $\u00221.0.{Git.GetCommitCount(RootDirectory)}\u0022;\n        }\n    }\n}\n"
  },
  {
    "Id": 142672932,
    "FirstIndexed": "2020-04-25T15:50:44.7355902+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626783+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434041+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.89398+02:00",
    "Name": "GoodAnalytics",
    "Owner": "JleruOHeP",
    "HtmlUrl": "https://github.com/JleruOHeP/GoodAnalytics",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/JleruOHeP/GoodAnalytics/blob/master/build/Build.cs",
    "BuildFileSize": 2024,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Build.Configuration;\n\nnamespace Build\n{\n    partial class Build : NukeBuild\n    {\n        private FolderSettings _folderSettings;\n        private FolderSettings FolderSettings \n        {\n            get { return _folderSettings ?? (_folderSettings = new FolderSettings(RootDirectory)); }\n        }\n\n        // Console application entry point. Also defines the default target.\n        public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n        // Auto-injection fields:\n\n        // [GitVersion] readonly GitVersion GitVersion;\n        // Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n\n        // [GitRepository] readonly GitRepository GitRepository;\n        // Parses origin, branch name and head from git config.\n        \n        // [Parameter] readonly string MyGetApiKey;\n        // Returns command-line arguments and environment variables.\n        \n        // [Solution] readonly Solution Solution;\n        // Provides access to the structure of the solution.\n\n        Target Clean =\u003E _ =\u003E _\n                .OnlyWhen(() =\u003E false) // Disabled for safety.\n                .Executes(() =\u003E\n                {\n                    DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n                    EnsureCleanDirectory(OutputDirectory);\n                });\n\n        Target Restore =\u003E _ =\u003E _\n                .DependsOn(Clean)\n                .Executes(() =\u003E\n                {\n                    DotNetRestore(s =\u003E DefaultDotNetRestore);\n                });\n\n        Target Compile =\u003E _ =\u003E _\n                .DependsOn(Restore)\n                .Executes(() =\u003E\n                {\n                    DotNetBuild(s =\u003E DefaultDotNetBuild);\n                });\n    }\n}\n\n"
  },
  {
    "Id": 143425359,
    "FirstIndexed": "2020-04-25T15:47:03.6113172+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.16308+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843106+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936944+02:00",
    "Name": "resharper-plugins",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/resharper-plugins",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 0,
    "BuildFilePath": "build/Build.Solution.cs",
    "BuildFileUrl": "https://github.com/matkoch/resharper-plugins/blob/master/build/Build.Solution.cs",
    "BuildFileSize": 3852,
    "BuildFileContent": "\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitHub;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ControlFlow;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.SerializationTasks;\nusing static Nuke.Common.ProjectModel.ProjectModelTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\npartial class Build : NukeBuild\n{\n    [Parameter] readonly bool UseSSH;\n\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath ExternalRepositoriesDirectory =\u003E RootDirectory / \u0022external\u0022;\n    IEnumerable\u003CSolution\u003E ExternalSolutions =\u003E ExternalRepositoriesDirectory.GlobFiles(\u0022*/*.sln\u0022).Select(x =\u003E ParseSolution(x));\n\n    Target CheckoutExternalRepositories =\u003E _ =\u003E _\n        .Executes(async () =\u003E\n        {\n            foreach (var plugin in Plugins)\n            {\n                var repository = GitRepository.FromUrl(plugin.repository);\n                var repositoryDirectory = ExternalRepositoriesDirectory / plugin.name.Replace(\u0022 \u0022, \u0022-\u0022);\n                var origin = UseSSH ? repository.SshUrl : repository.HttpsUrl;\n\n                if (!Directory.Exists(repositoryDirectory))\n                    Git($\u0022clone {origin} {repositoryDirectory} --branch {await repository.GetDefaultBranch()} --progress\u0022);\n                else\n                {\n                    SuppressErrors(() =\u003E Git($\u0022remote add origin {origin}\u0022, repositoryDirectory));\n                    Git($\u0022remote set-url origin {origin}\u0022, repositoryDirectory);\n                }\n            }\n        });\n\n    [UsedImplicitly]\n    Target GenerateGlobalSolution =\u003E _ =\u003E _\n        .DependsOn(CheckoutExternalRepositories)\n        .Executes(() =\u003E\n        {\n            Solution.Configurations =\n                new Dictionary\u003Cstring, string\u003E\n                {\n                    { \u0022Debug|Any CPU\u0022, \u0022Debug|Any CPU\u0022 },\n                    { \u0022Release|Any CPU\u0022, \u0022Release|Any CPU\u0022 }\n                };\n\n            SolutionFolder GetParentFolder(PrimitiveProject solutionFolder) =\u003E\n                Solution.AllSolutionFolders.FirstOrDefault(x =\u003E x.ProjectId == solutionFolder.SolutionFolder?.ProjectId);\n\n            void AddSolution(Solution solution, SolutionFolder folder = null)\n            {\n                IDictionary\u003Cstring, string\u003E GetItems(SolutionFolder solutionFolder)\n                {\n                    return solutionFolder.Items.Keys\n                        .Select(x =\u003E\n                            (string) (WinRelativePath) GetRelativePath(Solution.Directory, solution.Directory / x))\n                        .ToDictionary(x =\u003E x, x =\u003E x);\n                }\n\n                solution.AllSolutionFolders.ForEach(x =\u003E Solution.AddSolutionFolder(x.Name, x.ProjectId, GetParentFolder(x) ?? folder));\n                solution.AllSolutionFolders.ForEach(x =\u003E Solution.GetSolutionFolder(x.ProjectId).Items = GetItems(x));\n                solution.AllProjects.ForEach(x =\u003E Solution.AddProject(x.Name, x.TypeId, x.Path, x.ProjectId, x.Configurations, GetParentFolder(x) ?? folder));\n\n                Solution.AllSolutionFolders.ForEach(x =\u003E x.ProjectId = Guid.NewGuid());\n                Solution.AllProjects.ForEach(x =\u003E x.ProjectId = Guid.NewGuid());\n            }\n\n            Solution.AllProjects.Where(x =\u003E x.Name != \u0022_build\u0022 || x.SolutionFolder != null).ForEach(x =\u003E Solution.RemoveProject(x));\n            Solution.AllSolutionFolders.ForEach(x =\u003E Solution.RemoveSolutionFolder(x));\n\n            ExternalSolutions.ForEach(x =\u003E AddSolution(x, Solution.AddSolutionFolder(Path.GetFileName(x.Directory))));\n\n            Solution.Save();\n        });\n}"
  },
  {
    "Id": 143891974,
    "FirstIndexed": "2020-04-25T15:50:44.735588+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631181+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843403+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939788+02:00",
    "Name": "Dangl.AVACloudClientGenerator",
    "Owner": "Dangl-IT",
    "HtmlUrl": "https://github.com/Dangl-IT/Dangl.AVACloudClientGenerator",
    "Description": ".NET Core CLI tool to generate clients for AVACloud - GAEB \u0026 AVA as a Service",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Dangl-IT/Dangl.AVACloudClientGenerator/blob/develop/build/Build.cs",
    "BuildFileSize": 13888,
    "BuildFileContent": "using Nuke.Azure.KeyVault;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.GitHub;\nusing System.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.IO.TextTasks;\nusing System.Linq;\nusing System;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\n\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.GenerateAndPublishPythonClient);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [Parameter] readonly string NodePublishVersionOverride;\n    [Parameter] readonly string PythonClientRepositoryTag;\n\n    [Parameter] readonly string CustomSwaggerDefinitionUrl;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [KeyVaultSecret] readonly string GitHubAuthenticationToken;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            GlobDirectories(RootDirectory / \u0022test\u0022, \u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore();\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(RootDirectory / \u0022test\u0022, \u0022**/*.csproj\u0022);\n            var testRun = 1;\n            foreach (var testProject in testProjects)\n            {\n                var projectDirectory = Path.GetDirectoryName(testProject);\n                string testFile = OutputDirectory / $\u0022test_{testRun\u002B\u002B}.testresults.xml\u0022;\n                var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n\n                StartProcess(dotnetPath, \u0022test \u0022 \u002B\n                                         \u0022--no-build \u0022 \u002B\n                                         \u0022--test-adapter-path:. \u0022 \u002B\n                                         $\u0022\\\u0022--logger:xunit;LogFilePath={testFile}\\\u0022\u0022,\n                        workingDirectory: projectDirectory)\n                    // AssertWairForExit() instead of AssertZeroExitCode()\n                    // because we want to continue all tests even if some fail\n                    .AssertWaitForExit();\n            }\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(GenerateClients)\n        .Executes(async () =\u003E\n        {\n            var publishDir = OutputDirectory / \u0022publish\u0022;\n            var zipPath = OutputDirectory / \u0022AVACloud.Client.Generator.zip\u0022;\n\n            DotNetPublish(x =\u003E x\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetProject(SourceDirectory / \u0022Dangl.AVACloudClientGenerator\u0022 / \u0022Dangl.AVACloudClientGenerator.csproj\u0022)\n                .SetOutput(publishDir));\n\n            System.IO.Compression.ZipFile.CreateFromDirectory(publishDir, zipPath);\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            var isPrerelease = !(GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022));\n\n            var artifactPaths = new string[] { zipPath }.Concat(GlobFiles(OutputDirectory, \u0022*.zip\u0022)).Distinct().ToArray();\n\n            await PublishRelease(x =\u003E x\n                .SetArtifactPaths(artifactPaths)\n                .SetCommitSha(GitVersion.Sha)\n                .SetRepositoryName(repositoryInfo.repositoryName)\n                .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                .SetTag(GitVersion.NuGetVersion)\n                .SetPrerelease(isPrerelease)\n                .SetToken(GitHubAuthenticationToken));\n        });\n\n    Target GenerateClients =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var languages = new[] { \u0022Java\u0022, \u0022TypeScriptNode\u0022, \u0022JavaScript\u0022, \u0022Php\u0022, \u0022Python\u0022 };\n\n            foreach (var language in languages)\n            {\n                GenerateClient(language);\n            }\n        });\n\n    private void GenerateClient(string language)\n    {\n        var generatorPath = SourceDirectory / \u0022Dangl.AVACloudClientGenerator\u0022 / \u0022bin\u0022 / Configuration / \u0022netcoreapp2.1\u0022 / \u0022Dangl.AVACloudClientGenerator.dll\u0022;\n        var outputPath = OutputDirectory / language;\n\n\n        var arguments = $\u0022\\\u0022{generatorPath}\\\u0022 -l {language} -o \\\u0022{outputPath}\\\u0022\u0022;\n        if (!string.IsNullOrWhiteSpace(CustomSwaggerDefinitionUrl))\n        {\n            Logger.Log(LogLevel.Normal, \u0022Using custom Swagger definition url: \u0022 \u002B CustomSwaggerDefinitionUrl);\n            arguments \u002B= $\u0022 -u {CustomSwaggerDefinitionUrl}\u0022;\n        }\n\n        StartProcess(ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022), arguments)\n            .AssertZeroExitCode();\n\n        System.IO.Compression.ZipFile.CreateFromDirectory(outputPath, outputPath.ToString().TrimEnd(\u0027/\u0027).TrimEnd(\u0027\\\\\u0027) \u002B \u0022.zip\u0022);\n    }\n\n    Target GenerateAndPublishTypeScriptNpmClient =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            GenerateClient(\u0022TypeScriptNode\u0022);\n\n            var clientRoot = OutputDirectory / \u0022TypeScriptNode\u0022;\n            var clientDir = clientRoot / \u0022typescript-node-client\u0022;\n\n            CopyFile(clientRoot / \u0022README.md\u0022, clientDir / \u0022README.md\u0022);\n            CopyFile(clientRoot / \u0022LICENSE.md\u0022, clientDir / \u0022LICENSE.md\u0022);\n\n            if (!string.IsNullOrWhiteSpace(NodePublishVersionOverride))\n            {\n                Npm($\u0022version {NodePublishVersionOverride}\u0022, clientDir);\n            }\n\n            NpmInstall(x =\u003E x.SetWorkingDirectory(clientDir));\n            NpmRun(x =\u003E x.SetWorkingDirectory(clientDir).SetArgumentConfigurator(a =\u003E a.Add(\u0022build\u0022)));\n\n            Npm(\u0022publish --access=public\u0022, clientDir);\n        });\n\n    Target GenerateAndPublishJavaScriptNpmClient =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            GenerateClient(\u0022JavaScript\u0022);\n\n            var clientRoot = OutputDirectory / \u0022JavaScript\u0022;\n            var clientDir = clientRoot / \u0022javascript-client\u0022;\n\n            MoveFile(clientDir / \u0022README.md\u0022, clientDir / \u0022API_README.md\u0022);\n            CopyFile(clientRoot / \u0022README.md\u0022, clientDir / \u0022README.md\u0022);\n            CopyFile(clientRoot / \u0022LICENSE.md\u0022, clientDir / \u0022LICENSE.md\u0022);\n\n            if (!string.IsNullOrWhiteSpace(NodePublishVersionOverride))\n            {\n                Npm($\u0022version {NodePublishVersionOverride}\u0022, clientDir);\n            }\n\n            NpmInstall(x =\u003E x.SetWorkingDirectory(clientDir));\n            NpmRun(x =\u003E x.SetWorkingDirectory(clientDir).SetArgumentConfigurator(a =\u003E a.Add(\u0022build\u0022)));\n\n            Npm(\u0022publish --access=public\u0022, clientDir);\n        });\n\n    Target GenerateAndPublishPythonClient =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E PythonClientRepositoryTag)\n        .Executes(() =\u003E\n        {\n            GenerateClient(\u0022Python\u0022);\n\n            var clientRoot = OutputDirectory / \u0022Python\u0022;\n            var clientDir = clientRoot / \u0022python-client\u0022;\n\n            MoveFile(clientDir / \u0022README.md\u0022, clientDir / \u0022API_README.md\u0022);\n            CopyFile(clientRoot / \u0022README.md\u0022, clientDir / \u0022README.md\u0022);\n            CopyFile(clientRoot / \u0022LICENSE.md\u0022, clientDir / \u0022LICENSE.md\u0022);\n\n            var mirrorRepoDir = OutputDirectory / \u0022MirrorRepo\u0022;\n            Directory.CreateDirectory(mirrorRepoDir);\n            var mirrorBranchName = \u0022master\u0022;\n            var mirrorRepoUrl = \u0022https://github.com/Dangl-IT/avacloud-client-python.git\u0022;\n\n            try\n            {\n                Git($\u0022clone {mirrorRepoUrl} -b {mirrorBranchName}\u0022, mirrorRepoDir)?.ToList().ForEach(x =\u003E Logger.Log(LogLevel.Normal, x.Text));\n            }\n            catch\n            {\n                // If the branch doesn\u0027t exist, it should be created\n                Git($\u0022clone {mirrorRepoUrl}\u0022, mirrorRepoDir)?.ToList().ForEach(x =\u003E Logger.Log(LogLevel.Normal, x.Text));\n            }\n\n            mirrorRepoDir = mirrorRepoDir / \u0022avacloud-client-python\u0022; \n\n            // Delete all but .git/ in cloned repo\n            var dirs = Directory.EnumerateDirectories(mirrorRepoDir)\n                .Where(d =\u003E !d.EndsWith(\u0022.git\u0022, StringComparison.OrdinalIgnoreCase));\n            dirs.ForEach(DeleteDirectory);\n            var files = Directory.EnumerateFiles(mirrorRepoDir)\n                .ToList();\n            files.ForEach(File.Delete);\n            // Copy data into cloned repo\n            var dirsToCopy = Directory.EnumerateDirectories(clientDir)\n                .ToList();\n            dirsToCopy.ForEach(d =\u003E\n            {\n                var folderName = Path.GetFileName(d);\n                CopyDirectoryRecursively(d, mirrorRepoDir / folderName);\n            });\n            var filesToCopy = Directory.EnumerateFiles(clientDir)\n                .ToList();\n            filesToCopy.ForEach(f =\u003E\n            {\n                var fileName = Path.GetFileName(f);\n                File.Copy(f, mirrorRepoDir / fileName);\n            });\n\n            using (SwitchWorkingDirectory(mirrorRepoDir))\n            {\n                Git(\u0022add -A\u0022);\n                var commitMessage = \u0022Auto generated commit\u0022;\n                Git($\u0022commit -m \\\u0022{commitMessage}\\\u0022\u0022);\n                Git($\u0022tag \\\u0022{PythonClientRepositoryTag}\\\u0022\u0022);\n                Git($\u0022push --set-upstream origin {mirrorBranchName}\u0022);\n                Git(\u0022push --tags\u0022);\n            }\n        });\n\n    Target GenerateAndPublishPhpClient =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            GenerateClient(\u0022Php\u0022);\n\n            var composerJsonFile = GlobFiles(OutputDirectory, \u0022**/*composer.json\u0022).Single();\n            var composerJson = ReadAllText(composerJsonFile);\n            var composerJObject = JObject.Parse(composerJson);\n            composerJObject[\u0022version\u0022] = GitVersion.NuGetVersion;\n            WriteAllText(composerJsonFile, composerJObject.ToString());\n\n\n            var clientRoot = OutputDirectory / \u0022Php\u0022;\n            var clientDir = clientRoot / \u0022php-client\u0022 / \u0022Dangl\u0022 / \u0022AVACloud\u0022;\n\n            CopyFile(clientRoot / \u0022README.md\u0022, clientDir / \u0022CLIENT_README.md\u0022);\n            CopyFile(clientRoot / \u0022LICENSE.md\u0022, clientDir / \u0022LICENSE.md\u0022);\n\n            var mirrorRepoDir = OutputDirectory / \u0022MirrorRepo\u0022;\n            Directory.CreateDirectory(mirrorRepoDir);\n            var mirrorBranchName = \u0022master\u0022;\n            var mirrorRepoUrl = \u0022https://github.com/Dangl-IT/avacloud-client-php.git\u0022;\n\n            try\n            {\n                Git($\u0022clone {mirrorRepoUrl} {mirrorRepoDir} -b {mirrorBranchName}\u0022, mirrorRepoDir)?.ToList().ForEach(x =\u003E Logger.Log(LogLevel.Normal, x.Text));\n            }\n            catch\n            {\n                // If the branch doesn\u0027t exist, it should be created\n                Git($\u0022clone {mirrorRepoUrl}\u0022, mirrorRepoDir)?.ToList().ForEach(x =\u003E Logger.Log(LogLevel.Normal, x.Text));\n            }\n\n            // Delete all but .git/ in cloned repo\n            var dirs = Directory.EnumerateDirectories(mirrorRepoDir)\n                .Where(d =\u003E !d.EndsWith(\u0022.git\u0022, StringComparison.OrdinalIgnoreCase));\n            dirs.ForEach(DeleteDirectory);\n            var files = Directory.EnumerateFiles(mirrorRepoDir)\n                .ToList();\n            files.ForEach(File.Delete);\n            // Copy data into cloned repo\n            var dirsToCopy = Directory.EnumerateDirectories(clientDir)\n                .ToList();\n            dirsToCopy.ForEach(d =\u003E\n            {\n                var folderName = Path.GetFileName(d);\n                CopyDirectoryRecursively(d, mirrorRepoDir / folderName);\n            });\n            var filesToCopy = Directory.EnumerateFiles(clientDir)\n                .ToList();\n            filesToCopy.ForEach(f =\u003E\n            {\n                var fileName = Path.GetFileName(f);\n                File.Copy(f, mirrorRepoDir / fileName);\n            });\n\n\n            using (SwitchWorkingDirectory(mirrorRepoDir))\n            {\n                Git(\u0022add -A\u0022);\n                var commitMessage = \u0022Auto generated commit\u0022;\n                Git($\u0022commit -m \\\u0022{commitMessage}\\\u0022\u0022);\n                Git($\u0022tag \\\u0022v{GitVersion.NuGetVersion}\\\u0022\u0022);\n                Git($\u0022push --set-upstream origin {mirrorBranchName}\u0022);\n                Git(\u0022push --tags\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 143917738,
    "FirstIndexed": "2020-04-25T15:50:44.7355857+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626755+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434024+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939783+02:00",
    "Name": "Nuke.Test",
    "Owner": "grodnonetcommunity",
    "HtmlUrl": "https://github.com/grodnonetcommunity/Nuke.Test",
    "Description": null,
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/Build.BackEnd.cs",
    "BuildFileUrl": "https://github.com/grodnonetcommunity/Nuke.Test/blob/master/build/Build.BackEnd.cs",
    "BuildFileSize": 1883,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.Nunit;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.IO.PathConstruction;\n\npartial class Build : NukeBuild\n{\n    MSBuildSettings MsBuildSettings =\u003E DefaultMSBuild;\n\n    Target BackendClean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            foreach (var project in Solution.Projects.Where(p =\u003E\n                p.Directory.ToString() != EnvironmentInfo.BuildProjectDirectory.ToString()))\n            {\n                DeleteDirectories(GlobDirectories(project.Directory, \u0022bin\u0022, \u0022obj\u0022));\n            }\n        });\n\n    Target BackendRestore =\u003E _ =\u003E _\n        .DependsOn(BackendClean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E MsBuildSettings\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target BackendCompile =\u003E _ =\u003E _\n        .DependsOn(BackendRestore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E MsBuildSettings);\n        });\n\n    Target BackendPack =\u003E _ =\u003E _\n        .DependsOn(BackendCompile)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E MsBuildSettings\n                .SetTargets(\u0022Restore\u0022, \u0022Pack\u0022)\n                .SetPackageOutputPath(ArtifactsDirectory)\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols());\n        });\n\n    Target BackendUnitTests =\u003E _ =\u003E _\n        .DependsOn(BackendCompile)\n        .Executes(() =\u003E\n        {\n            var unitTestProjects = GlobFiles(SourceDirectory, \u0022Tests/**/*.UnitTests.*proj\u0022).ToList();\n            foreach (var unitTestProject in unitTestProjects)\n            {\n                DotNetTasks.DotNetTest(s =\u003E s\n                    .SetProjectFile(unitTestProject)\n                    .EnableNoBuild());\n            }\n        });\n}\n"
  },
  {
    "Id": 144425678,
    "FirstIndexed": "2020-04-25T15:50:44.7355828+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626738+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434013+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939771+02:00",
    "Name": "BuildSystem.Nuke.Sample",
    "Owner": "lucascebertin",
    "HtmlUrl": "https://github.com/lucascebertin/BuildSystem.Nuke.Sample",
    "Description": "Projeto sample do build system Nuke",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "build/Program.cs",
    "BuildFileUrl": "https://github.com/lucascebertin/BuildSystem.Nuke.Sample/blob/master/build/Program.cs",
    "BuildFileSize": 2384,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing System.Linq;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nnamespace build\n{\n    public class Build : NukeBuild\n    {\n        [Solution] readonly Solution Solution;\n\n        private Project ConsoleApp =\u003E Solution.GetProject(\u0022*.App\u0022).NotNull();\n\n        public static int Main() =\u003E\n            Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n        private Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                DeleteDirectories(GlobDirectories(SourceDirectory, \u0022*/bin\u0022, \u0022*/obj\u0022));\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n        private Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n                DotNetRestore(s =\u003E s\n                    .SetProjectFile(Solution))\n            );\n\n        private Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n                DotNetBuild(s =\u003E s\n                    .SetProjectFile(Solution)\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration)\n                    .SetAssemblyVersion(\u00221.0.0\u0022)\n                    .SetFileVersion(\u00221.0.0\u0022)\n                    .SetInformationalVersion(\u00221.0.0\u0022)));\n\n        private Target Publish =\u003E _ =\u003E _\n            .DependsOn(Test)\n            .Executes(() =\u003E\n            {\n                var publishSettings = new DotNetPublishSettings()\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration)\n                    .SetOutput(OutputDirectory);\n\n                DotNetPublish(s =\u003E publishSettings\n                    .SetProject(ConsoleApp)\n                    .SetFramework(\u0022netcoreapp2.1\u0022));\n            });\n\n        private Target Test =\u003E _ =\u003E _\n           .DependsOn(Compile)\n           .Executes(() =\u003E\n           {\n               foreach (var project in Solution.Projects.Where(x =\u003E x.Name.Contains(\u0022Tests\u0022)))\n               {\n                   var command =\n                       $\u0022test {project.Path} /p:CollectCoverage=true /p:Threshold=80 /p:CoverletOutputFormat=opencover /p:CoverletOutput=\\\u0022{OutputDirectory}\\\\result.{project.Name}.xml\\\u0022\u0022;\n\n                   DotNet(command);\n               }\n           });\n    }\n}\n"
  },
  {
    "Id": 144435441,
    "FirstIndexed": "2020-04-25T15:47:03.6115925+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625395+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431072+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "Domain",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Domain",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 145762701,
    "FirstIndexed": "2020-04-25T15:50:44.7355783+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626709+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843399+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939748+02:00",
    "Name": "Goui",
    "Owner": "KevinGliewe",
    "HtmlUrl": "https://github.com/KevinGliewe/Goui",
    "Description": "A small cross-platform UI library that brings the simplicity of native UI development to the web. A fork of https://github.com/praeclarum/Ooui, but not compatible!",
    "Archived": false,
    "Stars": 4,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/KevinGliewe/Goui/blob/master/build/Build.cs",
    "BuildFileSize": 7281,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.NuGet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\n\nusing GCore.Logging;\nusing GCore.Extensions.StringShEx;\nusing GCore.Extensions.ArrayEx;\nusing Nuke.Common.Tooling;\nusing System.IO;\n\nclass Build : NukeBuild\n{\n    public static int Main () {\n        Log.LoggingHandler.Add(new GCore.Logging.Logger.ConsoleLogger());\n        return Execute\u003CBuild\u003E(x =\u003E x.Compile);\n    }\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter(\u0022Defines the Github user account to push the Docs.\u0022)] readonly string GithubUsername;\n    [Parameter(\u0022Defines the Github token to push the Docs.\u0022)] readonly string GithubToken;\n    [Parameter(\u0022CommitFlags\u0022)] public string CommitFlags = \u0022\u0022;\n    [Parameter(\u0022DocFx tool command\u0022)] public string[] DocFxTool= new string[] { \u0022docfx\u0022 };\n\n\n    string Source =\u003E \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    string Branch =\u003E GitRepository.Branch;\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    String GitVersion = \u00221.0.1\u0022;\n    string GitVersionSuffix = \u00220\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath DocDirectory =\u003E RootDirectory / \u0022doc\u0022;\n    AbsolutePath DocBuildDirectory =\u003E DocDirectory / \u0022build\u0022;\n    AbsolutePath DocFxDirectory =\u003E DocDirectory / \u0022docfx\u0022;\n    AbsolutePath TempDir =\u003E (AbsolutePath)System.IO.Path.GetTempPath();\n    AbsolutePath GhPagesDir =\u003E TempDir / \u0022Goui\u0022;\n    AbsolutePath WasmTest =\u003E RootDirectory / \u0022PlatformSamples\u0022 / \u0022WasmFormsApp\u0022 / \u0022bin\u0022 / \u0022Debug\u0022 / \u0022netcoreapp2.0\u0022 / \u0022dist\u0022;\n    AbsolutePath WasmTestRelease =\u003E RootDirectory / \u0022PlatformSamples\u0022 / \u0022WasmFormsApp\u0022 / \u0022bin\u0022 / \u0022Release\u0022 / \u0022netcoreapp2.0\u0022 / \u0022dist\u0022;\n\n\n\n    Regex CommentFlagsRex = new Regex(@\u0022^.*\\|\\[([A-Z]\u002B)\\]\\|$\u0022);\n    public Build() {\n        var version = \u0022git tag\u0022.Sh().Split(\u0027\\n\u0027).Get(-2).ExtractVersion();\n        var suffix = \u0022git rev-list --count HEAD\u0022.Sh().Replace(\u0022\\n\u0022, \u0022\u0022).Trim();\n\n        if (CommitFlags.Length == 0) {\n            var comment = \u0022git log -1 --pretty=%B\u0022.Sh().Replace(\u0022\\n\u0022, \u0022\u0022).Trim();\n            var match = CommentFlagsRex.Match(comment);\n            if (match.Success)\n                CommitFlags = match.Groups[1].Value;\n        }\n        \n        Logger.Info($\u0022Using version tag : \u0027{version}\u0027\u0022);\n        Logger.Info($\u0022Using rev suffix  : \u0027{suffix}\u0027\u0022);\n        Logger.Info($\u0022Using commit flags: \u0027{CommitFlags}\u0027\u0022);\n\n        GitVersion = version.ToString(3);\n        GitVersionSuffix = GitVersion \u002B \u0022.\u0022 \u002B suffix;\n\n        Logger.Info($\u0022Using Version     : {GitVersionSuffix}\u0022);\n    }\n\n    void Ex(IProcess process) {\n        process.WaitForExit();\n        if (process.ExitCode != 0)\n            throw new Exception(process.FileName \u002B \u0022 failed\u0022);\n    }\n\n    void DocFx(string command = \u0022\u0022) {\n        Ex(ProcessTasks.StartProcess(DocFxTool[0], DocFxTool.Length \u003E 1 ? (string)(RootDirectory / DocFxTool[1]) \u002B \u0022 \u0022 \u002B command : command, DocFxDirectory));\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n            EnsureCleanDirectory(DocBuildDirectory);\n            EnsureCleanDirectory(GhPagesDir);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(SolutionFile));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(SolutionFile)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersionSuffix)\n                .SetFileVersion(GitVersionSuffix)\n                .SetInformationalVersion(GitVersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Doc =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E {\n            DocFx();\n            DocFx(\u0022build\u0022);\n        });\n\n    private Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .DependsOn(Doc)\n        .Executes(() =\u003E\n        {\n            var version = GitVersionSuffix;\n\n            DotNetPack(s =\u003E s\n                .SetProject(SolutionFile)\n                .SetVersion(version)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols());\n            \n            var basePath = RootDirectory / \u0022Goui.Wasm\u0022;\n            \n            NuGetTasks.NuGetPack(\n                basePath / \u0022Goui.Wasm.nuspec\u0022,\n                s =\u003E s\n                    .SetBasePath(basePath)\n                    .SetVersion(version)\n                    .SetOutputDirectory(ArtifactsDirectory)\n                    .SetConfiguration(Configuration)\n                \n            );\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E\n        {\n            // Nuget deploy\n            if (CommitFlags.Contains(\u0027N\u0027)) {\n                GlobFiles(ArtifactsDirectory, \u0022Goui.*.nupkg\u0022).NotEmpty()\n                    .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                    .ToList()\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(Source)\n                        .SetApiKey(ApiKey)));\n            } else Logger.Warn(\u0022Skipping push to Nuget\u0022);\n           \n        });\n\n    Target GhPages =\u003E _ =\u003E _\n        .DependsOn(Doc)\n        .Requires(() =\u003E GithubUsername)\n        .Requires(() =\u003E GithubToken)\n        .Executes(() =\u003E {\n            Git($\u0022clone -b gh-pages --single-branch https://{GithubUsername}:{GithubToken}@github.com/KevinGliewe/Goui --depth 1 {GhPagesDir}\u0022,\n                TempDir);\n\n            Logger.Info($\u0022Exists DocBuildDirectory \u0027{DocBuildDirectory}\u0027: {Directory.Exists(DocBuildDirectory)}\u0022);\n            Logger.Info($\u0022Exists GhPagesDir \u0027{GhPagesDir}\u0027: {Directory.Exists(GhPagesDir)}\u0022);\n            Logger.Info($\u0022Exists WasmTest \u0027{WasmTest}\u0027: {Directory.Exists(WasmTest)}\u0022);\n            Logger.Info($\u0022Exists WasmTestRelease \u0027{WasmTestRelease}\u0027: {Directory.Exists(WasmTestRelease)}\u0022);\n\n            CopyDirectoryRecursively(DocBuildDirectory, GhPagesDir, FileExistsPolicy.Overwrite);\n            CopyDirectoryRecursively(WasmTestRelease, GhPagesDir / \u0022WasmFormsApp\u0022, FileExistsPolicy.Overwrite);\n            Git(\u0022add .\u0022, GhPagesDir);\n            Git($\u0022commit -m \\\u0022{GitVersionSuffix}\\\u0022\u0022, GhPagesDir);\n\n            // Github pages commit\n            if (CommitFlags.Contains(\u0027P\u0027)) {\n                Git(\u0022push origin gh-pages\u0022, GhPagesDir);\n            } else Logger.Warn(\u0022Skipping push to Github-Pages\u0022);\n        });\n\n    Target All =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .DependsOn(GhPages);\n}\n"
  },
  {
    "Id": 146159057,
    "FirstIndexed": "2020-04-25T15:50:44.7354924+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632433+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433643+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939418+02:00",
    "Name": "kubernetes",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/kubernetes",
    "Description": "Kubernetes Addon",
    "Archived": false,
    "Stars": 3,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/matkoch/kubernetes/blob/master/build/Build.cs",
    "BuildFileSize": 6915,
    "BuildFileContent": "// Copyright 2018 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/nuke/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Octokit;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.GitHub.GitHubTasks;\n\n// ReSharper disable HeapView.DelegateAllocation\n\npartial class Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] readonly string SymbolSource = \u0022https://nuget.smbsrc.net/\u0022;\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter] readonly string GitHubToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    // [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly string SemanticVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    IEnumerable\u003Cstring\u003E SpecificationFiles =\u003E GlobFiles(SourceDirectory, \u0022*/*.json\u0022);\n\n    Target Generate =\u003E _ =\u003E _\n        .OnlyWhenDynamic(() =\u003E SpecificationFiles.Any())\n        .Executes(() =\u003E\n        {\n            string GetNamespace(string specificationFile)\n                =\u003E Solution.Projects.Single(x =\u003E IsDescendantPath(x.Directory, specificationFile)).Name;\n\n            GenerateCode(\n                SpecificationFiles.ToList(),\n                outputFileProvider: x =\u003E x.DefaultOutputFile,\n                namespaceProvider: x =\u003E GetNamespace(x.SpecificationFile),\n                sourceFileProvider: x =\u003E GitRepository.GetGitHubBrowseUrl(x.SpecificationFile));\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, Generate)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    IEnumerable\u003CNuke.Common.ProjectModel.Project\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E TestProjects.Any())\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(OutputDirectory)\n                .CombineWith(\n                    TestProjects, (cs, v) =\u003E cs\n                        .SetProjectFile(v)));\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Changelog =\u003E _ =\u003E _\n        .After(Test)\n        .Before(Pack)\n        .OnlyWhenDynamic(() =\u003E\n            GitRepository.IsOnMasterBranch() ||\n            GitRepository.IsOnReleaseBranch() ||\n            GitRepository.IsOnHotfixBranch())\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, SemanticVersion, GitRepository);\n            Git($\u0022add {ChangelogFile}\u0022);\n            Git($\u0022commit -m \\\u0022Finalize {Path.GetFileName(ChangelogFile)} for v{SemanticVersion}\\\u0022\u0022);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(SemanticVersion)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Changelog)\n        .DependsOn(Pack)\n        .Requires(() =\u003E SemanticVersion)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(async () =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetSource(Source)\n                    .SetSymbolSource(SymbolSource)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(\n                        OutputDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E cs\n                            .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n\n            Git($\u0022tag {SemanticVersion}\u0022);\n            Git($\u0022push origin {GitRepository.Branch} {SemanticVersion}\u0022);\n\n            return;\n\n            await PublishRelease(s =\u003E s\n                .SetToken(GitHubToken)\n                .SetRepositoryOwner(GitRepository.GetGitHubOwner())\n                .SetRepositoryName(GitRepository.GetGitHubName())\n                .SetCommitSha(GitRepository.Branch)\n                .SetTag($\u0022{SemanticVersion}\u0022)\n                .SetName($\u0022v{SemanticVersion}\u0022)\n                .SetReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    bool GitHubMilestoneClosed(bool mustExist) =\u003E GetMilestone().Result?.State.Value == ItemState.Closed;\n\n    async Task\u003CMilestone\u003E GetMilestone()\n    {\n        var client = new GitHubClient(new ProductHeaderValue(nameof(NukeBuild))) { Credentials = new Credentials(GitHubToken) };\n        var milestones = await client.Issue.Milestone.GetAllForRepository(\n            GitRepository.GetGitHubOwner(),\n            GitRepository.GetGitHubName());\n        return milestones.FirstOrDefault(x =\u003E x.Title == $\u0022v{SemanticVersion}\u0022);\n    }\n}\n"
  },
  {
    "Id": 146177400,
    "FirstIndexed": "2020-04-25T15:50:44.7355737+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626681+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433973+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939726+02:00",
    "Name": "dotapi",
    "Owner": "ElijahReva",
    "HtmlUrl": "https://github.com/ElijahReva/dotapi",
    "Description": "Generate publick api definition from netstandart2.0 assembly",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ElijahReva/dotapi/blob/develop/build/Build.cs",
    "BuildFileSize": 6537,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.ChangeLog;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tooling.ProcessTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.ControlFlow;\n\nclass Build : NukeBuild\n{\n    readonly string ProductName = \u0022dotapi\u0022;\n    readonly string MasterBranch = \u0022master\u0022;\n    readonly string DevelopBranch = \u0022develop\u0022;\n    \n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n    \n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter] string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] string SymbolSource = \u0022https://nuget.smbsrc.net/\u0022;\n    \n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    \n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    string ReleaseVersion =\u003E \u00220.4.1\u0022;\n    string FileVersion =\u003E $\u0022{ReleaseVersion}.0\u0022;\n    string NugetVersion =\u003E GetNugetVersion();\n    string InformationalVersion =\u003E $\u0022{NugetVersion}.{GetCommitId()}\u0022;\n    string ReleaseNotes =\u003E string.Join(NewLine, ExtractChangelogSectionNotes(ChangelogFile));\n    \n    Target PrintVersion =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Release Version: {0}\u0022, ReleaseVersion);\n            Logger.Info(\u0022File Version: {0}\u0022, FileVersion);\n            Logger.Info(\u0022Informational Version: {0}\u0022, InformationalVersion);\n            Logger.Info(\u0022NuGet Version: {0}\u0022, NugetVersion);\n            Logger.Info(\u0022Release Notes: {0}\u0022, ReleaseNotes);\n        });    \n    \n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(PrintVersion)\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022*/bin\u0022, \u0022*/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Project DotApiProject =\u003E Solution.GetProject(ProductName).NotNull();\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(SolutionFile)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(ReleaseVersion)\n                .SetFileVersion(FileVersion)\n                .SetInformationalVersion(InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n        {\n            GlobFiles(TestsDirectory, \u0022**/*.Tests.fsproj\u0022)\n                .NotEmpty()\n                .ForEach(project =\u003E\n                    DotNetTest(s =\u003E DefaultDotNetTest\n                        .EnableNoBuild()\n                        .SetProjectFile(project)\n                        .SetArgumentConfigurator(args =\u003E args\n                            .Add(\u0022/p:CollectCoverage=true\u0022)\n                            .Add(\u0022/p:CoverletOutputFormat=opencover\u0022))));\n        });\n    \n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(DotApiProject.Path)\n                .SetVersion(NugetVersion)\n                .SetOutputDirectory(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .SetPackageReleaseNotes(ReleaseNotes)\n                .EnableNoBuild());\n        });\n    \n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack, Test)\n        .OnlyWhen(    \n            () =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch), \n            () =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(DevelopBranch)\n        )\n        .Requires(() =\u003E ApiKey) \n        .Requires(() =\u003E GitStatus())\n        .Requires(() =\u003E Configuration.EqualsOrdinalIgnoreCase(\u0022release\u0022))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                    .SetTargetPath(x)\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)));\n        });\n    \n    Target Install =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Executes(() =\u003E\n        {\n            SuppressErrors(() =\u003E DotNet($\u0022tool uninstall -g {ProductName}\u0022));\n            DotNet($\u0022tool install -g {ProductName} --add-source {OutputDirectory} --version {NugetVersion}\u0022);\n        });\n\n    string GetNugetVersion()\n    {\n        var sb = new StringBuilder(ReleaseVersion);\n        if (!GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch))\n        {\n            if (!GitRepository.Branch.EqualsOrdinalIgnoreCase(DevelopBranch))\n            {\n                sb.Append($\u0022-{GitRepository.Branch?.Replace(\u0027/\u0027, \u0027-\u0027)}\u0022);\n            }\n            else\n            {\n                sb.Append(\u0022-dev\u0022);\n            }\n            if (IsServerBuild \u0026\u0026 Travis.Instance != null \u0026\u0026 Travis.Instance.Ci)\n            {\n                sb.Append(Travis.Instance.BuildNumber);\n            }\n            else\n            {\n                sb.Append(\u0022-local\u0022);\n            }\n        }\n        else\n        {\n            if (IsServerBuild \u0026\u0026 Travis.Instance != null \u0026\u0026 Travis.Instance.Ci)\n            {\n                sb.Append($\u0022.{Travis.Instance.BuildNumber}\u0022);\n            }\n            else\n            {\n                sb.Append(\u0022-local\u0022);\n            }    \n        }\n\n        return sb.ToString();\n    }\n\n    string GetCommitId()\n    {\n        var process = StartProcess(GitPath, \u0022rev-parse --short HEAD\u0022);\n        process.AssertZeroExitCode();\n        if (process.Output.Count == 1)\n        {\n           return process.Output.First().Text;\n        }\n        throw new InvalidOperationException(\u0022Not a git repo\u0022);\n    }\n\n    bool GitStatus()\n    {\n        // Fix chmod \u002Bx build.sh\n        return Git(\u0022status --short\u0022).All(o =\u003E o.Text.Contains(\u0022build.sh\u0022));\n    }\n\n}\n"
  },
  {
    "Id": 148007741,
    "FirstIndexed": "2020-04-25T15:50:44.7355669+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626635+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433945+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939697+02:00",
    "Name": "nukebuildtest",
    "Owner": "noufionline",
    "HtmlUrl": "https://github.com/noufionline/nukebuildtest",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/noufionline/nukebuildtest/blob/master/build/Build.cs",
    "BuildFileSize": 2162,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(SolutionFile));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(SolutionFile)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(SolutionFile)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols());\n        });\n}\n"
  },
  {
    "Id": 148132066,
    "FirstIndexed": "2020-04-25T15:50:44.7362193+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632621+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434906+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894063+02:00",
    "Name": "feed-the-monster",
    "Owner": "Megapop",
    "HtmlUrl": "https://github.com/Megapop/feed-the-monster",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 6,
    "BuildFilePath": "Assets/Editor/Megapop/HeadlessBuild.cs",
    "BuildFileUrl": "https://github.com/Megapop/feed-the-monster/blob/master/Assets/Editor/Megapop/HeadlessBuild.cs",
    "BuildFileSize": 10450,
    "BuildFileContent": "\uFEFFusing System;\nusing UnityEngine;\nusing System.IO;\nusing System.Linq;\nusing JetBrains.Annotations;\nusing UnityEditor;\n\n// ReSharper disable UnusedMember.Local\n\n/// \u003Csummary\u003E\n/// Only MenuItems that correspond to the current target are shown, to avoid accidentally triggering a full reimport of all assets in the Unity editor.\n/// To execute headless build from the command line, do something like this:\n/// \n/// Unity.exe -quit -batchmode -executeMethod HeadlessBuild.BuildiOS\n/// \u003C/summary\u003E\n\n[UsedImplicitly]\npublic class HeadlessBuild : MonoBehaviour\n{\n    /// \u003Csummary\u003E\n    /// Target environments for the headless builds.\n    /// \u003C/summary\u003E\n    private enum BuildSettingsEnvironment\n    {\n        /// \u003Csummary\u003E\n        /// Development environment, with all debugging enabled.\n        /// \u003C/summary\u003E\n        Dev,\n        /// \u003Csummary\u003E\n        /// Prod environment, connecting to the prod servers and with all debugging disabled.\n        /// \u003C/summary\u003E\n        Prod\n    }\n\n    /// \u003Csummary\u003E\n    /// Settings for a build.\n    /// \u003C/summary\u003E\n    private class BuildSettings\n    {\n        public BuildOptions Options = BuildOptions.None;\n        public BuildSettingsEnvironment Environment = BuildSettingsEnvironment.Dev;\n        public BuildTarget Target;\n        public BuildTargetGroup TargetGroup;\n    }\n\n    /// \u003Csummary\u003E\n    /// Find the build nyum\n    /// \u003C/summary\u003E\n    /// \u003Creturns\u003E\u003C/returns\u003E\n    private static string BuildNumber\n    {\n        get\n        {\n            var commandLineArgs = Environment.GetCommandLineArgs();\n\n            for (var index = 0; index \u003C commandLineArgs.Length; index\u002B\u002B)\n            {\n                var arg = commandLineArgs[index];\n                if (arg == \u0022-buildNumber\u0022)\n                {\n                    return commandLineArgs[index \u002B 1];\n                }\n            }\n            return \u00220\u0022;\n        }\n    }\n\n    private static string KeystorePassword\n    {\n        get\n        {\n            var commandLineArgs = Environment.GetCommandLineArgs();\n\n            for (var index = 0; index \u003C commandLineArgs.Length; index\u002B\u002B)\n            {\n                var arg = commandLineArgs[index];\n                if (arg == \u0022-storepass\u0022)\n                {\n                    return commandLineArgs[index \u002B 1];\n                }\n            }\n            return \u0022\u0022;\n        }\n    }\n\n    private static string KeyPassword\n    {\n        get\n        {\n            var commandLineArgs = Environment.GetCommandLineArgs();\n\n            for (var index = 0; index \u003C commandLineArgs.Length; index\u002B\u002B)\n            {\n                var arg = commandLineArgs[index];\n                if (arg == \u0022-keypass\u0022)\n                {\n                    return commandLineArgs[index \u002B 1];\n                }\n            }\n            return \u0022\u0022;\n        }\n    }\n\n    private static string[] Scenes\n    {\n        get\n        {\n            return (from scene in EditorBuildSettings.scenes\n                where scene.enabled\n                select scene.path).ToArray();\n        }\n    }\n\n    /// \u003Csummary\u003E\n    /// Get the root path of the Unity project.\n    /// \u003C/summary\u003E\n    private static string ProjectRoot\n    {\n        get\n        {\n            return (Application.dataPath.Replace(\u0022/Assets\u0022, \u0022\u0022));\n        }\n    }\n\n    /// \u003Csummary\u003E\n    /// Get the root path for all builds.\n    /// \u003C/summary\u003E\n    private static string OutputPath\n    {\n        get\n        {\n            return (ProjectRoot \u002B \u0022/build\u0022);\n        }\n    }\n\n    /// \u003Csummary\u003E\n    /// Get the full path for the current BuildTarget.\n    /// \u003C/summary\u003E\n    /// \u003Cparam name=\u0022buildTarget\u0022\u003E\u003C/param\u003E\n    /// \u003Creturns\u003E\u003C/returns\u003E\n    private static string GetTargetPath(BuildTarget buildTarget)\n\n    {\n        // ReSharper disable once SwitchStatementMissingSomeCases\n        switch (buildTarget)\n        {\n            case BuildTarget.iOS:\n                return \u0022FeedTheMonster_iOS\u0022;\n            case BuildTarget.Android:\n                return \u0022FeedTheMonster.apk\u0022;\n            case BuildTarget.StandaloneWindows:\n                return \u0022FeedTheMonster.exe\u0022;\n            default:\n                return \u0022\u0022;\n\n        }\n    }\n\n    private static void NukeBuild()\n    {\n        try\n        {\n            if (Directory.Exists(OutputPath))\n            {\n                Directory.Delete(OutputPath, true);\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogWarning(\u0022Failed to clear build output directory: \u0022 \u002B OutputPath \u002B \u0022: \u0022 \u002B e);\n        }\n    }\n\n    private static void PrepareBuild(BuildSettings settings)\n    {\n        NukeBuild();\n        Directory.CreateDirectory(OutputPath);\n\n        var defines = \u0022USES_NOTIFICATION_SERVICE;\u0022;\n\n        // Do not include Google Play Games on iOS.\n\n        if (settings.Target == BuildTarget.iOS)\n        {\n            defines \u002B= \u0022NO_GPGS;\u0022;\n            PlayerSettings.iOS.buildNumber = BuildNumber;\n        }\n\n        switch (settings.Environment)\n        {\n            case BuildSettingsEnvironment.Dev:\n                defines \u002B= \u0022DEBUG;\u0022;\n                break;\n            case BuildSettingsEnvironment.Prod:\n                defines \u002B= \u0022LIVE;RELEASE;\u0022;\n                break;\n            default:\n                throw new ArgumentOutOfRangeException();\n        }\n\n        Debug.Log(\u0022Defines for \u0022 \u002B settings.TargetGroup \u002B \u0022: \u0022 \u002B defines);\n\n        PlayerSettings.SetScriptingDefineSymbolsForGroup(settings.TargetGroup, defines);\n\n        // Build with Gradle.\n        if (settings.Target == BuildTarget.Android)\n        {\n            EditorUserBuildSettings.exportAsGoogleAndroidProject = false;\n        }\n    }\n\n    private static void Build(BuildSettings settings)\n    {\n        var targetPath = GetTargetPath(settings.Target);\n\n        Debug.Log(\u0022Starting \u0022 \u002B settings.Target \u002B \u0022 build to \u0027\u0022 \u002B targetPath \u002B \u0022\u0027 using options \u0027\u0022 \u002B settings.Options \u002B \u0022\u0027.\u0022);\n\n        var report = BuildPipeline.BuildPlayer(Scenes, targetPath, settings.Target, settings.Options);\n        var summary = report.summary;\n\n        if (summary.totalErrors \u003E 0)\n        {\n            Debug.LogError(settings.Target \u002B \u0022 build failed with \u0022 \u002B summary.totalErrors \u002B \u0022 total errors: \u0022 \u002B summary);\n            throw new Exception(summary.ToString());\n        }\n\n        Debug.Log(settings.Target \u002B \u0022 build successful.\u0022);\n    }\n\n    #region iOS\n\n#if UNITY_IOS || UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX\n    [MenuItem(\u0022Megapop/Build/Build iOS\u0022)]\n#endif\n    private static void BuildiOS()\n    {\n        var settings = new BuildSettings\n        {\n            Environment = BuildSettingsEnvironment.Dev,\n            Target = BuildTarget.iOS,\n            TargetGroup = BuildTargetGroup.iOS\n        };\n\n        Debug.Log(\u0022BuildiOS()\u0022);\n\n        PrepareBuild(settings);\n        Build(settings);\n    }\n\n#if UNITY_IOS || UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX\n    [MenuItem(\u0022Megapop/Build/Build iOS Prod\u0022)]\n#endif\n    private static void BuildiOSProd()\n    {\n        var settings = new BuildSettings\n        {\n            Environment = BuildSettingsEnvironment.Prod,\n            Target = BuildTarget.iOS,\n            TargetGroup = BuildTargetGroup.iOS\n        };\n\n        Debug.Log(\u0022BuildiOSProd()\u0022);\n\n        PrepareBuild(settings);\n        Build(settings);\n    }\n\n#if UNITY_IOS || UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX\n    [MenuItem(\u0022Megapop/Build/Build and Run iOS\u0022)]\n#endif\n    private static void BuildAndRuniOS()\n    {\n        var settings = new BuildSettings\n        {\n            Environment = BuildSettingsEnvironment.Dev,\n            Target = BuildTarget.iOS,\n            TargetGroup = BuildTargetGroup.iOS,\n            Options = BuildOptions.AllowDebugging | BuildOptions.AutoRunPlayer | BuildOptions.ConnectWithProfiler | BuildOptions.Development\n        };\n\n        Debug.Log(\u0022BuildAndRuniOS()\u0022);\n\n        PrepareBuild(settings);\n        Build(settings);\n    }\n\n    #endregion\n\n    #region Android\n\n    /// \u003Csummary\u003E\n    /// Build the project for Android.\n    /// \u003C/summary\u003E\n#if UNITY_ANDROID\n    [MenuItem(\u0022Megapop/Build/Build Android\u0022)]\n#endif\n    private static void BuildAndroid()\n    {\n        var settings = new BuildSettings\n        {\n            Environment = BuildSettingsEnvironment.Dev,\n            Target = BuildTarget.Android,\n            TargetGroup = BuildTargetGroup.Android\n        };\n\n        Debug.Log(\u0022BuildAndroid()\u0022);\n\n        PrepareAndBuildAndroid(settings);\n    }\n\n    /// \u003Csummary\u003E\n    /// Build the project for Android.\n    /// \u003C/summary\u003E\n#if UNITY_ANDROID\n    [MenuItem(\u0022Megapop/Build/Build Android Live\u0022)]\n#endif\n    private static void BuildAndroidProd()\n    {\n        var settings = new BuildSettings\n        {\n            Environment = BuildSettingsEnvironment.Prod,\n            Target = BuildTarget.Android,\n            TargetGroup = BuildTargetGroup.Android\n        };\n\n        Debug.Log(\u0022BuildAndroidProd()\u0022);\n\n        PrepareAndBuildAndroid(settings);\n    }\n\n    /// \u003Csummary\u003E\n    /// Build and immediately run the project on an attached Android device.\n    /// \u003C/summary\u003E\n#if UNITY_ANDROID\n    [MenuItem(\u0022Megapop/Build/Build and Run Android\u0022)]\n#endif\n    private static void BuildAndRunAndroid()\n    {\n        var settings = new BuildSettings\n        {\n            Environment = BuildSettingsEnvironment.Dev,\n            Target = BuildTarget.Android,\n            TargetGroup = BuildTargetGroup.Android,\n            Options = BuildOptions.AllowDebugging | BuildOptions.AutoRunPlayer | BuildOptions.ConnectWithProfiler | BuildOptions.Development\n        };\n\n        Debug.Log(\u0022BuildAndRunAndroid()\u0022);\n\n        PrepareAndBuildAndroid(settings);\n    }\n\n    private static void PrepareAndBuildAndroid(BuildSettings settings)\n    {\n        PrepareBuild(settings);\n\n        if (settings.Environment == BuildSettingsEnvironment.Dev)\n        {\n            Debug.Log(\u0022Select debug key from \u0027debug.keystore\u0027.\u0022);\n\n            PlayerSettings.Android.keystoreName = \u0022debug.keystore\u0022;\n            PlayerSettings.Android.keystorePass = \u0022debug123\u0022;\n            PlayerSettings.Android.keyaliasName = \u0022debug\u0022;\n            PlayerSettings.Android.keyaliasPass = \u0022debug123\u0022;\n        }\n        else\n        {\n            Debug.Log(\u0022Select upload key from \u0027upload.keystore\u0027.\u0022);\n\n            PlayerSettings.Android.keystoreName = \u0022upload.keystore\u0022;\n            PlayerSettings.Android.keystorePass = KeystorePassword;\n            PlayerSettings.Android.keyaliasName = \u0022upload\u0022;\n            PlayerSettings.Android.keyaliasPass = KeyPassword;\n        }\n\n        Build(settings);\n    }\n    #endregion\n}\n"
  },
  {
    "Id": 148135427,
    "FirstIndexed": "2020-04-25T15:50:44.7355646+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632308+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433933+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939686+02:00",
    "Name": "nuke-helm",
    "Owner": "arodus",
    "HtmlUrl": "https://github.com/arodus/nuke-helm",
    "Description": "Helm Addon",
    "Archived": false,
    "Stars": 4,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/arodus/nuke-helm/blob/master/build/Build.cs",
    "BuildFileSize": 6959,
    "BuildFileContent": "\uFEFF// Copyright 2018 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/nuke/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Octokit;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.GitHub.GitHubTasks;\n\n// ReSharper disable HeapView.DelegateAllocation\n\npartial class Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] readonly string SymbolSource = \u0022https://nuget.smbsrc.net/\u0022;\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter] readonly string GitHubToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    // [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly string SemanticVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    IEnumerable\u003Cstring\u003E SpecificationFiles =\u003E GlobFiles(SourceDirectory, \u0022*/*.json\u0022);\n\n    Target Generate =\u003E _ =\u003E _\n        .OnlyWhenDynamic(() =\u003E SpecificationFiles.Any())\n        .Executes(() =\u003E\n        {\n            string GetNamespace(string specificationFile)\n                =\u003E Solution.Projects.Single(x =\u003E IsDescendantPath(x.Directory, specificationFile)).Name;\n\n            GenerateCode(\n                SpecificationFiles.ToList(),\n                outputFileProvider: x =\u003E x.DefaultOutputFile,\n                namespaceProvider: x =\u003E GetNamespace(x.SpecificationFile),\n                sourceFileProvider: x =\u003E GitRepository.GetGitHubBrowseUrl(x.SpecificationFile));\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, Generate)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    IEnumerable\u003CNuke.Common.ProjectModel.Project\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E TestProjects.Any())\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(OutputDirectory)\n                .CombineWith(\n                    TestProjects, (cs, v) =\u003E cs\n                        .SetProjectFile(v)));\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Changelog =\u003E _ =\u003E _\n        .After(Test)\n        .Before(Pack)\n        .Requires(() =\u003E SemanticVersion)\n        .OnlyWhenDynamic(() =\u003E\n            GitRepository.IsOnMasterBranch() ||\n            GitRepository.IsOnReleaseBranch() ||\n            GitRepository.IsOnHotfixBranch())\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, SemanticVersion, GitRepository);\n            Git($\u0022add {ChangelogFile}\u0022);\n            Git($\u0022commit -m \\\u0022Finalize {Path.GetFileName(ChangelogFile)} for v{SemanticVersion}\\\u0022\u0022);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(SemanticVersion)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Changelog)\n        .DependsOn(Pack)\n        .Requires(() =\u003E SemanticVersion)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(async () =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetSource(Source)\n                    .SetSymbolSource(SymbolSource)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(\n                        OutputDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E cs\n                            .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n\n            Git($\u0022tag {SemanticVersion}\u0022);\n            Git($\u0022push origin {GitRepository.Branch} {SemanticVersion}\u0022);\n\n            return;\n\n            await PublishRelease(s =\u003E s\n                .SetToken(GitHubToken)\n                .SetRepositoryOwner(GitRepository.GetGitHubOwner())\n                .SetRepositoryName(GitRepository.GetGitHubName())\n                .SetCommitSha(GitRepository.Branch)\n                .SetTag($\u0022{SemanticVersion}\u0022)\n                .SetName($\u0022v{SemanticVersion}\u0022)\n                .SetReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    bool GitHubMilestoneClosed(bool mustExist) =\u003E GetMilestone().Result?.State.Value == ItemState.Closed;\n\n    async Task\u003CMilestone\u003E GetMilestone()\n    {\n        var client = new GitHubClient(new ProductHeaderValue(nameof(NukeBuild))) { Credentials = new Credentials(GitHubToken) };\n        var milestones = await client.Issue.Milestone.GetAllForRepository(\n            GitRepository.GetGitHubOwner(),\n            GitRepository.GetGitHubName());\n        return milestones.FirstOrDefault(x =\u003E x.Title == $\u0022v{SemanticVersion}\u0022);\n    }\n}\n"
  },
  {
    "Id": 148547903,
    "FirstIndexed": "2020-04-25T15:50:44.7355413+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163266+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433831+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939589+02:00",
    "Name": "Dangl.EvaluationPackageGenerator",
    "Owner": "Dangl-IT",
    "HtmlUrl": "https://github.com/Dangl-IT/Dangl.EvaluationPackageGenerator",
    "Description": "Internal tool to generate evaluation packages",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Dangl-IT/Dangl.EvaluationPackageGenerator/blob/master/build/Build.cs",
    "BuildFileSize": 6295,
    "BuildFileContent": "using Nuke.Azure.KeyVault;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.DocFX;\nusing Nuke.WebDocu;\nusing System;\nusing System.IO;\nusing System.IO.Compression;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.TextTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.DocFX.DocFXTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n    [KeyVault] readonly KeyVault KeyVault;\n\n    [KeyVaultSettings(\n    BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n    ClientIdParameterName = nameof(KeyVaultClientId),\n    ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [KeyVaultSecret] readonly string DocuBaseUrl;\n    [KeyVaultSecret(\u0022DanglEvaluationPackageGenerator-DocuApiKey\u0022)] readonly string DocuApiKey;\n\n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath X64CliZipPath =\u003E OutputDirectory / \u0022Dangl.EvaluationPackageGenerator_Win_x64.zip\u0022;\n    AbsolutePath X86CliZipPath =\u003E OutputDirectory / \u0022Dangl.EvaluationPackageGenerator_Win_x86.zip\u0022;\n    string DocFxFile =\u003E RootDirectory / \u0022docfx.json\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target WriteVersion =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var buildDate = DateTime.UtcNow;\n            var filePath = RootDirectory / \u0022Dangl.EvaluationPackageGenerator\u0022 / \u0022VersionInfo.cs\u0022;\n\n            var currentDateUtc = $\u0022new DateTime({buildDate.Year}, {buildDate.Month}, {buildDate.Day}, {buildDate.Hour}, {buildDate.Minute}, {buildDate.Second}, DateTimeKind.Utc)\u0022;\n\n            var content = $@\u0022using System;\n\nnamespace Dangl.EvaluationPackageGenerator\n{{\n#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member\n    // This file is automatically generated\n    [System.CodeDom.Compiler.GeneratedCode(\u0022\u0022GitVersionBuild\u0022\u0022, \u0022\u0022\u0022\u0022)]\n    public static class VersionInfo\n    {{\n        public static string Version =\u003E \u0022\u0022{GitVersion.NuGetVersionV2}\u0022\u0022;\n        public static string CommitInfo =\u003E \u0022\u0022{GitVersion.FullBuildMetaData}\u0022\u0022;\n        public static string CommitDate =\u003E \u0022\u0022{GitVersion.CommitDate}\u0022\u0022;\n        public static string CommitHash =\u003E \u0022\u0022{GitVersion.Sha}\u0022\u0022;\n        public static string InformationalVersion =\u003E \u0022\u0022{GitVersion.InformationalVersion}\u0022\u0022;\n        public static DateTime BuildDateUtc =\u003E {currentDateUtc};\n    }}\n}}\u0022;\n            WriteAllText(filePath, content);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(WriteVersion)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E Configuration == \u0022Release\u0022)\n        .Executes(() =\u003E\n        {\n            var publishPath = OutputDirectory / \u0022CLI_Tool\u0022;\n            DotNetPublish(x =\u003E x\n                .SetWorkingDirectory(RootDirectory / \u0022Dangl.EvaluationPackageGenerator\u0022)\n                .SetSelfContained(true)\n                .SetConfiguration(\u0022Release\u0022)\n                .SetRuntime(\u0022win10-x64\u0022)\n                .SetOutput(publishPath)\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.NuGetVersionV2));\n            ZipFile.CreateFromDirectory(publishPath, X64CliZipPath);\n            DeleteDirectory(publishPath);\n\n            DotNetPublish(x =\u003E x\n                .SetWorkingDirectory(RootDirectory / \u0022Dangl.EvaluationPackageGenerator\u0022)\n                .SetSelfContained(true)\n                .SetConfiguration(\u0022Release\u0022)\n                .SetRuntime(\u0022win10-x86\u0022)\n                .SetOutput(publishPath)\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetInformationalVersion(GitVersion.NuGetVersionV2));\n            ZipFile.CreateFromDirectory(publishPath, X86CliZipPath);\n            DeleteDirectory(publishPath);\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(RootDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(RootDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(RootDirectory / \u0022README.md\u0022, RootDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(s =\u003E s.SetConfigFile(DocFxFile));\n\n            File.Delete(RootDirectory / \u0022index.md\u0022);\n        });\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n        .DependsOn(BuildDocumentation)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuBaseUrl)\n        .Executes(() =\u003E\n        {\n            WebDocu(s =\u003E s\n                .SetDocuBaseUrl(DocuBaseUrl)\n                .SetDocuApiKey(DocuApiKey)\n                .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                .SetVersion(GitVersion.NuGetVersion)\n                .SetAssetFilePaths(new string[] { X64CliZipPath, X86CliZipPath })\n            );\n        });\n}\n"
  },
  {
    "Id": 148631334,
    "FirstIndexed": "2020-04-25T15:50:44.7354947+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632404+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433655+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "docfx",
    "Owner": "arodus",
    "HtmlUrl": "https://github.com/arodus/docfx",
    "Description": "DocFX Addon",
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 148825834,
    "FirstIndexed": "2020-04-25T15:50:44.7355624+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626607+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433922+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939674+02:00",
    "Name": "AzureFolderMigrator",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/AzureFolderMigrator",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/AzureFolderMigrator/blob/develop/build/Build.cs",
    "BuildFileSize": 3561,
    "BuildFileContent": "using Nuke.Azure.KeyVault;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.GitHub;\nusing System;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.GitHub.GitHubTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] readonly string KeyVaultBaseUrl;\n    [Parameter] readonly string KeyVaultClientId;\n    [Parameter] readonly string KeyVaultClientSecret;\n    [GitVersion] readonly GitVersion GitVersion;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [KeyVaultSecret] readonly string GitHubAuthenticationToken;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    string ZipPath =\u003E RootDirectory / \u0022AzureFolderMigrator.zip\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteFile(ZipPath);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E DefaultDotNetRestore);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E DefaultDotNetBuild\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetAssemblyVersion(GitVersion.AssemblySemVer));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(SourceDirectory / \u0022AzureFolderMigrator\u0022)\n                .SetOutput(OutputDirectory)\n                .SetConfiguration(Configuration));\n        });\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.NuGetVersion}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n            ZipFile.CreateFromDirectory(OutputDirectory, ZipPath);\n\n            var isStable = GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022);\n\n            await PublishRelease(x =\u003E x\n                    .SetArtifactPaths(new string[] { ZipPath })\n                    .SetReleaseNotes(completeChangeLog)\n                    .SetCommitSha(GitVersion.Sha)\n                    .SetPrerelease(!isStable)\n                    .SetRepositoryName(repositoryInfo.repositoryName)\n                    .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                    .SetTag(releaseTag)\n                    .SetToken(GitHubAuthenticationToken));\n        });\n}\n"
  },
  {
    "Id": 151045318,
    "FirstIndexed": "2020-04-25T15:50:44.736258+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362592+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843506+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940778+02:00",
    "Name": "helm-terminal",
    "Owner": "ElijahReva",
    "HtmlUrl": "https://github.com/ElijahReva/helm-terminal",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ElijahReva/helm-terminal/blob/master/build/Build.cs",
    "BuildFileSize": 2714,
    "BuildFileContent": "\uFEFFusing System.Linq;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    AbsolutePath SourceDir =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestDir =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutDir =\u003E RootDirectory / \u0022out\u0022;\n    \n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDir, \u0022*/wwwroot/*\u0022));\n            DeleteDirectories(GlobDirectories(SourceDir, \u0022*/bin/*\u0022, \u0022*/obj/*\u0022));\n            DeleteDirectories(GlobDirectories(TestDir, \u0022*/bin\u0022, \u0022*/obj\u0022));\n        });\n    \n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s);\n        });\n\n    /// \u003Csummary\u003E\n    /// Building solution with version information included\n    /// \u003C/summary\u003E\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s.AddProperty(\u0022nodeReuse\u0022, \u0022false\u0022).SetConfiguration(\u0022Release\u0022));\n        });\n\n    /// \u003Csummary\u003E\n    /// Running all tests with coverlet params \n    /// \u003C/summary\u003E\n    /// \u003Cseealso\u003E\n    ///     https://github.com/tonerdo/coverlet\n    /// \u003C/seealso\u003E\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            GlobFiles(\u0022tests\u0022, \u0022*.Tests.*proj\u0022).NotEmpty()\n                .ForEach(testProjectFile =\u003E\n                    DotNetTest(s =\u003E s\n                            .SetProjectFile(testProjectFile)\n                            .SetArgumentConfigurator(args =\u003E args\n                                    .Add(\u0022/p:CollectCoverage=true\u0022)\n                                    .Add(\u0022/p:CoverletOutputFormat=opencover\u0022))));\n        });\n\n    /// \u003Csummary\u003E\n    /// Target used inside Dockerfile to create signed asseblies\n    /// \u003C/summary\u003E\n    Target Publish =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var globFiles = GlobFiles(SourceDir, \u0022*.fsproj\u0022);\n            var projectFile = globFiles.First();\n            Logger.Info($\u0022Project File: {projectFile}\u0022);\n            Logger.Info($\u0022Output Dir: {OutDir}\u0022);\n\n            DotNetPublish(s =\u003E\n                s\n                .SetOutput(OutDir)\n                .SetProject(projectFile));\n        });\n\n    /// \u003Csummary\u003E\n    /// Removes node_modules folder in src/\n    /// \u003C/summary\u003E\n    Target nr =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDir, \u0022*/node*\u0022));\n        });\n}\n"
  },
  {
    "Id": 152327443,
    "FirstIndexed": "2020-04-25T15:47:03.6110731+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629805+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431083+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936955+02:00",
    "Name": "RxSockets",
    "Owner": "davidnajar",
    "HtmlUrl": "https://github.com/davidnajar/RxSockets",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/davidnajar/RxSockets/blob/master/build/Build.cs",
    "BuildFileSize": 3745,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.NuGet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AppVeyor(AppVeyorImage.VisualStudio2019, AutoGenerate =true)]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Script);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Nuget API Key\u0022)]\n    readonly string NugetApiKey;\n\n    \n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath Project =\u003E SourceDirectory / \u0022RxSockets/RxSockets.csproj\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n     \n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Version =\u003E _ =\u003E _\n        .DependsOn(Clean)\n    .Executes(() =\u003E\n    {\n        Logger.Info($\u0022Next version is {GitVersion.AssemblySemVer}\u0022);\n     \n    });\n\n\n\n    Target Restore =\u003E _ =\u003E _\n    .DependsOn(Version)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetVersion(GitVersion.SemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n     .DependsOn(Compile)\n     .Produces(OutputDirectory / \u0022*.nupkg\u0022)\n     .Executes(() =\u003E\n     {\n         DotNetPack(_ =\u003E _\n         .SetConfiguration(Configuration)\n         .SetNoBuild(true)\n         .SetPackageId(\u0022Rx.Sockets\u0022)\n         .SetVersion(GitVersion.SemVer)\n         .SetOutputDirectory(OutputDirectory)\n         .SetProject(Project));\n     });\n    Target Push =\u003E _ =\u003E _\n .DependsOn(Pack)\n    .OnlyWhenDynamic(()=\u003E!IsLocalBuild \u0026\u0026 GitVersion.BranchName==\u0022master\u0022)\n    .Requires(()=\u003ENugetApiKey)\n .Executes(() =\u003E\n {\n     DotNetNuGetPush(_ =\u003E _\n        .SetTargetPath(OutputDirectory / \u0022*.nupkg\u0022)\n        .SetApiKey(NugetApiKey)\n        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n\n\n     );\n });\n    Target Script  =\u003E _ =\u003E _\n        .DependsOn(Push);\n\n\n\n\n}\n"
  },
  {
    "Id": 153035538,
    "FirstIndexed": "2020-04-25T15:47:03.6116181+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625469+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431095+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936967+02:00",
    "Name": "AutoMapper.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/AutoMapper.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/AutoMapper.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 153039197,
    "FirstIndexed": "2020-04-25T15:47:03.6115874+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625367+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431106+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936978+02:00",
    "Name": "FluentValidation.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/FluentValidation.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/FluentValidation.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 153040060,
    "FirstIndexed": "2020-04-25T15:47:03.6115806+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625327+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431112+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8936989+02:00",
    "Name": "MediatR.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/MediatR.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/MediatR.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 153040181,
    "FirstIndexed": "2020-04-25T15:47:03.6115829+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625338+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431123+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937001+02:00",
    "Name": "Marten.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Marten.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Marten.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 154881326,
    "FirstIndexed": "2020-04-25T15:47:03.6116278+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631818+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431134+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937012+02:00",
    "Name": "Syrup",
    "Owner": "pkudrel",
    "HtmlUrl": "https://github.com/pkudrel/Syrup",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "src/build/Build.cs",
    "BuildFileUrl": "https://github.com/pkudrel/Syrup/blob/production/src/build/Build.cs",
    "BuildFileSize": 12858,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing Helpers;\nusing Helpers.Azure;\nusing Helpers.MagicVersionService;\nusing Helpers.Syrup;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// Parameters\n    [Parameter(\u0022Build counter from outside environment\u0022)]\n    readonly int BuildCounter;\n\n    readonly DateTime BuildDate = DateTime.UtcNow;\n\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    readonly bool IsAzureDevOps = string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\u0022AGENT_NAME\u0022)) == false;\n\n    readonly bool IsTeamCity = string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\u0022TEAMCITY_VERSION\u0022)) == false;\n\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath ToolsDir =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath DevDir =\u003E RootDirectory / \u0022dev\u0022;\n    AbsolutePath LibzPath =\u003E ToolsDir / \u0022LibZ.Tool\u0022 / \u0022tools\u0022 / \u0022libz.exe\u0022;\n    AbsolutePath NugetPath =\u003E ToolsDir / \u0022nuget.exe\u0022;\n    AbsolutePath TmpBuild =\u003E TemporaryDirectory / \u0022build\u0022;\n    AbsolutePath ArtifactsDir =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath SourceDir =\u003E RootDirectory / \u0022src\u0022;\n\n    MagicVersion MagicVersion =\u003E MagicVersionFactory.Make(1, 0, 0,\n        BuildCounter,\n        MagicVersionStrategy.PatchFromCounter,\n        BuildDate,\n        MachineName);\n\n    ProductInfo ProductInfo =\u003E new ProductInfo\n    {\n        Company = \u0022Deneblab\u0022,\n        Copyright = $\u0022Deneblab \u00A9 {DateTime.UtcNow.Year}\u0022\n    };\n\n    /// Projects\n    Project SyrupProject =\u003E Solution.GetProject(\u0022Syrup\u0022).NotNull();\n\n    Project ScriptExecutorProject =\u003E Solution.GetProject(\u0022Syrup.ScriptExecutor\u0022).NotNull();\n    Project SelfProject =\u003E Solution.GetProject(\u0022Syrup.Self\u0022).NotNull();\n\n\n    List\u003CProjectDefinition\u003E Projects =\u003E new List\u003CProjectDefinition\u003E\n    {\n        new ProjectDefinition\n        {\n            Name = SyrupProject.Name,\n            Dir = SyrupProject.Name,\n            Exe = \u0022Syrup.exe\u0022,\n            DstExe = \u0022Syrup.exe\u0022,\n            Project = SyrupProject\n        },\n        new ProjectDefinition\n        {\n            Name = SelfProject.Name,\n            Dir = SelfProject.Name,\n            Exe = \u0022Syrup.Self.exe\u0022,\n            DstExe = \u0022Syrup.Self.exe\u0022,\n            Project = SelfProject\n        },\n        new ProjectDefinition\n        {\n            Name = ScriptExecutorProject.Name,\n            Dir = ScriptExecutorProject.Name,\n            Exe = \u0022Syrup.ScriptExecutor.exe\u0022,\n            DstExe = \u0022Syrup.ScriptExecutor.exe\u0022,\n            Project = ScriptExecutorProject\n        }\n    };\n\n\n    Target Information =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var b = MagicVersion;\n            Logger.Normal($\u0022Host: \u0027{Host}\u0027\u0022);\n            Logger.Normal($\u0022Version: \u0027{b.SemVersion}\u0027\u0022);\n            Logger.Normal($\u0022Date: \u0027{b.DateTime:s}Z\u0027\u0022);\n            Logger.Normal($\u0022FullVersion: \u0027{b.InformationalVersion}\u0027\u0022);\n            Logger.Normal($\u0022env:TEAMCITY_VERSION: \u0027{Environment.GetEnvironmentVariable(\u0022TEAMCITY_VERSION\u0022)}\u0027\u0022);\n            Logger.Normal($\u0022env:Agent.Name: \u0027{Environment.GetEnvironmentVariable(\u0022AGENT_NAME\u0022)}\u0027\u0022);\n            Logger.Normal(\n                $\u0022env:Build.ArtifactStagingDirectory: \u0027{Environment.GetEnvironmentVariable(\u0022BUILD_ARTIFACTSTAGINGDIRECTORY\u0022)}\u0027\u0022);\n        });\n\n\n    Target ConfigureAzureDevOps =\u003E _ =\u003E _\n        .DependsOn(Information)\n        .OnlyWhenStatic(() =\u003E IsAzureDevOps)\n        .Executes(() =\u003E\n        {\n            Logger.Normal($\u0022Set version to AzureDevOps: {MagicVersion.SemVersion}\u0022);\n            // https://github.com/microsoft/azure-pipelines-tasks/blob/master/docs/authoring/commands.md\n            Logger.Normal($\u0022##vso[build.updatebuildnumber]{MagicVersion.SemVersion}\u0022);\n        });\n\n    Target Configure =\u003E _ =\u003E _\n        .DependsOn(ConfigureAzureDevOps);\n\n\n    Target CheckTools =\u003E _ =\u003E _\n        .DependsOn(Configure)\n        .Executes(() =\u003E\n        {\n            Downloader.DownloadIfNotExists(\u0022https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\u0022, NugetPath,\n                \u0022Nuget\u0022);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(CheckTools)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(TmpBuild);\n            GlobDirectories(TmpBuild, \u0022**/*\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDir);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022restore  {Solution.Path}\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n    Target MakeComponents =\u003E _ =\u003E _\n        .DependsOn(MakeSyrupSelf, MakeScriptExecutor, CopyComponents);\n\n\n    Target MakeSyrupSelf =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            var project = Projects.FirstOrDefault(x =\u003E x.Project == SelfProject);\n            BuildFn(project);\n            MargeFn(project);\n        });\n\n\n    Target MakeScriptExecutor =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            var project = Projects.FirstOrDefault(x =\u003E x.Project == ScriptExecutorProject);\n            BuildFn(project);\n            MargeFn(project);\n        });\n\n    Target MakeSyrup =\u003E _ =\u003E _\n        .DependsOn(MakeComponents)\n        .Executes(() =\u003E\n\n        {\n            var project = Projects.FirstOrDefault(x =\u003E x.Project == SyrupProject);\n            BuildFn(project);\n            MargeFn(project);\n        });\n\n\n    Target CopyComponents =\u003E _ =\u003E _\n        .DependsOn(MakeSyrupSelf, MakeScriptExecutor)\n        .Executes(() =\u003E\n\n        {\n            var embedDir = SyrupProject.Directory / \u0022Embed\u0022;\n            var selfProjectExe = TmpBuild / CommonDir.Merge / SelfProject.Name / $\u0022{SelfProject.Name}.exe\u0022;\n            var scriptExecutorProjectExe = TmpBuild / CommonDir.Merge / ScriptExecutorProject.Name /\n                                           $\u0022{ScriptExecutorProject.Name}.exe\u0022;\n            ;\n            CopyFile(selfProjectExe, embedDir / \u0022syrup-self.bin\u0022, FileExistsPolicy.Overwrite);\n            CopyFile(scriptExecutorProjectExe, embedDir / \u0022syrup-executor.bin\u0022, FileExistsPolicy.Overwrite);\n        });\n\n\n    Target Nuget =\u003E _ =\u003E _\n        .DependsOn(MakeSyrup)\n        .Executes(() =\u003E\n\n        {\n            var p = Projects.FirstOrDefault(x =\u003E x.Project == SyrupProject);\n\n            var tmpMerge = TmpBuild / CommonDir.Merge / p.Dir;\n            var tmpNuget = TmpBuild / CommonDir.Nuget / p.Dir;\n            var tmpMain = tmpNuget / \u0022main\u0022 / p.Dir;\n            var tmpOthers = tmpNuget / \u0022others\u0022;\n            var srcBuild = SourceDir / CommonDir.Build;\n            var tmpReady = TmpBuild / CommonDir.Ready;\n\n            EnsureExistingDirectory(tmpNuget);\n            EnsureExistingDirectory(tmpReady);\n\n\n            // main dir\n            EnsureExistingDirectory(tmpMain);\n            CopyFile(tmpMerge / \u0022Syrup.exe\u0022, tmpMain / \u0022Syrup.exe\u0022);\n\n\n            // nuget definition\n            var srcNugetFile = srcBuild / \u0022nuget\u0022 / \u0022nuget.nuspec\u0022;\n            var dstNugetFile = tmpNuget / \u0022Syrup.nuspec\u0022;\n            //CopyFile(srcBuild / \u0022nuget\u0022 / \u0022nuget.nuspec\u0022, dstNugetFile);\n\n            var text = File.ReadAllText(srcNugetFile);\n            var r = text.Replace(\u0022{Version}\u0022, MagicVersion.NugetVersion);\n            File.WriteAllText(dstNugetFile, r, Encoding.UTF8);\n\n\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022pack {dstNugetFile} -OutputDirectory {tmpReady} -NoPackageAnalysis\u0022,\n                tmpNuget))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget report generation process exited with some errors.\u0022);\n            }\n\n            var nugetFiles = GlobFiles(tmpReady, \u0022*.nupkg\u0022);\n\n            foreach (var file in nugetFiles) SyrupTools.MakeSyrupFile(file, MagicVersion, p);\n        });\n\n    Target PublishAzureDevOps =\u003E _ =\u003E _\n        .DependsOn(Nuget)\n        .OnlyWhenStatic(() =\u003E IsAzureDevOps)\n        .Executes(() =\u003E\n        {\n            var tmpReady = TmpBuild / CommonDir.Ready;\n            var serverPublishArtifact = Environment.GetEnvironmentVariable(\u0022BUILD_ARTIFACTSTAGINGDIRECTORY\u0022);\n            CopyDirectoryRecursively(tmpReady, serverPublishArtifact, DirectoryExistsPolicy.Merge);\n        });\n\n    Target PublishAzureDevOpsStorage =\u003E _ =\u003E _\n        .DependsOn(PublishAzureDevOps)\n        .OnlyWhenStatic(() =\u003E IsAzureDevOps)\n        .Executes(async () =\u003E\n        {\n            void LogFiles(string title, List\u003CSyrupInfo\u003E filesToShow)\n            {\n                Logger.Info($\u0022{title}: {filesToShow.Count}\u0022);\n                foreach (var l in filesToShow) Logger.Info($\u0022Name: {l.Name}; Date: {l.ReleaseDate}\u0022);\n            }\n\n            var storageConnectionString = Environment.GetEnvironmentVariable(\u0022azureStorageConnectionString\u0022);\n            Logger.Info($\u0022Build; storageConnectionString: {storageConnectionString}\u0022);\n            var serverPublishArtifact = Environment.GetEnvironmentVariable(\u0022BUILD_ARTIFACTSTAGINGDIRECTORY\u0022);\n            var files = Directory.GetFiles(serverPublishArtifact).ToList();\n            var client = AzureSyrupTools.Create(storageConnectionString, \u0022syrup\u0022);\n            await client.UploadFiles(files);\n            var list = await client.GetSyrupFiles();\n            var fileToRemove = list.OrderByDescending(x =\u003E x.ReleaseDate).Skip(15).ToList();\n            LogFiles(\u0022Files to remove\u0022, fileToRemove);\n            await client.RemoveSyrupFiles(fileToRemove);\n            var newList = await client.GetSyrupFiles();\n            await client.CreateSyrupFilesList(newList);\n            LogFiles(\u0022Files in container\u0022, newList);\n        });\n\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Nuget, PublishAzureDevOps, PublishAzureDevOpsStorage);\n\n    void BuildFn(ProjectDefinition p)\n    {\n        var buildOut = TmpBuild / CommonDir.Build / p.Dir;\n        var projectFile = p.Project.Path;\n        var projectDir = Path.GetDirectoryName(projectFile);\n        EnsureExistingDirectory(buildOut);\n        Logger.Normal($\u0022Build; Project file: {projectFile}\u0022);\n        Logger.Normal($\u0022Build; Project dir: {projectDir}\u0022);\n        Logger.Normal($\u0022Build; Out dir: {buildOut}\u0022);\n        Logger.Normal($\u0022Build; Target: {Configuration}\u0022);\n        Logger.Normal($\u0022Build; Target: {GitRepository.Branch}\u0022);\n\n        //AssemblyTools.Patch(projectDir, MagicVersion, p, ProductInfo);\n\n        MSBuild(s =\u003E s\n            .SetProjectFile(projectFile)\n            .SetOutDir(buildOut)\n            .SetVerbosity(MSBuildVerbosity.Quiet)\n            .SetConfiguration(Configuration)\n            .SetTargetPlatform(MSBuildTargetPlatform.x64)\n            .SetMaxCpuCount(Environment.ProcessorCount)\n            .SetNodeReuse(IsLocalBuild));\n    }\n\n    void MargeFn(ProjectDefinition p)\n    {\n        var buildOut = TmpBuild / CommonDir.Build / p.Dir;\n        var margeOut = TmpBuild / CommonDir.Merge / p.Dir;\n\n        EnsureExistingDirectory(margeOut);\n        CopyDirectoryRecursively(buildOut, margeOut, DirectoryExistsPolicy.Merge);\n\n        using (var process = ProcessTasks.StartProcess(\n            LibzPath,\n            $\u0022inject-dll --assembly {p.Exe} --include *.dll --move\u0022,\n            margeOut))\n        {\n            process.AssertWaitForExit();\n            ControlFlow.AssertWarn(process.ExitCode == 0,\n                \u0022Libz report generation process exited with some errors.\u0022);\n        }\n    }\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n}"
  },
  {
    "Id": 155535722,
    "FirstIndexed": "2020-04-25T15:50:44.7354639+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629275+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433524+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939299+02:00",
    "Name": "ThemeEditor",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/ThemeEditor",
    "Description": "Avalonia Theme Editor",
    "Archived": false,
    "Stars": 57,
    "Watchers": 3,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/ThemeEditor/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 156291726,
    "FirstIndexed": "2020-04-25T15:47:03.6115078+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629418+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431146+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937023+02:00",
    "Name": "MHWAppearanceEditor",
    "Owner": "Fusion86",
    "HtmlUrl": "https://github.com/Fusion86/MHWAppearanceEditor",
    "Description": "Monster Hunter World appearance editor \u002B importer/exporter",
    "Archived": false,
    "Stars": 10,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Fusion86/MHWAppearanceEditor/blob/master/build/Build.cs",
    "BuildFileSize": 7613,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E();\n\n    //[GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Which .NET framework to use, can be either \u0027netcoreapp3.0\u0027 or \u0027net461\u0027. Release always uses \u0027net461\u0027.\u0022)]\n    string Framework = \u0022netcoreapp3.0\u0022;\n\n    [Parameter(\u0022Which runtime to use. Release always uses \u0027win7-x64\u0027.\u0022)]\n    string Runtime = \u0022any\u0022;\n\n    static readonly AbsolutePath AppearanceEditorProject = RootDirectory / \u0022src\u0022 / \u0022MHWAppearanceEditor\u0022 / \u0022MHWAppearanceEditor.csproj\u0022;\n    static readonly AbsolutePath OdogaronProject = RootDirectory / \u0022src\u0022 / \u0022Odogaron\u0022 / \u0022Odogaron.csproj\u0022;\n    static readonly AbsolutePath ScriptsDirectory = RootDirectory / \u0022scripts\u0022;\n    static readonly AbsolutePath CharacterAssetsGen = ScriptsDirectory / \u0022character_assets.py\u0022;\n    static readonly AbsolutePath PaletteExtractor = ScriptsDirectory / \u0022palette_extractor.py\u0022;\n    static readonly AbsolutePath InnoSetupConfig = ScriptsDirectory / \u0022installer.iss\u0022;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    private static Lazy\u003Cstring\u003E PythonPath = new Lazy\u003Cstring\u003E(() =\u003E\n    {\n        try\n        {\n            var process = Process.Start(new ProcessStartInfo\n            {\n                FileName = \u0022python\u0022,\n                Arguments = \u0022--version\u0022,\n                RedirectStandardError = true,\n                UseShellExecute = false,\n            });\n\n            var stderr = process.StandardError.ReadToEnd();\n            process.WaitForExit();\n\n            if (stderr.Contains(\u0022Python 2.\u0022))\n                return \u0022python3\u0022;\n        }\n        catch (Exception) { }\n\n        return \u0022python\u0022;\n    });\n\n    private static void ExecPython(string path) =\u003E Exec(PythonPath.Value, path);\n\n    private static void Exec(string program, string args)\n    {\n        var process = Process.Start(new ProcessStartInfo\n        {\n            FileName = program,\n            Arguments = args\n        });\n\n        process.WaitForExit();\n        Logger.Info(\u0022Exit code: \u0022 \u002B process.ExitCode);\n\n        if (process.ExitCode != 0)\n            throw new Exception(\u0022Got a non-zero exit code!\u0022);\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(OdogaronProject));\n        });\n\n    Target RestoreOdogaron =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(AppearanceEditorProject));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(CompileOdogaron)\n        .Executes(() =\u003E\n        {\n            // Force net461 for a Release\n            if (ExecutingTargets.Contains(Release))\n            {\n                Configuration = Configuration.Release;\n            }\n\n            Framework = \u0022net461\u0022;\n            Runtime = \u0022win7-x64\u0022;\n\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(AppearanceEditorProject)\n                .SetConfiguration(Configuration)\n                // TODO: This also sets the Cirilla.Core version, which we DO NOT want\n                //.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                //.SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                //.SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore()\n                .SetOutputDirectory(OutputDirectory)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime));\n\n            // Move DLLs to lib folder and remove leftover files\n            string libDir = OutputDirectory / \u0022lib\u0022;\n            EnsureExistingDirectory(libDir);\n\n            foreach (var dll in GlobFiles(OutputDirectory, \u0022*.dll\u0022))\n                MoveFileToDirectory(dll, libDir);\n\n            foreach (var file in GlobFiles(OutputDirectory, \u0022*.exe.config\u0022, \u0022*.pdb\u0022, \u0022*.deps.json\u0022))\n                DeleteFile(file);\n        });\n\n    Target CompileOdogaron =\u003E _ =\u003E _\n        .DependsOn(RestoreOdogaron)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(OdogaronProject)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    Target GenerateCharacterAssets =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            ExecPython(CharacterAssetsGen);\n        });\n\n    Target GenerateColorPalette =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            ExecPython(PaletteExtractor);\n        });\n\n    Target CopyAssets =\u003E _ =\u003E _\n        .After(GenerateColorPalette)\n        .After(GenerateCharacterAssets)\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            var characterAssetsDir = OutputDirectory / \u0022assets\u0022;\n\n            if (DirectoryExists(characterAssetsDir))\n                DeleteDirectory(characterAssetsDir);\n\n            CopyDirectoryRecursively(ScriptsDirectory / \u0022assets\u0022, characterAssetsDir);\n\n            if (!FileExists(characterAssetsDir / \u0022character_assets.json\u0022))\n                throw new Exception(\u0022character_assets.json is missing!\u0022);\n\n            if (!FileExists(characterAssetsDir / \u0022skin_color.png\u0022))\n                throw new Exception(\u0022skin_color.png is missing!\u0022);\n\n            if (!FileExists(characterAssetsDir / \u0022palette.json\u0022))\n                throw new Exception(\u0022palette.json is missing!\u0022);\n        });\n\n    Target EnsureSecretsAreSet =\u003E _ =\u003E _\n        .Before(Compile)\n        .Executes(() =\u003E\n        {\n            var code = File.ReadAllText(RootDirectory / \u0022src\u0022 / \u0022MHWAppearanceEditor\u0022 / \u0022SuperSecret.cs\u0022);\n            if (code.Contains(\u0022\\\u0022\\\u0022\u0022))\n                throw new Exception(\u0022Something is not set!\u0022);\n        });\n\n    Target Debug =\u003E _ =\u003E _\n        .Description(\u0022Create a release running on the net461 platform (without secret-checking or installer).\u0022)\n        .DependsOn(Clean, Compile, CopyAssets)\n        .After(Compile);\n\n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Create a release running on the net461 platform.\u0022)\n        .DependsOn(EnsureSecretsAreSet, Clean, Compile, CopyAssets, CreateInstaller)\n        .After(Compile);\n\n    Target Full =\u003E _ =\u003E _\n        .Description(\u0022Same as Release, but also rebuild all assets.\u0022)\n        .DependsOn(GenerateCharacterAssets, GenerateColorPalette, Release);\n\n    Target CreateInstaller =\u003E _ =\u003E _\n        .Description(\u0022Create installer with Inno Setup\u0022)\n        .After(Compile, CopyAssets)\n        .Executes(() =\u003E\n        {\n            Exec(@\u0022C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe\u0022, $\u0022{InnoSetupConfig}\u0022);\n        });\n}\n"
  },
  {
    "Id": 156755311,
    "FirstIndexed": "2020-04-25T15:50:44.7362557+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362569+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435048+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940767+02:00",
    "Name": "NukeAutomation",
    "Owner": "WhistlerHusky",
    "HtmlUrl": "https://github.com/WhistlerHusky/NukeAutomation",
    "Description": "BuildAutomation",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/WhistlerHusky/NukeAutomation/blob/master/build/Build.cs",
    "BuildFileSize": 4279,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.InspectCode;\nusing Nuke.Common.Tools.OpenCover;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.Xunit;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing static Nuke.Common.ControlFlow;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.OpenCover.OpenCoverTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main ()\n    {\n        Execute\u003CBuild\u003E(x =\u003E x.Test);\n        Console.ReadKey();\n\n        return 0;\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022NukeAutomation.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols());\n        });\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            //xunit.runner.console\uC774 .net framework\uBC16\uC5D0 \uC9C0\uC6D0\uC548\uD574\uC11C \uC5B4\uCA54\uC218\uC5C6\uC774 net461\uB85C \uCF54\uB4DC \uD14C\uC2A4\uD2B8\n            var framework = \u0022net461\u0022;\n            var xunitSettings = new Xunit2Settings()\n                .SetFramework(framework)\n                .AddTargetAssemblies(GlobFiles(Solution.Directory, $\u0022*/bin/{Configuration}/{framework}/Nuke*Test.dll\u0022).NotEmpty())\n                .AddResultReport(Xunit2ResultFormat.Xml, OutputDirectory / \u0022tests.xml\u0022);\n\n            if (IsWin)\n            {\n                OpenCover(s =\u003E s\n                    .SetTargetSettings(xunitSettings)\n                    .SetOutput(OutputDirectory / \u0022coverage.xml\u0022)\n                    .SetSearchDirectories(xunitSettings.TargetAssemblyWithConfigs.Select(x =\u003E Path.GetDirectoryName(x.Key)))\n                    .SetRegistration(RegistrationType.User)\n                    .SetTargetExitCodeOffset(targetExitCodeOffset: 0)\n                    .SetFilters(\n                        \u0022\u002B[*]*\u0022,\n                        \u0022-[xunit.*]*\u0022,\n                        \u0022-[FluentAssertions.*]*\u0022)\n                    .SetExcludeByAttributes(\u0022System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute\u0022));\n\n                ReportGenerator(s =\u003E s\n                    .AddReports(OutputDirectory / \u0022coverage.xml\u0022)\n                    .AddReportTypes(ReportTypes.Html)\n                    .SetTargetDirectory(OutputDirectory / \u0022coverage\u0022));\n            }\n            else\n                Xunit2(s =\u003E xunitSettings);\n        });\n}\n"
  },
  {
    "Id": 157010086,
    "FirstIndexed": "2020-04-25T15:47:03.6111505+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630362+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431157+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937029+02:00",
    "Name": "StudentAssistant",
    "Owner": "boogiedk",
    "HtmlUrl": "https://github.com/boogiedk/StudentAssistant",
    "Description": "Student Assistant - this is a web service with an open source project. The created for a convenient and flexible way to monitor the study schedule.",
    "Archived": false,
    "Stars": 1,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/boogiedk/StudentAssistant/blob/master/build/Build.cs",
    "BuildFileSize": 3282,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n   public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.RunInteractive);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] readonly bool Interactive;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022StudentAssistant.Tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    const string CoverageFileName = \u0022coverage.cobertura.xml\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(RunUnitTests)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target RunUnitTests =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n            RootDirectory\n                .GlobFiles(\u0022**/*.Tests.csproj\u0022)\n                .ForEach(path =\u003E\n                    DotNetTest(settings =\u003E settings\n                        .SetProjectFile(path)\n                        .SetConfiguration(Configuration)\n                        .SetLogger($\u0022trx;LogFileName={ArtifactsDirectory / \u0022report.trx\u0022}\u0022)\n                        .AddProperty(\u0022CollectCoverage\u0022, true)\n                        .AddProperty(\u0022CoverletOutputFormat\u0022, \u0022cobertura\u0022)\n                        .AddProperty(\u0022Exclude\u0022, \u0022[xunit.*]*\u0022)\n                        .AddProperty(\u0022CoverletOutput\u0022, ArtifactsDirectory / CoverageFileName))));\n\n    Target CompileStudentAssistant =\u003E _ =\u003E _\n        .DependsOn(RunUnitTests)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target RunInteractive =\u003E _ =\u003E _\n        .DependsOn(CompileStudentAssistant)\n        .Executes(() =\u003E RootDirectory\n            .GlobFiles($\u0022**/StudentAssistant.Backend.csproj\u0022)\n            .Where(x =\u003E Interactive)\n            .ForEach(path =\u003E\n                DotNetRun(settings =\u003E settings\n                    .SetProjectFile(path)\n                    .SetConfiguration(Configuration))));\n}\n"
  },
  {
    "Id": 157315088,
    "FirstIndexed": "2020-04-25T15:50:44.7362404+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362415+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434991+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940704+02:00",
    "Name": "MyRepresentatives",
    "Owner": "rgreen32",
    "HtmlUrl": "https://github.com/rgreen32/MyRepresentatives",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/MyRepresentatives.Build/Build.cs",
    "BuildFileUrl": "https://github.com/rgreen32/MyRepresentatives/blob/master/build/MyRepresentatives.Build/Build.cs",
    "BuildFileSize": 2778,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Npm;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\n\nclass Build : NukeBuild {\n    const string ClientApp = nameof(ClientApp);\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src/MyRepresentatives.Web\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath ClientAppDirectory =\u003E SourceDirectory / ClientApp;\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E (x =\u003E x.Copy_Assets);\n\n    [Parameter (\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes (() =\u003E {\n            DeleteDirectories (GlobDirectories (SourceDirectory, \u0022bin\u0022, \u0022obj\u0022));\n            EnsureCleanDirectory (OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn (Clean)\n        .Executes (() =\u003E {\n            Npm (\u0022install\u0022, ClientAppDirectory);\n            DotNetRestore (SourceDirectory);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn (Restore)\n        .Executes (() =\u003E {\n            NpmBuild ();\n            DotNetPublish(configurator =\u003E {\n                return configurator.SetWorkingDirectory(SourceDirectory);\n            });\n        });\n\n    private void NpmBuild () {\n        //todo: adjust for Release\n        Npm ($\u0022run build --prefix {ClientAppDirectory}\u0022);\n    }\n\n    Target Copy_Assets =\u003E _ =\u003E _\n        .DependsOn (Compile)\n        .Executes (() =\u003E {\n            var binDir = getBinDir ();\n            var binOutputDir = getBinOutputDir ();\n            CopyDirectoryRecursively (binDir, binOutputDir);\n\n            var clientAppDir = getClientAppDir ();\n            var clientAppOutputDir = getGlientAppOutputDir ();\n            CopyDirectoryRecursively (clientAppDir, clientAppOutputDir);\n        });\n\n    private AbsolutePath getBinDir () {\n        //todo: adjust for Release\n        var binDir = SourceDirectory / \u0022bin\u0022 / \u0022Debug\u0022 / \u0022netcoreapp2.1\u0022 / \u0022publish\u0022;\n        return binDir;\n    }\n\n    private AbsolutePath getBinOutputDir () {\n        var binOutputDir = OutputDirectory / \u0022bin\u0022;\n        return binOutputDir;\n    }\n\n    private AbsolutePath getClientAppDir () {\n        //todo: adjust for Release\n        var clientAppDir = ClientAppDirectory / \u0022build\u0022;\n        return clientAppDir;\n    }\n\n    private AbsolutePath getGlientAppOutputDir () {\n        var clientAppOutputDir = OutputDirectory / ClientApp / \u0022build\u0022;\n        return clientAppOutputDir;\n    }\n}"
  },
  {
    "Id": 157962782,
    "FirstIndexed": "2020-04-25T15:47:03.6112142+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630595+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431169+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937041+02:00",
    "Name": "bipinpaul.com",
    "Owner": "iAmBipinPaul",
    "HtmlUrl": "https://github.com/iAmBipinPaul/bipinpaul.com",
    "Description": "The code for the bipinpaul.com.np website.",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/iAmBipinPaul/bipinpaul.com/blob/master/build/Build.cs",
    "BuildFileSize": 1466,
    "BuildFileContent": "using System;\nusing NetlifySharp;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.IO.PathConstruction;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n   \n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Deploy);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    [Parameter(\u0022Netlify access token for packages\u0022)]\n    readonly string NetlifyAccessToken;\n    Target Deploy =\u003E _ =\u003E _\n        .Executes(() =\u003E \n        {\n            Console.WriteLine(RootDirectory.ToString());\n            var netlifyToken = NetlifyAccessToken;\n            if (string.IsNullOrEmpty(netlifyToken))\n            {\n                throw new Exception(\u0022Could not get Netlify token environment variable\u0022);\n            }\n            Console.WriteLine(OutputDirectory.ToString());\n            var client = new NetlifyClient(netlifyToken);\n            client.UpdateSite($\u0022bipinpaul.netlify.com\u0022, OutputDirectory.ToString()).SendAsync().Wait();\n        });\n\n}\n"
  },
  {
    "Id": 158023057,
    "FirstIndexed": "2020-04-25T15:50:44.7362512+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362523+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435031+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940744+02:00",
    "Name": "avacloud-demo-javascript",
    "Owner": "Dangl-IT",
    "HtmlUrl": "https://github.com/Dangl-IT/avacloud-demo-javascript",
    "Description": "AVACloud demo in Java to read, write, convert and create GAEB files",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Dangl-IT/avacloud-demo-javascript/blob/master/build/Build.cs",
    "BuildFileSize": 2663,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\nusing Nuke.Common.Utilities;\nusing static Nuke.WebDocu.WebDocuTasks;\nusing Nuke.Azure.KeyVault;\nusing Nuke.WebDocu;\nusing Nuke.Common.Tools.GitVersion;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    AbsolutePath SolutionDirectory =\u003E Solution.Directory;\n    AbsolutePath OutputDirectory =\u003E SolutionDirectory / \u0022output\u0022;\n    AbsolutePath ZipPath =\u003E SolutionDirectory /  \u0022page.zip\u0022;\n\n    [Solution(\u0022avacloud-demo-javascript.sln\u0022)]\n    Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [KeyVaultSettings(\n        BaseUrlParameterName = nameof(KeyVaultBaseUrl),\n        ClientIdParameterName = nameof(KeyVaultClientId),\n        ClientSecretParameterName = nameof(KeyVaultClientSecret))]\n    readonly KeyVaultSettings KeyVaultSettings;\n\n    [Parameter] string KeyVaultBaseUrl;\n    [Parameter] string KeyVaultClientId;\n    [Parameter] string KeyVaultClientSecret;\n\n    [KeyVaultSecret] string DocuApiEndpoint;\n    [KeyVaultSecret(\u0022AvaCloudJavaScriptDemo-DocuApiKey\u0022)] string DocuApiKey;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n            DeleteFile(ZipPath);\n        });\n\n    Target BuildPage =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E {\n            Npm(\u0022ci\u0022, SolutionDirectory);\n            var endingsToCopy = new[]{\u0022.js\u0022, \u0022.html\u0022, \u0022.css\u0022, \u0022.png\u0022, \u0022.X86\u0022};\n            foreach (var file in System.IO.Directory.EnumerateFiles(SolutionDirectory).Where(path =\u003E endingsToCopy.Any(ending =\u003E path.EndsWith(ending))))\n            {\n                var fileName = System.IO.Path.GetFileName(file);\n                CopyFile(file, OutputDirectory / fileName);\n            }\n            CopyDirectoryRecursively(SolutionDirectory / \u0022dist\u0022, OutputDirectory / \u0022dist\u0022);\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(BuildPage)\n        .Requires(() =\u003E DocuApiKey)\n        .Requires(() =\u003E DocuApiEndpoint)\n        .Executes(() =\u003E {\n            WebDocu(s =\u003E s\n                .SetDocuApiEndpoint(DocuApiEndpoint)\n                .SetDocuApiKey(DocuApiKey)\n                .SetSourceDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersion));\n        });\n}\n"
  },
  {
    "Id": 158305394,
    "FirstIndexed": "2020-04-25T15:50:44.7362489+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362501+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843502+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940733+02:00",
    "Name": "RazorCli",
    "Owner": "KevinGliewe",
    "HtmlUrl": "https://github.com/KevinGliewe/RazorCli",
    "Description": "A dotnet tool to compile Razor templates.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "src/build/Build.cs",
    "BuildFileUrl": "https://github.com/KevinGliewe/RazorCli/blob/master/src/build/Build.cs",
    "BuildFileSize": 1798,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022RazorCli.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n    \n}\n"
  },
  {
    "Id": 158741385,
    "FirstIndexed": "2020-04-25T15:50:44.7361152+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631648+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434775+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940505+02:00",
    "Name": "Camelotia",
    "Owner": "worldbeater",
    "HtmlUrl": "https://github.com/worldbeater/Camelotia",
    "Description": "Cross-platform demo file manager for cloud storages. Built with ReactiveUI, DynamicData, Akavache, Avalonia, Universal Windows Platform, Xamarin Forms and WPF, runs on Windows, Linux, Mac OS and Android.",
    "Archived": false,
    "Stars": 99,
    "Watchers": 7,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/worldbeater/Camelotia/blob/master/build/Build.cs",
    "BuildFileSize": 7504,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n// ReSharper disable ArrangeTypeMemberModifiers\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\ninternal class Build : NukeBuild\n{\n    const string InteractiveProjectName = \u0022Camelotia.Presentation.Avalonia\u0022;\n    const string CoverageFileName = \u0022coverage.cobertura.xml\u0022;\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.RunInteractive);\n    \n    [Parameter] readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n    [Parameter] readonly bool Interactive;\n    [Parameter] readonly bool Full;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(RunUnitTests)\n        .Executes(() =\u003E SourceDirectory\n            .GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022, \u0022**/AppPackages\u0022, \u0022**/BundleArtifacts\u0022)\n            .Concat(RootDirectory.GlobDirectories(\u0022**/artifacts\u0022))\n            .ForEach(DeleteDirectory));\n    \n    Target RunUnitTests =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E SourceDirectory\n            .GlobFiles(\u0022**/*.Tests.csproj\u0022)\n            .ForEach(path =\u003E\n                DotNetTest(settings =\u003E settings\n                    .SetProjectFile(path)\n                    .SetConfiguration(Configuration)\n                    .SetLogger($\u0022trx;LogFileName={ArtifactsDirectory / \u0022report.trx\u0022}\u0022)\n                    .AddProperty(\u0022CollectCoverage\u0022, true)\n                    .AddProperty(\u0022CoverletOutputFormat\u0022, \u0022cobertura\u0022)\n                    .AddProperty(\u0022Exclude\u0022, \u0022[xunit.*]*\u0022)\n                    .AddProperty(\u0022CoverletOutput\u0022, ArtifactsDirectory / CoverageFileName))));\n\n    Target CompileAvaloniaApp =\u003E _ =\u003E _\n        .DependsOn(RunUnitTests)\n        .Executes(() =\u003E SourceDirectory\n            .GlobFiles(\u0022**/*.Avalonia.csproj\u0022)\n            .ForEach(path =\u003E\n                DotNetBuild(settings =\u003E settings\n                    .SetProjectFile(path)\n                    .SetConfiguration(Configuration))));\n\n    Target CompileUniversalWindowsApp =\u003E _ =\u003E _\n        .DependsOn(RunUnitTests)\n        .Executes(() =\u003E\n        {\n            var execute = EnvironmentInfo.IsWin \u0026\u0026 Full;\n            Logger.Info($\u0022Should compile for Universal Windows: {execute}\u0022);\n            if (!execute) return;\n\n            Logger.Normal(\u0022Restoring packages required by UAP...\u0022);\n            var project = SourceDirectory.GlobFiles(\u0022**/*.Uwp.csproj\u0022).First();\n            MSBuild(settings =\u003E settings\n                .SetProjectFile(project)\n                .SetTargets(\u0022Restore\u0022));\n            Logger.Success(\u0022Successfully restored UAP packages.\u0022);\n\n            new[] { MSBuildTargetPlatform.x86,\n                    MSBuildTargetPlatform.x64,\n                    MSBuildTargetPlatform.arm }\n                .ForEach(BuildApp);\n\n            void BuildApp(MSBuildTargetPlatform platform)\n            {\n                Logger.Normal(\u0022Cleaning UAP project...\u0022);\n                MSBuild(settings =\u003E settings\n                    .SetProjectFile(project)\n                    .SetTargets(\u0022Clean\u0022));\n                Logger.Success(\u0022Successfully managed to clean UAP project.\u0022);\n\n                Logger.Normal($\u0022Building UAP project for {platform}...\u0022);\n                MSBuild(settings =\u003E settings\n                    .SetProjectFile(project)\n                    .SetTargets(\u0022Build\u0022)\n                    .SetConfiguration(Configuration)\n                    .SetTargetPlatform(platform)\n                    .SetProperty(\u0022AppxPackageSigningEnabled\u0022, false)\n                    .SetProperty(\u0022AppxPackageDir\u0022, ArtifactsDirectory)\n                    .SetProperty(\u0022UapAppxPackageBuildMode\u0022, \u0022CI\u0022)\n                    .SetProperty(\u0022AppxBundle\u0022, \u0022Always\u0022));\n                Logger.Success($\u0022Successfully built UAP project for {platform}.\u0022);\n            }\n        });\n\n    Target CompileXamarinAndroidApp =\u003E _ =\u003E _\n        .DependsOn(RunUnitTests)\n        .Executes(() =\u003E\n        {\n            var execute = EnvironmentInfo.IsWin \u0026\u0026 Full;\n            Logger.Info($\u0022Should compile for Android: {execute}\u0022);\n            if (!execute) return;\n\n            Logger.Normal(\u0022Restoring packages required by Xamarin Android...\u0022);\n            var project = SourceDirectory.GlobFiles(\u0022**/*.Xamarin.Droid.csproj\u0022).First();\n            MSBuild(settings =\u003E settings\n                .SetProjectFile(project)\n                .SetTargets(\u0022Restore\u0022));\n            Logger.Success(\u0022Successfully restored Xamarin Android packages.\u0022);\n\n            Logger.Normal(\u0022Building Xamarin Android project...\u0022);\n            var java = Environment.GetEnvironmentVariable(\u0022JAVA_HOME\u0022);\n            MSBuild(settings =\u003E settings\n                .SetProjectFile(project)\n                .SetTargets(\u0022Build\u0022)\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022JavaSdkDirectory\u0022, java));\n            Logger.Success(\u0022Successfully built Xamarin Android project.\u0022);\n\n            Logger.Normal(\u0022Signing Android package...\u0022);\n            MSBuild(settings =\u003E settings\n                .SetProjectFile(project)\n                .SetTargets(\u0022SignAndroidPackage\u0022)\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022JavaSdkDirectory\u0022, java));\n            Logger.Success(\u0022Successfully signed Xamarin Android APK.\u0022);\n\n            Logger.Normal(\u0022Moving APK files to artifacts directory...\u0022);\n            SourceDirectory\n                .GlobFiles(\u0022**/bin/**/*-Signed.apk\u0022)\n                .ForEach(file =\u003E MoveFileToDirectory(file, ArtifactsDirectory));\n            Logger.Success(\u0022Successfully moved APK files.\u0022);\n        });\n\n    Target CompileWindowsPresentationApp =\u003E _ =\u003E _\n        .DependsOn(RunUnitTests)\n        .Executes(() =\u003E\n        {\n            var execute = EnvironmentInfo.IsWin \u0026\u0026 Full;\n            Logger.Info($\u0022Should compile for WPF: {execute}\u0022);\n            if (!execute) return;\n\n            Logger.Normal(\u0022Restoring packages required by WPF app...\u0022);\n            var project = SourceDirectory.GlobFiles(\u0022**/*.Wpf.csproj\u0022).First();\n            MSBuild(settings =\u003E settings\n                .SetProjectFile(project)\n                .SetTargets(\u0022Restore\u0022));\n            Logger.Success(\u0022Successfully restored Wpf packages.\u0022);\n\n            Logger.Normal(\u0022Building WPF project...\u0022);\n            MSBuild(settings =\u003E settings\n                .SetProjectFile(project)\n                .SetTargets(\u0022Build\u0022)\n                .SetConfiguration(Configuration));\n            Logger.Success(\u0022Successfully built WPF project.\u0022);\n        });\n\n    Target RunInteractive =\u003E _ =\u003E _\n        .DependsOn(CompileAvaloniaApp)\n        .DependsOn(CompileUniversalWindowsApp)\n        .DependsOn(CompileXamarinAndroidApp)\n        .DependsOn(CompileWindowsPresentationApp)\n        .Executes(() =\u003E SourceDirectory\n            .GlobFiles($\u0022**/{InteractiveProjectName}.csproj\u0022)\n            .Where(x =\u003E Interactive)\n            .ForEach(path =\u003E \n                DotNetRun(settings =\u003E settings\n                    .SetProjectFile(path)\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore()\n                    .EnableNoBuild())));\n}\n"
  },
  {
    "Id": 159178092,
    "FirstIndexed": "2020-04-25T15:50:44.7362455+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362461+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435009+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940727+02:00",
    "Name": "RetrospectiveClient",
    "Owner": "haavamoa",
    "HtmlUrl": "https://github.com/haavamoa/RetrospectiveClient",
    "Description": "A client to use during a team retrospective to create notes and publish them to a Slack channel.",
    "Archived": false,
    "Stars": 5,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/haavamoa/RetrospectiveClient/blob/master/build/Build.cs",
    "BuildFileSize": 1627,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022src/Retrospective.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n    \n}\n"
  },
  {
    "Id": 159438732,
    "FirstIndexed": "2020-04-25T15:50:44.7362427+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362438+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8435003+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940716+02:00",
    "Name": "react-demo",
    "Owner": "joeybrown",
    "HtmlUrl": "https://github.com/joeybrown/react-demo",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/DemoApp.Build/Build.cs",
    "BuildFileUrl": "https://github.com/joeybrown/react-demo/blob/master/build/DemoApp.Build/Build.cs",
    "BuildFileSize": 2621,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Npm;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\n\nclass Build : NukeBuild {\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src/DemoApp.Web\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath ClientAppDirectory =\u003E SourceDirectory / \u0022ClientApp\u0022;\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E (x =\u003E x.Copy_Assets);\n\n    [Parameter (\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes (() =\u003E {\n            DeleteDirectories (GlobDirectories (SourceDirectory, \u0022bin\u0022, \u0022obj\u0022));\n            EnsureCleanDirectory (OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn (Clean)\n        .Executes (() =\u003E {\n            Npm (\u0022install\u0022, ClientAppDirectory);\n            DotNetRestore (SourceDirectory);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn (Restore)\n        .Executes (() =\u003E {\n            NpmBuild ();\n            DotNetBuild (SourceDirectory);\n        });\n\n    private void NpmBuild () {\n        //todo: adjust for Release\n        Npm ($\u0022run build --prefix {ClientAppDirectory}\u0022);\n    }\n\n    Target Copy_Assets =\u003E _ =\u003E _\n        .DependsOn (Compile)\n        .Executes (() =\u003E {\n            var binDir = getBinDir ();\n            var binOutputDir = getBinOutputDir ();\n            CopyDirectoryRecursively (binDir, binOutputDir);\n\n            var clientAppDir = getClientAppDir ();\n            var clientAppOutputDir = getGlientAppOutputDir ();\n            CopyDirectoryRecursively (clientAppDir, clientAppOutputDir);\n        });\n\n    private AbsolutePath getBinDir () {\n        //todo: adjust for Release\n        var binDir = SourceDirectory / \u0022bin\u0022 / \u0022Debug\u0022 / \u0022netcoreapp2.1\u0022;\n        return binDir;\n    }\n\n    private AbsolutePath getBinOutputDir () {\n        var binOutputDir = OutputDirectory / \u0022bin\u0022;\n        return binOutputDir;\n    }\n\n    private AbsolutePath getClientAppDir () {\n        //todo: adjust for Release\n        var clientAppDir = ClientAppDirectory / \u0022build\u0022;\n        return clientAppDir;\n    }\n\n    private AbsolutePath getGlientAppOutputDir () {\n        var clientAppOutputDir = OutputDirectory / \u0022ClientApp\u0022 / \u0022build\u0022;\n        return clientAppOutputDir;\n    }\n}"
  },
  {
    "Id": 161607535,
    "FirstIndexed": "2020-04-25T15:50:44.7359673+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.16301+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843465+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940369+02:00",
    "Name": "Arbatel",
    "Owner": "ItEndsWithTens",
    "HtmlUrl": "https://github.com/ItEndsWithTens/Arbatel",
    "Description": "A Quake .map viewer with support for func_instance entities.",
    "Archived": false,
    "Stars": 5,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ItEndsWithTens/Arbatel/blob/master/build/Build.cs",
    "BuildFileSize": 11365,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NUnit;\nusing Nuke.Common.Tools.VSWhere;\nusing SharpCompress.Archives;\nusing SharpCompress.Archives.Tar;\nusing SharpCompress.Archives.Zip;\nusing SharpCompress.Common;\nusing SharpCompress.Compressors.Deflate;\nusing SharpCompress.Writers;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NUnit.NUnitTasks;\nusing static Nuke.Common.Tools.VSWhere.VSWhereTasks;\n\nclass Build : NukeBuild\n{\n\tconst string ProductName = \u0022Arbatel\u0022;\n\n\treadonly string[] EtoPlatformsWin = new[] { \u0022WinForms\u0022, \u0022Wpf\u0022 };\n\treadonly string[] EtoPlatformsLin = new[] { \u0022Gtk\u0022 };\n\treadonly string[] EtoPlatformsMac = new[] { \u0022Mac\u0022 }; //, \u0022XamMac\u0022 };\n\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\tAbsolutePath TestSourceDirectory =\u003E RootDirectory / \u0022test\u0022 / \u0022src\u0022;\n\tAbsolutePath CustomMsBuildPath;\n\n\tAbsolutePath EtoVeldridRoot =\u003E RootDirectory / \u0022lib\u0022 / \u0022Eto.Veldrid\u0022;\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n\t[Solution(ProductName \u002B \u0022.sln\u0022)]\n\treadonly Solution Solution;\n\n\t[GitVersion]\n\treadonly GitVersion GitVersion;\n\n\tpublic static Dictionary\u003CPlatformFamily, string\u003E OsFriendlyName = new Dictionary\u003CPlatformFamily, string\u003E\n\t{\n\t\t{ PlatformFamily.Unknown, \u0022\u0022 },\n\t\t{ PlatformFamily.Windows, \u0022Windows\u0022 },\n\t\t{ PlatformFamily.Linux, \u0022Linux\u0022 },\n\t\t{ PlatformFamily.OSX, \u0022macOS\u0022 },\n\t};\n\n\tpublic static int Main()\n\t{\n\t\tif (EnvironmentInfo.IsOsx)\n\t\t{\n\t\t\treturn Execute\u003CBuild\u003E(x =\u003E x.PackageMac);\n\t\t}\n\t\telse if (EnvironmentInfo.IsLinux)\n\t\t{\n\t\t\treturn Execute\u003CBuild\u003E(x =\u003E x.PackageLinux);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn Execute\u003CBuild\u003E(x =\u003E x.PackageWindows);\n\t\t}\n\t}\n\n\t/// \u003Csummary\u003E\n\t/// Get the absolute path to a given project\u0027s compile output directory.\n\t/// \u003C/summary\u003E\n\t/// \u003Cparam name=\u0022name\u0022\u003EThe name of the project.\u003C/param\u003E\n\t/// \u003Creturns\u003EThe full, absolute path to the directory specified by a\n\t/// project\u0027s \u0022OutputPath\u0022 property.\u003C/returns\u003E\n\tpublic AbsolutePath GetOutputPath(string name)\n\t{\n\t\tProject n = Solution.GetProject(name);\n\n\t\t// The OutputPath property has a different value depending on the active\n\t\t// build configuration, so it\u0027s necessary to take that into account.\n\t\tMicrosoft.Build.Evaluation.Project parsed = ProjectModelTasks.ParseProject(n, Configuration);\n\n\t\treturn n.Directory / parsed.GetPropertyValue(\u0022OutputPath\u0022);\n\t}\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\t// Using SetTargets(\u0022Rebuild\u0022) in the compile targets below would\n\t\t\t// ensure that everything got cleaned and built fresh every time the\n\t\t\t// build scripts were run. Unfortunately, project references in\n\t\t\t// .csproj files mean that dependencies would also be rebuilt, which\n\t\t\t// in this case means the core class library. To start fresh every\n\t\t\t// time, but still build the core library only once, it\u0027s important\n\t\t\t// to clean all bin and obj folders, then use SetTargets(\u0022Build\u0022) on\n\t\t\t// each GUI project to trigger an incremental build. The core will\n\t\t\t// be built anew, with no time wasted rebuilding it for every GUI.\n\t\t\tforeach (string d in GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022))\n\t\t\t{\n\t\t\t\tEnsureCleanDirectory(d);\n\t\t\t}\n\n\t\t\tforeach (string d in GlobDirectories(TestSourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022))\n\t\t\t{\n\t\t\t\tEnsureCleanDirectory(d);\n\t\t\t}\n\t\t});\n\n\tTarget SetVisualStudioPaths =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tif (EnvironmentInfo.IsWin)\n\t\t\t{\n\t\t\t\tLogger.Info(\u0022Windows build; setting Visual Studio paths.\u0022);\n\n\t\t\t\tVSWhereSettings vswhereSettings = new VSWhereSettings()\n\t\t\t\t\t.EnableLatest()\n\t\t\t\t\t.AddRequires(MsBuildComponent);\n\n\t\t\t\tIReadOnlyCollection\u003COutput\u003E output = VSWhere(s =\u003E vswhereSettings).Output;\n\n\t\t\t\tOutput outputPath = output.FirstOrDefault(o =\u003E o.Text.StartsWith(\u0022installationPath\u0022));\n\t\t\t\tOutput outputVersion = output.FirstOrDefault(o =\u003E o.Text.StartsWith(\u0022installationVersion\u0022));\n\n\t\t\t\t// A list of component IDs and friendly names can be found at\n\t\t\t\t// https://docs.microsoft.com/en-us/visualstudio/install/workload-and-component-ids\n\t\t\t\tif (String.IsNullOrEmpty(outputPath.Text) || String.IsNullOrEmpty(outputVersion.Text))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\u0022Couldn\u0027t find a suitable Visual Studio installation! \u0022 \u002B\n\t\t\t\t\t\t\u0022Either VS is not installed, or no available version \u0022 \u002B\n\t\t\t\t\t\t\u0022has all of the following components installed:\u0022 \u002B\n\t\t\t\t\t\t\u0022\\n\u0022 \u002B\n\t\t\t\t\t\t\u0022\\n\u0022 \u002B\n\t\t\t\t\t\t$\u0022MSBuild ({MsBuildComponent})\u0022);\n\t\t\t\t}\n\n\t\t\t\tstring vsPath = outputPath.Text.Replace(\u0022installationPath: \u0022, \u0022\u0022);\n\t\t\t\tstring vsVersion = outputVersion.Text.Replace(\u0022installationVersion: \u0022, \u0022\u0022);\n\t\t\t\tInt32.TryParse(vsVersion.Split(\u0027.\u0027)[0], out int vsMajor);\n\n\t\t\t\tif (vsMajor \u003C 15)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\u0022Can\u0027t build with less than VS 2017!\u0022);\n\t\t\t\t}\n\n\t\t\t\t// Windows developers with Visual Studio installed to a directory\n\t\t\t\t// other than System.Environment.SpecialFolder.ProgramFilesX86 need\n\t\t\t\t// to tell Nuke the path to MSBuild.exe themselves.\n\t\t\t\tCustomMsBuildPath = (AbsolutePath)GlobFiles(Path.Combine(vsPath, \u0022MSBuild\u0022), \u0022**/Bin/MSBuild.exe\u0022).First();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLogger.Info(\u0022Mono build; no Visual Studio paths to set.\u0022);\n\t\t\t}\n\t\t});\n\n\tprivate void CompileEtoVeldrid(params RelativePath[] projects)\n\t{\n\t\tif (!DirectoryExists(EtoVeldridRoot) || !Directory.EnumerateFileSystemEntries(EtoVeldridRoot).Any())\n\t\t{\n\t\t\tGit(\u0022submodule update --init lib/Eto.Veldrid\u0022);\n\t\t}\n\n\t\tMSBuild(settings =\u003E settings\n\t\t\t.SetWorkingDirectory(EtoVeldridRoot)\n\t\t\t.EnableRestore()\n\t\t\t.SetTargets(\u0022Build\u0022)\n\t\t\t.SetConfiguration(\u0022Release\u0022)\n\t\t\t.When(CustomMsBuildPath != null, s =\u003E s\n\t\t\t\t.SetToolPath(CustomMsBuildPath))\n\t\t\t.CombineWith(projects, (s, p) =\u003E s\n\t\t\t\t.SetProjectFile(EtoVeldridRoot / p)));\n\t}\n\n\tTarget CompileWindowsDependencies =\u003E _ =\u003E _\n\t\t.DependsOn(Clean, SetVisualStudioPaths)\n\t\t.Before(CompileCore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompileEtoVeldrid(\n\t\t\t\t(RelativePath)\u0022src\u0022 / \u0022Eto.Veldrid.WinForms\u0022 / \u0022Eto.Veldrid.WinForms.csproj\u0022,\n\t\t\t\t(RelativePath)\u0022src\u0022 / \u0022Eto.Veldrid.Wpf\u0022 / \u0022Eto.Veldrid.Wpf.csproj\u0022);\n\t\t});\n\n\tTarget CompileLinuxDependencies =\u003E _ =\u003E _\n\t\t.DependsOn(Clean, SetVisualStudioPaths)\n\t\t.Before(CompileCore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompileEtoVeldrid(\n\t\t\t\t(RelativePath)\u0022src\u0022 / \u0022Eto.Veldrid.Gtk\u0022 / \u0022Eto.Veldrid.Gtk2.csproj\u0022,\n\t\t\t\t(RelativePath)\u0022src\u0022 / \u0022Eto.Veldrid.Gtk\u0022 / \u0022Eto.Veldrid.Gtk.csproj\u0022);\n\t\t});\n\n\tTarget CompileMacDependencies =\u003E _ =\u003E _\n\t\t.DependsOn(Clean, SetVisualStudioPaths)\n\t\t.Before(CompileCore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompileEtoVeldrid(\n\t\t\t\t(RelativePath)\u0022src\u0022 / \u0022Eto.Veldrid.Mac\u0022 / \u0022Eto.Veldrid.Mac64.csproj\u0022);\n\t\t});\n\n\tprivate void Compile(string[] projects)\n\t{\n\t\tMSBuild(settings =\u003E settings\n\t\t\t.EnableRestore()\n\t\t\t.SetTargets(\u0022Build\u0022)\n\t\t\t.SetConfiguration(Configuration)\n\t\t\t.When(CustomMsBuildPath != null, s =\u003E s\n\t\t\t\t.SetToolPath(CustomMsBuildPath))\n\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t.SetMaxCpuCount(Environment.ProcessorCount)\n\t\t\t.SetNodeReuse(IsLocalBuild)\n\t\t\t.CombineWith(projects, (s, p) =\u003E s\n\t\t\t\t.SetProjectFile(Solution.GetProject($\u0022{p}\u0022))));\n\t}\n\n\tTarget CompileCore =\u003E _ =\u003E _\n\t\t.DependsOn(Clean, SetVisualStudioPaths)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompile(new string[] { $\u0022{ProductName}.Core\u0022 });\n\t\t});\n\n\tTarget CompileWindows =\u003E _ =\u003E _\n\t\t.DependsOn(CompileCore, CompileWindowsDependencies)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompile(EtoPlatformsWin.Select(p =\u003E $\u0022{ProductName}.{p}\u0022).ToArray());\n\t\t});\n\n\tTarget CompileLinux =\u003E _ =\u003E _\n\t\t.DependsOn(CompileCore, CompileLinuxDependencies)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompile(EtoPlatformsLin.Select(p =\u003E $\u0022{ProductName}.{p}\u0022).ToArray());\n\t\t});\n\n\tTarget CompileMac =\u003E _ =\u003E _\n\t\t.DependsOn(CompileCore, CompileMacDependencies)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompile(EtoPlatformsMac.Select(p =\u003E $\u0022{ProductName}.{p}\u0022).ToArray());\n\t\t});\n\n\tTarget CompileTests =\u003E _ =\u003E _\n\t\t.DependsOn(CompileCore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tCompile(new string[] { $\u0022{ProductName}Test.Core\u0022, $\u0022{ProductName}Test.Rendering\u0022 });\n\t\t});\n\n\tTarget Test =\u003E _ =\u003E _\n\t\t.DependsOn(CompileTests)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tstring project = $\u0022{ProductName}Test.Core\u0022;\n\n\t\t\t// Nuke supports passing project file names directly into NUnit to\n\t\t\t// specify which test assemblies to load. The NUnit console runner\n\t\t\t// can\u0027t load .csproj files out of the box, but the developers offer\n\t\t\t// an extension that does the trick. Unfortunately, NUnit currently\n\t\t\t// loads extensions by looking in your NuGet package directory for\n\t\t\t// anything matching the pattern NUnit.Extension.*, whereas NuGet\n\t\t\t// restores everything in lowercase these days. Works in Windows,\n\t\t\t// fails in Linux and macOS. Passing in the output assembly path\n\t\t\t// instead is the next best thing.\n\t\t\tNUnit3(settings =\u003E settings\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetInputFiles(GetOutputPath(project) / $\u0022{project}.dll\u0022)\n\t\t\t\t.AddParameter(\u0022dataDirectory\u0022, RootDirectory / \u0022test/data\u0022)\n\t\t\t\t.AddParameter(\u0022fgdDirectory\u0022, RootDirectory / \u0022extras\u0022)\n\t\t\t\t.When(Configuration != \u0022Release\u0022,\n\t\t\t\t\ts =\u003E s.SetWhereExpression(\u0022cat != Performance\u0022)));\n\t\t});\n\n\tprivate void Package(string[] etoPlatforms, Action\u003CAbsolutePath, AbsolutePath, string\u003E save)\n\t{\n\t\tforeach (string platform in etoPlatforms)\n\t\t{\n\t\t\tAbsolutePath source = GetOutputPath($\u0022{ProductName}.{platform}\u0022) / (EnvironmentInfo.IsOsx ? $\u0022{ProductName}.app \u0022 : \u0022\u0022);\n\t\t\tAbsolutePath dest = ArtifactsDirectory / platform;\n\n\t\t\t// Cleaning the entire artifacts directory is undesirable, since\n\t\t\t// usually this script is only building for one OS at a time. If\n\t\t\t// other platforms\u0027 packages exist already, leave them be.\n\t\t\tEnsureCleanDirectory(dest);\n\n\t\t\tstring name = String.Join(\u0027-\u0027, ProductName, GitVersion.MajorMinorPatch, OsFriendlyName[EnvironmentInfo.Platform]);\n\n\t\t\tsave.Invoke(source, dest, name);\n\t\t}\n\t}\n\n\tTarget PackageWindows =\u003E _ =\u003E _\n\t\t.DependsOn(CompileWindows, Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tPackage(EtoPlatformsWin, (source, dest, name) =\u003E\n\t\t\t{\n\t\t\t\tusing (var archive = ZipArchive.Create())\n\t\t\t\t{\n\t\t\t\t\tarchive.DeflateCompressionLevel = CompressionLevel.BestCompression;\n\t\t\t\t\tarchive.AddAllFromDirectory(source);\n\t\t\t\t\tarchive.SaveTo(dest / name \u002B \u0022.zip\u0022, new WriterOptions(CompressionType.Deflate));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\tTarget PackageLinux =\u003E _ =\u003E _\n\t\t.DependsOn(CompileLinux, Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tPackage(EtoPlatformsLin, (source, dest, name) =\u003E\n\t\t\t{\n\t\t\t\tusing (var tarball = TarArchive.Create())\n\t\t\t\t{\n\t\t\t\t\ttarball.AddAllFromDirectory(source);\n\t\t\t\t\ttarball.SaveTo(dest / name \u002B \u0022.tar.gz\u0022, new WriterOptions(CompressionType.GZip));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\tTarget PackageMac =\u003E _ =\u003E _\n\t\t.DependsOn(CompileMac, Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tPackage(EtoPlatformsMac, (source, dest, name) =\u003E\n\t\t\t{\n\t\t\t\tProcessTasks.StartProcess(\n\t\t\t\t\t\u0022dmgbuild\u0022,\n\t\t\t\t\t$\u0022-s {BuildProjectDirectory / \u0022dmgbuild-settings.py\u0022} \u0022 \u002B\n\t\t\t\t\t$\u0022-D app={source} \u0022 \u002B\n\t\t\t\t\t$\u0022{ProductName} \u0022 \u002B\n\t\t\t\t\t$\u0022{dest / name}.dmg\u0022).AssertZeroExitCode();\n\t\t\t});\n\t\t});\n}\n"
  },
  {
    "Id": 162144142,
    "FirstIndexed": "2020-04-25T15:50:44.7355436+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631995+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433842+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939601+02:00",
    "Name": "adrapi",
    "Owner": "ffquintella",
    "HtmlUrl": "https://github.com/ffquintella/adrapi",
    "Description": "Active Directory Rest API",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ffquintella/adrapi/blob/master/build/Build.cs",
    "BuildFileSize": 4870,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Docker;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.Docker.DockerBuildSettings;\nusing static Nuke.Docker.DockerTasks;\nusing System.IO;\n\n\nclass Build : NukeBuild\n{\n    \n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    //readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    readonly Configuration Configuration = Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PackDirectory =\u003E RootDirectory / \u0022artifacts/nupkg\u0022;\n    AbsolutePath AppDirectory =\u003E RootDirectory / \u0022artifacts/app\u0022;\n\n    AbsolutePath DockerFile =\u003E RootDirectory / \u0022Dockerfile\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n\n    string[] Authors = { \u0022Felipe F Quintella\u0022 };\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            Logger.Log(\u0022Restoring packages!\u0022);\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(AppDirectory);\n\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetOutputDirectory(AppDirectory)\n                .EnableNoRestore());\n        });\n\n    private Target Local_Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            Logger.Log(\u0022Publishing to artifacts...\u0022);\n            EnsureExistingDirectory(AppDirectory);\n            DotNetPublish(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetAuthors(Authors)\n                .SetVersion(GitVersion.GetNormalizedFileVersion())\n                .SetTitle(\u0022ADRAPI\u0022)\n                .SetOutput(AppDirectory)\n                .SetWorkingDirectory(RootDirectory)\n                .SetProject(Solution)\n            );\n          \n            DeleteFile(AppDirectory \u002B \u0022/appsettings.Development.json\u0022);\n            CopyFile(RootDirectory \u002B \u0022/adrapi/nLog.prod.config\u0022, AppDirectory \u002B \u0022/nlog.config\u0022, FileExistsPolicy.OverwriteIfNewer);\n\n            string fileName = AppDirectory \u002B \u0022/version.txt\u0022;\n            using (StreamWriter sw = new StreamWriter(fileName, false))\n            {\n                sw.WriteLine(GitVersion.GetNormalizedFileVersion());\n            }\n            \n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n\n            Logger.Log(\u0022Creating Nupackages...\u0022);\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackDirectory)\n                .SetPackageReleaseNotes(changeLog));\n                \n        });\n\n    Target Create_Docker_Image =\u003E _ =\u003E _\n        .DependsOn(Local_Publish)\n        .Executes(() =\u003E\n        {\n            Logger.Log(\u0022Creating Docker Image...\u0022);\n\n            DockerBuild(s =\u003E s\n                .AddLabel(\u0022adrapi\u0022)\n                .SetTag(\u0022ffquintella/adrapi:\u0022 \u002B GitVersion.GetNormalizedFileVersion())\n                .SetFile(DockerFile)\n                .SetForceRm(true)\n                .SetPath(RootDirectory)\n                );\n\n        });\n\n    private Target Deploy_Docker_Image =\u003E _ =\u003E _\n        .DependsOn(Create_Docker_Image)\n        .Executes(() =\u003E\n        {\n            DockerPush(s =\u003E s\n                .SetWorkingDirectory(RootDirectory)\n                .SetName(\u0022ffquintella/adrapi:\u0022 \u002B GitVersion.GetNormalizedFileVersion())\n            );\n        });\n}\n"
  },
  {
    "Id": 162758234,
    "FirstIndexed": "2020-04-25T15:50:44.7362381+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362392+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843498+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940693+02:00",
    "Name": "playground",
    "Owner": "agillesp",
    "HtmlUrl": "https://github.com/agillesp/playground",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "_build/Build.cs",
    "BuildFileUrl": "https://github.com/agillesp/playground/blob/master/_build/Build.cs",
    "BuildFileSize": 1341,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    \n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022BuildFun.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n    \n}\n"
  },
  {
    "Id": 162898791,
    "FirstIndexed": "2020-04-25T15:47:03.6111716+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163051+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843118+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937052+02:00",
    "Name": "DotGGPK",
    "Owner": "t081as",
    "HtmlUrl": "https://github.com/t081as/DotGGPK",
    "Description": "A .NET standard library for parsing Path of Exile\u0027s GGPK archive file format; mirror of the official repository https://gitlab.com/tobiaskoch/DotGGPK",
    "Archived": false,
    "Stars": 3,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/t081as/DotGGPK/blob/master/build/Build.cs",
    "BuildFileSize": 8450,
    "BuildFileContent": "// The MIT License (MIT)\n//\n// Copyright \u00A9 2017-2020 Tobias Koch\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \u201CSoftware\u201D), to deal in the Software without\n// restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\nusing System.IO;\nusing System.Linq;\nusing static Mjolnir.Build.VCS.GitVersionTasks;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.ReportGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing System.Xml.Linq;\nusing System.Globalization;\nusing System;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Parameter]\n    readonly ulong Buildnumber = 0;\n\n    [Parameter]\n    readonly string Key = string.Empty;\n\n    [Solution]\n    readonly Solution Solution;\n\n    readonly string coverageFiles = \u0022**/TestResults/*/coverage.cobertura.xml\u0022;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string shortVersion = \u00220.0.0\u0022;\n    string version = \u00220.0.0.0\u0022;\n    string semanticVersion = \u00220.0.0\u002BXXXXXXXX\u0022;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            //// TestsDirectory.GlobFiles(\u0022**/TestResults/TestResults.xml\u0022).ForEach(DeleteFile);\n\n            RootDirectory.GlobFiles(\u0022**/*.nupkg\u0022).ForEach(DeleteFile);\n            RootDirectory.GlobFiles(coverageFiles).ForEach(DeleteFile);\n\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Version =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n\n            (string shortVersion, string version, string semanticVersion) = GetGitTagVersion(RootDirectory, Buildnumber);\n\n            Logger.Info($\u0022Version: {version}\u0022);\n            Logger.Info($\u0022Short Version: {shortVersion}\u0022);\n            Logger.Info($\u0022Semantic Version: {semanticVersion}\u0022);\n            Logger.Info($\u0022Buildnumber: {Buildnumber}\u0022);\n\n            if (Configuration == Configuration.Release)\n            {\n                this.shortVersion = shortVersion;\n                this.version = version;\n                this.semanticVersion = semanticVersion;\n            }\n            else\n            {\n                Logger.Info(\u0022Debug build - skipping version\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .DependsOn(Version)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersion(semanticVersion)\n                .SetAssemblyVersion(version)\n                .SetFileVersion(version)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            string loggerConfiguration = $\u0022junit;LogFilePath={OutputDirectory / \u0022TestResults\u0022 / \u0022TestResults.xml\u0022};MethodFormat=Class;FailureBodyFormat=Verbose\u0022;\n            \n            if (Configuration == Configuration.Release)\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .EnableNoBuild());\n            }\n            else\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .SetDataCollector(\u0022XPlat Code Coverage\u0022));\n\n                var reportFiles = RootDirectory / coverageFiles;\n\n                if (EnvironmentInfo.IsWin)\n                {\n                    ReportGenerator(_ =\u003E _\n                        .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, null, \u0022netcoreapp3.0\u0022))\n                        .SetReports(reportFiles)\n                        .SetTargetDirectory(OutputDirectory / \u0022coverage\u0022)\n                        .SetReportTypes(ReportTypes.TextSummary, ReportTypes.Html));\n\n                    Logger.Info(File.ReadAllText(OutputDirectory / \u0022coverage\u0022 / \u0022Summary.txt\u0022));\n                }\n                else\n                {\n                    var coverageFileNames = RootDirectory.GlobFiles(coverageFiles);\n\n                    double overallLineCoverage = 0;\n\n                    foreach (var coverageFileName in coverageFileNames)\n                    {\n                        XDocument xdoc = XDocument.Load(coverageFileName);\n                        double lineCoverage = double.Parse(xdoc.Descendants(\u0022coverage\u0022).FirstOrDefault().Attribute(\u0022line-rate\u0022).Value, CultureInfo.GetCultureInfo(\u0022en-US\u0022));\n\n                        overallLineCoverage \u002B= lineCoverage;\n                    }\n\n                    Logger.Info(\u0022Summary\u0022);\n                    Logger.Info($\u0022  Line coverage: {Math.Round(overallLineCoverage * 100, 2).ToString(CultureInfo.GetCultureInfo(\u0022en-US\u0022))}%\u0022);\n                    Logger.Info(\u0022End Summary\u0022);\n                }\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var projects = new string[]\n            {\n                RootDirectory / \u0022src\u0022 / \u0022DotGGPK\u0022 / \u0022DotGGPK.csproj\u0022,\n            };\n\n            var changeLog = GetNuGetReleaseNotes(RootDirectory / \u0022CHANGELOG.md\u0022);\n\n            foreach (var project in projects)\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .EnableNoRestore()\n                    .SetVersion(semanticVersion)\n                    .SetAssemblyVersion(version)\n                    .SetFileVersion(version)\n                    .SetIncludeSource(true)\n                    .SetIncludeSymbols(true)\n                    .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                    .SetPackageReleaseNotes(changeLog)\n                    .SetOutputDirectory(OutputDirectory));\n            }\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E Key)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var generatedPackages = OutputDirectory.GlobFiles(\u0022*.nupkg\u0022)\n                .NotEmpty()\n                .Where(p =\u003E !p.ToString().EndsWith(\u0022.symbols.nupkg\u0022));\n\n            foreach (var package in generatedPackages)\n            {\n                Logger.Info($\u0022Pushing package {package}\u0022);\n\n                DotNetNuGetPush(_ =\u003E _\n                    .SetTargetPath(package)\n                    .SetApiKey(Key)\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022));\n            }\n        });\n}"
  },
  {
    "Id": 163200240,
    "FirstIndexed": "2020-04-25T15:50:44.7355504+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627802+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433871+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939623+02:00",
    "Name": "template",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/template",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nuke-build/template/blob/master/build/Build.cs",
    "BuildFileSize": 7140,
    "BuildFileContent": "// Copyright 2018 Maintainers of NUKE.\n// Distributed under the MIT License.\n// https://github.com/nuke-build/nuke/blob/master/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing static Nuke.CodeGeneration.CodeGenerator;\nusing static Nuke.GitHub.GitHubTasks;\n\n// ReSharper disable HeapView.DelegateAllocation\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Parameter] readonly string SymbolSource = \u0022https://nuget.smbsrc.net/\u0022;\n    // [Parameter] readonly string Source = \u0022https://www.myget.org/F/nukebuild/api/v3/index.json\u0022;\n    // [Parameter] readonly string SymbolSource = \u0022https://www.myget.org/F/nukebuild/symbols/api/v2/package\u0022;\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)] readonly string ApiKey;\n    [Parameter] readonly string GitHubToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    string SemanticVersion =\u003E GitVersion.MajorMinorPatch;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    IEnumerable\u003Cstring\u003E SpecificationFiles =\u003E GlobFiles(SourceDirectory, \u0022*/*.json\u0022);\n\n    Target Generate =\u003E _ =\u003E _\n        .OnlyWhenDynamic(() =\u003E SpecificationFiles.Any())\n        .Executes(() =\u003E\n        {\n            string GetNamespace(string specificationFile)\n                =\u003E Solution.Projects.Single(x =\u003E IsDescendantPath(x.Directory, specificationFile)).Name;\n\n            GenerateCode(\n                SpecificationFiles.ToList(),\n                outputFileProvider: x =\u003E x.DefaultOutputFile,\n                namespaceProvider: x =\u003E GetNamespace(x.SpecificationFile),\n                sourceFileProvider: x =\u003E GitRepository.GetGitHubBrowseUrl(x.SpecificationFile));\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, Generate)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetProperty(\u0022ReplacePackageReferences\u0022, false));\n        });\n\n    IEnumerable\u003CNuke.Common.ProjectModel.Project\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E TestProjects.Any())\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(OutputDirectory)\n                .CombineWith(TestProjects, (cs, v) =\u003E cs\n                    .SetProjectFile(v)));\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangelogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangelogFile);\n\n    Target Changelog =\u003E _ =\u003E _\n        .After(Test)\n        .Before(Pack)\n        .OnlyWhenDynamic(() =\u003E\n            GitRepository.IsOnMasterBranch() ||\n            GitRepository.IsOnReleaseBranch() ||\n            GitRepository.IsOnHotfixBranch())\n        .Executes(() =\u003E\n        {\n            FinalizeChangelog(ChangelogFile, SemanticVersion, GitRepository);\n            Git($\u0022add {ChangelogFile}\u0022);\n            Git($\u0022commit -m \\\u0022Finalize {Path.GetFileName(ChangelogFile)} for v{SemanticVersion}\\\u0022\u0022);\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Changelog)\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        // .Requires(() =\u003E GitHubToken)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        // .Requires(() =\u003E GitHubMilestoneClosed(mustExist: false))\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        // .Requires(() =\u003E GitRepository.IsOnMasterBranch() ||\n        //                 GitRepository.IsOnDevelopBranch() ||\n        //                 GitRepository.IsOnReleaseBranch() ||\n        //                 GitRepository.IsOnHotfixBranch())\n        .Executes(async () =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetSource(Source)\n                    .SetSymbolSource(SymbolSource)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(OutputDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E cs\n                        .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n\n            Git($\u0022tag {SemanticVersion}\u0022);\n            Git($\u0022push origin {GitRepository.Branch} {SemanticVersion}\u0022);\n\n            return;\n\n            await PublishRelease(s =\u003E s\n                .SetToken(GitHubToken)\n                .SetRepositoryOwner(GitRepository.GetGitHubOwner())\n                .SetRepositoryName(GitRepository.GetGitHubName())\n                .SetCommitSha(GitRepository.Branch)\n                .SetTag($\u0022{SemanticVersion}\u0022)\n                .SetName($\u0022v{SemanticVersion}\u0022)\n                .SetReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\n        });\n\n    bool GitHubMilestoneClosed(bool mustExist) =\u003E GetMilestone().Result?.State.Value == ItemState.Closed;\n\n    async Task\u003CMilestone\u003E GetMilestone()\n    {\n        var client = new GitHubClient(new ProductHeaderValue(nameof(NukeBuild))) { Credentials = new Credentials(GitHubToken) };\n        var milestones = await client.Issue.Milestone.GetAllForRepository(\n            GitRepository.GetGitHubOwner(),\n            GitRepository.GetGitHubName());\n        return milestones.FirstOrDefault(x =\u003E x.Title == $\u0022v{SemanticVersion}\u0022);\n    }\n}\n"
  },
  {
    "Id": 163290537,
    "FirstIndexed": "2020-04-25T15:50:44.7362114+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632547+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434895+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940619+02:00",
    "Name": "NodaTime.Serialization.Utf8Json",
    "Owner": "DSilence",
    "HtmlUrl": "https://github.com/DSilence/NodaTime.Serialization.Utf8Json",
    "Description": "A port of NodaTime.Serialization.JsonNet to utilize Utf8Json instead",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/DSilence/NodaTime.Serialization.Utf8Json/blob/develop/build/Build.cs",
    "BuildFileSize": 3575,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Ci);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Parameter(\u0022Explicit framework to build\u0022)] readonly string Framework = null;\n\n    [Parameter(\u0022Collect code coverage. Default is \u0027true\u0027\u0022)] readonly bool? Cover = true;\n\n    [Parameter(\u0022Coverage threshold. Default is 80%\u0022)] readonly int Threshold = 80;\n\n    [Solution(\u0022src/NodaTime.Serialization.Utf8Json/NodaTime.Serialization.Utf8Json.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetFramework(Framework)\n                .EnableNoRestore()\n\n            );\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022DS.NodaTime.Serialization.Utf8Json.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetLogger(\u0022trx\u0022)\n                .SetLogOutput(true)\n                .SetFramework(Framework)\n                .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, Cover)\n                    .Add(\u0022/p:CoverletOutput={0}/\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:Threshold={0}\u0022, Threshold)\n                    .Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n                .SetResultsDirectory(ArtifactsDirectory / \u0022tests\u0022));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022DS.NodaTime.Serialization.Utf8Json\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n        });\n\n    Target CiNonWin =\u003E _ =\u003E _\n        .DependsOn(Test);\n    Target Ci =\u003E _ =\u003E _\n        .DependsOn(Pack, Test);\n\n}\n"
  },
  {
    "Id": 163432680,
    "FirstIndexed": "2020-04-25T15:47:03.6116631+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628029+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431191+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937063+02:00",
    "Name": "allors2",
    "Owner": "Allors",
    "HtmlUrl": "https://github.com/Allors/allors2",
    "Description": "The monorepo for the Allors Platform",
    "Archived": false,
    "Stars": 1,
    "Watchers": 7,
    "BuildFilePath": "build/Build.Core.cs",
    "BuildFileUrl": "https://github.com/Allors/allors2/blob/master/build/Build.Core.cs",
    "BuildFileSize": 10951,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.Npm;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Npm.NpmTasks;\n\npartial class Build\n{\n    Target CoreResetDatabase =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var database = \u0022Core\u0022;\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Drop(database);\n                sqlServer.Create(database);\n            }\n        });\n\n    private Target CoreMerge =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRun(s =\u003E s\n                .SetProjectFile(Paths.CoreDatabaseMerge)\n                .SetApplicationArguments($\u0022{Paths.CoreDatabaseResourcesCore} {Paths.CoreDatabaseResourcesCustom} {Paths.CoreDatabaseResources}\u0022));\n        });\n\n    Target CoreGenerate =\u003E _ =\u003E _\n        .After(Clean)\n        .DependsOn(CoreMerge)\n        .Executes(() =\u003E\n        {\n            DotNetRun(s =\u003E s\n                .SetProjectFile(Paths.PlatformRepositoryGenerate)\n                .SetApplicationArguments($\u0022{Paths.CoreRepositoryDomainRepository} {Paths.PlatformRepositoryTemplatesMetaCs} {Paths.CoreDatabaseMetaGenerated}\u0022));\n            DotNetRun(s =\u003E s\n                .SetWorkingDirectory(Paths.Core)\n                .SetProjectFile(Paths.CoreDatabaseGenerate));\n        });\n\n    Target CoreDatabaseTestDomain =\u003E _ =\u003E _\n        .DependsOn(CoreGenerate)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Paths.CoreDatabaseDomainTests)\n                .SetLogger(\u0022trx;LogFileName=CoreDatabaseDomain.trx\u0022)\n                .SetResultsDirectory(Paths.ArtifactsTests));\n        });\n\n    Target CorePublishCommands =\u003E _ =\u003E _\n        .DependsOn(CoreGenerate)\n        .Executes(() =\u003E\n        {\n            var dotNetPublishSettings = new DotNetPublishSettings()\n                .SetWorkingDirectory(Paths.CoreDatabaseCommands)\n                .SetOutput(Paths.ArtifactsCoreCommands);\n            DotNetPublish(dotNetPublishSettings);\n        });\n\n    Target CorePublishServer =\u003E _ =\u003E _\n        .DependsOn(CoreGenerate)\n        .Executes(() =\u003E\n        {\n            var dotNetPublishSettings = new DotNetPublishSettings()\n                .SetWorkingDirectory(Paths.CoreDatabaseServer)\n                .SetOutput(Paths.ArtifactsCoreServer);\n            DotNetPublish(dotNetPublishSettings);\n        });\n\n    Target CoreDatabaseTestServer =\u003E _ =\u003E _\n        .DependsOn(CoreGenerate)\n        .DependsOn(CorePublishServer)\n        .DependsOn(CorePublishCommands)\n        .DependsOn(CoreResetDatabase)\n        .Executes(async () =\u003E\n        {\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Populate(Paths.ArtifactsCoreCommands);\n                using (var server = new Server(Paths.ArtifactsCoreServer))\n                {\n                    await server.Ready();\n                    DotNetTest(s =\u003E s\n                        .SetProjectFile(Paths.CoreDatabaseServerTests)\n                        .SetLogger(\u0022trx;LogFileName=CoreDatabaseServer.trx\u0022)\n                        .SetResultsDirectory(Paths.ArtifactsTests));\n                }\n            }\n        });\n\n    Target CoreWorkspaceNpmInstall =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            foreach (var path in Paths.CoreWorkspaceTypescript)\n            {\n                NpmInstall(s =\u003E s\n                    .SetEnvironmentVariable(\u0022npm_config_loglevel\u0022, \u0022error\u0022)\n                    .SetWorkingDirectory(path));\n            }\n        });\n\n    Target CoreWorkspaceSetup =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceNpmInstall)\n        .DependsOn(CoreGenerate);\n\n    Target CoreWorkspaceAutotest =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceSetup)\n        .Executes(() =\u003E\n        {\n            foreach (var path in new[] { Paths.CoreWorkspaceTypescriptMaterial, Paths.CoreWorkspaceTypescriptAutotestAngular })\n            {\n                NpmRun(s =\u003E s\n                    .SetEnvironmentVariable(\u0022npm_config_loglevel\u0022, \u0022error\u0022)\n                    .SetWorkingDirectory(path)\n                    .SetCommand(\u0022autotest\u0022));\n            }\n\n            DotNetRun(s =\u003E s\n                .SetWorkingDirectory(Paths.Core)\n                .SetProjectFile(Paths.CoreWorkspaceTypescriptAutotestGenerateGenerate));\n        });\n\n    Target CoreWorkspaceTypescriptDomain =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceSetup)\n        .DependsOn(EnsureDirectories)\n        .Executes(() =\u003E\n        {\n            NpmRun(s =\u003E s\n                .SetEnvironmentVariable(\u0022npm_config_loglevel\u0022, \u0022error\u0022)\n                .SetWorkingDirectory(Paths.CoreWorkspaceTypescriptDomain)\n                .SetArguments(\u0022--reporter-options\u0022, $\u0022output={Paths.ArtifactsTestsCoreWorkspaceTypescriptDomain}\u0022)\n                .SetCommand(\u0022az:test\u0022));\n        });\n\n    Target CoreWorkspaceTypescriptPromise =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceSetup)\n        .DependsOn(CorePublishServer)\n        .DependsOn(CorePublishCommands)\n        .DependsOn(EnsureDirectories)\n        .DependsOn(CoreResetDatabase)\n        .Executes(async () =\u003E\n        {\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Populate(Paths.ArtifactsCoreCommands);\n                using (var server = new Server(Paths.ArtifactsCoreServer))\n                {\n                    await server.Ready();\n                    NpmRun(s =\u003E s\n                        .SetEnvironmentVariable(\u0022npm_config_loglevel\u0022, \u0022error\u0022)\n                        .SetWorkingDirectory(Paths.CoreWorkspaceTypescriptPromise)\n                        .SetArguments(\u0022--reporter-options\u0022, $\u0022output={Paths.ArtifactsTestsCoreWorkspaceTypescriptPromise}\u0022)\n                        .SetCommand(\u0022az:test\u0022));\n                }\n            }\n        });\n\n    Target CoreWorkspaceTypescriptAngular =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceSetup)\n        .DependsOn(CorePublishServer)\n        .DependsOn(CorePublishCommands)\n        .DependsOn(EnsureDirectories)\n        .DependsOn(CoreResetDatabase)\n        .Executes(async () =\u003E\n        {\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Populate(Paths.ArtifactsCoreCommands);\n                using (var server = new Server(Paths.ArtifactsCoreServer))\n                {\n                    await server.Ready();\n                    NpmRun(s =\u003E s\n                        .SetEnvironmentVariable(\u0022npm_config_loglevel\u0022, \u0022error\u0022)\n                        .SetWorkingDirectory(Paths.CoreWorkspaceTypescriptAngular)\n                        .SetArguments(\u0022--watch=false\u0022, \u0022--reporters\u0022, \u0022trx\u0022)\n                        .SetCommand(\u0022test\u0022));\n                    CopyFileToDirectory(Paths.CoreWorkspaceTypescriptAngularTrx, Paths.ArtifactsTests,\n                        FileExistsPolicy.Overwrite);\n                }\n            }\n        });\n\n    Target CoreWorkspaceTypescriptMaterial =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceSetup)\n        .DependsOn(CorePublishServer)\n        .DependsOn(CorePublishCommands)\n        .DependsOn(CoreResetDatabase)\n        .Executes(async () =\u003E\n        {\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Populate(Paths.ArtifactsCoreCommands);\n                using (var server = new Server(Paths.ArtifactsCoreServer))\n                {\n                    await server.Ready();\n                    NpmRun(s =\u003E s\n                        .SetEnvironmentVariable(\u0022npm_config_loglevel\u0022, \u0022error\u0022)\n                        .SetWorkingDirectory(Paths.CoreWorkspaceTypescriptMaterial)\n                        .SetArguments(\u0022--watch=false\u0022, \u0022--reporters\u0022, \u0022trx\u0022)\n                        .SetCommand(\u0022test\u0022));\n                    CopyFileToDirectory(Paths.CoreWorkspaceTypescriptMaterialTrx, Paths.ArtifactsTests,\n                        FileExistsPolicy.Overwrite);\n                }\n            }\n        });\n\n    Target CoreWorkspaceTypescriptMaterialTests =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceAutotest)\n        .DependsOn(CorePublishServer)\n        .DependsOn(CorePublishCommands)\n        .DependsOn(CoreResetDatabase)\n        .Executes(async () =\u003E\n        {\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Populate(Paths.ArtifactsCoreCommands);\n                using (var server = new Server(Paths.ArtifactsCoreServer))\n                {\n                    using (var angular = new Angular(Paths.CoreWorkspaceTypescriptMaterial))\n                    {\n                        await server.Ready();\n                        await angular.Init();\n                        DotNetTest(s =\u003E s\n                            .SetProjectFile(Paths.CoreWorkspaceTypescriptMaterialTests)\n                            .SetLogger(\u0022trx;LogFileName=CoreWorkspaceTypescriptMaterialTests.trx\u0022)\n                            .SetResultsDirectory(Paths.ArtifactsTests));\n                    }\n                }\n            }\n        });\n\n    Target CoreWorkspaceCSharpDomainTests =\u003E _ =\u003E _\n        .DependsOn(CorePublishServer)\n        .DependsOn(CorePublishCommands)\n        .DependsOn(CoreResetDatabase)\n        .Executes(async () =\u003E\n        {\n            using (var sqlServer = new SqlServer())\n            {\n                sqlServer.Restart();\n                sqlServer.Populate(Paths.ArtifactsCoreCommands);\n                using (var server = new Server(Paths.ArtifactsCoreServer))\n                {\n                    await server.Ready();\n                    DotNetTest(s =\u003E s\n                        .SetProjectFile(Paths.CoreWorkspaceCSharpDomainTests)\n                        .SetLogger(\u0022trx;LogFileName=CoreWorkspaceCSharpDomainTests.trx\u0022)\n                        .SetResultsDirectory(Paths.ArtifactsTests));\n                }\n            }\n        });\n\n    Target CoreDatabaseTest =\u003E _ =\u003E _\n        .DependsOn(CoreDatabaseTestDomain)\n        .DependsOn(CoreDatabaseTestServer);\n\n    Target CoreWorkspaceTypescriptTest =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceTypescriptDomain)\n        .DependsOn(CoreWorkspaceTypescriptPromise)\n        .DependsOn(CoreWorkspaceTypescriptAngular)\n        .DependsOn(CoreWorkspaceTypescriptMaterial)\n        .DependsOn(CoreWorkspaceTypescriptMaterialTests);\n\n    Target CoreWorkspaceCSharpTest =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceCSharpDomainTests);\n\n    Target CoreWorkspaceTest =\u003E _ =\u003E _\n        .DependsOn(CoreWorkspaceCSharpTest)\n        .DependsOn(CoreWorkspaceTypescriptTest);\n\n    Target CoreTest =\u003E _ =\u003E _\n        .DependsOn(CoreDatabaseTest)\n        .DependsOn(CoreWorkspaceTest);\n\n    Target Core =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(CoreTest);\n}\n"
  },
  {
    "Id": 163589754,
    "FirstIndexed": "2020-04-25T15:50:44.7362336+02:00",
    "LastIndexUpdated": "2020-04-25T15:50:44.7362347+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434957+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940676+02:00",
    "Name": "Ademund.Utils",
    "Owner": "netclectic",
    "HtmlUrl": "https://github.com/netclectic/Ademund.Utils",
    "Description": "some C# utils",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/netclectic/Ademund.Utils/blob/master/build/Build.cs",
    "BuildFileSize": 1941,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022Ademund.Utils.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n    \n}\n"
  },
  {
    "Id": 163593689,
    "FirstIndexed": "2020-04-25T15:50:44.7354435+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630664+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433433+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939214+02:00",
    "Name": "TTController",
    "Owner": "MoshiMoshi0",
    "HtmlUrl": "https://github.com/MoshiMoshi0/TTController",
    "Description": "controller software for thermaltake devices",
    "Archived": false,
    "Stars": 26,
    "Watchers": 7,
    "BuildFilePath": "Build/Build.cs",
    "BuildFileUrl": "https://github.com/MoshiMoshi0/TTController/blob/master/Build/Build.cs",
    "BuildFileSize": 5164,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build\u0022)]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022Source\u0022;\n    AbsolutePath PluginsDirectory =\u003E RootDirectory / \u0022Plugins\u0022;\n    AbsolutePath ThirdPartyDirectory =\u003E RootDirectory / \u0022ThirdParty\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022Build\u0022 / \u0022artifacts\u0022;\n\n    AbsolutePath ServiceBinPath =\u003E SourceDirectory / \u0022TTController.Service\u0022 / \u0022bin\u0022 / Configuration;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            // Clean source folders but skip the service project as we are cleaning it manually later\n            SourceDirectory.GlobDirectories(\u0022**/obj\u0022).ForEach(DeleteDirectory);\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022)\n                .Where(f =\u003E !f.Parent.ToString().EndsWith(\u0022TTController.Service\u0022))\n                .ForEach(DeleteDirectory);\n\n            PluginsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            ThirdPartyDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\n            // Clean service bin path but leave \u0027config.json\u0027 file\n            if (Directory.Exists(ServiceBinPath))\n            {\n                ServiceBinPath.GlobDirectories(\u0022*\u0022).ForEach(DeleteDirectory);\n                ServiceBinPath.GlobFiles(\u0022*\u0022).Where(f =\u003E !f.ToString().EndsWith(\u0022config.json\u0022)).ForEach(DeleteFile);\n            }\n\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n\n            // Copy plugin files to service bin path      \n            var fileBlacklist = new[] { \u0022TTController.Common\u0022, \u0022LibreHardwareMonitorLib\u0022, \u0022HidLibrary\u0022, \u0022Newtonsoft.Json\u0022 };\n            var extensionWhitelist = Configuration == Configuration.Debug ? new[] { \u0022.pdb\u0022, \u0022.dll\u0022 } : new[] { \u0022.dll\u0022 };\n            Solution.GetProjects(\u0022TTController.Plugin.*\u0022)\n                .ForEach(p =\u003E\n                {\n                    CopyDirectoryRecursively(p.Directory / \u0022bin\u0022 / Configuration,\n                                             ServiceBinPath / \u0022Plugins\u0022 / Path.GetFileName(p.Directory.Parent) / Path.GetFileName(p.Directory),\n                                             DirectoryExistsPolicy.Merge,\n                                             FileExistsPolicy.OverwriteIfNewer,\n                                             null,\n                                             f =\u003E fileBlacklist.Contains(Path.GetFileNameWithoutExtension(f.Name)) || !extensionWhitelist.Contains(Path.GetExtension(f.Name)));\n                });\n\n            CopyDirectoryRecursively(PluginsDirectory / \u0022Devices\u0022, ServiceBinPath / \u0022Plugins\u0022 / \u0022Devices\u0022, DirectoryExistsPolicy.Merge, FileExistsPolicy.OverwriteIfNewer); \n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var files = Directory.EnumerateFiles(ServiceBinPath, \u0022*\u0022, SearchOption.AllDirectories)\n                .Where(f =\u003E Path.GetFileName(f) != \u0022config.json\u0022\n                         \u0026\u0026 Path.GetExtension(f) != \u0022InstallState\u0022);\n\n            if (Configuration != Configuration.Debug)\n                files = files.Where(f =\u003E Path.GetExtension(f) != \u0022.pdb\u0022);\n\n            ZipFiles(ArtifactsDirectory / $\u0022TTController_{GitVersion.AssemblySemVer}{GitVersion.PreReleaseTagWithDash}.{GitVersion.Sha}.zip\u0022, ServiceBinPath, files);\n        });\n\n    private static void ZipFiles(string outFile, string workingDirectory, IEnumerable\u003Cstring\u003E files)\n    {\n        using (var zip = ZipFile.Open(outFile, ZipArchiveMode.Create))\n            foreach(var file in files)\n                zip.CreateEntryFromFile(file, Path.GetRelativePath(workingDirectory, file), CompressionLevel.Optimal);\n    }\n}\n"
  },
  {
    "Id": 163597288,
    "FirstIndexed": "2020-04-25T15:47:03.6114702+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624843+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431197+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937075+02:00",
    "Name": "MarkdownCodeEmbed",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/MarkdownCodeEmbed",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/MarkdownCodeEmbed/blob/master/build/Build.cs",
    "BuildFileSize": 253,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 163762923,
    "FirstIndexed": "2020-04-25T15:50:44.7362296+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632689+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434946+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940664+02:00",
    "Name": "ChromelySmallSingleExecutable",
    "Owner": "pkudrel",
    "HtmlUrl": "https://github.com/pkudrel/ChromelySmallSingleExecutable",
    "Description": "This is an example of small, single file executable Chromely app - https://github.com/mattkol/Chromely",
    "Archived": false,
    "Stars": 5,
    "Watchers": 1,
    "BuildFilePath": "src/build/Build.cs",
    "BuildFileUrl": "https://github.com/pkudrel/ChromelySmallSingleExecutable/blob/master/src/build/Build.cs",
    "BuildFileSize": 5909,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing AbcVersionTool;\nusing Helpers;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    static readonly DateTime _buildDate = DateTime.UtcNow;\n    [Parameter(\u0022Build counter from outside environment\u0022)] readonly int BuildCounter;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = \u0022Release\u0022;\n\n\n    [Solution(\u0022src/ChromelySmallSingleExecutable.sln\u0022)] readonly Solution Solution;\n    MSBuildTargetPlatform Platform = MSBuildTargetPlatform.x64;\n\n    AbcVersion Version =\u003E AbcVersionFactory.Create(BuildCounter, _buildDate);\n\n    Project MainProject =\u003E\n        Solution.GetProject(\u0022ChromelySmallSingleExecutable\u0022).NotNull();\n\n    AbsolutePath SourceDir =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ToolsDir =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath ArtifactsDir =\u003E RootDirectory / \u0022_artifacts\u0022;\n    AbsolutePath TmpBuild =\u003E TemporaryDirectory / \u0022build\u0022;\n    AbsolutePath LibzPath =\u003E ToolsDir / \u0022LibZ.Tool\u0022 / \u0022tools\u0022 / \u0022libz.exe\u0022;\n    AbsolutePath NugetPath =\u003E ToolsDir / \u0022nuget\u0022 / \u0022nuget.exe\u0022;\n    AbsolutePath SevenZipPath =\u003E ToolsDir / \u00227-Zip.CommandLine\u0022 / \u0022tools\u0022 / \u00227za.exe\u0022;\n\n\n    Target Information =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022SemVer: {Version.SemVersion}\u0022);\n            Logger.Info($\u0022InformationalVersion: {Version.InformationalVersion}\u0022);\n        });\n\n\n    Target CheckTools =\u003E _ =\u003E _\n        .DependsOn(Information)\n        .Executes(() =\u003E\n        {\n            Downloader.DownloadIfNotExists(\u0022https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\u0022, NugetPath,\n                \u0022Nuget\u0022);\n            var toolsNugetFile = ToolsDir / \u0022packages.config\u0022;\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022install   {toolsNugetFile} -OutputDirectory {ToolsDir} -ExcludeVersion\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(CheckTools)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(TmpBuild);\n            DeleteDirectories(GlobDirectories(TmpBuild, \u0022**/*\u0022));\n            EnsureCleanDirectory(ArtifactsDir);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022restore  {Solution.Path}\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            var buildOut = TmpBuild / CommonDir.Build /\n                           MainProject.Name;\n            EnsureExistingDirectory(buildOut);\n\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                .SetOutDir(buildOut)\n                .SetVerbosity(MSBuildVerbosity.Quiet)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(Version.AssemblyVersion)\n                .SetFileVersion(Version.FileVersion)\n                .SetInformationalVersion(Version.InformationalVersion)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target Marge =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n\n        {\n            var doNotMarge = new[]\n            {\n                \u0022build.dll\u0022, \u0022libcef.dll\u0022, \u0022chrome_elf.dll\u0022, \u0022d3dcompiler_47.dll\u0022,\n                \u0022libEGL.dll\u0022, \u0022libGLESv2.dll\u0022, \u0022CefSharp.dll\u0022, \u0022CefSharp.Core.dll\u0022,\n                \u0022CefSharp.BrowserSubprocess.Core.dll\u0022\n            };\n            var exclude = string.Join(\u0027 \u0027, doNotMarge.Select(x =\u003E $\u0022--exclude={x}\u0022));\n\n            var buildOut = TmpBuild / CommonDir.Build /\n                           MainProject.Name;\n            var margeOut = TmpBuild / CommonDir.Merge /\n                           MainProject.Name;\n\n            EnsureExistingDirectory(margeOut);\n            CopyDirectoryRecursively(buildOut, margeOut);\n\n            using (var process = ProcessTasks.StartProcess(\n                LibzPath,\n                $\u0022inject-dll --assembly ChromelySmallSingleExecutable.exe --include *.dll {exclude} --move\u0022,\n                margeOut))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Libz report generation process exited with some errors.\u0022);\n            }\n        });\n\n\n    Target CopyToArtifacts =\u003E _ =\u003E _\n        .DependsOn(Marge)\n        .Executes(() =\u003E\n\n        {\n            var margeOut = TmpBuild / CommonDir.Merge /\n                           MainProject.Name;\n\n            var readyOut = TmpBuild / CommonDir.Ready /\n                           MainProject.Name;\n\n            EnsureExistingDirectory(readyOut);\n            CopyFile(margeOut / $\u0022{MainProject.Name}.exe\u0022, ArtifactsDir / \u0022simple-chromely.exe\u0022);\n        });\n\n    Target CleanOnTheEnd =\u003E _ =\u003E _\n        .DependsOn(CopyToArtifacts)\n        .Executes(() =\u003E\n        {\n            DeleteDirectory(TmpBuild);\n        });\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.CleanOnTheEnd);\n}"
  },
  {
    "Id": 164127453,
    "FirstIndexed": "2020-04-25T15:50:44.7355459+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631096+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433854+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "common",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/common",
    "Description": "THIS REPOSITORY HAS MOVED TO",
    "Archived": true,
    "Stars": 28,
    "Watchers": 6,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 165511895,
    "FirstIndexed": "2020-04-25T15:47:03.6112097+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629941+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431208+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937086+02:00",
    "Name": "Mjolnir",
    "Owner": "t081as",
    "HtmlUrl": "https://github.com/t081as/Mjolnir",
    "Description": "Common library for .NET applications; mirror of the official repository https://gitlab.com/tobiaskoch/Mjolnir",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/t081as/Mjolnir/blob/master/build/Build.cs",
    "BuildFileSize": 8484,
    "BuildFileContent": "\uFEFF// The MIT License (MIT)\n//\n// Copyright \u00A9 2017-2020 Tobias Koch\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \u201CSoftware\u201D), to deal in the Software without\n// restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\nusing System.IO;\nusing System.Linq;\nusing static Mjolnir.Build.VCS.GitVersionTasks;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.ReportGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing System.Xml.Linq;\nusing System.Globalization;\nusing System;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Parameter]\n    readonly ulong Buildnumber = 0;\n\n    [Parameter]\n    readonly string Key = string.Empty;\n\n    [Solution]\n    readonly Solution Solution;\n\n    readonly string coverageFiles = \u0022**/TestResults/*/coverage.cobertura.xml\u0022;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string shortVersion = \u00220.0.0\u0022;\n    string version = \u00220.0.0.0\u0022;\n    string semanticVersion = \u00220.0.0\u002BXXXXXXXX\u0022;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobFiles(\u0022**/TestResults/TestResults.xml\u0022).ForEach(DeleteFile);\n\n            RootDirectory.GlobFiles(\u0022**/*.nupkg\u0022).ForEach(DeleteFile);\n            RootDirectory.GlobFiles(coverageFiles).ForEach(DeleteFile);\n\n            EnsureCleanDirectory(OutputDirectory);\n            DotNetClean();\n        });\n\n    Target Version =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            \n            (string shortVersion, string version, string semanticVersion) = GetGitTagVersion(RootDirectory, Buildnumber);\n\n            Logger.Info($\u0022Version: {version}\u0022);\n            Logger.Info($\u0022Short Version: {shortVersion}\u0022);\n            Logger.Info($\u0022Semantic Version: {semanticVersion}\u0022);\n            Logger.Info($\u0022Buildnumber: {Buildnumber}\u0022);\n\n            if (Configuration == Configuration.Release)\n            {\n                this.shortVersion = shortVersion;\n                this.version = version;\n                this.semanticVersion = semanticVersion;\n            }\n            else\n            {\n                Logger.Info(\u0022Debug build - skipping version\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .DependsOn(Version)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersion(semanticVersion)\n                .SetAssemblyVersion(version)\n                .SetFileVersion(version)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            string loggerConfiguration = $\u0022junit;LogFilePath={OutputDirectory / \u0022TestResults\u0022 / \u0022TestResults.xml\u0022};MethodFormat=Class;FailureBodyFormat=Verbose\u0022;\n\n            if (Configuration == Configuration.Release)\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .EnableNoBuild());\n            }\n            else\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .SetDataCollector(\u0022XPlat Code Coverage\u0022));\n\n                var reportFiles = RootDirectory / coverageFiles;\n\n                if (EnvironmentInfo.IsWin)\n                {\n                    ReportGenerator(_ =\u003E _\n                        .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, null, \u0022netcoreapp3.0\u0022))\n                        .SetReports(reportFiles)\n                        .SetTargetDirectory(OutputDirectory / \u0022coverage\u0022)\n                        .SetReportTypes(ReportTypes.TextSummary, ReportTypes.Html));\n\n                    Logger.Info(File.ReadAllText(OutputDirectory / \u0022coverage\u0022 / \u0022Summary.txt\u0022));\n                }\n                else\n                {\n                    var coverageFileNames = RootDirectory.GlobFiles(coverageFiles);\n\n                    double overallLineCoverage = 0;\n\n                    foreach (var coverageFileName in coverageFileNames)\n                    {\n                        XDocument xdoc = XDocument.Load(coverageFileName);\n                        double lineCoverage = double.Parse(xdoc.Descendants(\u0022coverage\u0022).FirstOrDefault().Attribute(\u0022line-rate\u0022).Value, CultureInfo.GetCultureInfo(\u0022en-US\u0022));\n\n                        overallLineCoverage \u002B= lineCoverage;\n                    }\n\n                    Logger.Info(\u0022Summary\u0022);\n                    Logger.Info($\u0022  Line coverage: {Math.Round(overallLineCoverage * 100, 2).ToString(CultureInfo.GetCultureInfo(\u0022en-US\u0022))}%\u0022);\n                    Logger.Info(\u0022End Summary\u0022);\n                }\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var projects = new string[]\n            {\n                RootDirectory / \u0022src\u0022 / \u0022Mjolnir\u0022 / \u0022Mjolnir.csproj\u0022,\n            };\n\n            var changeLog = GetNuGetReleaseNotes(RootDirectory / \u0022CHANGELOG.md\u0022);\n\n            foreach (var project in projects)\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .EnableNoRestore()\n                    .SetVersion(semanticVersion)\n                    .SetAssemblyVersion(version)\n                    .SetFileVersion(version)\n                    .SetIncludeSource(true)\n                    .SetIncludeSymbols(true)\n                    .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                    .SetPackageReleaseNotes(changeLog)\n                    .SetOutputDirectory(OutputDirectory));\n            }\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E Key)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var generatedPackages = OutputDirectory.GlobFiles(\u0022*.nupkg\u0022)\n                .NotEmpty()\n                .Where(p =\u003E !p.ToString().EndsWith(\u0022.symbols.nupkg\u0022));\n\n            foreach (var package in generatedPackages)\n            {\n                Logger.Info($\u0022Pushing package {package}\u0022);\n\n                DotNetNuGetPush(_ =\u003E _\n                    .SetTargetPath(package)\n                    .SetApiKey(Key)\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022));\n            }\n        });\n}"
  },
  {
    "Id": 165941115,
    "FirstIndexed": "2020-04-25T15:50:44.7362239+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632649+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434929+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940642+02:00",
    "Name": "nuke_xunit_test",
    "Owner": "netclectic",
    "HtmlUrl": "https://github.com/netclectic/nuke_xunit_test",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/netclectic/nuke_xunit_test/blob/master/build/Build.cs",
    "BuildFileSize": 2278,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.Xunit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022ClassLibrary1.sln\u0022)] readonly Solution Solution;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory;\n    AbsolutePath TestsDirectory =\u003E RootDirectory;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022[!build]**/bin\u0022, \u0022[!build]**/obj\u0022));\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var xUnit_netcore_Settings = new Xunit2Settings()\n                .AddTargetAssemblies(GlobFiles(TestsDirectory, $\u0022*/bin/*/netcore*/*.Tests.dll\u0022).NotEmpty())\n                .AddResultReport(Xunit2ResultFormat.Xml, OutputDirectory / \u0022netcore_tests.xml\u0022)\n                .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022xunit.runner.console\u0022, \u0022xunit.console.dll\u0022, \u0022netcoreapp2.0\u0022))\n                .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022xunit.extensibility.execution\u0022, \u0022xunit.execution.dotnet.dll\u0022, \u0022netcoreapp2.0\u0022));\n\n            Xunit2(s =\u003E xUnit_netcore_Settings);\n        });\n}"
  },
  {
    "Id": 166080869,
    "FirstIndexed": "2020-04-25T15:47:03.6115538+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631449+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843122+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937097+02:00",
    "Name": "Kickstart",
    "Owner": "Allors",
    "HtmlUrl": "https://github.com/Allors/Kickstart",
    "Description": "Clone this repository to kickstart a new project based on Allors",
    "Archived": false,
    "Stars": 0,
    "Watchers": 6,
    "BuildFilePath": "build/Build.Custom.cs",
    "BuildFileUrl": "https://github.com/Allors/Kickstart/blob/master/build/Build.Custom.cs",
    "BuildFileSize": 2102,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\npartial class Build\n{\n    Target CustomGenerate =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRun(s =\u003E s\n                .SetProjectFile(Paths.PlatformRepositoryGenerate)\n                .SetApplicationArguments($\u0022{Paths.CustomRepositoryDomainRepository} {Paths.PlatformRepositoryTemplatesMetaCs} {Paths.CustomDatabaseMetaGenerated}\u0022));\n            DotNetRun(s =\u003E s\n                .SetWorkingDirectory(Paths.Custom)\n                .SetProjectFile(Paths.CustomDatabaseGenerate));\n        });\n\n    Target CustomDatabaseTestDomain =\u003E _ =\u003E _\n        .DependsOn(CustomGenerate)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Paths.CustomDatabaseDomainTests)\n                .SetLogger(\u0022trx;LogFileName=CustomDatabaseDomain.trx\u0022)\n                .SetResultsDirectory(Paths.ArtifactsTests));\n        });\n\n    Target CustomPublishCommands =\u003E _ =\u003E _\n        .DependsOn(CustomGenerate)\n        .Executes(() =\u003E\n        {\n            var dotNetPublishSettings = new DotNetPublishSettings()\n                .SetWorkingDirectory(Paths.CustomDatabaseCommands)\n                .SetOutput(Paths.ArtifactsCustomCommands);\n            DotNetPublish(dotNetPublishSettings);\n        });\n\n    Target CustomPublishServer =\u003E _ =\u003E _\n        .DependsOn(CustomGenerate)\n        .Executes(() =\u003E\n        {\n            var dotNetPublishSettings = new DotNetPublishSettings()\n                .SetWorkingDirectory(Paths.CustomDatabaseServer)\n                .SetOutput(Paths.ArtifactsCustomServer);\n            DotNetPublish(dotNetPublishSettings);\n        });\n\n    Target CustomWorkspaceSetup =\u003E _ =\u003E _\n        .DependsOn(CustomGenerate);\n    \n    Target CustomDatabaseTest =\u003E _ =\u003E _\n        .DependsOn(CustomDatabaseTestDomain);\n\n    Target CustomTest =\u003E _ =\u003E _\n        .After(Clean)\n        .DependsOn(CustomDatabaseTest);\n\n    Target Custom =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(CustomTest);\n}\n"
  },
  {
    "Id": 167223699,
    "FirstIndexed": "2020-04-25T15:50:44.735539+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632592+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843382+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939583+02:00",
    "Name": "lapi",
    "Owner": "ffquintella",
    "HtmlUrl": "https://github.com/ffquintella/lapi",
    "Description": "Ldap API",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ffquintella/lapi/blob/master/build/Build.cs",
    "BuildFileSize": 4721,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Docker;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\nusing static Nuke.Docker.DockerBuildSettings;\nusing static Nuke.Docker.DockerTasks;\nusing System.IO;\n\n\nclass Build : NukeBuild\n{\n    \n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PackDirectory =\u003E RootDirectory / \u0022artifacts/nupkg\u0022;\n    AbsolutePath AppDirectory =\u003E RootDirectory / \u0022artifacts/app\u0022;\n\n    AbsolutePath DockerFile =\u003E RootDirectory / \u0022Dockerfile\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n\n    string[] Authors = { \u0022Felipe F Quintella\u0022 };\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            Logger.Log(\u0022Restoring packages!\u0022);\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(AppDirectory);\n\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetOutputDirectory(AppDirectory)\n                .EnableNoRestore());\n        });\n\n    private Target Local_Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            Logger.Log(\u0022Publishing to artifacts...\u0022);\n            EnsureExistingDirectory(AppDirectory);\n            DotNetPublish(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetAuthors(Authors)\n                .SetVersion(GitVersion.GetNormalizedFileVersion())\n                .SetTitle(\u0022LAPI\u0022)\n                .SetOutput(AppDirectory)\n                .SetWorkingDirectory(RootDirectory)\n                .SetProject(Solution)\n            );\n          \n            CopyFile(RootDirectory \u002B \u0022/lapi/nLog.prod.config\u0022, AppDirectory \u002B \u0022/nlog.config\u0022, FileExistsPolicy.OverwriteIfNewer);\n\n            string fileName = AppDirectory \u002B \u0022/version.txt\u0022;\n            using (StreamWriter sw = new StreamWriter(fileName, false))\n            {\n                sw.WriteLine(GitVersion.GetNormalizedFileVersion());\n            }\n            \n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n\n            Logger.Log(\u0022Creating Nupackages...\u0022);\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                .EscapeStringPropertyForMsBuild();\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackDirectory)\n                .SetPackageReleaseNotes(changeLog));\n                \n        });\n\n    Target Create_Docker_Image =\u003E _ =\u003E _\n        .DependsOn(Local_Publish)\n        .Executes(() =\u003E\n        {\n            Logger.Log(\u0022Creating Docker Image...\u0022);\n\n            DockerBuild(s =\u003E s\n                .AddLabel(\u0022ldapi\u0022)\n                .SetTag(\u0022ffquintella/lapi:\u0022 \u002B GitVersion.GetNormalizedFileVersion())\n                .SetFile(DockerFile)\n                .SetForceRm(true)\n                .SetPath(RootDirectory)\n                );\n\n        });\n\n    private Target Deploy_Docker_Image =\u003E _ =\u003E _\n        .DependsOn(Create_Docker_Image)\n        .Executes(() =\u003E\n        {\n            DockerPush(s =\u003E s\n                .SetWorkingDirectory(RootDirectory)\n                .SetName(\u0022ffquintella/lapi:\u0022 \u002B GitVersion.GetNormalizedFileVersion())\n            );\n        });\n}\n"
  },
  {
    "Id": 167390816,
    "FirstIndexed": "2020-04-25T15:50:44.7355174+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631983+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433757+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939515+02:00",
    "Name": "LazyCoder",
    "Owner": "mifopen",
    "HtmlUrl": "https://github.com/mifopen/LazyCoder",
    "Description": "Writes Typescript for you",
    "Archived": false,
    "Stars": 8,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mifopen/LazyCoder/blob/master/build/Build.cs",
    "BuildFileSize": 6274,
    "BuildFileContent": "using System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\nclass Build: NukeBuild\r\n{\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration =\r\n        IsLocalBuild\r\n            ? Configuration.Debug\r\n            : Configuration.Release;\r\n\r\n    [Parameter(\u0022NuGet api key\u0022)] readonly string ApiKey;\r\n    readonly string LicenseFile = RootDirectory / \u0022LICENSE\u0022;\r\n\r\n    [Parameter(\u0022Local nuget source\u0022)] readonly string LocalNugetSource;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    Target Clean\r\n        =\u003E _ =\u003E _\r\n                .Before(Restore)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022)\r\n                                             .ToArray()\r\n                                             .ForEach(DeleteDirectory);\r\n                              TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022)\r\n                                            .ToArray()\r\n                                            .ForEach(DeleteDirectory);\r\n                              EnsureCleanDirectory(ArtifactsDirectory);\r\n                          });\r\n\r\n    Target Restore\r\n        =\u003E _ =\u003E _\r\n               .Executes(() =\u003E\r\n                         {\r\n                             DotNetRestore(s =\u003E s\r\n                                               .SetProjectFile(Solution));\r\n                         });\r\n\r\n    Target Compile\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Restore)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              DotNetBuild(s =\u003E s\r\n                                               .SetProjectFile(Solution)\r\n                                               .SetConfiguration(Configuration)\r\n                                               .SetAssemblyVersion(GitVersion\r\n                                                                       .GetNormalizedAssemblyVersion())\r\n                                               .SetFileVersion(GitVersion\r\n                                                                   .GetNormalizedFileVersion())\r\n                                               .SetInformationalVersion(GitVersion\r\n                                                                            .InformationalVersion)\r\n                                               .EnableNoRestore());\r\n                          });\r\n\r\n    Target Pack\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Clean, Compile)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              var licenseUrl =\r\n                                  GitRepository.GetGitHubBrowseUrl(LicenseFile, \u0022master\u0022);\r\n                              DotNetPack(s =\u003E s\r\n                                              //.SetPackageReleaseNotes(changelogUrl)\r\n                                              .SetWorkingDirectory(RootDirectory)\r\n                                              .SetPackageLicenseUrl(licenseUrl)\r\n                                              .SetProject(Solution.Path)\r\n                                              .SetRepositoryUrl(\u0022https://github.com/mifopen/LazyCoder\u0022)\r\n                                              .EnableNoBuild()\r\n                                              .SetConfiguration(Configuration)\r\n                                              .EnableIncludeSymbols()\r\n                                              .SetOutputDirectory(ArtifactsDirectory)\r\n                                              .SetDescription(\u0022Writes Typescript for you\u0022)\r\n                                              .SetAuthors(\u0022mif\u0022)\r\n                                              .SetPackageTags(\u0022typescript\u0022, \u0022generator\u0022)\r\n                                              .SetVersion(GitVersion.NuGetVersionV2));\r\n                          });\r\n\r\n    Target Publish\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Pack)\r\n                .Requires(() =\u003E ApiKey)\r\n                .Requires(() =\u003E Equals(Configuration, Configuration.Release))\r\n                .Executes(() =\u003E\r\n                          {\r\n                              GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022)\r\n                                  .NotEmpty()\r\n                                  .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\r\n                                  .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                                                                     .SetTargetPath(x)\r\n                                                                     .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                                                                     .SetApiKey(ApiKey)));\r\n                          });\r\n\r\n    Target PublishLocal\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Pack)\r\n                .Requires(() =\u003E LocalNugetSource)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              EnsureExistingDirectory(LocalNugetSource);\r\n                              GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022)\r\n                                  .NotEmpty()\r\n                                  .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\r\n                                  .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                                                                     .SetTargetPath(x)\r\n                                                                     .SetSource(LocalNugetSource)));\r\n                          });\r\n}\r\n"
  },
  {
    "Id": 167486350,
    "FirstIndexed": "2020-04-25T15:50:44.7354992+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163249+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433677+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939441+02:00",
    "Name": "Ubiety.Stringprep.Core",
    "Owner": "ubiety",
    "HtmlUrl": "https://github.com/ubiety/Ubiety.Stringprep.Core",
    "Description": "Stringprep library implementing RFC 3454",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ubiety/Ubiety.Stringprep.Core/blob/master/build/Build.cs",
    "BuildFileSize": 5414,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.CoverallsNet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.DotNetSonarScanner;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.DotNetSonarScanner.DotNetSonarScannerTasks;\nusing static Nuke.Common.Tools.CoverallsNet.CoverallsNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Complete);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string SonarKey;\n    [Parameter] readonly string NuGetKey;\n    [Parameter] readonly bool? Cover = true;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    readonly string MasterBranch = \u0022master\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target SonarBegin =\u003E _ =\u003E _\n        .Before(Compile)\n        .Requires(() =\u003E SonarKey)\n        .Unlisted()\n        .Executes(() =\u003E\n        {\n            DotNetSonarScannerBegin(s =\u003E s\n                .SetLogin(SonarKey)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetProjectKey(\u0022ubiety_Ubiety.Stringprep.Core\u0022)\n                .SetOrganization(\u0022ubiety\u0022)\n                .SetServer(\u0022https://sonarcloud.io\u0022)\n                .SetOpenCoverPaths(ArtifactsDirectory / \u0022coverage.opencover.xml\u0022));\n        });\n\n    Target SonarEnd =\u003E _ =\u003E _\n        .After(Test)\n        .Requires(() =\u003E SonarKey)\n        .Unlisted()\n        .Executes(() =\u003E\n        {\n            DotNetSonarScannerEnd(s =\u003E s\n                .SetLogin(SonarKey));\n        });\n\n    Target Sonar =\u003E _ =\u003E _\n        .DependsOn(SonarBegin, Test, SonarEnd);\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022Ubiety.Stringprep.Tests\u0022))\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetArgumentConfigurator(a =\u003E a.Add(\u0022/p:CollectCoverage={0}\u0022, Cover)\n                    .Add(\u0022/p:CoverletOutput={0}\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022opencover\u0022)\n                    .Add(\u0022/p:Exclude={0}\u0022, \u0022[xunit.*]*\u0022)));\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            CoverallsNet(s =\u003E s\n                .SetOpenCover(true)\n                .SetInput(ArtifactsDirectory / \u0022coverage.opencover.xml\u0022));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .After(SonarEnd)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E NuGetKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Requires(() =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch))\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                .SetApiKey(NuGetKey)\n                .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                .CombineWith(\n                    ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E cs.SetTargetPath(v)),\n                5,\n                true);\n        });\n\n    Target Complete =\u003E _ =\u003E _\n        .DependsOn(Clean, Sonar, Publish);\n}"
  },
  {
    "Id": 167504240,
    "FirstIndexed": "2020-04-25T15:50:44.7354969+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632461+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433666+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893943+02:00",
    "Name": "Ubiety.Scram.Core",
    "Owner": "ubiety",
    "HtmlUrl": "https://github.com/ubiety/Ubiety.Scram.Core",
    "Description": "Salted Challenge and Response Authentication Mechanism library for .NET Core",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ubiety/Ubiety.Scram.Core/blob/master/build/Build.cs",
    "BuildFileSize": 4975,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.DotNetSonarScanner;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.DotNetSonarScanner.DotNetSonarScannerTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly bool? Cover = true;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    [Parameter] readonly string NuGetKey;\n\n    readonly string NuGetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n\n    [Parameter] readonly string SonarKey;\n    readonly string SonarProjectKey = \u0022ubiety_Ubiety.Scram.Core\u0022;\n    [Unlisted] [ProjectFrom(nameof(Solution))] readonly Project UbietyScramTestProject;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target SonarBegin =\u003E _ =\u003E _\n        .Before(Compile)\n        .Requires(() =\u003E SonarKey)\n        .Unlisted()\n        .Executes(() =\u003E\n        {\n            DotNetSonarScannerBegin(s =\u003E s\n                .SetLogin(SonarKey)\n                .SetProjectKey(SonarProjectKey)\n                .SetOrganization(\u0022ubiety\u0022)\n                .SetServer(\u0022https://sonarcloud.io\u0022)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOpenCoverPaths(ArtifactsDirectory / \u0022coverage.opencover.xml\u0022));\n        });\n\n    Target SonarEnd =\u003E _ =\u003E _\n        .After(Test)\n        .DependsOn(SonarBegin)\n        .Requires(() =\u003E SonarKey)\n        .AssuredAfterFailure()\n        .Unlisted()\n        .Executes(() =\u003E\n        {\n            DotNetSonarScannerEnd(s =\u003E s\n                .SetLogin(SonarKey));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(UbietyScramTestProject)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetArgumentConfigurator(args =\u003E args.Add(\u0022/p:CollectCoverage={0}\u0022, Cover)\n                    .Add(\u0022/p:CoverletOutput={0}\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022opencover\u0022)\n                    .Add(\u0022/p:Exclude={0}\u0022, \u0022[xunit.*]*\u0022)));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .After(Test)\n        .OnlyWhenStatic(() =\u003E GitRepository.IsOnMasterBranch())\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E NuGetKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .OnlyWhenStatic(() =\u003E GitRepository.IsOnMasterBranch())\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetApiKey(NuGetKey)\n                    .SetSource(NuGetSource)\n                    .CombineWith(\n                        ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E\n                            cs.SetTargetPath(v)),\n                5,\n                true);\n        });\n\n    Target Appveyor =\u003E _ =\u003E _\n        .DependsOn(Test, SonarEnd, Publish);\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n}\n"
  },
  {
    "Id": 168365350,
    "FirstIndexed": "2020-04-25T15:50:44.7355316+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632575+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433791+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939549+02:00",
    "Name": "git-standup",
    "Owner": "lftkv",
    "HtmlUrl": "https://github.com/lftkv/git-standup",
    "Description": "A simple command-line utility to report commits of Git repositories for daily standups",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/lftkv/git-standup/blob/master/build/Build.cs",
    "BuildFileSize": 3046,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    Project GitStandupCliProject =\u003E Solution.GetProject(\u0022GitStandupCli\u0022).NotNull();\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenStatic(() =\u003E IsLocalBuild == false)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(GitStandupCliProject)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022GitStandupCli\u0022 \u002B GitVersion.GetNormalizedAssemblyVersion())\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 168463606,
    "FirstIndexed": "2020-04-25T15:47:03.6115174+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625048+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431231+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937109+02:00",
    "Name": "serilog-sinks-appcenter",
    "Owner": "RLittlesII",
    "HtmlUrl": "https://github.com/RLittlesII/serilog-sinks-appcenter",
    "Description": "A Serilog sink that writes events to App Center",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RLittlesII/serilog-sinks-appcenter/blob/master/.build/Build.cs",
    "BuildFileSize": 936,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;using static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : DotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _.DependsOn(DotNetCore);\n}\n"
  },
  {
    "Id": 168635224,
    "FirstIndexed": "2020-04-25T15:50:44.7354275+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162787+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843341+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939191+02:00",
    "Name": "UdpServer",
    "Owner": "Beffyman",
    "HtmlUrl": "https://github.com/Beffyman/UdpServer",
    "Description": "Experimenting with a UdpServer in .net core",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "build/BuildScripts.cs",
    "BuildFileUrl": "https://github.com/Beffyman/UdpServer/blob/master/build/BuildScripts.cs",
    "BuildFileSize": 5232,
    "BuildFileContent": "using System;\nusing System.Threading.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\npublic class BuildScripts : NukeBuild\n{\n\t/*\n\t/// Support plugins are available for:\n\t///   - JetBrains ReSharper        https://nuke.build/resharper\n\t///   - JetBrains Rider            https://nuke.build/rider\n\t///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n\t///   - Microsoft VSCode           https://nuke.build/vscode\n\t*/\n\n\tpublic static int Main() =\u003E Execute\u003CBuildScripts\u003E(x =\u003E x.Build);\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Solution] readonly Solution Solution;\n\t[GitRepository] readonly GitRepository GitRepository;\n\t[GitVersion] readonly GitVersion GitVersion;\n\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\tAbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\tAbsolutePath TestArtifactsDirectory =\u003E ArtifactsDirectory / \u0022tests\u0022;\n\tAbsolutePath NugetDirectory =\u003E ArtifactsDirectory / \u0022nuget\u0022;\n\tAbsolutePath CodeCoverageReportOutput =\u003E TestArtifactsDirectory / \u0022Reports\u0022;\n\tAbsolutePath CodeCoverageFile =\u003E TestArtifactsDirectory / \u0022coverage.cobertura.xml\u0022;\n\n\tAbsolutePath PerformanceProject =\u003E TestsDirectory / \u0022Beffyman.UdpServer.Performance\u0022;\n\tAbsolutePath DemoClientProject =\u003E TestsDirectory / \u0022Beffyman.UdpServer.Demo.Client\u0022;\n\tAbsolutePath DemoServerProject =\u003E TestsDirectory / \u0022Beffyman.UdpServer.Demo\u0022;\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Before(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tTestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tEnsureCleanDirectory(ArtifactsDirectory);\n\t\t});\n\n\tTarget Restore =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution));\n\t\t});\n\n\tTarget Build =\u003E _ =\u003E _\n\t\t.DependsOn(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetBuild(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t.AddProperty(\u0022TreatWarningsAsErrors\u0022, \u0022true\u0022)\n\t\t\t\t.EnableNoRestore());\n\t\t});\n\n\n\tTarget Pack =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(() =\u003E\n\t\t{\n\n\t\t\tDotNetPack(s =\u003E s.SetProject(Solution)\n\t\t\t\t\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t\t\t\t.EnableNoBuild()\n\t\t\t\t\t.EnableIncludeSource()\n\t\t\t\t\t.EnableIncludeSymbols()\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t\t.SetOutputDirectory(NugetDirectory));\n\t\t});\n\n\tTarget Test =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetTest(s =\u003E s.EnableNoBuild()\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.SetLogger(\u0022trx\u0022)\n\t\t\t\t.SetResultsDirectory(TestArtifactsDirectory)\n\t\t\t\t.SetLogOutput(true)\n\t\t\t\t.SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t.Add(\u0022/p:CoverletOutput={0}/\u0022, TestArtifactsDirectory)\n\t\t\t\t\t//.Add(\u0022/p:Threshold={0}\u0022, 90)\n\t\t\t\t\t.Add(\u0022/p:Exclude=\\\u0022[xunit*]*%2c[*.Tests]*\\\u0022\u0022)\n\t\t\t\t\t.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t.Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n\t\t\t\t.SetProjectFile(Solution));\n\n\t\t\tFileExists(CodeCoverageFile);\n\t\t});\n\n\tTarget PerfTest =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRun(s =\u003E s.SetConfiguration(Configuration.Release)\n\t\t\t\t.SetWorkingDirectory(PerformanceProject));\n\t\t});\n\n\tTarget Local_Benchmark =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(async () =\u003E\n\t\t{\n\n\t\t\tvar server = Task.Run(() =\u003E DotNetRun(s =\u003E s.SetConfiguration(Configuration.Release)\n\t\t\t\t.SetWorkingDirectory(DemoServerProject))).ConfigureAwait(false);\n\n\t\t\tawait Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false);\n\n\t\t\tvar client = Task.Run(() =\u003E DotNetRun(s =\u003E s.SetConfiguration(Configuration.Release)\n\t\t\t\t  .SetWorkingDirectory(DemoClientProject))).ConfigureAwait(false);\n\n\t\t\tawait client;\n\t\t\tawait server;\n\t\t});\n\n\n\tTarget Report =\u003E _ =\u003E _\n\t\t.DependsOn(Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tReportGenerator(s =\u003E s.SetReports(CodeCoverageFile)\n\t\t\t\t\t\t\t\t.SetTargetDirectory(CodeCoverageReportOutput)\n\t\t\t\t\t\t\t\t.SetTag(GitVersion.NuGetVersionV2)\n\t\t\t\t\t\t\t\t.SetReportTypes(ReportTypes.HtmlInline_AzurePipelines_Dark));\n\t\t});\n\n\n\tTarget CI =\u003E _ =\u003E _\n\t\t.DependsOn(Pack)\n\t\t.DependsOn(Report)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tNuke.Common.CI.AzurePipelines.AzurePipelines.Instance?.UpdateBuildNumber(GitVersion.NuGetVersionV2);\n\t\t});\n}\n"
  },
  {
    "Id": 168659314,
    "FirstIndexed": "2020-04-25T15:47:03.6115311+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625139+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431242+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893712+02:00",
    "Name": "Essentials",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Essentials",
    "Description": "Abstractions and wrappers around Xamarin.Essentials library",
    "Archived": false,
    "Stars": 1,
    "Watchers": 3,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Essentials/blob/master/.build/Build.cs",
    "BuildFileSize": 992,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Rocket.Surgery.Nuke.MsBuild;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : MsBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _.DependsOn(NetFramework);\n}\n"
  },
  {
    "Id": 168866255,
    "FirstIndexed": "2020-04-25T15:50:44.7355345+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630009+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433802+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939555+02:00",
    "Name": "DotNet.Project.LaunchSettings",
    "Owner": "andygjp",
    "HtmlUrl": "https://github.com/andygjp/DotNet.Project.LaunchSettings",
    "Description": "Parses Visual Studio launchSettings.json",
    "Archived": false,
    "Stars": 3,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/andygjp/DotNet.Project.LaunchSettings/blob/master/build/Build.cs",
    "BuildFileSize": 3652,
    "BuildFileContent": "#define WINDOWS\n\nusing System;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution(\u0022DotNet.Project.LaunchSettings.sln\u0022)] readonly Solution Solution;\n\n    readonly AbsolutePath OutputDirectory = RootDirectory / \u0022output\u0022;\n\n    readonly AbsolutePath TestResultsDirectory = RootDirectory / \u0022test_results\u0022;\n\n    readonly AbsolutePath PackageDirectory = RootDirectory / \u0022package\u0022;\n\n    readonly AbsolutePath NuspecFile = RootDirectory / \u0022DotNet.Project.LaunchSettings.nuspec\u0022;\n\n    readonly string Project = \u0022DotNet.Project.LaunchSettings\u0022;\n\n#if WINDOWS\n    [GitVersion] readonly GitVersion GitVersion;\n#endif\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n            EnsureCleanDirectory(TestResultsDirectory);\n            EnsureCleanDirectory(PackageDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n#if WINDOWS\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n#endif\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger($\u0022xunit;LogFilePath={TestResultsDirectory}\\\\results.xml\u0022)\n                .EnableNoBuild());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Project)\n                .SetConfiguration(Configuration)\n                .SetOutput(OutputDirectory)\n                .EnableNoBuild());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Project)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackageDirectory)\n                .SetProperty(\u0022NuspecFile\u0022, NuspecFile.ToString())\n#if WINDOWS\n                .SetProperty(\u0022NuspecProperties\u0022, $\u0022Version={GitVersion.NuGetVersionV2}\u0022)\n#endif\n                .EnableNoBuild());\n        });\n}\n"
  },
  {
    "Id": 169285451,
    "FirstIndexed": "2020-04-25T15:50:44.7355294+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631716+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843378+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939538+02:00",
    "Name": "sess",
    "Owner": "ffquintella",
    "HtmlUrl": "https://github.com/ffquintella/sess",
    "Description": "Multi purpose session management API with redis back end",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ffquintella/sess/blob/master/build/Build.cs",
    "BuildFileSize": 4423,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Docker;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Docker.DockerBuildSettings;\nusing static Nuke.Docker.DockerTasks;\nusing System.IO;\n\n//[CheckBuildProjectConfigurations]\nclass Build : NukeBuild\n{\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    //readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    readonly Configuration Configuration = Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath AppDirectory =\u003E RootDirectory / \u0022artifacts/app\u0022;\n    AbsolutePath DockerFile =\u003E RootDirectory / \u0022Dockerfile\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    \n    string[] Authors = { \u0022Felipe F Quintella\u0022 };\n\n    string Title = \u0022SESS\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(TestsDirectory);\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            //TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Restoring Packages\u0022);\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(AppDirectory);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetOutputDirectory(AppDirectory)\n                .EnableNoRestore());\n        });\n    private Target Local_Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Publishing to artifacts...\u0022);\n            EnsureExistingDirectory(AppDirectory);\n            DotNetPublish(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetAuthors(Authors)\n                .SetVersion(GitVersion.GetNormalizedFileVersion())\n                .SetTitle(Title)\n                .SetOutput(AppDirectory)\n                .SetWorkingDirectory(RootDirectory)\n                .SetProject(Solution)\n            );\n          \n            //CopyFile(RootDirectory \u002B \u0022/sess/nLog.prod.config\u0022, AppDirectory \u002B \u0022/nlog.config\u0022, FileExistsPolicy.OverwriteIfNewer);\n\n            string fileName = AppDirectory \u002B \u0022/version.txt\u0022;\n            using (StreamWriter sw = new StreamWriter(fileName, false))\n            {\n                sw.WriteLine(GitVersion.GetNormalizedFileVersion());\n            }\n            \n        });\n    Target Create_Docker_Image =\u003E _ =\u003E _\n        .DependsOn(Local_Publish)\n        .Executes(() =\u003E\n        {\n            //Logger.Info(\u0022Creating Docker Image...\u0022);\n\n            DockerBuild(s =\u003E s\n                .AddLabel(Title)\n                .SetTag(\u0022ffquintella/sess:\u0022 \u002B GitVersion.GetNormalizedFileVersion())\n                .SetFile(DockerFile)\n                .SetForceRm(true)\n                .SetPath(RootDirectory)\n            );\n\n        });\n\n   Target Deploy_Docker_Image =\u003E _ =\u003E _\n    .DependsOn(Create_Docker_Image)\n    .Executes(() =\u003E\n    {\n        DockerPush(s =\u003E s\n            .SetWorkingDirectory(RootDirectory)\n            .SetName(\u0022ffquintella/sess:\u0022 \u002B GitVersion.GetNormalizedFileVersion())\n        );\n    });\n}\n"
  },
  {
    "Id": 169615819,
    "FirstIndexed": "2020-04-25T15:50:44.7355203+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630817+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433768+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939527+02:00",
    "Name": "YandexCloudDotNet",
    "Owner": "mifopen",
    "HtmlUrl": "https://github.com/mifopen/YandexCloudDotNet",
    "Description": "Yandex Cloud Api .NET client",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mifopen/YandexCloudDotNet/blob/master/build/Build.cs",
    "BuildFileSize": 6635,
    "BuildFileContent": "using System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.Git.GitTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\nclass Build: NukeBuild\r\n{\r\n    public static int Main()\r\n    {\r\n        return Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n    }\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Parameter(\u0022NuGet api key\u0022)] readonly string ApiKey;\r\n    readonly string LicenseFile = RootDirectory / \u0022LICENSE\u0022;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    Target Clean\r\n        =\u003E _ =\u003E _\r\n                .Before(Restore)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022)\r\n                                             .ToArray()\r\n                                             .ForEach(DeleteDirectory);\r\n                              TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022)\r\n                                            .ToArray()\r\n                                            .ForEach(DeleteDirectory);\r\n                              EnsureCleanDirectory(ArtifactsDirectory);\r\n                          });\r\n\r\n    Target Restore\r\n        =\u003E _ =\u003E _\r\n               .Executes(() =\u003E\r\n                         {\r\n                             DotNetRestore(s =\u003E s\r\n                                               .SetProjectFile(Solution));\r\n                         });\r\n\r\n    Target Compile\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Restore)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              DotNetBuild(s =\u003E s\r\n                                               .SetProjectFile(Solution)\r\n                                               .SetConfiguration(Configuration)\r\n                                               .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                                               .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                                               .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                                               .EnableNoRestore());\r\n                          });\r\n\r\n    Target Pack\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Clean, Compile)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              var licenseUrl = GitRepository.GetGitHubBrowseUrl(LicenseFile, \u0022master\u0022);\r\n                              DotNetPack(s =\u003E s\r\n                                              //                                            .SetPackageReleaseNotes(changelogUrl)\r\n                                              .SetWorkingDirectory(RootDirectory)\r\n                                              .SetPackageLicenseUrl(licenseUrl)\r\n                                              .SetProject(Solution.Path)\r\n                                              .EnableNoBuild()\r\n                                              .SetConfiguration(Configuration)\r\n                                              .EnableIncludeSymbols()\r\n                                              .SetOutputDirectory(ArtifactsDirectory)\r\n                                              .SetDescription(\u0022.NET http client for Yandex Cloud Api\u0022)\r\n                                              .SetVersion(GitVersion.NuGetVersionV2));\r\n                          });\r\n\r\n    Target Publish\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Pack)\r\n                .Requires(() =\u003E ApiKey)\r\n                .Requires(() =\u003E Equals(Configuration, Configuration.Release))\r\n                .Executes(() =\u003E\r\n                          {\r\n                              GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022)\r\n                                  .NotEmpty()\r\n                                  .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\r\n                                  .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                                                                     .SetTargetPath(x)\r\n                                                                     .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                                                                     .SetApiKey(ApiKey)));\r\n                          });\r\n\r\n    Target PublishLocal\r\n        =\u003E _ =\u003E _\r\n                .DependsOn(Pack)\r\n                .Executes(() =\u003E\r\n                          {\r\n                              GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022)\r\n                                  .NotEmpty()\r\n                                  .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\r\n                                  .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                                                                     .SetTargetPath(x)\r\n                                                                     .SetSource(\u0022/Users/mif/Documents/GitHub/localnuget\u0022)));\r\n                          });\r\n\r\n    Target GenerateProto\r\n        =\u003E _ =\u003E _\r\n               .Executes(() =\u003E\r\n                         {\r\n                             var dir = BuildProjectDirectory / \u0022ProtoGenerator\u0022;\r\n                             var sourceDirectory = SourceDirectory / \u0022YandexCloudDotNet\u0022 / \u0022cloudapi\u0022;\r\n                             DeleteDirectory(dir / \u0022cloudapi\u0022);\r\n                             DeleteDirectory(dir / \u0022Generated\u0022);\r\n                             DeleteDirectory(sourceDirectory);\r\n\r\n                             Git(\u0022clone https://github.com/yandex-cloud/cloudapi.git\u0022, dir);\r\n                             DotNetBuild(x =\u003E x.SetWorkingDirectory(dir));\r\n                             CopyDirectoryRecursively(dir / \u0022Generated\u0022 / \u0022cloudapi\u0022,\r\n                                                      sourceDirectory);\r\n\r\n                             DeleteDirectory(dir / \u0022cloudapi\u0022);\r\n                             DeleteDirectory(dir / \u0022Generated\u0022);\r\n                         });\r\n}\r\n"
  },
  {
    "Id": 169719064,
    "FirstIndexed": "2020-04-25T15:47:03.6108052+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627858+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431248+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937132+02:00",
    "Name": "StructLinq",
    "Owner": "reegeek",
    "HtmlUrl": "https://github.com/reegeek/StructLinq",
    "Description": "Implementation in C# of LINQ concept with struct",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "Build/Nuke/Build.cs",
    "BuildFileUrl": "https://github.com/reegeek/StructLinq/blob/master/Build/Nuke/Build.cs",
    "BuildFileSize": 8038,
    "BuildFileContent": "using System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\n    \u0022continuous\u0022,\n    GitHubActionsImage.WindowsLatest,\n    On = new[] { GitHubActionsTrigger.Push },\n    ImportGitHubTokenAs = nameof(GitHubToken),\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) })]\n[GitHubActions(\n    \u0022continuousCore\u0022,\n    GitHubActionsImage.UbuntuLatest,\n    GitHubActionsImage.MacOsLatest,\n    On = new[] { GitHubActionsTrigger.Push },\n    ImportGitHubTokenAs = nameof(GitHubToken),\n    InvokedTargets = new[] { nameof(TestCoreOnly) })]\n[AppVeyor(\n    AppVeyorImage.VisualStudio2019,\n    SkipTags = true,\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) })]\n[AzurePipelines(\n    suffix: null,\n    AzurePipelinesImage.WindowsLatest,\n    AzurePipelinesImage.UbuntuLatest,\n    AzurePipelinesImage.MacOsLatest,\n    InvokedTargets = new[] { nameof(Test), nameof(TestCoreOnly), nameof(Pack), nameof(PackCoreOnly) },\n    NonEntryTargets = new[] { nameof(Restore) },\n    ExcludedTargets = new[] { nameof(Clean)})]\n\npartial class Build : Nuke.Common.NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [CI] readonly AzurePipelines AzurePipelines;\n    [Parameter(\u0022GitHub Token\u0022)] readonly string GitHubToken;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ResultDirectory =\u003E RootDirectory / \u0022.result\u0022;\n    AbsolutePath PackagesDirectory =\u003E ResultDirectory / \u0022packages\u0022;\n    AbsolutePath TestResultDirectory =\u003E ResultDirectory / \u0022test-results\u0022;\n    IEnumerable\u003CProject\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n    IEnumerable\u003CProject\u003E AllProjects =\u003E Solution.AllProjects.Where(x=\u003E SourceDirectory.Contains(x.Path));\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ResultDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E ExecutesCompile(false));\n    void ExecutesCompile(bool excludeNetFramework)\n    {\n        Logger.Info(excludeNetFramework ? \u0022Exclude net framework\u0022 : \u0022Include net framework\u0022);\n        if (excludeNetFramework)\n        {\n            var frameworks =\n                from project in AllProjects\n                from framework in project.GetTargetFrameworks(true)\n                select new {project, framework};\n\n\n            DotNetBuild(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .CombineWith(frameworks, (s, f) =\u003E s\n                    .SetFramework(f.framework)\n                    .SetProjectFile(f.project)));\n        }\n        else\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        }\n    }\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Executes(() =\u003E ExecutesTest(false));\n    void ExecutesTest(bool excludeNetFramework)\n    {\n        Logger.Info(excludeNetFramework ? \u0022Exclude net framework\u0022 : \u0022Include net framework\u0022);\n\n        var testConfigurations =\n            from project in TestProjects\n            from framework in project.GetTargetFrameworks(excludeNetFramework)\n            select new {project, framework};\n\n        DotNetTest(_ =\u003E\n            {\n                return _\n                    .SetConfiguration(Configuration)\n                    .SetNoRestore(InvokedTargets.Contains(Restore))\n                    .SetNoBuild(InvokedTargets.Contains(Compile))\n                    .ResetVerbosity()\n                    .SetResultsDirectory(TestResultDirectory)\n                    .CombineWith(testConfigurations, (_, v) =\u003E _\n                        .SetProjectFile(v.project)\n                        .SetFramework(v.framework)\n                        .SetLogger($\u0022trx;LogFileName={v.project.Name}.trx\u0022));\n            });\n\n        TestResultDirectory.GlobFiles(\u0022*.trx\u0022).ForEach(x =\u003E\n            AzurePipelines?.PublishTestResults(\n                type: AzurePipelinesTestResultsType.VSTest,\n                title: $\u0022{Path.GetFileNameWithoutExtension(x)} ({AzurePipelines.StageDisplayName})\u0022,\n                files: new string[] {x}));\n    }\n\n    Target CompileCoreOnly =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            var excludeNetFramework = AllProjects.SelectMany(x =\u003E x.GetTargetFrameworks()).Distinct()\n                .Any(x =\u003E !x.Contains(\u0022standard\u0022) || !x.Contains(\u0022core\u0022));\n            ExecutesCompile(excludeNetFramework);\n        });\n\n    Target TestCoreOnly =\u003E _ =\u003E _\n        .DependsOn(CompileCoreOnly)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Executes(() =\u003E\n        {\n            var excludeNetFramework = AllProjects.SelectMany(x =\u003E x.GetTargetFrameworks()).Distinct()\n                .Any(x =\u003E !x.Contains(\u0022standard\u0022) || !x.Contains(\u0022core\u0022));\n            ExecutesTest(excludeNetFramework);\n        });\n\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n        .Executes(ExecutesPack);\n\n    Target PackCoreOnly =\u003E _ =\u003E _\n        .DependsOn(CompileCoreOnly)\n        .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n        .Executes(ExecutesPack);\n\n\n    void ExecutesPack() =\u003E\n        DotNetPack(_ =\u003E\n        {\n            var repositoryUrl = $\u0022https://{GitRepository.Endpoint}/{GitRepository.Identifier}/\u0022;\n\n            return _    \n                .SetProject(Solution)\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackagesDirectory)\n                .DisablePackageRequireLicenseAcceptance()\n                .SetRepositoryType(\u0022git\u0022)\n                .SetRepositoryUrl(repositoryUrl)\n                .SetProperty(\u0022RepositoryCommit\u0022, GitVersion.Sha)\n                .SetPackageReleaseNotes($\u0022{repositoryUrl}releases/v{GitVersion.MajorMinorPatch}\u0022)\n                .SetAuthors(\u0022Reegeek\u0022)\n                .SetProperty(\u0022Owners\u0022, \u0022Reegeek\u0022)\n                .SetPackageProjectUrl(repositoryUrl)\n                .SetVersion(GitVersion.NuGetVersionV2);\n        });\n}"
  },
  {
    "Id": 169894281,
    "FirstIndexed": "2020-04-25T15:50:44.735163+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629776+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433325+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939094+02:00",
    "Name": "SpaTemplate",
    "Owner": "Xeinaemm",
    "HtmlUrl": "https://github.com/Xeinaemm/SpaTemplate",
    "Description": "Monolithic template of ASP.NET Core with Angular, CleanArchitecture",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Xeinaemm/SpaTemplate/blob/master/build/Build.cs",
    "BuildFileSize": 8309,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.WebDeploy;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.CI;\nusing System.Collections.Generic;\nusing Nuke.Common.Tools.Coverlet;\nusing System.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.Tools.InspectCode.InspectCodeTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.InspectCode;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelines(\n    AzurePipelinesImage.WindowsLatest,\n    InvokedTargets = new[] { nameof(Test), nameof(Pack) },\n    NonEntryTargets = new[] { nameof(Restore) },\n    ExcludedTargets = new[] { nameof(Clean), nameof(Coverage) })]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Run);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string ProjectName = \u0022Allegro.Api\u0022;\n    [Parameter] readonly string WebDeployUsername;\n    [Parameter] readonly string WebDeployPassword;\n    [Parameter] readonly string WebDeployPublishUrl;\n    [Parameter] readonly string WebDeploySiteName;\n    [Parameter] bool IgnoreFailedSources;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n    [CI] readonly AzurePipelines AzurePipelines;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PackagesDirectory =\u003E ArtifactsDirectory / \u0022packages\u0022;\n    AbsolutePath TestResultsDirectory =\u003E ArtifactsDirectory / \u0022test-results\u0022;\n    AbsolutePath CoverageReportDirectory =\u003E ArtifactsDirectory / \u0022coverage-report\u0022;\n    AbsolutePath CoverageReportZipDirectory =\u003E ArtifactsDirectory / \u0022coverage-report.zip\u0022;\n    AbsolutePath PublishDirectory =\u003E ArtifactsDirectory / \u0022publish\u0022;\n    AbsolutePath PublishProjectDirectory =\u003E PublishDirectory / ProjectName;\n    AbsolutePath InspectCodeDirectory =\u003E ArtifactsDirectory / \u0022inspectCode.xml\u0022;\n\n    [Partition(2)] readonly Partition TestPartition;\n    IEnumerable\u003CProject\u003E TestProjects =\u003E TestPartition.GetCurrent(Solution.GetProjects(\u0022*.Tests\u0022));\n\n    Target Run =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E DotNetRun(_ =\u003E _.SetProjectFile(SourceDirectory / ProjectName / $\u0022{ProjectName}.csproj\u0022)));\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetIgnoreFailedSources(IgnoreFailedSources));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n    .Executes(() =\u003E\n    {\n        DotNetPack(_ =\u003E _\n            .SetProject(Solution)\n            .SetNoBuild(InvokedTargets.Contains(Compile))\n            .SetConfiguration(Configuration)\n            .SetOutputDirectory(PackagesDirectory)\n            .SetVersion(GitVersion.NuGetVersionV2));\n    });\n\n    Target Test =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .Produces(TestResultsDirectory / \u0022*.trx\u0022)\n    .Produces(TestResultsDirectory / \u0022*.xml\u0022)\n    .Partition(() =\u003E TestPartition)\n    .Executes(() =\u003E\n    {\n        DotNetTest(_ =\u003E _\n            .SetConfiguration(Configuration)\n            .SetNoBuild(InvokedTargets.Contains(Compile))\n            .ResetVerbosity()\n            .SetResultsDirectory(TestResultsDirectory)\n            .When(InvokedTargets.Contains(Coverage) || IsServerBuild, _ =\u003E _\n                .EnableCollectCoverage()\n                .SetCoverletOutputFormat(CoverletOutputFormat.cobertura)\n                .SetExcludeByFile(\u0022*.Generated.cs\u0022)\n                .When(IsServerBuild, _ =\u003E _\n                    .EnableUseSourceLink()))\n            .CombineWith(TestProjects, (_, v) =\u003E _\n                .SetProjectFile(v)\n                .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\n                .When(InvokedTargets.Contains(Coverage) || IsServerBuild, _ =\u003E _\n                    .SetCoverletOutput(TestResultsDirectory / $\u0022{v.Name}.xml\u0022))));\n\n        TestResultsDirectory.GlobFiles(\u0022*.trx\u0022).ForEach(x =\u003E\n            AzurePipelines?.PublishTestResults(\n                type: AzurePipelinesTestResultsType.VSTest,\n                title: $\u0022{Path.GetFileNameWithoutExtension(x)} ({AzurePipelines.StageDisplayName})\u0022,\n                files: new string[] { x }));\n    });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Consumes(Test)\n        .Produces(CoverageReportZipDirectory)\n        .Executes(() =\u003E\n        {\n            ReportGenerator(_ =\u003E _\n                .SetReports(TestResultsDirectory / \u0022*.xml\u0022)\n                .SetReportTypes(ReportTypes.HtmlInline)\n                .SetTargetDirectory(CoverageReportDirectory)\n                .SetFramework(\u0022netcoreapp3.0\u0022));\n\n            TestResultsDirectory.GlobFiles(\u0022*.xml\u0022).ForEach(x =\u003E\n                AzurePipelines?.PublishCodeCoverage(\n                    AzurePipelinesCodeCoverageToolType.Cobertura,\n                    x,\n                    CoverageReportDirectory));\n\n            CompressZip(\n                directory: CoverageReportDirectory,\n                archiveFile: CoverageReportZipDirectory,\n                fileMode: FileMode.Create);\n        });\n\n    Target Analysis =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            InspectCode(_ =\u003E _\n                .SetTargetPath(Solution)\n                .SetOutput(InspectCodeDirectory)\n                .AddPlugin(\u0022EtherealCode.ReSpeller\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022PowerToys.CyclomaticComplexity\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022ReSharper.ImplicitNullability\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022ReSharper.SerializationInspections\u0022, InspectCodePluginLatest)\n                .AddPlugin(\u0022ReSharper.XmlDocInspections\u0022, InspectCodePluginLatest));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Requires(() =\u003E Configuration)\n        .Requires(() =\u003E ProjectName)\n        .Executes(() =\u003E DotNetPublish(p =\u003E p.SetWorkingDirectory(SourceDirectory / ProjectName)\n            .SetConfiguration(Configuration)\n            .SetOutput(PublishProjectDirectory)));\n\n    Target Deploy =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Requires(() =\u003E WebDeployUsername)\n        .Requires(() =\u003E WebDeployPassword)\n        .Requires(() =\u003E WebDeployPublishUrl)\n        .Requires(() =\u003E WebDeploySiteName)\n        .Executes(() =\u003E\n        {\n            WebDeployTasks.WebDeploy(s =\u003E\n            {\n                return s.SetSourcePath(PublishProjectDirectory)\n                        .SetUsername(WebDeployUsername)\n                        .SetPassword(WebDeployPassword)\n                        .SetEnableAppOfflineRule(true)\n                        .SetPublishUrl(WebDeployPublishUrl)\n                        .SetSiteName(WebDeploySiteName);\n            });\n        });\n}\n"
  },
  {
    "Id": 170298042,
    "FirstIndexed": "2020-04-25T15:50:44.7354457+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631432+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433444+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939219+02:00",
    "Name": "smartive-core",
    "Owner": "smartive",
    "HtmlUrl": "https://github.com/smartive/smartive-core",
    "Description": ".net core library for your everyday work. contains helpers, additions and useful extensions",
    "Archived": false,
    "Stars": 1,
    "Watchers": 6,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/smartive/smartive-core/blob/master/build/Build.cs",
    "BuildFileSize": 4314,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI.GitLab;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\npublic class Build : NukeBuild\n{\n    const string NugetSource = \u0022https://www.nuget.org/api/v2/package\u0022;\n\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Version that is built. Needed for packaging. (format: x.x.x)\u0022)]\n    readonly string Version = GitLab.Instance?.CommitTag?.Substring(1);\n\n    readonly string NugetKey = Environment.GetEnvironmentVariable(\u0022NUGET_KEY\u0022);\n\n    [Solution] readonly Solution Solution;\n\n    IEnumerable\u003CProject\u003E SourceProjects =\u003E Solution.AllProjects.Where(p =\u003E p.SolutionFolder?.Name == \u0022src\u0022);\n    IEnumerable\u003CProject\u003E TestProjects =\u003E Solution.AllProjects.Where(p =\u003E p.SolutionFolder?.Name == \u0022test\u0022);\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022test\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath CoverageDirectory =\u003E RootDirectory / \u0022coverage\u0022;\n    AbsolutePath ToolsDirectory =\u003E RootDirectory / \u0022tools\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n            EnsureCleanDirectory(CoverageDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Cleanup coverage directory.\u0022);\n            EnsureCleanDirectory(CoverageDirectory);\n        })\n        .Executes(() =\u003E DotNetTest(s =\u003E s\n            .SetConfiguration(Configuration)\n            .EnableNoBuild()\n            .CombineWith(TestProjects, (ss, p) =\u003E ss\n                .SetProjectFile(p))));\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean, Compile)\n        .Requires(() =\u003E Version != default)\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022Pack the projects for version {Version}\u0022);\n            DotNetPack(s =\u003E s\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(Version)\n                .SetFileVersion(Version)\n                .SetAssemblyVersion(Version)\n                .CombineWith(SourceProjects, (ss, project) =\u003E ss\n                    .SetProject(project)), Environment.ProcessorCount);\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E NugetKey != default)\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Publish Packages\u0022);\n            DotNetNuGetPush(s =\u003E s\n                    .SetApiKey(NugetKey)\n                    .SetSource(NugetSource)\n                    .CombineWith(ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022), (ss, file) =\u003E ss.SetTargetPath(file)),\n                Environment.ProcessorCount);\n        });\n}\n"
  },
  {
    "Id": 170360617,
    "FirstIndexed": "2020-04-25T15:47:03.6110208+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629531+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843126+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937137+02:00",
    "Name": "ProvisionData.ResourceHelpr",
    "Owner": "provisiondata",
    "HtmlUrl": "https://github.com/provisiondata/ProvisionData.ResourceHelpr",
    "Description": "Read Strings and Streams from local Assemblies",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/provisiondata/ProvisionData.ResourceHelpr/blob/master/build/Build.cs",
    "BuildFileSize": 6163,
    "BuildFileContent": "namespace ProvisionData.Build\n{\n    using System;\n    using System.Linq;\n    using Nuke.Common;\n    using Nuke.Common.Execution;\n    using Nuke.Common.Git;\n    using Nuke.Common.IO;\n    using Nuke.Common.ProjectModel;\n    using Nuke.Common.Tooling;\n    using Nuke.Common.Tools.DotNet;\n    using Nuke.Common.Tools.GitVersion;\n    using Nuke.Common.Utilities.Collections;\n    using static Nuke.Common.IO.FileSystemTasks;\n    using static Nuke.Common.IO.PathConstruction;\n    using static Nuke.Common.Tools.DotNet.DotNetTasks;\n    using static Nuke.GitHub.ChangeLogExtensions;\n\n    [CheckBuildProjectConfigurations]\n    [UnsetVisualStudioEnvironmentVariables]\n    class Build : NukeBuild\n    {\n        // Support plug-ins are available for:\n        //   - JetBrains ReSharper        https://nuke.build/resharper\n        //   - JetBrains Rider            https://nuke.build/rider\n        //   - Microsoft VisualStudio     https://nuke.build/visualstudio\n        //   - Microsoft VSCode           https://nuke.build/vscode\n\n        public static Int32 Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        readonly Configuration Configuration = Configuration.Release;\n\n        [Parameter(\u0022Explicit framework to build\u0022)] readonly String Framework;\n        [Parameter(\u0022NuGet API Key\u0022)] readonly String NuGetApiKey;\n        [Parameter(\u0022PDSI API Key\u0022)] readonly String PdsiApiKey;\n\n        [Solution] readonly Solution Solution;\n        [GitRepository] readonly GitRepository GitRepository;\n        [GitVersion] readonly GitVersion GitVersion;\n\n        AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n        AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n        AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n        String ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n        Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(ArtifactsDirectory);\n            });\n\n        Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(_ =\u003E _\n                    .SetProjectFile(Solution));\n            });\n\n        Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(_ =\u003E _\n                    .SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore());\n            });\n\n        Target Publish =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                var publishCombinations = from project in Solution.Projects\n                                          from framework in project.GetTargetFrameworks()\n                                          select new { project, framework };\n\n                DotNetPublish(_ =\u003E _\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration)\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                    .CombineWith(publishCombinations, (oo, v) =\u003E oo\n                        .SetProject(v.project)\n                        .SetFramework(v.framework)\n                        )\n                    );\n            });\n\n        Target Test =\u003E _ =\u003E _\n                   .DependsOn(Publish)\n                   .Executes(() =\u003E\n                   {\n                       DotNetTest(s =\u003E s\n                           .SetConfiguration(Configuration)\n                           .EnableNoBuild()\n                           .EnableNoRestore()\n                           .SetLogger(\u0022trx\u0022)\n                           .SetLogOutput(true)\n                           .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022))\n                           .SetResultsDirectory(TestsDirectory / \u0022results\u0022));\n                   });\n\n        Target Pack =\u003E _ =\u003E _\n            .DependsOn(Test)\n            .Executes(() =\u003E\n            {\n                var changeLog = GetCompleteChangeLog(ChangeLogFile)\n                                    .EscapeStringPropertyForMsBuild();\n\n               DotNetPack(s =\u003E s\n                    .SetConfiguration(Configuration)\n                    .EnableIncludeSymbols()\n                    .EnableNoBuild()\n                    .EnableNoRestore()\n                    .SetProperty(\u0022PackageVersion\u0022, GitVersion.NuGetVersionV2)\n                    .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022)\n                    .SetPackageReleaseNotes(changeLog));\n           });\n\n        Target PushToNuGet =\u003E _ =\u003E _\n            .DependsOn(Pack)\n            .Requires(() =\u003E NuGetApiKey)\n            .Requires(() =\u003E Equals(Configuration, Configuration.Release))\n            .Executes(() =\u003E\n            {\n                GlobFiles(ArtifactsDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\n                    .NotEmpty()\n                    .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                        .SetApiKey(NuGetApiKey))\n                    );\n         });\n\n        Target PushToPdsi =\u003E _ =\u003E _\n            .DependsOn(Pack)\n            .Requires(() =\u003E PdsiApiKey)\n            .Requires(() =\u003E Equals(Configuration, Configuration.Release))\n            .Executes(() =\u003E\n            {\n                GlobFiles(ArtifactsDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\n                    .NotEmpty()\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(\u0022https://baget.pdsint.net/v3/index.json\u0022)\n                        .SetApiKey(PdsiApiKey)));\n         });\n    }\n}\n"
  },
  {
    "Id": 170647563,
    "FirstIndexed": "2020-04-25T15:50:44.7355151+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632535+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433746+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939504+02:00",
    "Name": "Azure.Offline.Sync",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Azure.Offline.Sync",
    "Description": "Abstractions for offline sync with Azure Mobile Sync Framework",
    "Archived": false,
    "Stars": 0,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Azure.Offline.Sync/blob/master/build/Build.cs",
    "BuildFileSize": 6072,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\npartial class Build : NukeBuild\n{\n    /// \u003Csummary\u003E\n    /// The main entry point for the build program.\n    /// \u003C/summary\u003E\n    /// \u003Creturns\u003E\u003C/returns\u003E\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.AzureDevOps);\n\n    BuildParameters Parameters { get; set; }\n\n    /// \u003Cinheritdoc /\u003E\n    protected override void OnBuildInitialized()\n    {\n        Parameters = new BuildParameters(this);\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [Solution(\u0022benchmarks/Benchmarks.sln\u0022)] readonly Solution BenchmarkSolution;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022test\u0022;\n    AbsolutePath BenchmarkDirectory =\u003E RootDirectory / \u0022benchmarks\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PackageDirectory =\u003E ArtifactsDirectory / \u0022packages\u0022;\n    AbsolutePath BenchmarkResultsDirectory =\u003E ArtifactsDirectory / \u0022benchmarks\u0022;\n    AbsolutePath TestResultsDirectory =\u003E ArtifactsDirectory / \u0022TestResults\u0022;\n    AbsolutePath TestResultFilePath =\u003E TestResultsDirectory / $\u0022{Parameters.Title}.trx\u0022;\n\n    Target BuildVersion =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Information(\u0022Building version {0} of Rocket.Surgery.Azure.Sync ({1}) using version {2} of Nuke.\u0022,\n                GitVersion.NuGetVersionV2 ?? GitVersion.NuGetVersion,\n                Configuration,\n                typeof(NukeBuild).Assembly.GetName().Version.ToString());\n        });\n\n    Target ShowInfo =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Information(\u0022Configuration: {0}\u0022, Configuration);\n\n            Information(\u0022RepositoryName: {0}\u0022, Parameters.RepositoryName);\n            Information(\u0022IsMainRepo: {0}\u0022, Parameters.IsMainRepo);\n            Information(\u0022IsMasterBranch: {0}\u0022, Parameters.IsMasterBranch);\n            Information(\u0022IsDevelopmentBranch: {0}\u0022, Parameters.IsDevelopmentBranch);\n            Information(\u0022IsReleaseBranch: {0}\u0022, Parameters.IsReleaseBranch);\n            Information(\u0022IsPullRequest: {0}\u0022, Parameters.IsPullRequest);\n\n            Information(\u0022IsLocalBuild: {0}\u0022, Parameters.IsLocalBuild);\n            Information(\u0022IsRunningOnUnix: {0}\u0022, Parameters.IsRunningOnUnix);\n            Information(\u0022IsRunningOnWindows: {0}\u0022, Parameters.IsRunningOnWindows);\n            Information(\u0022IsRunningOnAzureDevOps: {0}\u0022, Parameters.IsRunningOnAzureDevOps);\n\n            Information(\u0022IsReleasable: {0}\u0022, Parameters.IsReleasable);\n            Information(\u0022ShouldPublishMyGet: {0}\u0022, Parameters.ShouldPublishMyGet);\n            Information(\u0022ShouldPublishNuGet: {0}\u0022, Parameters.ShouldPublishNuGet);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(ShowInfo)\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(restore =\u003E restore.SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(build =\u003E\n                build\n                    .SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                    .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                    .EnableNoRestore());\n        });\n\n    Target UnitTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(TestResultsDirectory);\n\n            foreach (var project in Solution.AllProjects.Where(x =\u003E x.Name.Contains(\u0022Tests\u0022)))\n            {\n                Information(\u0022Test: {0}\u0022, project.Name);\n                DotNetTest(test =\u003E\n                    test\n                        .SetProjectFile(project)\n                        .SetConfiguration(Configuration)\n                        .SetResultsDirectory(TestResultsDirectory)\n                        .SetLogger($\u0022trx;LogFileName={Parameters.Title}.trx\u0022)\n                        .EnableNoBuild()\n                        .EnableNoRestore());\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Benchmarks)\n        .Executes(() =\u003E\n        {\n            DotNetPack(pack =\u003E pack.SetOutputDirectory(PackageDirectory));\n        });\n\n    Target PublishToMyGet =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .OnlyWhenDynamic(() =\u003E Parameters.ShouldPublishMyGet)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(args =\u003E\n                args\n                    .SetApiKey(EnvironmentVariable(Parameters.MyGetApiKey))\n                    .SetSource(EnvironmentVariable(Parameters.MyGetSource))\n                    .SetTargetPath(string.Empty));\n        });\n\n    Target PublishToNuGet =\u003E _ =\u003E _\n        .DependsOn(PublishToMyGet)\n        .OnlyWhenDynamic(() =\u003E Parameters.ShouldPublishNuGet)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(args =\u003E\n                args\n                    .SetApiKey(EnvironmentVariable(Parameters.NuGetApiKey))\n                    .SetSource(EnvironmentVariable(Parameters.NuGetSource))\n                    .SetTargetPath(string.Empty));\n        });\n}\n"
  },
  {
    "Id": 171691248,
    "FirstIndexed": "2020-04-25T15:47:03.6116301+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631847+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431271+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937149+02:00",
    "Name": "web-config-transform-buildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/web-config-transform-buildpack",
    "Description": null,
    "Archived": false,
    "Stars": 2,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/web-config-transform-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 8318,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing FileMode = System.IO.FileMode;\nusing ZipFile = System.IO.Compression.ZipFile;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public enum StackType\n    {\n        Windows,\n        Linux\n    }\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n    const string BuildpackProjectName = \u0022Pivotal.Web.Config.Transform.Buildpack\u0022;\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    \n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\n    readonly StackType Stack = StackType.Windows;\n    \n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GitHubToken;\n\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;  \n    string Framework =\u003E Stack == StackType.Windows ? \u0022net47\u0022 : \u0022netcoreapp2.2\u0022;\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetRuntime(Runtime));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .Description(\u0022Compiles the buildpack\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info(Stack);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n    \n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\n            EnsureCleanDirectory(TemporaryDirectory);\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\n            var scriptsDirectory = RootDirectory / \u0022scripts\u0022;\n            \n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            var tempZipFile = TemporaryDirectory / PackageZipName;\n            \n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\n            MakeFilesInZipUnixExecutable(tempZipFile);\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\n            Logger.Block(ArtifactsDirectory / PackageZipName);\n\n        });\n    \n\n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\n        .DependsOn(Publish)\n        .Requires(() =\u003E GitHubToken)\n        .Executes(async () =\u003E\n        {\n            if (!GitRepository.IsGitHubRepository())\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n            \n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\n            {\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\n            };\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n            var owner = gitIdParts[0];\n            var repoName = gitIdParts[1];\n            \n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n            Release release;\n            try\n            {\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\n            }\n            catch (NotFoundException)\n            {\n                var newRelease = new NewRelease(releaseName)\n                {\n                    Name = releaseName, \n                    Draft = false, \n                    Prerelease = false\n                };\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\n            }\n\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\n            if (existingAsset != null)\n            {\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n            }\n            \n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\n            \n            Logger.Block(releaseAsset.BrowserDownloadUrl);\n        });\n\n    public static void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\n    {\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\n        {\n            output.SetLevel(9);\n            ZipEntry entry;\n\t\t\n            while ((entry = input.GetNextEntry()) != null)\n            {\n                var outEntry = new ZipEntry(entry.Name);\n                outEntry.HostSystem = (int)HostSystemID.Unix;\n                outEntry.ExternalFileAttributes = -2115174400;\n                output.PutNextEntry(outEntry);\n                input.CopyTo(output);\n            }\n            output.Finish();\n            output.Flush();\n        }\n\n        DeleteFile(zipFile);\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\n    }\n}\n"
  },
  {
    "Id": 171793388,
    "FirstIndexed": "2020-04-25T15:47:03.6113485+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624314+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431282+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893716+02:00",
    "Name": "Airframe",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Airframe",
    "Description": "A collection of abstract classes that extend ReactiveUI implementations",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Airframe/blob/master/.build/Build.cs",
    "BuildFileSize": 1123,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Rocket.Surgery.Nuke;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Rocket.Surgery.Nuke.MsBuild;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Airframe : MsBuild, IMsBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CAirframe\u003E(x =\u003E x.Default);\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, MsBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, MsBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, MsBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, MsBuild.Pack);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack);\n}"
  },
  {
    "Id": 172135121,
    "FirstIndexed": "2020-04-25T15:50:44.7354617+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632291+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433512+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939288+02:00",
    "Name": "ScrewTurnWiki",
    "Owner": "MarkZither",
    "HtmlUrl": "https://github.com/MarkZither/ScrewTurnWiki",
    "Description": "ScrewTurnWIki v3 Updated to .net Framework 4.7",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/MarkZither/ScrewTurnWiki/blob/master/build/Build.cs",
    "BuildFileSize": 4380,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing Nuke.Common.Tools.NUnit;\nusing static Nuke.Common.Tools.NUnit.NUnitTasks;\nusing System.IO;\nusing Nuke.Common.Tools.OpenCover;\nusing static Nuke.Common.Tools.OpenCover.OpenCoverTasks;\nusing Nuke.Common.Tools.MSBuild;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n\t/// Support plugins are available for:\n\t///   - JetBrains ReSharper        https://nuke.build/resharper\n\t///   - JetBrains Rider            https://nuke.build/rider\n\t///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n\t///   - Microsoft VSCode           https://nuke.build/vscode\n\n\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.PublishGitHubRelease);\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Solution] readonly Solution Solution;\n\t[GitRepository] readonly GitRepository GitRepository;\n\t[GitVersion] readonly GitVersion GitVersion;\n\n\tAbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\tAbsolutePath SolutionDirectory =\u003E RootDirectory;\n\tAbsolutePath WebApplicationDirectory =\u003E RootDirectory / \u0022WebApplication\u0022;\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Before(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tEnsureCleanDirectory(OutputDirectory);\n\t\t});\n\n\tTarget Restore =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution));\n\t\t\tNuGetRestore(s =\u003E s.SetWorkingDirectory(SolutionDirectory));\n\t\t});\n\n\tTarget Compile =\u003E _ =\u003E _\n\t\t.DependsOn(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tMSBuild(s =\u003E s.SetWorkingDirectory(SolutionDirectory));\n\t\t\t//DotNetBuild(s =\u003E s\n\t\t\t//  .SetProjectFile(Solution)\n\t\t\t//.SetConfiguration(Configuration)\n\t\t\t//.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n\t\t\t//.SetFileVersion(GitVersion.GetNormalizedFileVersion())\n\t\t\t//.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t//.EnableNoRestore());\n\t\t});\n\n\tTarget TestAndCoverage =\u003E _ =\u003E _\n\t.DependsOn(Compile)\n\t.Executes(() =\u003E\n\t{\n\t\tvar assemblies = GlobFiles(SolutionDirectory, $\u0022*/bin/{Configuration}/net4*/ScrewTurn.Wiki.*.Tests.dll\u0022).NotEmpty();\n\t\tvar nunitSettings = new NUnit3Settings()\n\t\t\t.AddInputFiles(assemblies)\n\t\t\t.AddResults(OutputDirectory / \u0022tests.xml\u0022);\n\n\t\tif(EnvironmentInfo.IsWin)\n\t\t{\n\t\t\tvar searchDirectories = nunitSettings.InputFiles.Select(x =\u003E Path.GetDirectoryName(x));\n\n\t\t\tOpenCoverTasks.OpenCover(s =\u003E s\n\t\t\t\t.SetOutput(OutputDirectory / \u0022coverage.xml\u0022)\n\t\t\t\t.SetTargetSettings(nunitSettings)\n\t\t\t\t.SetSearchDirectories(searchDirectories)\n\t\t\t\t.SetWorkingDirectory(RootDirectory)\n\t\t\t\t.SetRegistration(RegistrationType.User)\n\t\t\t\t.SetTargetExitCodeOffset(targetExitCodeOffset: 0)\n\t\t\t\t.SetFilters(\n\t\t\t\t\t\u0022\u002B[*]*\u0022,\n\t\t\t\t\t\u0022-[xunit.*]*\u0022,\n\t\t\t\t\t\u0022-[FluentAssertions.*]*\u0022)\n\t\t\t\t.SetExcludeByAttributes(\n\t\t\t\t\t\u0022*.Explicit*\u0022,\n\t\t\t\t\t\u0022*.Ignore*\u0022,\n\t\t\t\t\t\u0022System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute\u0022)\n\t\t\t\t.SetExcludeByFile(\n\t\t\t\t\t\u0022*/*.Generated.cs\u0022,\n\t\t\t\t\t\u0022*/*.Designer.cs\u0022,\n\t\t\t\t\t\u0022*/*.g.cs\u0022,\n\t\t\t\t\t\u0022*/*.g.i.cs\u0022));\n\n\t\t\t// Or using static imports and default settings:\n\t\t\t/*OpenCover(s =\u003E s\n\t\t\t\t.SetOutput(OutputDirectory / \u0022coverage.xml\u0022)\n\t\t\t\t.SetTargetSettings(nunitSettings)\n\t\t\t\t.SetSearchDirectories(searchDirectories));*/\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNUnit3(s =\u003E nunitSettings);\n\t\t}\n\t});\n\n\tTarget PublishGitHubRelease =\u003E _ =\u003E _\n\t//.DependsOn(Compile)\n\t//.OnlyWhenStatic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n\t.Executes(() =\u003E\n\t{\n\t\tMSBuildSettings buildSettings = new MSBuildSettings()\n\t\t.SetWorkingDirectory(WebApplicationDirectory)\n\t\t.SetProjectFile(\u0022WebApplication.csproj\u0022)\n\t\t.SetOutDir(\u0022C:\\\\publish\\\\ScrewTurnWiki\\\\WebApplication\u0022)\n\t\t.AddProperty(\u0022PublishProfile\u0022, \u0022FolderProfile\u0022)\n\t\t.SetVerbosity(MSBuildVerbosity.Detailed);\n\t\tMSBuild(buildSettings);\n\t});\n}\n"
  },
  {
    "Id": 172874863,
    "FirstIndexed": "2020-04-25T15:50:44.7355083+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632518+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433717+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939481+02:00",
    "Name": "nuke-issue-239",
    "Owner": "DannySotzny",
    "HtmlUrl": "https://github.com/DannySotzny/nuke-issue-239",
    "Description": "Example Repo",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/DannySotzny/nuke-issue-239/blob/master/build/Build.cs",
    "BuildFileSize": 2127,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 174915669,
    "FirstIndexed": "2020-04-25T15:50:44.7355015+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632507+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433689+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939453+02:00",
    "Name": "Ubiety.StyleCop",
    "Owner": "ubiety",
    "HtmlUrl": "https://github.com/ubiety/Ubiety.StyleCop",
    "Description": "StyleCop rules library for shared projects",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ubiety/Ubiety.StyleCop/blob/master/build/Build.cs",
    "BuildFileSize": 2656,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string ApiKey;\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetOutputDirectory(ArtifactsDirectory)\n                .EnableNoBuild()\n                .SetProject(Solution)\n                .SetConfiguration(Configuration));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Restore, Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                .SetApiKey(ApiKey)\n                .SetSource(Source)\n                .CombineWith(\n                    ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E \n                        cs.SetTargetPath(v)),\n                5,\n                true);\n        });\n\n}\n"
  },
  {
    "Id": 177240564,
    "FirstIndexed": "2020-04-25T15:50:44.7354503+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632234+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433461+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939242+02:00",
    "Name": "DsvParser",
    "Owner": "Beffyman",
    "HtmlUrl": "https://github.com/Beffyman/DsvParser",
    "Description": "Attempt at a delimiter seperated values parser, csv, tsv, psv",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/BuildScripts.cs",
    "BuildFileUrl": "https://github.com/Beffyman/DsvParser/blob/master/build/BuildScripts.cs",
    "BuildFileSize": 4405,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\npublic class BuildScripts : NukeBuild\n{\n\t/*\n\t/// Support plugins are available for:\n\t///   - JetBrains ReSharper        https://nuke.build/resharper\n\t///   - JetBrains Rider            https://nuke.build/rider\n\t///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n\t///   - Microsoft VSCode           https://nuke.build/vscode\n\t*/\n\n\tpublic static int Main() =\u003E Execute\u003CBuildScripts\u003E(x =\u003E x.Pack);\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Solution] readonly Solution Solution;\n\t[GitRepository] readonly GitRepository GitRepository;\n\t[GitVersion] readonly GitVersion GitVersion;\n\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\tAbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\tAbsolutePath TestArtifactsDirectory =\u003E ArtifactsDirectory / \u0022tests\u0022;\n\tAbsolutePath CodeCoverageReportOutput =\u003E TestArtifactsDirectory / \u0022Reports\u0022;\n\tAbsolutePath CodeCoverageFile =\u003E TestArtifactsDirectory / \u0022coverage.cobertura.xml\u0022;\n\n\tAbsolutePath PerformanceProject =\u003E TestsDirectory / \u0022Beffyman.DsvParser.Performance\u0022;\n\n\tTarget Pack =\u003E _ =\u003E _\n\t\t.DependsOn(Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetPack(s =\u003E s.SetProject(Solution)\n\t\t\t\t\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t\t\t\t.EnableNoBuild()\n\t\t\t\t\t.EnableIncludeSource()\n\t\t\t\t\t.EnableIncludeSymbols()\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n\t\t\t\t\t.SetFileVersion(GitVersion.GetNormalizedFileVersion())\n\t\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t\t.SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n\t\t});\n\n\tTarget Test =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetTest(s =\u003E s.EnableNoBuild()\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.SetLogger(\u0022trx\u0022)\n\t\t\t\t.SetResultsDirectory(TestArtifactsDirectory)\n\t\t\t\t.SetLogOutput(true)\n\t\t\t\t.SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t.Add(\u0022/p:CoverletOutput={0}/\u0022, TestArtifactsDirectory)\n\t\t\t\t\t.Add(\u0022/p:Threshold={0}\u0022, 90)\n\t\t\t\t\t.Add(\u0022/p:Exclude=\\\u0022[xunit*]*%2c[*.Tests]*\\\u0022\u0022)\n\t\t\t\t\t.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t.Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n\t\t\t\t.SetProjectFile(Solution));\n\n\t\t\tFileExists(CodeCoverageFile);\n\t\t});\n\n\tTarget PerfTest =\u003E _ =\u003E _\n\t\t.DependsOn(Build)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRun(s =\u003E s.SetConfiguration(Configuration.Release)\n\t\t\t\t.SetWorkingDirectory(PerformanceProject));\n\t\t});\n\n\tTarget Restore =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution));\n\t\t});\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tTestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tEnsureCleanDirectory(ArtifactsDirectory);\n\t\t});\n\n\tTarget Build =\u003E _ =\u003E _\n\t\t.DependsOn(Clean)\n\t\t.DependsOn(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetBuild(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n\t\t\t\t.SetFileVersion(GitVersion.GetNormalizedFileVersion())\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t.EnableNoRestore());\n\t\t});\n\n\tTarget Report =\u003E _ =\u003E _\n\t\t.DependsOn(Pack)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tReportGenerator(s =\u003E s.SetReports(CodeCoverageFile)\n\t\t\t\t\t\t\t\t.SetTargetDirectory(CodeCoverageReportOutput)\n\t\t\t\t\t\t\t\t.SetTag(GitVersion.NuGetVersionV2)\n\t\t\t\t\t\t\t\t.SetReportTypes(ReportTypes.HtmlInline_AzurePipelines_Dark));\n\t\t});\n\n\n\tTarget CI =\u003E _ =\u003E _\n\t\t.DependsOn(Report)\n\t\t.Executes(() =\u003E { });\n\n}\n"
  },
  {
    "Id": 177320232,
    "FirstIndexed": "2020-04-25T15:50:44.7354873+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632393+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433626+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939401+02:00",
    "Name": "wpf-eye-tracking-experiments",
    "Owner": "dansav",
    "HtmlUrl": "https://github.com/dansav/wpf-eye-tracking-experiments",
    "Description": "Small applications exploring how to use eye tracking in an WPF application",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/dansav/wpf-eye-tracking-experiments/blob/master/build/Build.cs",
    "BuildFileSize": 4144,
    "BuildFileContent": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO.Compression;\nusing System.Linq;\nusing Microsoft.Build.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Default);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    ICollection\u003CProject\u003E ProjectsToBuild =\u003E Solution.AllProjects\n        .Where(p =\u003E\n        {\n            var refList = new[]\n            {\n                \u0022XRayVision\u0022,\n            };\n            return refList.Contains(p.Name);\n        })\n        .ToArray();\n\n    Target Default =\u003E t =\u003E t\n        .DependsOn(Clean, Restore, Compile, Pack);\n\n    Target Clean =\u003E t =\u003E t\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E t =\u003E t\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            foreach (var project in ProjectsToBuild)\n            {\n                NuGetTasks.NuGetRestore(s =\u003E s\n                    .SetTargetPath(project.Path)\n                    .SetPackagesDirectory(RootDirectory / \u0022packages\u0022));\n            }\n        });\n\n    Target Compile =\u003E t =\u003E t\n        .After(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Normal($\u0022Building version: {GitVersion.SemVer}\u0022);\n\n            foreach (var project in ProjectsToBuild)\n            {\n                MSBuild(s =\u003E s\n                    .SetTargetPath(project)\n                    .SetTargets(\u0022Rebuild\u0022)\n                    .SetConfiguration(Configuration)\n                    .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                    .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                    .SetMaxCpuCount(Environment.ProcessorCount)\n                    .SetNodeReuse(IsLocalBuild));\n            }\n        });\n\n    Target Pack =\u003E t =\u003E t\n        .After(Compile)\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022Creating {Configuration} packages for version {GitVersion.SemVer}\u0022);\n\n            foreach (var project in ProjectsToBuild)\n            {\n                var dir = (AbsolutePath) System.IO.Path.GetDirectoryName(project.Path) / \u0022bin\u0022 / Configuration;\n\n                AbsolutePath zipFile;\n                if (Configuration.Debug.Equals(Configuration))\n                {\n                    zipFile = OutputDirectory / $\u0022{project.Name}_{GitVersion.SemVer}_debug.zip\u0022;\n                }\n                else\n                {\n                    zipFile = OutputDirectory / $\u0022{project.Name}_{GitVersion.SemVer}.zip\u0022;\n                }\n\n                //Nuke.Compression.CompressionTasks.Compress(dir, zipFile);\n                ZipFile.CreateFromDirectory(dir, zipFile);\n            }\n        });\n}\n"
  },
  {
    "Id": 179025940,
    "FirstIndexed": "2020-04-25T15:50:44.7354594+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1626021+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433501+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "PaternalMessenger",
    "Owner": "Joe-Soap",
    "HtmlUrl": "https://github.com/Joe-Soap/PaternalMessenger",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 179481020,
    "FirstIndexed": "2020-04-25T15:50:44.7354571+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629332+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843349+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939276+02:00",
    "Name": "Avalonia.ThemeManager",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/Avalonia.ThemeManager",
    "Description": "Theme manager for Avalonia applications.",
    "Archived": false,
    "Stars": 13,
    "Watchers": 1,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/Avalonia.ThemeManager/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 180605911,
    "FirstIndexed": "2020-04-25T15:47:03.6115436+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631705+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431294+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937171+02:00",
    "Name": "redis-session-aspnet-buildpack",
    "Owner": "alfusinigoj",
    "HtmlUrl": "https://github.com/alfusinigoj/redis-session-aspnet-buildpack",
    "Description": "Buildpack that enables session backing using redis",
    "Archived": false,
    "Stars": 2,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/alfusinigoj/redis-session-aspnet-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 10869,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing FileMode = System.IO.FileMode;\nusing ZipFile = System.IO.Compression.ZipFile;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public enum StackType\n    {\n        Windows,\n        Linux\n    }\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n    const string BuildpackProjectName = \u0022Pivotal.Redis.Aspnet.Session.Buildpack\u0022;\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\n    readonly StackType Stack = StackType.Windows;\n\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GitHubToken;\n\n    [Parameter(\u0022If this release should be marked as a pre-release\u0022)]\n    bool IsPreRelease = false;\n\n    [Parameter(\u0022Build Version Number\u0022)]\n    readonly string BuildVersion = string.Empty;\n\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;\n    string Framework =\u003E Stack == StackType.Windows ? \u0022net47\u0022 : \u0022netcoreapp2.2\u0022;\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath VersionFile =\u003E RootDirectory / \u0022release.version\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target SetPackageZipName =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            if (!GitRepository.IsGitHubRepository())\n                throw new Exception(\u0022SetPackageZipName supported when this is in a git repository\u0022);\n\n            Logger.Log(LogLevel.Normal, $\u0022Updating version file {VersionFile} with name {PackageZipName}\u0022);\n\n            File.WriteAllText(VersionFile, $\u0022{PackageZipName}\u0022);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\n        .DependsOn(SetPackageZipName)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetRuntime(Runtime));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .Description(\u0022Compiles the buildpack\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info(Stack);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .Description(\u0022Execute tests\u0022)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\n            EnsureCleanDirectory(TemporaryDirectory);\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\n            var scriptsDirectory = RootDirectory / \u0022scripts\u0022;\n\n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n\n            var tempZipFile = TemporaryDirectory / PackageZipName;\n\n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\n            MakeFilesInZipUnixExecutable(tempZipFile);\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\n            Logger.Block(ArtifactsDirectory / PackageZipName);\n\n        });\n\n\n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\n        .Requires(() =\u003E GitHubToken)\n        .Requires(() =\u003E BuildVersion)\n        .Executes(async () =\u003E\n        {\n            if (!GitRepository.IsGitHubRepository())\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n\n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\n            {\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\n            };\n\n            Logger.Log(LogLevel.Normal, $\u0022Releasing in Github {client.BaseAddress}\u0022);\n\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n            var owner = gitIdParts[0];\n            var repoName = gitIdParts[1];\n\n            var packageFileNamewithoutExtension = Path.GetFileNameWithoutExtension(GetPackageZipNameFromVersionFile());\n            var majorMinorPatch = packageFileNamewithoutExtension.Split(\u0027-\u0027)[3];\n\n            var releaseName = IsPreRelease ? $\u0022v{majorMinorPatch}-prerelease\u0022 : $\u0022v{majorMinorPatch}\u0022;\n\n            Release release;\n            try\n            {\n                Logger.Log(LogLevel.Normal, $\u0022Checking for existence of release with name {releaseName}...\u0022);\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\n                Logger.Log(LogLevel.Normal, $\u0022Found release {releaseName} at {release.AssetsUrl}\u0022);\n            }\n            catch (Exception)\n            {\n                Logger.Log(LogLevel.Normal, $\u0022Release with name {releaseName} not found.. so creating new...\u0022);\n\n                var newRelease = new NewRelease(releaseName)\n                {\n                    Name = releaseName,\n                    Draft = false,\n                    Prerelease = IsPreRelease,\n                    Body = $\u0022Build Version: {(string.IsNullOrWhiteSpace(BuildVersion) ? \u0022Unknown\u0022 : BuildVersion)}\u0022\n                };\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\n            }\n\n            var targetPackageName = IsPreRelease ? $\u0022{packageFileNamewithoutExtension}-prerelease.zip\u0022 : GetPackageZipNameFromVersionFile();\n\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == targetPackageName);\n            if (existingAsset != null)\n            {\n                Logger.Log(LogLevel.Normal, $\u0022Deleting assert {existingAsset.Name}...\u0022);\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n            }\n\n            var zipPackageLocation = ArtifactsDirectory / GetPackageZipNameFromVersionFile();\n            var targetZipPackageLocation = ArtifactsDirectory / targetPackageName;\n\n            if (string.Compare(zipPackageLocation, targetZipPackageLocation) != 0)\n                File.Copy(zipPackageLocation, targetZipPackageLocation, true);\n\n            var releaseAssetUpload = new ReleaseAssetUpload(targetPackageName, \u0022application/zip\u0022, File.OpenRead(targetZipPackageLocation), null);\n\n            Logger.Log(LogLevel.Normal, $\u0022Uploading assert {releaseAssetUpload.FileName}...\u0022);\n\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\n\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\n\n            Logger.Log(LogLevel.Normal, $\u0022Released in Github {client.BaseAddress}, successfully\u0022);\n        });\n\n    public static void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\n    {\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\n        {\n            output.SetLevel(9);\n            ZipEntry entry;\n\n            while ((entry = input.GetNextEntry()) != null)\n            {\n                var outEntry = new ZipEntry(entry.Name);\n                outEntry.HostSystem = (int)HostSystemID.Unix;\n                outEntry.ExternalFileAttributes = -2115174400;\n                output.PutNextEntry(outEntry);\n                input.CopyTo(output);\n            }\n            output.Finish();\n            output.Flush();\n        }\n\n        DeleteFile(zipFile);\n        RenameFile(tmpFileName, zipFile, FileExistsPolicy.Overwrite);\n    }\n\n    public string GetPackageZipNameFromVersionFile()\n    {\n        if (!File.Exists(VersionFile))\n            throw new FileNotFoundException(VersionFile);\n\n        return File.ReadAllText(VersionFile);\n    }\n}\n"
  },
  {
    "Id": 182458480,
    "FirstIndexed": "2020-04-25T15:50:44.7361829+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632262+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434878+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940602+02:00",
    "Name": "GitAutoVersionTool",
    "Owner": "prom3theu5",
    "HtmlUrl": "https://github.com/prom3theu5/GitAutoVersionTool",
    "Description": "Nuke.Build Auto SemVer based on Git Commits",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "src/GitAutoVersionTool/GitTool.cs",
    "BuildFileUrl": "https://github.com/prom3theu5/GitAutoVersionTool/blob/master/src/GitAutoVersionTool/GitTool.cs",
    "BuildFileSize": 5260,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing GitAutoVersionTool.Helpers;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tools.Git;\nusing Nuke.Common.Utilities;\n\nnamespace GitAutoVersionTool\n{\n    public class GitTool\n    {\n        static readonly PathConstruction.AbsolutePath _rootPath = NukeBuild.RootDirectory;\n        static readonly LocalRunner _gitLocalRunner = new LocalRunner(GitTasks.GitPath);\n        public static string GetHash()\n        {\n            var result = _gitLocalRunner\n                .Run(\u0022log --max-count=1 --pretty=format:%H HEAD\u0022,\n                    _rootPath, logOutput: false);\n            var hash = result.Select(x =\u003E x.Text).Take(1).Join(Environment.NewLine);\n            return hash;\n        }\n\n        public static GitAutoVersionGitSubData GetAllGitData()\n        {\n            var hash = GetHash();\n            var commitNumber = GetCommitNumberAll();\n            var commitNumberCurrentBranch = GetCommitNumberCurrentBranch();\n            var commitNumberCurrentBranchFirstParent = GetCommitNumberCurrentBranchFirstParent();\n            var branch = GetBranch();\n            var ret = new GitAutoVersionGitSubData(hash, commitNumber, branch, commitNumberCurrentBranch,\n                commitNumberCurrentBranchFirstParent);\n            return ret;\n        }\n\n\n        public static int GetCommitNumberAll()\n        {\n            var text = RunGenericCommandReturnText(\u0022rev-list --all --count\u0022);\n            try\n            {\n                var number = int.Parse(text);\n                return number;\n            }\n            catch (Exception e)\n            {\n                Logger.Error(e);\n                throw;\n            }\n        }\n\n        public static int GetCommitNumberCurrentBranch()\n        {\n            var text = RunGenericCommandReturnText(\u0022rev-list HEAD --count\u0022);\n            try\n            {\n                var number = int.Parse(text);\n                return number;\n            }\n            catch (Exception e)\n            {\n                Logger.Error(e);\n                throw;\n            }\n        }\n\n\n        public static string GetTimestamp()\n        {\n            var text = RunGenericCommandReturnText(\u0022log --max-count=1 --pretty=format:%cI HEAD\u0022);\n            try\n            {\n                var date = DateTime.Parse(text).ToUniversalTime().ToString(\u0022yyyy-MM-ddTHH:mm:ssZ\u0022);\n                return date;\n            }\n            catch (Exception e)\n            {\n                Logger.Error(e);\n                throw;\n            }\n        }\n\n        static string RunGenericCommandReturnText(string command, int numberLinesToReturn = 1)\n        {\n            try\n            {\n                var result = _gitLocalRunner.Run(command, _rootPath, logOutput: false);\n                var text = result.Select(x =\u003E x.Text).Take(numberLinesToReturn).Join(Environment.NewLine);\n                return text;\n            }\n            catch (Exception e)\n            {\n                Logger.Error(e);\n                throw;\n            }\n        }\n\n\n        public static string GetBranch()\n        {\n            var result1 = _gitLocalRunner\n                .Run(\u0022rev-parse --abbrev-ref HEAD\u0022,\n                    _rootPath, logOutput: false);\n            var result2 = result1.Select(x =\u003E x.Text).Take(1).Join(Environment.NewLine);\n            if (result2.IndexOf(\u0022HEAD\u0022, StringComparison.OrdinalIgnoreCase) == -1) return result2;\n\n            var result3 = _gitLocalRunner\n                .Run(\u0022symbolic-ref --short -q HEAD\u0022,\n                    _rootPath, logOutput: false);\n            var result4 = result3.Select(x =\u003E x.Text).Take(1).Join(Environment.NewLine);\n            if (result4.IndexOf(\u0022HEAD\u0022, StringComparison.OrdinalIgnoreCase) == -1) return result2;\n\n            return string.Empty;\n        }\n\n        /// \u003Csummary\u003E\n        /// https://stackoverflow.com/a/49567820\n        /// Follow only the first parent commit upon seeing a merge commit.\n        /// This option can give a better overview when viewing the evolution of a particular topic branch,\n        /// because merges into a topic branch tend to be only about adjusting to updated upstream from time to time,\n        /// and this option allows you to ignore the individual commits brought in to your history by such a merge.\n        /// Cannot be combined with --bisect.\n        /// \u003C/summary\u003E\n        /// \u003Creturns\u003E\u003C/returns\u003E\n        public static int GetCommitNumberCurrentBranchFirstParent()\n        {\n            var text = RunGenericCommandReturnText(\u0022rev-list HEAD --count --first-parent\u0022);\n            try\n            {\n                var number = int.Parse(text);\n                return number;\n            }\n            catch (Exception e)\n            {\n                Logger.Error(e);\n                throw;\n            }\n        }\n\n\n        public static int GetCommitNumberCurrentBranchFirstParent(string sinceSha)\n        {\n            var text = RunGenericCommandReturnText($\u0022rev-list {sinceSha}..HEAD --count --first-parent\u0022);\n            try\n            {\n                var number = int.Parse(text);\n                return number;\n            }\n            catch (Exception e)\n            {\n                Logger.Error(e);\n                throw;\n            }\n        }\n    }\n}"
  },
  {
    "Id": 182578786,
    "FirstIndexed": "2020-04-25T15:50:44.7354526+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632251+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433473+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939253+02:00",
    "Name": "Gateways",
    "Owner": "dbarrera1984",
    "HtmlUrl": "https://github.com/dbarrera1984/Gateways",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/dbarrera1984/Gateways/blob/master/build/Build.cs",
    "BuildFileSize": 2265,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n}\n"
  },
  {
    "Id": 182865632,
    "FirstIndexed": "2020-04-25T15:50:44.7361778+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632222+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434866+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894059+02:00",
    "Name": "Tartarus",
    "Owner": "prom3theu5",
    "HtmlUrl": "https://github.com/prom3theu5/Tartarus",
    "Description": "CoX Launcher",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/prom3theu5/Tartarus/blob/master/build/Build.cs",
    "BuildFileSize": 6175,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing GitAutoVersionTool;\nusing Helpers;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\nclass Build : NukeBuild\n{\n    static readonly DateTime _buildDate = DateTime.UtcNow;\n    const string AssemblyName = \u0022Tartarus.exe\u0022;\n\n    [Parameter(\u0022Build counter from outside environment\u0022, Name = \u0022build\u0022)] readonly int BuildCounter;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022, Name = \u0022config\u0022)]\n    readonly string Configuration = \u0022Release\u0022;\n\n\n    [Solution(\u0022Tartarus.sln\u0022)] readonly Solution Solution;\n    MSBuildTargetPlatform Platform = MSBuildTargetPlatform.x64;\n\n    GitAutoVersion Version =\u003E GitAutoVersionFactory.Create(BuildCounter, _buildDate);\n\n    Project MainProject =\u003E Solution.GetProject(\u0022Tartarus\u0022).NotNull();\n\n    AbsolutePath SourceDir =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ToolsDir =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath ArtifactsDir =\u003E RootDirectory / \u0022_artifacts\u0022;\n    AbsolutePath TmpBuild =\u003E TemporaryDirectory / \u0022build\u0022;\n    AbsolutePath LibzPath =\u003E ToolsDir / \u0022LibZ.Tool\u0022 / \u0022tools\u0022 / \u0022libz.exe\u0022;\n    AbsolutePath NugetPath =\u003E ToolsDir / \u0022nuget\u0022 / \u0022nuget.exe\u0022;\n\n    AbsolutePath SevenZipPath =\u003E ToolsDir / \u00227-Zip.CommandLine\u0022 / \u0022tools\u0022 / \u00227za.exe\u0022;\n\n\n    Target Information =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022SemVer: {Version.SemVersion}\u0022);\n            Logger.Info($\u0022InformationalVersion: {Version.InformationalVersion}\u0022);\n            Logger.Info($\u0022AssemblyVersion: {Version.AssemblyVersion}\u0022);\n            Logger.Info($\u0022FileVersion: {Version.FileVersion}\u0022);\n        });\n\n\n    Target CheckTools =\u003E _ =\u003E _\n        .DependsOn(Information)\n        .Executes(() =\u003E\n        {\n            Downloader.DownloadIfNotExists(\u0022https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\u0022, NugetPath,\n                \u0022Nuget\u0022);\n            var toolsNugetFile = ToolsDir / \u0022packages.config\u0022;\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022install   {toolsNugetFile} -OutputDirectory {ToolsDir} -ExcludeVersion\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(CheckTools)\n        .Executes(() =\u003E\n        {\n            if (DirectoryExists(TmpBuild))\n                DeleteDirectory(TmpBuild);\n\n            if (DirectoryExists(ArtifactsDir))\n                DeleteDirectory(ArtifactsDir);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022restore  {Solution.Path}\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            var buildOut = TmpBuild / CommonDir.Build /\n                           MainProject.Name;\n            EnsureExistingDirectory(buildOut);\n\n            MSBuild(s =\u003E s\n                .SetToolPath(\u0022c:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\2019\\\\Enterprise\\\\MSBuild\\\\Current\\\\Bin\\\\msbuild.exe\u0022)\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetTargetPlatform(Platform)\n                .SetOutDir(buildOut)\n                .SetVerbosity(MSBuildVerbosity.Quiet)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(Version.AssemblyVersion)\n                .SetFileVersion(Version.FileVersion)\n                .SetInformationalVersion(Version.InformationalVersion)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target Merge =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            var doNotMerge = new[]\n            {\n                \u0022build.dll\u0022, \u0022libcef.dll\u0022, \u0022chrome_elf.dll\u0022, \u0022d3dcompiler_47.dll\u0022,\n                \u0022libEGL.dll\u0022, \u0022libGLESv2.dll\u0022, \u0022CefSharp.dll\u0022, \u0022CefSharp.Core.dll\u0022,\n                \u0022CefSharp.BrowserSubprocess.Core.dll\u0022\n            };\n            var exclude = string.Join(\u0027 \u0027, doNotMerge.Select(x =\u003E $\u0022--exclude={x}\u0022));\n\n            var buildOut = TmpBuild / CommonDir.Build /\n                           MainProject.Name;\n\n            var mergeOut = TmpBuild / CommonDir.Merge /\n                           MainProject.Name;\n\n            CopyDirectoryRecursively(buildOut, mergeOut);\n\n            using (var process = ProcessTasks.StartProcess(\n                LibzPath,\n                $\u0022inject-dll --assembly {AssemblyName} --include *.dll {exclude} --move\u0022,\n                mergeOut))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Libz report generation process exited with some errors.\u0022);\n            }\n        });\n\n\n    Target CopyToArtifacts =\u003E _ =\u003E _\n        .DependsOn(Merge)\n        .Executes(() =\u003E\n\n        {\n            var mergeOut = TmpBuild / CommonDir.Merge /\n                           MainProject.Name;\n\n            var readyOut = TmpBuild / CommonDir.Ready /\n                           MainProject.Name;\n\n            EnsureExistingDirectory(readyOut);\n            CopyFile(mergeOut / $\u0022{AssemblyName}\u0022, ArtifactsDir / $\u0022{AssemblyName}\u0022);\n        });\n\n    Target CleanOnTheEnd =\u003E _ =\u003E _\n        .DependsOn(CopyToArtifacts)\n        .Executes(() =\u003E\n        {\n            DeleteDirectory(TmpBuild);\n        });\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.CleanOnTheEnd);\n}"
  },
  {
    "Id": 183058628,
    "FirstIndexed": "2020-04-25T15:47:03.6111243+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629361+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431305+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937183+02:00",
    "Name": "cf-buildpack-template",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/cf-buildpack-template",
    "Description": "Cloud Foundry Buildpack Template for .NET Core",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/cf-buildpack-template/blob/master/build/Build.cs",
    "BuildFileSize": 12981,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Runtime.CompilerServices;\r\nusing ICSharpCode.SharpZipLib.Zip;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitHub;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing FileMode = System.IO.FileMode;\r\nusing ZipFile = System.IO.Compression.ZipFile;\r\n\r\n[assembly: InternalsVisibleTo(\u0022MyBuildpackTests\u0022)]\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    [Flags]\r\n    public enum StackType\r\n    {\r\n        Windows = 1,\r\n        Linux = 2\r\n    }\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n    const string BuildpackProjectName = \u0022MyBuildpack\u0022;\r\n    string GetPackageZipName(string runtime) =\u003E $\u0022{BuildpackProjectName}-{runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    \r\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is both\u0022)]\r\n    readonly StackType Stack = StackType.Windows | StackType.Linux;\r\n    \r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    [Parameter(\u0022Application directory against which buildpack will be applied\u0022)]\r\n    readonly string ApplicationDirectory;\r\n\r\n    IEnumerable\u003CPublishTarget\u003E PublishCombinations\r\n    {\r\n        get\r\n        {\r\n            if (Stack.HasFlag(StackType.Windows))\r\n                yield return new PublishTarget {Framework = \u0022net472\u0022, Runtime = \u0022win-x64\u0022};\r\n            if (Stack.HasFlag(StackType.Linux))\r\n                yield return new PublishTarget {Framework = \u0022netcoreapp3.1\u0022, Runtime = \u0022linux-x64\u0022};\r\n        }\r\n    }\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    \r\n    string[] LifecycleHooks = {\u0022detect\u0022, \u0022supply\u0022, \u0022release\u0022, \u0022finalize\u0022};\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .Description(\u0022Compiles the buildpack\u0022)\r\n        .DependsOn(Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            \r\n            Logger.Info(Stack);\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                \r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .CombineWith(PublishCombinations, (c, p) =\u003E c\r\n                    .SetFramework(p.Framework)\r\n                    .SetRuntime(p.Runtime)));\r\n        });\r\n    \r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\r\n        .DependsOn(Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var framework = publishCombination.Framework;\r\n                var runtime = publishCombination.Runtime;\r\n                var packageZipName = GetPackageZipName(runtime);\r\n                var workDirectory = TemporaryDirectory / \u0022pack\u0022;\r\n                EnsureCleanDirectory(TemporaryDirectory);\r\n                var buildpackProject = Solution.GetProject(BuildpackProjectName);\r\n                if(buildpackProject == null)\r\n                    throw new Exception($\u0022Unable to find project called {BuildpackProjectName} in solution {Solution.Name}\u0022);\r\n                var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022;\r\n                var workBinDirectory = workDirectory / \u0022bin\u0022;\r\n\r\n\r\n                DotNetPublish(s =\u003E s\r\n                    .SetProject(Solution)\r\n                    .SetConfiguration(Configuration)\r\n                    .SetFramework(framework)\r\n                    .SetRuntime(runtime)\r\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                );\r\n\r\n                var lifecycleBinaries = Solution.GetProjects(\u0022Lifecycle*\u0022)\r\n                    .Select(x =\u003E x.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022)\r\n                    .SelectMany(x =\u003E Directory.GetFiles(x).Where(path =\u003E LifecycleHooks.Any(hook =\u003E Path.GetFileName(path).StartsWith(hook))));\r\n\r\n                foreach (var lifecycleBinary in lifecycleBinaries)\r\n                {\r\n                    CopyFileToDirectory(lifecycleBinary, workBinDirectory, FileExistsPolicy.OverwriteIfNewer);\r\n                }\r\n\r\n                CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n                var tempZipFile = TemporaryDirectory / packageZipName;\r\n\r\n                ZipFile.CreateFromDirectory(workDirectory, tempZipFile, CompressionLevel.NoCompression, false);\r\n                MakeFilesInZipUnixExecutable(tempZipFile);\r\n                CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\r\n                Logger.Block(ArtifactsDirectory / packageZipName);\r\n            }\r\n        });\r\n    \r\n    \r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or amends existing) and uploads buildpack artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var runtime = publishCombination.Runtime;\r\n                var packageZipName = GetPackageZipName(runtime);\r\n                if (!GitRepository.IsGitHubRepository())\r\n                    throw new Exception(\u0022Only supported when git repo remote is github\u0022);\r\n    \r\n                var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\r\n                {\r\n                    Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n                };\r\n                var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n                var owner = gitIdParts[0];\r\n                var repoName = gitIdParts[1];\r\n    \r\n                var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n                Release release;\r\n                try\r\n                {\r\n                    release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n                }\r\n                catch (NotFoundException)\r\n                {\r\n                    var newRelease = new NewRelease(releaseName)\r\n                    {\r\n                        Name = releaseName,\r\n                        Draft = false,\r\n                        Prerelease = false\r\n                    };\r\n                    release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n                }\r\n    \r\n                var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == packageZipName);\r\n                if (existingAsset != null)\r\n                {\r\n                    await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n                }\r\n    \r\n                var zipPackageLocation = ArtifactsDirectory / packageZipName;\r\n                var stream = File.OpenRead(zipPackageLocation);\r\n                var releaseAssetUpload = new ReleaseAssetUpload(packageZipName, \u0022application/zip\u0022, stream, TimeSpan.FromHours(1));\r\n                var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n    \r\n                Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n            }\r\n        });\r\n\r\n    Target Detect =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027detect\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Executes(() =\u003E\r\n        {\r\n            try\r\n            {\r\n                DotNetRun(s =\u003E s\r\n                    .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Detect\u0022).Path)\r\n                    .SetApplicationArguments(ApplicationDirectory)\r\n                    .SetConfiguration(Configuration)\r\n                    .SetFramework(\u0022netcoreapp3.1\u0022));\r\n                Logger.Block(\u0022Detect returned \u0027true\u0027\u0022);\r\n            }\r\n            catch (ProcessException)\r\n            {\r\n                Logger.Block(\u0022Detect returned \u0027false\u0027\u0022);\r\n            }\r\n        });\r\n\r\n    Target Supply =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027supply\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Executes(() =\u003E\r\n        {\r\n            var home = (AbsolutePath)Path.GetTempPath() / Guid.NewGuid().ToString();\r\n            var app = home / \u0022app\u0022;\r\n            var deps = home / \u0022deps\u0022;\r\n            var index = 0;\r\n            var cache = home / \u0022cache\u0022;\r\n            CopyDirectoryRecursively(ApplicationDirectory, app);\r\n\r\n            DotNetRun(s =\u003E s\r\n                .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Supply\u0022).Path)\r\n                .SetApplicationArguments($\u0022{app} {cache} {app} {deps} {index}\u0022)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(\u0022netcoreapp3.1\u0022));\r\n            Logger.Block($\u0022Buildpack applied. Droplet is available in {home}\u0022);\r\n\r\n        });\r\n\r\n    public void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\r\n    {\r\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\r\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\r\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\r\n        {\r\n            output.SetLevel(9);\r\n            ZipEntry entry;\r\n\t\t\r\n            while ((entry = input.GetNextEntry()) != null)\r\n            {\r\n                var outEntry = new ZipEntry(entry.Name) {HostSystem = (int) HostSystemID.Unix};\r\n                var entryAttributes =  \r\n                    ZipEntryAttributes.ReadOwner | \r\n                    ZipEntryAttributes.ReadOther | \r\n                    ZipEntryAttributes.ReadGroup |\r\n                    ZipEntryAttributes.ExecuteOwner | \r\n                    ZipEntryAttributes.ExecuteOther | \r\n                    ZipEntryAttributes.ExecuteGroup;\r\n                entryAttributes = entryAttributes | (entry.IsDirectory ? ZipEntryAttributes.Directory : ZipEntryAttributes.Regular);\r\n                outEntry.ExternalFileAttributes = (int) (entryAttributes) \u003C\u003C 16; // https://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute\r\n                output.PutNextEntry(outEntry);\r\n                input.CopyTo(output);\r\n            }\r\n            output.Finish();\r\n            output.Flush();\r\n        }\r\n\r\n        DeleteFile(zipFile);\r\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\r\n    }\r\n    \r\n    [Flags]\r\n    enum ZipEntryAttributes\r\n    {\r\n        ExecuteOther = 1,\r\n        WriteOther = 2,\r\n        ReadOther = 4,\r\n\t\r\n        ExecuteGroup = 8,\r\n        WriteGroup = 16,\r\n        ReadGroup = 32,\r\n\r\n        ExecuteOwner = 64,\r\n        WriteOwner = 128,\r\n        ReadOwner = 256,\r\n\r\n        Sticky = 512, // S_ISVTX\r\n        SetGroupIdOnExecution = 1024,\r\n        SetUserIdOnExecution = 2048,\r\n\r\n        //This is the file type constant of a block-oriented device file.\r\n        NamedPipe = 4096,\r\n        CharacterSpecial = 8192,\r\n        Directory = 16384,\r\n        Block = 24576,\r\n        Regular = 32768,\r\n        SymbolicLink = 40960,\r\n        Socket = 49152\r\n\t\r\n    }\r\n    class PublishTarget\r\n    {\r\n        public string Framework { get; set; }\r\n        public string Runtime { get; set; }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 183304981,
    "FirstIndexed": "2020-04-25T15:47:03.6109855+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629156+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431316+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937194+02:00",
    "Name": "cf-buildpack-windows-services",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/cf-buildpack-windows-services",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/cf-buildpack-windows-services/blob/master/build/Build.cs",
    "BuildFileSize": 17558,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Threading.Tasks;\r\nusing ICSharpCode.SharpZipLib.Zip;\r\nusing Microsoft.Build.Framework;\r\nusing Microsoft.Build.Tasks;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.CloudFoundry;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitHub;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.CloudFoundry.CloudFoundryTasks;\r\nusing FileMode = System.IO.FileMode;\r\nusing ZipFile = System.IO.Compression.ZipFile;\r\n\r\n[assembly: InternalsVisibleTo(\u0022WindowsServicesBuildpackTests\u0022)]\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    [Flags]\r\n    public enum StackType\r\n    {\r\n        Windows = 1,\r\n        Linux = 2\r\n    }\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n    const string BuildpackProjectName = \u0022WindowsServicesBuildpack\u0022;\r\n    AbsolutePath BuildpackProjectDirectory =\u003E RootDirectory / \u0022src\u0022 / BuildpackProjectName;\r\n    string GetPackageZipName(string runtime) =\u003E $\u0022{BuildpackProjectName}-{runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    \r\n    readonly StackType Stack = StackType.Windows;\r\n    \r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    [Parameter(\u0022Application directory against which buildpack will be applied\u0022)]\r\n    readonly string ApplicationDirectory;\r\n    \r\n    [Parameter(\u0022Cloud Foundry API endpoint\u0022)]\r\n    string CfApiUrl;\r\n    [Parameter(\u0022If SSL should be skipped when talking to Cloud Foundry\u0022)]\r\n    bool CfSkipSsl = true;\r\n    [Parameter(\u0022Cloud Foundry Username\u0022)]\r\n    string CfUsername;\r\n    [Parameter(\u0022Cloud Foundry Password\u0022)]\r\n    string CfPassword;\r\n    [Parameter(\u0022Cloud Foundry org\u0022)]\r\n    string CfOrg;\r\n    [Parameter(\u0022Cloud Foundry space\u0022)]\r\n    string CfSpace;\r\n    [Parameter(\u0022Skip loggin and target and use whatever the current CF cli is pointing at\u0022)]\r\n    bool CfSkipLogin;\r\n    \r\n    \r\n\r\n    IEnumerable\u003CPublishTarget\u003E PublishCombinations\r\n    {\r\n        get\r\n        {\r\n            if (Stack.HasFlag(StackType.Windows))\r\n                yield return new PublishTarget {Framework = \u0022net472\u0022, Runtime = \u0022win-x64\u0022};\r\n            // if (Stack.HasFlag(StackType.Windows))\r\n            //     yield return new PublishTarget {Framework = \u0022net472\u0022, Runtime = \u0022win-x86\u0022};\r\n        }\r\n    }\r\n\r\n    bool IsMultipleStacks =\u003E ((Stack \u0026 (Stack - 1)) != 0);\r\n    \r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    string ReleaseName =\u003E $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n    AbsolutePath GetPublishSampleDir(PublishTarget publishCombination) =\u003E ArtifactsDirectory / $\u0022sampleapp-{publishCombination.Runtime}\u0022 ;\r\n    string[] LifecycleHooks = {\u0022detect\u0022, \u0022supply\u0022, \u0022release\u0022, \u0022finalize\u0022, \u0022launch\u0022};\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        });\r\n\r\n    [Parameter(\u0022The URL of test buildpack. If not specified, will be set to where Release publishes to\u0022)]\r\n    string BuildpackUrl;\r\n\r\n    Target PublishSample =\u003E _ =\u003E _\r\n        .DependsOn(Clean)\r\n        .DependsOn(PublishSolution)\r\n        .Executes(async () =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var samplesFolder = RootDirectory / \u0022test\u0022 / \u0022SampleService\u0022;\r\n\r\n                var publishSampleDir = GetPublishSampleDir(publishCombination);\r\n                DeleteDirectory(publishSampleDir);\r\n                CopyDirectoryRecursively(samplesFolder / \u0022bin\u0022 / Configuration / publishCombination.Framework / publishCombination.Runtime / \u0022publish\u0022, publishSampleDir);\r\n\r\n                var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName));\r\n                var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n                var owner = gitIdParts[0];\r\n                var repoName = gitIdParts[1];\r\n                var latestRelease = await client.Repository.Release.GetLatest(owner, repoName);\r\n                var latestBuildpackUrl = latestRelease.Assets.FirstOrDefault(x =\u003E x.Name.Contains(\u0022x64\u0022))?.BrowserDownloadUrl;\r\n                ControlFlow.NotNull(latestBuildpackUrl, \u0022Can\u0027t find buildpack URL asset on github releases\u0022);\r\n\r\n                var manifestTemplate = File.ReadAllText(samplesFolder / \u0022manifest.yml\u0022);\r\n                var manifestText = manifestTemplate.Replace(\u0022{{buildpackurl}}\u0022, latestBuildpackUrl);\r\n                File.WriteAllText(publishSampleDir / \u0022manifest.yml\u0022, manifestText);\r\n                Logger.Block($\u0022Sample has been compiled and can be pushed from {samplesFolder}\u0022);\r\n            }\r\n        });\r\n\r\n    Target PublishSolution =\u003E _ =\u003E _\r\n        .Unlisted()\r\n        .DependsOn(Clean)\r\n        .Description(\u0022Executes DotNet publish on the solution\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetPublish(s =\u003E s\r\n                .SetProject(Solution)\r\n                .SetConfiguration(Configuration)\r\n\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .CombineWith(PublishCombinations, (ss,v) =\u003E ss\r\n                    .SetFramework(v.Framework)\r\n                    .SetRuntime(v.Runtime))\r\n            );\r\n        });\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\r\n        .DependsOn(Clean)\r\n        .DependsOn(PublishSolution)\r\n        .Triggers(PublishSample)\r\n        .Executes(async () =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var framework = publishCombination.Framework;\r\n                var runtime = publishCombination.Runtime;\r\n                var packageZipName = GetPackageZipName(runtime);\r\n                var workDirectory = TemporaryDirectory / \u0022pack\u0022;\r\n                EnsureCleanDirectory(TemporaryDirectory);\r\n                var buildpackProject = Solution.GetProject(BuildpackProjectName);\r\n                if(buildpackProject == null)\r\n                    throw new Exception($\u0022Unable to find project called {BuildpackProjectName} in solution {Solution.Name}\u0022);\r\n                var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022;\r\n                var workBinDirectory = workDirectory / \u0022bin\u0022;\r\n\r\n                var lifecycleBinaries = Solution.GetProjects(\u0022Lifecycle*\u0022)\r\n                    .Select(x =\u003E x.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022)\r\n                    .SelectMany(x =\u003E Directory.GetFiles(x).Where(path =\u003E LifecycleHooks.Any(hook =\u003E Path.GetFileName(path).StartsWith(hook))));\r\n\r\n                foreach (var lifecycleBinary in lifecycleBinaries)\r\n                {\r\n                    CopyFileToDirectory(lifecycleBinary, workBinDirectory, FileExistsPolicy.OverwriteIfNewer);\r\n                }\r\n                DeleteDirectory(publishDirectory / \u0022app.publish\u0022);\r\n                CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n                var tempZipFile = TemporaryDirectory / packageZipName;\r\n\r\n                ZipFile.CreateFromDirectory(workDirectory, tempZipFile, CompressionLevel.NoCompression, false);\r\n                MakeFilesInZipUnixExecutable(tempZipFile);\r\n                CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\r\n                Logger.Block(ArtifactsDirectory / packageZipName);\r\n            }\r\n        });\r\n    \r\n    \r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or amends existing) and uploads buildpack artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var runtime = publishCombination.Runtime;\r\n                var packageZipName = GetPackageZipName(runtime);\r\n                if (!GitRepository.IsGitHubRepository())\r\n                    throw new Exception(\u0022Only supported when git repo remote is github\u0022);\r\n    \r\n                var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\r\n                {\r\n                    Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n                };\r\n                var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n                var owner = gitIdParts[0];\r\n                var repoName = gitIdParts[1];\r\n    \r\n                \r\n                Release release;\r\n                try\r\n                {\r\n                    release = await client.Repository.Release.Get(owner, repoName, ReleaseName);\r\n                }\r\n                catch (NotFoundException)\r\n                {\r\n                    var newRelease = new NewRelease(ReleaseName)\r\n                    {\r\n                        Name = ReleaseName,\r\n                        Draft = false,\r\n                        Prerelease = false\r\n                    };\r\n                    release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n                }\r\n    \r\n                var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == packageZipName);\r\n                if (existingAsset != null)\r\n                {\r\n                    await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n                }\r\n    \r\n                var zipPackageLocation = ArtifactsDirectory / packageZipName;\r\n                var stream = File.OpenRead(zipPackageLocation);\r\n                var releaseAssetUpload = new ReleaseAssetUpload(packageZipName, \u0022application/zip\u0022, stream, TimeSpan.FromHours(1));\r\n                var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n                if(BuildpackUrl == null)\r\n                    BuildpackUrl = releaseAsset.BrowserDownloadUrl;\r\n                \r\n                Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n            }\r\n        });\r\n\r\n    Target AcceptanceTest =\u003E _ =\u003E _\r\n        .DependsOn(Release)\r\n        .Requires(() =\u003E CfApiUrl)\r\n        .Requires(() =\u003E CfUsername)\r\n        .Requires(() =\u003E CfPassword)\r\n        .Requires(() =\u003E CfOrg)\r\n        .Requires(() =\u003E CfSpace)\r\n        .Executes(async () =\u003E\r\n        {\r\n            if (!CfSkipLogin)\r\n            {\r\n                CloudFoundryApi(o =\u003E o\r\n                    .SetUrl(CfApiUrl)\r\n                    .SetSkipSSLValidation(CfSkipSsl));\r\n                CloudFoundryAuth(o =\u003E o\r\n                    .SetUsername(CfUsername)\r\n                    .SetPassword(CfPassword));\r\n                CloudFoundryCreateSpace(o =\u003E o\r\n                    .SetOrg(CfOrg)\r\n                    .SetSpace(CfSpace));\r\n                CloudFoundryTarget(o =\u003E o\r\n                    .SetOrg(CfOrg)\r\n                    .SetSpace(CfSpace));\r\n            }\r\n\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var appName = \u0022test-windows-service\u0022;\r\n                CloudFoundryDeleteApplication(o =\u003E o.SetAppName(appName));\r\n                var publishSampleDir = GetPublishSampleDir(publishCombination);\r\n                CloudFoundryPush(o =\u003E o\r\n                    .SetWorkingDirectory(publishSampleDir)\r\n                    .SetBuildpack(BuildpackUrl)\r\n                );\r\n                CloudFoundryStop(o =\u003E o.SetAppName(appName));\r\n                // await Task.Delay(10000);\r\n                var result = CloudFoundry($\u0022logs {appName} --recent\u0022);\r\n                ControlFlow.Assert(result.Any(x =\u003E x.Text.Contains(\u0022OnStart called\u0022)), \u0022OnStart was not called\u0022);\r\n                // ControlFlow.Assert(result.Any(x =\u003E x.Text.Contains(\u0022OnStop called\u0022)), \u0022OnStop was not called\u0022);\r\n                \r\n            }\r\n            \r\n        });\r\n\r\n\r\n\r\n    Target Detect =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027detect\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Requires(() =\u003E !IsMultipleStacks)\r\n        .Executes(() =\u003E\r\n        {\r\n            var framework = PublishCombinations.Single().Framework;\r\n            try\r\n            {\r\n                DotNetRun(s =\u003E s\r\n                    .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Detect\u0022).Path)\r\n                    .SetApplicationArguments(ApplicationDirectory)\r\n                    .SetConfiguration(Configuration)\r\n                    .SetFramework(framework));\r\n                Logger.Block(\u0022Detect returned \u0027true\u0027\u0022);\r\n            }\r\n            catch (ProcessException)\r\n            {\r\n                Logger.Block(\u0022Detect returned \u0027false\u0027\u0022);\r\n            }\r\n        });\r\n\r\n    Target Supply =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027supply\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Requires(() =\u003E !IsMultipleStacks)\r\n        .Executes(() =\u003E\r\n        {\r\n            var framework = PublishCombinations.Single().Framework;\r\n            var home = (AbsolutePath)Path.GetTempPath() / Guid.NewGuid().ToString();\r\n            var app = home / \u0022app\u0022;\r\n            var deps = home / \u0022deps\u0022;\r\n            var index = 0;\r\n            var cache = home / \u0022cache\u0022;\r\n            CopyDirectoryRecursively(ApplicationDirectory, app);\r\n\r\n            DotNetRun(s =\u003E s\r\n                .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Supply\u0022).Path)\r\n                .SetApplicationArguments($\u0022{app} {cache} {app} {deps} {index}\u0022)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(framework));\r\n            Logger.Block($\u0022Buildpack applied. Droplet is available in {home}\u0022);\r\n\r\n        });\r\n\r\n    public void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\r\n    {\r\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\r\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\r\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\r\n        {\r\n            output.SetLevel(9);\r\n            ZipEntry entry;\r\n\t\t\r\n            while ((entry = input.GetNextEntry()) != null)\r\n            {\r\n                var outEntry = new ZipEntry(entry.Name) {HostSystem = (int) HostSystemID.Unix};\r\n                var entryAttributes =  \r\n                    ZipEntryAttributes.ReadOwner | \r\n                    ZipEntryAttributes.ReadOther | \r\n                    ZipEntryAttributes.ReadGroup |\r\n                    ZipEntryAttributes.ExecuteOwner | \r\n                    ZipEntryAttributes.ExecuteOther | \r\n                    ZipEntryAttributes.ExecuteGroup;\r\n                entryAttributes = entryAttributes | (entry.IsDirectory ? ZipEntryAttributes.Directory : ZipEntryAttributes.Regular);\r\n                outEntry.ExternalFileAttributes = (int) (entryAttributes) \u003C\u003C 16; // https://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute\r\n                output.PutNextEntry(outEntry);\r\n                input.CopyTo(output);\r\n            }\r\n            output.Finish();\r\n            output.Flush();\r\n        }\r\n\r\n        DeleteFile(zipFile);\r\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\r\n    }\r\n    \r\n    [Flags]\r\n    enum ZipEntryAttributes\r\n    {\r\n        ExecuteOther = 1,\r\n        WriteOther = 2,\r\n        ReadOther = 4,\r\n\t\r\n        ExecuteGroup = 8,\r\n        WriteGroup = 16,\r\n        ReadGroup = 32,\r\n\r\n        ExecuteOwner = 64,\r\n        WriteOwner = 128,\r\n        ReadOwner = 256,\r\n\r\n        Sticky = 512, // S_ISVTX\r\n        SetGroupIdOnExecution = 1024,\r\n        SetUserIdOnExecution = 2048,\r\n\r\n        //This is the file type constant of a block-oriented device file.\r\n        NamedPipe = 4096,\r\n        CharacterSpecial = 8192,\r\n        Directory = 16384,\r\n        Block = 24576,\r\n        Regular = 32768,\r\n        SymbolicLink = 40960,\r\n        Socket = 49152\r\n\t\r\n    }\r\n    class PublishTarget\r\n    {\r\n        public string Framework { get; set; }\r\n        public string Runtime { get; set; }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 184136649,
    "FirstIndexed": "2020-04-25T15:47:03.6110709+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629787+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431328+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937205+02:00",
    "Name": "Xeinaemm.Standard",
    "Owner": "Xeinaemm",
    "HtmlUrl": "https://github.com/Xeinaemm/Xeinaemm.Standard",
    "Description": "Useful code\u0027s snippets that can be used in .NET",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Xeinaemm/Xeinaemm.Standard/blob/master/build/Build.cs",
    "BuildFileSize": 4510,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.CI.TeamCity;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.InspectCode;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tools.Slack;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.ControlFlow;\nusing static Nuke.Common.Gitter.GitterTasks;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tools.InspectCode.InspectCodeTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Nuke.Common.Tools.Slack.SlackTasks;\nusing Nuke.Common.Tools.NuGet;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelines(\n    AzurePipelinesImage.WindowsLatest,\n    InvokedTargets = new[] { nameof(Pack) },\n    NonEntryTargets = new[] { nameof(Restore) },\n    ExcludedTargets = new[] { nameof(Clean) })]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] bool IgnoreFailedSources;\n    [Parameter(\u0022NuGet Api Key\u0022)] readonly string ApiKey;\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://pkgs.dev.azure.com/Xeinaemm/Jarvis/_packaging/Jarvis-public/nuget/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PackagesDirectory =\u003E ArtifactsDirectory / \u0022packages\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetIgnoreFailedSources(IgnoreFailedSources));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .Produces(PackagesDirectory / \u0022*.nupkg\u0022)\n    .Executes(() =\u003E\n    {\n        DotNetPack(_ =\u003E _\n            .SetProject(Solution)\n            .SetNoBuild(InvokedTargets.Contains(Compile))\n            .SetConfiguration(Configuration)\n            .SetOutputDirectory(PackagesDirectory)\n            .SetVersion(GitVersion.NuGetVersionV2));\n    });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E\n        {\n            var packages = PackagesDirectory.GlobFiles(\u0022*.nupkg\u0022);\n\n            DotNetNuGetPush(_ =\u003E _\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)\n                    .SetArgumentConfigurator(x =\u003E x.Add(\u0022--interactive\u0022))\n                    .SetTargetPath(PackagesDirectory / \u0022*.nupkg\u0022));\n        });\n}\n"
  },
  {
    "Id": 184184158,
    "FirstIndexed": "2020-04-25T15:50:44.7354406+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632194+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433421+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939202+02:00",
    "Name": "Nullforce.Api.Derpibooru.JsonModels",
    "Owner": "nullforce-public",
    "HtmlUrl": "https://github.com/nullforce-public/Nullforce.Api.Derpibooru.JsonModels",
    "Description": "A C# wrapper for Derpibooru JSON models",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nullforce-public/Nullforce.Api.Derpibooru.JsonModels/blob/master/build/Build.cs",
    "BuildFileSize": 4048,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022NuGet API key for push - Default is empty string\u0022)]\n    readonly string NugetApiKey;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    readonly string NuGetSource = IsLocalBuild ? \u0022Local\u0022 : \u0022nuget.org\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022PackageVersion\u0022, GitVersion.NuGetVersionV2)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n\n            DotNetPack(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(OutputDirectory)\n                .SetProperty(\u0022PackageVersion\u0022, GitVersion.NuGetVersionV2)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoBuild()\n            );\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(TestsDirectory, \u0022**/*.csproj\u0022);\n\n            foreach (var testProject in testProjects)\n            {\n                DotNetTest(s =\u003E s\n                    .SetProjectFile(testProject)\n                    .SetConfiguration(Configuration)\n                    .SetResultsDirectory(OutputDirectory / \u0022TestResults\u0022)\n                    .SetLogger(\u0022trx\u0022)\n                    .EnableNoBuild()\n                );\n            }\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Compile)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            if (!IsLocalBuild \u0026\u0026 string.IsNullOrEmpty(NugetApiKey))\n            {\n                Logger.Error(\u0022NuGet API key was not provided. Unable to push NuGet package.\u0022);\n                return;\n            }\n\n            var nugetPackage = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).First();\n\n            DotNetNuGetPush(s =\u003E s\n                .SetSource(NuGetSource)\n                .SetTargetPath(nugetPackage)\n                .SetApiKey(NugetApiKey)\n            );\n        });\n}\n"
  },
  {
    "Id": 184773705,
    "FirstIndexed": "2020-04-25T15:47:03.6114725+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163146+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431339+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937217+02:00",
    "Name": "ProvisionData.Common",
    "Owner": "provisiondata",
    "HtmlUrl": "https://github.com/provisiondata/ProvisionData.Common",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/provisiondata/ProvisionData.Common/blob/master/build/Build.cs",
    "BuildFileSize": 4547,
    "BuildFileContent": "using Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing System;\r\nusing System.Linq;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.GitHub.ChangeLogExtensions;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    public static Int32 Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Parameter(\u0022Explicit framework to build\u0022)] readonly String Framework;\r\n    [Parameter(\u0022NuGet API Key\u0022)] readonly String NuGetApiKey;\r\n    [Parameter(\u0022Pdsi API Key\u0022)] readonly String PdsiApiKey;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    String ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .DependsOn(Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    Target Test =\u003E _ =\u003E _\r\n           .DependsOn(Compile)\r\n           .Executes(() =\u003E\r\n           {\r\n               DotNetTest(s =\u003E s\r\n                   .SetConfiguration(Configuration)\r\n                   .EnableNoBuild()\r\n                   .EnableNoRestore()\r\n                   .SetLogger(\u0022trx\u0022)\r\n                   .SetLogOutput(true)\r\n                   .SetFramework(Framework)\r\n                   .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022))\r\n                   .SetResultsDirectory(ArtifactsDirectory / \u0022tests\u0022));\r\n           });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Test)\r\n        .Executes(() =\u003E\r\n        {\r\n            var changeLog = GetCompleteChangeLog(ChangeLogFile)\r\n               .EscapeStringPropertyForMsBuild();\r\n\r\n            DotNetPack(s =\u003E s\r\n                .SetConfiguration(Configuration)\r\n                .EnableIncludeSymbols()\r\n                .EnableNoBuild()\r\n                .EnableNoRestore()\r\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022)\r\n                .SetPackageReleaseNotes(changeLog));\r\n        });\r\n\r\n    Target PublishToNuGet =\u003E _ =\u003E _\r\n         .DependsOn(Pack)\r\n         .Requires(() =\u003E NuGetApiKey)\r\n         .Requires(() =\u003E Equals(Configuration, Configuration.Release))\r\n         .Executes(() =\u003E\r\n         {\r\n             GlobFiles(ArtifactsDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\r\n             .NotEmpty()\r\n             .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\r\n             .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                 .SetTargetPath(x)\r\n                 .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                 .SetApiKey(NuGetApiKey)));\r\n         });\r\n\r\n    Target PublishToPdsi =\u003E _ =\u003E _\r\n         .DependsOn(Pack)\r\n         .Requires(() =\u003E PdsiApiKey)\r\n         .Requires(() =\u003E Equals(Configuration, Configuration.Release))\r\n         .Executes(() =\u003E\r\n         {\r\n             GlobFiles(ArtifactsDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\r\n                 .NotEmpty()\r\n                 .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                     .SetTargetPath(x)\r\n                     .SetSource(\u0022https://baget.pdsint.net/v3/index.json\u0022)\r\n                     .SetApiKey(PdsiApiKey)));\r\n         });\r\n}\r\n"
  },
  {
    "Id": 185118311,
    "FirstIndexed": "2020-04-25T15:47:03.611642+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631944+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431351+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937228+02:00",
    "Name": "route-service-auth-buildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/route-service-auth-buildpack",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/route-service-auth-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 8492,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing FileMode = System.IO.FileMode;\nusing ZipFile = System.IO.Compression.ZipFile;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public enum StackType\n    {\n        Windows,\n        Linux\n    }\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n    const string BuildpackProjectName = \u0022Pivotal.RouteService.Auth.Ingress.Buildpack\u0022;\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\n    readonly StackType Stack = StackType.Windows;\n\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GitHubToken;\n\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;\n    string Framework =\u003E Stack == StackType.Windows ? \u0022net47\u0022 : \u0022netcoreapp2.2\u0022;\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetRuntime(Runtime));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .Description(\u0022Compiles the buildpack\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info(Stack);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .Description(\u0022Execute tests\u0022)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\n            EnsureCleanDirectory(TemporaryDirectory);\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\n            var scriptsDirectory = RootDirectory / \u0022scripts\u0022;\n\n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n\n            var tempZipFile = TemporaryDirectory / PackageZipName;\n\n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\n            MakeFilesInZipUnixExecutable(tempZipFile);\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\n            Logger.Block(ArtifactsDirectory / PackageZipName);\n\n        });\n\n\n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\n        .DependsOn(Publish)\n        .Requires(() =\u003E GitHubToken)\n        .Executes(async () =\u003E\n        {\n            if (!GitRepository.IsGitHubRepository())\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n\n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\n            {\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\n            };\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n            var owner = gitIdParts[0];\n            var repoName = gitIdParts[1];\n\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n            Release release;\n            try\n            {\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\n            }\n            catch (NotFoundException)\n            {\n                var newRelease = new NewRelease(releaseName)\n                {\n                    Name = releaseName,\n                    Draft = false,\n                    Prerelease = false\n                };\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\n            }\n\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\n            if (existingAsset != null)\n            {\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n            }\n\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\n\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\n        });\n\n    public static void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\n    {\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\n        {\n            output.SetLevel(9);\n            ZipEntry entry;\n\n            while ((entry = input.GetNextEntry()) != null)\n            {\n                var outEntry = new ZipEntry(entry.Name);\n                outEntry.HostSystem = (int)HostSystemID.Unix;\n                outEntry.ExternalFileAttributes = -2115174400;\n                output.PutNextEntry(outEntry);\n                input.CopyTo(output);\n            }\n            output.Finish();\n            output.Flush();\n        }\n\n        DeleteFile(zipFile);\n        RenameFile(tmpFileName, zipFile, FileExistsPolicy.Overwrite);\n    }\n}\n"
  },
  {
    "Id": 185595639,
    "FirstIndexed": "2020-04-25T15:59:09.1625788+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625805+02:00",
    "LastDetailUpdated": "0001-01-01T00:00:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "AzureUploader",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/AzureUploader",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 185656523,
    "FirstIndexed": "2020-04-25T15:50:44.7357177+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627682+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434497+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940209+02:00",
    "Name": "Nuke.Useful",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/Nuke.Useful",
    "Description": "Collection of useful classes for working with Nuke (nuke.build)",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/Nuke.Useful/blob/master/build/Build.cs",
    "BuildFileSize": 252,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 185680808,
    "FirstIndexed": "2020-04-25T15:47:03.6115197+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631614+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431362+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893724+02:00",
    "Name": "AvaloniaDockApplication",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/AvaloniaDockApplication",
    "Description": "Sample Dock application.",
    "Archived": false,
    "Stars": 27,
    "Watchers": 1,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/AvaloniaDockApplication/blob/master/build/build/Build.cs",
    "BuildFileSize": 3744,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 186215581,
    "FirstIndexed": "2020-04-25T15:47:03.6116824+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632137+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431373+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937245+02:00",
    "Name": "Nullforce.Api.DeviantArt.JsonModels",
    "Owner": "nullforce-public",
    "HtmlUrl": "https://github.com/nullforce-public/Nullforce.Api.DeviantArt.JsonModels",
    "Description": "A C# wrapper for DeviantArt JSON models",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nullforce-public/Nullforce.Api.DeviantArt.JsonModels/blob/master/build/Build.cs",
    "BuildFileSize": 4048,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022NuGet API key for push - Default is empty string\u0022)]\n    readonly string NugetApiKey;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    readonly string NuGetSource = IsLocalBuild ? \u0022Local\u0022 : \u0022nuget.org\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetProperty(\u0022PackageVersion\u0022, GitVersion.NuGetVersionV2)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n\n            DotNetPack(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(OutputDirectory)\n                .SetProperty(\u0022PackageVersion\u0022, GitVersion.NuGetVersionV2)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoBuild()\n            );\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testProjects = GlobFiles(TestsDirectory, \u0022**/*.csproj\u0022);\n\n            foreach (var testProject in testProjects)\n            {\n                DotNetTest(s =\u003E s\n                    .SetProjectFile(testProject)\n                    .SetConfiguration(Configuration)\n                    .SetResultsDirectory(OutputDirectory / \u0022TestResults\u0022)\n                    .SetLogger(\u0022trx\u0022)\n                    .EnableNoBuild()\n                );\n            }\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Compile)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            if (!IsLocalBuild \u0026\u0026 string.IsNullOrEmpty(NugetApiKey))\n            {\n                Logger.Error(\u0022NuGet API key was not provided. Unable to push NuGet package.\u0022);\n                return;\n            }\n\n            var nugetPackage = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).First();\n\n            DotNetNuGetPush(s =\u003E s\n                .SetSource(NuGetSource)\n                .SetTargetPath(nugetPackage)\n                .SetApiKey(NugetApiKey)\n            );\n        });\n}\n"
  },
  {
    "Id": 186393928,
    "FirstIndexed": "2020-04-25T15:47:03.6116801+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163212+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431385+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937257+02:00",
    "Name": "AopLite.Net",
    "Owner": "A-HSien",
    "HtmlUrl": "https://github.com/A-HSien/AopLite.Net",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/A-HSien/AopLite.Net/blob/master/build/Build.cs",
    "BuildFileSize": 3686,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration =\n        //IsLocalBuild ?\n        //Configuration.Debug :\n        Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022Build Started : {Configuration}\u0022);\n            Logger.Info($\u0022AssemblyVersion : {GitVersion.GetNormalizedAssemblyVersion()}\u0022);\n            Logger.Info($\u0022FileVersion : {GitVersion.GetNormalizedFileVersion()}\u0022);\n            Logger.Info($\u0022InformationalVersion : {GitVersion.InformationalVersion}\u0022);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .Executes(() =\u003E\n    {\n        DotNetTest(s =\u003E s\n            .SetProjectFile(Solution.GetProject(\u0022AopLite.Net.HttpApiTesting.Test\u0022))\n            .SetConfiguration(Configuration)\n            .EnableNoBuild()\n            .EnableNoRestore()\n            .SetLogger(\u0022trx\u0022)\n            .SetLogOutput(true)\n            .SetResultsDirectory(TestsDirectory));\n    });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            Logger.Info($\u0022Pack Started : Nuget packages will be created in \u0027{OutputDirectory}\u0027\u0022);\n            Logger.Info($\u0022Version : {GitVersion.NuGetVersionV2}\u0022);\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022AopLite.Net.HttpProxyClient\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory));\n        });\n}\n"
  },
  {
    "Id": 186610807,
    "FirstIndexed": "2020-04-25T15:50:44.7361653+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632109+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434849+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940568+02:00",
    "Name": "pwiz-ef47e62",
    "Owner": "tachengxmu",
    "HtmlUrl": "https://github.com/tachengxmu/pwiz-ef47e62",
    "Description": "Build ProteoWizard",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "ProteoWizard-ef47e62f0f9e759988b2436c04018580782669ed/src/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileUrl": "https://github.com/tachengxmu/pwiz-ef47e62/blob/master/ProteoWizard-ef47e62f0f9e759988b2436c04018580782669ed/src/pwiz_tools/Skyline/SkylineTester/TabBuild.cs",
    "BuildFileSize": 11172,
    "BuildFileContent": "\uFEFF/*\n * Original author: Don Marsh \u003Cdonmarsh .at. u.washington.edu\u003E,\n *                  MacCoss Lab, Department of Genome Sciences, UW\n *\n * Copyright 2013 University of Washington - Seattle, WA\n * \n * Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Net;\nusing System.Windows.Forms;\nusing pwiz.Common.SystemUtil;\n\nnamespace SkylineTester\n{\n    public class TabBuild : TabBase\n    {\n        public TabBuild()\n        {\n            MainWindow.LabelSpecifyPath.Text =\n                \u0022(Specify absolute path or relative path from {0} folder)\u0022.With(Path.GetFileName(MainWindow.RootDir));\n        }\n\n        public override void Enter()\n        {\n            var buildRoot = MainWindow.GetBuildRoot();\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\n            MainWindow.DefaultButton = MainWindow.RunBuild;\n        }\n\n        public override bool Run()\n        {\n            if (!MainWindow.HasBuildPrerequisites)\n                return false;\n            var architectures = GetArchitectures();\n            if (architectures.Count == 0)\n            {\n                MessageBox.Show(\u0022Select 32 or 64 bit architecture (or both).\u0022);\n                return false;\n            }\n\n            StartLog(\u0022Build\u0022, MainWindow.DefaultLogFile, true);\n            CreateBuildCommands(\n                GetBranchUrl(),\n                MainWindow.GetBuildRoot(), \n                architectures, \n                MainWindow.NukeBuild.Checked, \n                MainWindow.UpdateBuild.Checked,\n                MainWindow.RunBuildVerificationTests.Checked);\n            MainWindow.RunCommands();\n            return true;\n        }\n\n        public override bool Stop(bool success)\n        {\n            if (success \u0026\u0026 MainWindow.StartSln.Checked \u0026\u0026 MainWindow.Devenv != null)\n            {\n                var buildRoot = MainWindow.GetBuildRoot();\n                var slnDirectory = Path.Combine(buildRoot, @\u0022pwiz_tools\\Skyline\u0022);\n                var process = new Process\n                {\n                    StartInfo =\n                    {\n                        FileName = Path.Combine(slnDirectory, \u0022Skyline.sln\u0022),\n                        WorkingDirectory = slnDirectory,\n                        UseShellExecute = true,\n                    }\n                };\n                process.Start();\n            }\n\n            return true;\n        }\n\n        public override int Find(string text, int position)\n        {\n            return VerifyFind(text, position, \u0022Build\u0022);\n        }\n\n        public static List\u003Cint\u003E GetArchitectures()\n        {\n            var architectures = new List\u003Cint\u003E();\n            if (MainWindow.Build32.Checked)\n                architectures.Add(32);\n            if (MainWindow.Build64.Checked)\n                architectures.Add(64);\n            return architectures;\n        }\n\n        public static string GetMasterUrl()\n        {\n            return @\u0022https://github.com/ProteoWizard/pwiz\u0022;\n        }\n\n        public static string GetBranchUrl()\n        {\n            return MainWindow.BuildTrunk.Checked\n                ? GetMasterUrl()\n                : MainWindow.BranchUrl.Text;\n        }\n\n        public static bool CreateBuildCommands(\n            string branchUrl, \n            string buildRoot, \n            IList\u003Cint\u003E architectures, \n            bool nukeBuild, \n            bool updateBuild,\n            bool runBuildTests)\n        {\n            var commandShell = MainWindow.CommandShell;\n            var branchParts = branchUrl.Split(\u0027/\u0027);\n            var branchName = branchParts[branchParts.Length - 1].Equals(\u0022pwiz\u0022)\n                ? \u0022Skyline (master)\u0022\n                : \u0022Skyline ({0}/{1})\u0022.With(branchParts[branchParts.Length - 2], branchParts[branchParts.Length - 1]);\n            var git = MainWindow.Git;\n\n            // Determine toolset requirement based on .Net usage\n            // Pull a file like\n            // https://raw.githubusercontent.com/ProteoWizard/pwiz/master/pwiz_tools/Skyline/Skyline.csproj\n            // or\n            // https://raw.githubusercontent.com/ProteoWizard/pwiz/feature/VS2017-update/pwiz_tools/Skyline/Skyline.csproj\n            var toolset = \u0022msvc-14.1\u0022; // VS2017\n            for (var retry = 60; retry-- \u003E0;)\n            {\n                var csProjFileUrl = \u0022[unknown]\u0022;\n                try\n                {\n                     csProjFileUrl = GetMasterUrl().Equals(branchUrl)\n                        ? \u0022https://raw.githubusercontent.com/ProteoWizard/pwiz/master/pwiz_tools/Skyline/Skyline.csproj\u0022\n                        : \u0022https://raw.githubusercontent.com/ProteoWizard/pwiz/\u0022 \u002B GetBranchPath(branchUrl) \u002B \u0022/pwiz_tools/Skyline/Skyline.csproj\u0022;\n                    var csProjText = (new WebClient()).DownloadString(csProjFileUrl);\n                    var dotNetVersion = csProjText.Split(new[] {\u0022TargetFrameworkVersion\u0022}, StringSplitOptions.None)[1].Split(\u0027v\u0027)[1].Split(new []{\u0027.\u0027});\n                    if ((int.Parse(dotNetVersion[0]) \u003E= 4) \u0026\u0026 (int.Parse(dotNetVersion[1]) \u003E= 7))\n                    {\n                        toolset = \u0022msvc-14.1\u0022; // VS2017 for .Net 4.7.x or greater\n                    }\n                    break;\n                }\n                catch (Exception e)\n                {\n\n                    commandShell.AddImmediate(\u0022Trouble fetching {0} for .Net version inspection ({1})\u0022, csProjFileUrl, e.Message);\n                    if (retry == 0)\n                        throw;\n                    commandShell.AddImmediate(\u0022retrying...\u0022);\n                    commandShell.IsWaiting = true;\n                    // CONSIDER: Wait for up to 60 seconds while pumping messages for UI. Kind of a hack, but better than\n                    //           blocking the UI thread completely while trying.\n                    var watch = new Stopwatch();\n                    watch.Start();\n                    while (watch.Elapsed.TotalSeconds \u003C 60)\n                    {\n                        if (!commandShell.IsWaiting)\n                            return false;   // Cancelled\n                        Application.DoEvents();\n                    }\n                    commandShell.IsWaiting = false;\n                }\n            }\n\n            var architectureList = string.Join(\u0022- and \u0022, architectures);\n            commandShell.Add(\u0022# Build {0} {1}-bit...\u0022, branchName, architectureList);\n\n            if (Directory.Exists(buildRoot))\n            {\n                if (nukeBuild)\n                {\n                    commandShell.Add(\u0022#@ Deleting Build directory...\\n\u0022);\n                    commandShell.Add(\u0022# Deleting Build directory...\u0022);\n                    commandShell.Add(\u0022rmdir /s {0}\u0022, buildRoot.Quote());\n                }\n                else if (updateBuild)\n                {\n                    commandShell.Add(\u0022#@ Updating Build directory...\\n\u0022);\n                    commandShell.Add(\u0022# Updating Build directory...\u0022);\n                    commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\n                    commandShell.Add(\u0022{0} pull\u0022, git.Quote());\n                }\n            }\n\n            if (nukeBuild || updateBuild)\n            {\n                string tutorialsFolder = Path.Combine(PathEx.GetDownloadsPath(), \u0022Tutorials\u0022);\n                commandShell.Add(\u0022#@ Deleting Tutorials directory...\\n\u0022);\n                commandShell.Add(\u0022# Deleting Tutorials directory...\u0022);\n                commandShell.Add(\u0022rmdir /s {0}\u0022, tutorialsFolder);\n            }\n\n            if (nukeBuild)\n            {\n                commandShell.Add(\u0022#@ Checking out {0} source files...\\n\u0022, branchName);\n                commandShell.Add(\u0022# Checking out {0} source files...\u0022, branchName);\n                if (branchName.Contains(\u0022master\u0022))\n                {\n                    commandShell.Add(\u0022{0} clone {1} {2}\u0022, git.Quote(), branchUrl.Quote(), buildRoot.Quote());\n                }\n                else\n                {\n                    var branch = branchUrl.Split(new[] {\u0022tree/\u0022}, StringSplitOptions.None)[1];\n                    commandShell.Add(\u0022{0} clone {1} -b {2} {3}\u0022, git.Quote(), GetMasterUrl().Quote(), branch.Quote(), buildRoot.Quote());\n                }\n            }\n\n            commandShell.Add(\u0022# Building Skyline...\u0022);\n            commandShell.Add(\u0022cd {0}\u0022, buildRoot.Quote());\n            foreach (int architecture in architectures)\n            {\n                commandShell.Add(\u0022#@ Building Skyline {0} bit...\\n\u0022, architecture);\n                commandShell.Add(\u0022{0} {1} {2} --i-agree-to-the-vendor-licenses toolset={3} nolog\u0022,\n                    Path.Combine(buildRoot, @\u0022pwiz_tools\\build-apps.bat\u0022).Quote(),\n                    architecture,\n                    runBuildTests ? \u0022pwiz_tools/Skyline\u0022 : \u0022pwiz_tools/Skyline//Skyline.exe\u0022,\n                    toolset);\n            }\n\n            commandShell.Add(\u0022# Build done.\u0022);\n            return true;\n        }\n\n        private static string GetBranchPath(string branchUrl)\n        {\n            const string splitString = \u0022/pwiz/tree/\u0022;\n            var branchHalves = branchUrl.Split(new[] { splitString }, StringSplitOptions.None);\n            if (branchHalves.Length == 1)\n                throw new ArgumentException(string.Format(\u0022The branch URL {0} must contain the branch prefix {1}\u0022, branchUrl, splitString));\n            // Return the part after the split string\n            return branchHalves[1];\n        }\n\n        public void DeleteBuild()\n        {\n            var buildRoot = MainWindow.GetBuildRoot();\n            if (!Directory.Exists(buildRoot) ||\n                MessageBox.Show(MainWindow, \u0022Delete \\\u0022\u0022 \u002B buildRoot \u002B \u0022\\\u0022 folder?\u0022, \u0022Confirm delete\u0022,\n                    MessageBoxButtons.OKCancel) != DialogResult.OK)\n            {\n                return;\n            }\n\n            using (var deleteWindow = new DeleteWindow(buildRoot))\n            {\n                deleteWindow.ShowDialog();\n            }\n\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(buildRoot);\n        }\n\n        public void BrowseBuild()\n        {\n            using (var dlg = new FolderBrowserDialog\n            {\n                Description = \u0022Select or create a root folder for build source files.\u0022,\n                ShowNewFolderButton = true\n            })\n            {\n                if (dlg.ShowDialog(MainWindow) == DialogResult.OK)\n                    MainWindow.BuildRoot.Text = dlg.SelectedPath;\n            }\n\n            MainWindow.ButtonDeleteBuild.Enabled = Directory.Exists(MainWindow.GetBuildRoot()); // MainWindow.GetBuildRoot() is the directory that actually gets deleted in DeleteBuild()\n        }\n    }\n}\n"
  },
  {
    "Id": 186654036,
    "FirstIndexed": "2020-04-25T15:50:44.736163+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632097+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434838+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940556+02:00",
    "Name": "ThrowawayDb",
    "Owner": "Zaid-Ajaj",
    "HtmlUrl": "https://github.com/Zaid-Ajaj/ThrowawayDb",
    "Description": "Dead simple integration tests with SQL Server or Postgres throwaway databases that are created on the fly, used briefly then disposed of automagically.",
    "Archived": false,
    "Stars": 49,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Zaid-Ajaj/ThrowawayDb/blob/master/build/Build.cs",
    "BuildFileSize": 6022,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tooling.ProcessTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    static AbsolutePath Source =\u003E RootDirectory / \u0022src\u0022;\n    static AbsolutePath ThrowawayDb =\u003E Source / \u0022ThrowawayDb\u0022; \n    static AbsolutePath ThrowawayDbPostgres =\u003E Source / \u0022ThrowawayDb.Postgres\u0022;\n    static AbsolutePath ThrowawayDbTests =\u003E RootDirectory / \u0022tests\u0022 / \u0022ThrowawayDb\u0022;\n    static AbsolutePath ThrowawayDbPostgresTests =\u003E RootDirectory / \u0022tests\u0022 / \u0022ThrowawayDb.Postgres\u0022;\n    static AbsolutePath PublishDir =\u003E RootDirectory / \u0022publish\u0022;\n    static readonly string DOTNET = \u0022dotnet\u0022;\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Target Clean =\u003E task =\u003E \n      task  \n        .Executes(() =\u003E\n        {\n            var directories = new List\u003Cstring\u003E {\n                ThrowawayDb / \u0022bin\u0022,\n                ThrowawayDb / \u0022obj\u0022, \n                ThrowawayDbPostgres / \u0022bin\u0022, \n                ThrowawayDbPostgres / \u0022obj\u0022,\n                ThrowawayDbTests / \u0022bin\u0022,\n                ThrowawayDbTests / \u0022obj\u0022,\n                ThrowawayDbPostgresTests / \u0022bin\u0022,\n                ThrowawayDbPostgresTests / \u0022obj\u0022,\n                PublishDir\n            };\n\n            foreach(var dir in directories) \n            {\n                DeleteDirectory(dir);\n            }\n        });\n\n    Target Compile =\u003E task =\u003E\n      task\n        .DependsOn(Clean)\n        .Executes(() =\u003E {\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, ThrowawayDb).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, ThrowawayDb).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, ThrowawayDbPostgres).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, ThrowawayDbPostgres).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, ThrowawayDbTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, ThrowawayDbTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, ThrowawayDbPostgresTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, ThrowawayDbPostgresTests).AssertZeroExitCode();\n        });\n\n    Target Test =\u003E task =\u003E \n      task\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            StartProcess(DOTNET, \u0022restore\u0022, ThrowawayDbTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, ThrowawayDbTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022run\u0022, ThrowawayDbTests).AssertZeroExitCode();\n\n            StartProcess(DOTNET, \u0022restore\u0022, ThrowawayDbPostgresTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022build\u0022, ThrowawayDbPostgresTests).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022run\u0022, ThrowawayDbPostgresTests).AssertZeroExitCode();\n        });\n\n    Target PackThrowawayDb =\u003E task =\u003E\n      task \n        .DependsOn(Compile)\n        .Executes(() =\u003E \n        {\n            var packCmd = $\u0022pack -c Release -o {PublishDir}\u0022;\n            StartProcess(DOTNET, packCmd, ThrowawayDb).AssertZeroExitCode();\n        });\n\n    Target PublishThrowawayDb =\u003E task =\u003E\n      task\n        .DependsOn(PackThrowawayDb) \n        .Executes(() =\u003E \n        {\n            var nugetFile = Directory.GetFiles(PublishDir).FirstOrDefault() ?? \u0022\u0022;\n            if (!nugetFile.EndsWith(\u0022.nupkg\u0022))\n            {\n                Logger.Error(\u0022No nuget package found\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            Logger.Info($\u0022About to publish nuget package: {nugetFile}\u0022);\n            var nugetApiKey = EnsureVariable(\u0022NUGET_KEY\u0022) ?? \u0022\u0022;\n\n            if (string.IsNullOrWhiteSpace(nugetApiKey))\n            {\n                Logger.Error(\u0022Nuget API Key was not setup on your local machine, missing environment variable NUGET_KEY\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            var nugetFileName = new FileInfo(nugetFile).Name;\n            StartProcess(DOTNET, $\u0022nuget push {nugetFileName} -s https://api.nuget.org/v3/index.json -k {nugetApiKey}\u0022, PublishDir).AssertZeroExitCode();\n        });\n\n    Target PackThrowawayDbPostgres =\u003E task =\u003E\n      task \n        .DependsOn(Compile)\n        .Executes(() =\u003E \n        {\n            var packCmd = $\u0022pack -c Release -o {PublishDir}\u0022;\n            StartProcess(DOTNET, packCmd, ThrowawayDbPostgres).AssertZeroExitCode();\n        });\n\n    Target PublishThrowawayDbPostgres =\u003E task =\u003E\n      task\n        .DependsOn(PackThrowawayDbPostgres) \n        .Executes(() =\u003E \n        {\n            var nugetFile = Directory.GetFiles(PublishDir).FirstOrDefault() ?? \u0022\u0022;\n            if (!nugetFile.EndsWith(\u0022.nupkg\u0022))\n            {\n                Logger.Error(\u0022No nuget package found\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            Logger.Info($\u0022About to publish nuget package: {nugetFile}\u0022);\n            var nugetApiKey = EnsureVariable(\u0022NUGET_KEY\u0022) ?? \u0022\u0022;\n\n            if (string.IsNullOrWhiteSpace(nugetApiKey))\n            {\n                Logger.Error(\u0022Nuget API Key was not setup on your local machine, missing environment variable NUGET_KEY\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            var nugetFileName = new FileInfo(nugetFile).Name;\n            StartProcess(DOTNET, $\u0022nuget push {nugetFileName} -s https://api.nuget.org/v3/index.json -k {nugetApiKey}\u0022, PublishDir).AssertZeroExitCode();\n        });        \n}\n"
  },
  {
    "Id": 187889795,
    "FirstIndexed": "2020-04-25T15:50:44.7361602+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163208+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434826+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940545+02:00",
    "Name": "Elmish.AnimatedTree",
    "Owner": "Zaid-Ajaj",
    "HtmlUrl": "https://github.com/Zaid-Ajaj/Elmish.AnimatedTree",
    "Description": "An animated tree user interface made for Elmish applications",
    "Archived": false,
    "Stars": 10,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Zaid-Ajaj/Elmish.AnimatedTree/blob/master/build/Build.cs",
    "BuildFileSize": 3285,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tooling.ProcessTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    static AbsolutePath Source =\u003E RootDirectory / \u0022src\u0022;\n    static AbsolutePath Demo =\u003E RootDirectory / \u0022demo\u0022;\n    static AbsolutePath PublishDir =\u003E RootDirectory / \u0022publish\u0022;\n    static readonly string DOTNET = \u0022dotnet\u0022;\n    static readonly string NODE = \u0022node\u0022;\n    static readonly string NPM = \u0022npm\u0022;\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Target Clean =\u003E task =\u003E \n      task  \n        .Executes(() =\u003E\n        {\n            var directories = new List\u003Cstring\u003E {\n                Source / \u0022bin\u0022,\n                Source / \u0022obj\u0022, \n                Demo / \u0022bin\u0022,\n                Demo / \u0022obj\u0022,\n                PublishDir\n            };\n\n            foreach(var dir in directories) {\n                DeleteDirectory(dir);\n            }\n        });\n\n    Target Restore =\u003E task =\u003E\n      task\n        .DependsOn(Clean)\n        .Executes(() =\u003E \n        {\n            StartProcess(NPM, \u0022install\u0022, RootDirectory).AssertZeroExitCode();\n        });\n\n    Target Compile =\u003E task =\u003E\n      task\n        .DependsOn(Restore)\n        .Executes(() =\u003E {\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, Source).AssertZeroExitCode();\n            StartProcess(DOTNET, \u0022restore --no-cache\u0022, Demo).AssertZeroExitCode();\n            StartProcess(NPM, \u0022run build\u0022, RootDirectory).AssertZeroExitCode();\n        });\n\n    Target Pack =\u003E task =\u003E\n      task \n        .DependsOn(Clean)\n        .Executes(() =\u003E \n        {\n            var packCmd = $\u0022pack -c Release -o {PublishDir}\u0022;\n            StartProcess(DOTNET, packCmd, Source).AssertZeroExitCode();\n        });\n\n    Target Publish =\u003E task =\u003E\n      task\n        .DependsOn(Pack) \n        .Executes(() =\u003E \n        {\n            var nugetFile = Directory.GetFiles(PublishDir).FirstOrDefault() ?? \u0022\u0022;\n            if (!nugetFile.EndsWith(\u0022.nupkg\u0022))\n            {\n                Logger.Error(\u0022No nuget package found\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            Logger.Info($\u0022About to publish nuget package: {nugetFile}\u0022);\n            var nugetApiKey = EnsureVariable(\u0022NUGET_KEY\u0022) ?? \u0022\u0022;\n\n            if (string.IsNullOrWhiteSpace(nugetApiKey))\n            {\n                Logger.Error(\u0022Nuget API Key was not setup on your local machine, missing environment variable NUGET_KEY\u0022);\n                System.Diagnostics.Process.GetCurrentProcess().Kill();\n            }\n\n            var nugetFileName = new FileInfo(nugetFile).Name;\n            StartProcess(DOTNET, $\u0022nuget push {nugetFileName} -s https://api.nuget.org/v3/index.json -k {nugetApiKey}\u0022, PublishDir).AssertZeroExitCode();\n        });\n}\n"
  },
  {
    "Id": 188103619,
    "FirstIndexed": "2020-04-25T15:47:03.6116773+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631835+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843139+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937268+02:00",
    "Name": "kerberos-auth-egress-wcf-client-interceptor",
    "Owner": "alfusinigoj",
    "HtmlUrl": "https://github.com/alfusinigoj/kerberos-auth-egress-wcf-client-interceptor",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/alfusinigoj/kerberos-auth-egress-wcf-client-interceptor/blob/master/build/Build.cs",
    "BuildFileSize": 9007,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022ApiKey for the specified source.\u0022)]\n    readonly string SourceApiKey;\n\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GithubApiKey;\n\n    const string nugetSourceUrl = @\u0022https://api.nuget.org/v3/index.json\u0022;\n    const string mygetSourceUrl = @\u0022https://www.myget.org/F/ajaganathan/api/v2/package\u0022;\n\n    [Parameter(\u0022Source url for the nuget/myget repository\u0022)]\n    readonly string Source = mygetSourceUrl;\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitVersion]\n    readonly GitVersion GitVersion;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ProjectDirectory =\u003E SourceDirectory / \u0022RouteServiceIwaWcfInterceptor\u0022;\n    AbsolutePath ProjectFile =\u003E ProjectDirectory / \u0022RouteServiceIwaWcfInterceptor.csproj\u0022;\n    AbsolutePath NuspecFile =\u003E ProjectDirectory / \u0022RouteServiceIwaWcfInterceptor.nuspec\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            //TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                //.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetAssemblyVersion(\u00221.0.0.0\u0022) //For the sake of buildpack configuring behaviour extension\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .Executes(() =\u003E\n    {\n        var preReleaseTag = Source.Contains(\u0022nuget\u0022) ? \u0022beta\u0022 : \u0022alpha\u0022;\n        RunProcess(\u0022nuget.exe\u0022, $\u0022pack {ProjectFile} -Version {GitVersion.MajorMinorPatch}-{preReleaseTag} -OutputDirectory {ArtifactsDirectory} -Properties Configuration={Configuration}\u0022);\n    });\n\n    Target Push =\u003E _ =\u003E _\n    .DependsOn(Pack)\n    .Requires(() =\u003E Source)\n    .Requires(() =\u003E Configuration)\n    .Requires(() =\u003E SourceApiKey)\n    .Requires(() =\u003E GithubApiKey)\n    .Executes(() =\u003E\n    {\n        GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022).NotEmpty()\n            .Where(artifactFullPath =\u003E !artifactFullPath.EndsWith(\u0022.symbols.nupkg\u0022))\n            .ForEach(artifactFullPath =\u003E\n            {\n                if (Path.IsPathRooted(Source))\n                {\n                    throw new Exception($\u0022Source should be a nuget or myget url for executing target \u0027Push\u0027\u0022);\n                }\n                else\n                {\n                    ReleaseInGitHub(artifactFullPath);\n\n                    Logger.Log(LogLevel.Normal, $\u0022Pushing to nuget source {Source}\u0022);\n\n                    DotNetTasks.DotNetNuGetPush(s =\u003E s\n                        .SetApiKey(SourceApiKey)\n                        .SetTargetPath(artifactFullPath)\n                        .SetSource(Source));\n\n                    Logger.Log(LogLevel.Normal, $\u0022Pushed to nuget source {Source} completed successfully\u0022);\n                }\n            });\n    });\n\n    Target Add =\u003E _ =\u003E _\n   .DependsOn(Pack)\n   .Requires(() =\u003E Source)\n   .Executes(() =\u003E\n   {\n       GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022).NotEmpty()\n           .Where(artifactFullPath =\u003E !artifactFullPath.EndsWith(\u0022.symbols.nupkg\u0022))\n           .ForEach(artifactFullPath =\u003E\n           {\n               if (Path.IsPathRooted(Source))\n               {\n                   RunProcess(\u0022nuget.exe\u0022, $\u0022add {Path.Combine(ArtifactsDirectory, artifactFullPath)} -Source {Source}\u0022);\n               }\n               else\n               {\n                   throw new Exception($\u0022Source should be an absolute path for executing target \u0027Add\u0027\u0022);\n               }\n           });\n   });\n\n    private void ReleaseInGitHub(string artifactFullPath)\n    {\n\n        if (!GitRepository.IsGitHubRepository())\n            throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n\n        var preReleaseTag = Source.Contains(\u0022nuget\u0022) ? \u0022beta\u0022 : \u0022alpha\u0022;\n\n        var packageName = Path.GetFileName(artifactFullPath);\n\n        var client = new GitHubClient(new ProductHeaderValue(Path.GetFileNameWithoutExtension(artifactFullPath)))\n        {\n            Credentials = new Credentials(GithubApiKey, AuthenticationType.Bearer)\n        };\n\n        Logger.Log(LogLevel.Normal, $\u0022Releasing in Github {client.BaseAddress}\u0022);\n\n        var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n        var owner = gitIdParts[0];\n        var repoName = gitIdParts[1];\n\n        var releaseName = $\u0022v{GitVersion.MajorMinorPatch}-{preReleaseTag}\u0022;\n\n        Release release;\n        try\n        {\n            Logger.Log(LogLevel.Normal, $\u0022Checking for existence of release with name {releaseName}...\u0022);\n\n            release = client.Repository.Release.Get(owner, repoName, releaseName).Result;\n\n            Logger.Log(LogLevel.Normal, $\u0022Found release {releaseName} at {release.AssetsUrl}\u0022);\n        }\n        catch (Exception)\n        {\n            Logger.Log(LogLevel.Normal, $\u0022Release with name {releaseName} not found.. so creating new...\u0022); \n\n            var newRelease = new NewRelease(releaseName)\n            {\n                Name = releaseName,\n                Draft = false,\n                Prerelease = false,\n                Body = \u0022Package sources: \\n https://www.nuget.org/packages/PivotalServices.WcfClient.Kerberos.Interceptor \\n https://www.myget.org/feed/ajaganathan/package/nuget/PivotalServices.WcfClient.Kerberos.Interceptor\u0022\n            };\n            release = client.Repository.Release.Create(owner, repoName, newRelease).Result;\n        }\n\n        var existingAsset = release.Assets.FirstOrDefault(y =\u003E y.Name == packageName);\n\n        if (existingAsset != null)\n        {\n            Logger.Log(LogLevel.Normal, $\u0022Deleting assert {existingAsset.Name}...\u0022);\n\n            client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n        }\n\n        var releaseAssetUpload = new ReleaseAssetUpload(packageName, \u0022application/zip\u0022, File.OpenRead(artifactFullPath), null);\n\n        Logger.Log(LogLevel.Normal, $\u0022Uploading assert {releaseAssetUpload.FileName}...\u0022);\n\n        var releaseAsset = client.Repository.Release.UploadAsset(release, releaseAssetUpload).Result;\n\n        Logger.Block(releaseAsset.BrowserDownloadUrl);\n\n        Logger.Log(LogLevel.Normal, $\u0022Released in Github {client.BaseAddress}, successfully\u0022);\n    }\n\n    private void RunProcess(string processFullName, string argument)\n    {\n        var startInfo = new ProcessStartInfo(processFullName)\n        {\n            Arguments = argument,\n            RedirectStandardOutput = true,\n            RedirectStandardError = true,\n            UseShellExecute = false,\n        };\n\n        var process = Process.Start(startInfo);\n        var result = process.StandardOutput.ReadToEnd();\n        var error = process.StandardError.ReadToEnd();\n\n        if (!string.IsNullOrWhiteSpace(error))\n            throw new Exception(error);\n\n        Console.Write(result);\n\n        process.WaitForExit();\n    }\n}\n"
  },
  {
    "Id": 188310980,
    "FirstIndexed": "2020-04-25T15:47:03.6116369+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631892+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431402+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937279+02:00",
    "Name": "Serilog.Sinks.NewRelicInsights",
    "Owner": "mishrsud",
    "HtmlUrl": "https://github.com/mishrsud/Serilog.Sinks.NewRelicInsights",
    "Description": "A Serilog sink for NewRelic Insights",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mishrsud/Serilog.Sinks.NewRelicInsights/blob/master/build/Build.cs",
    "BuildFileSize": 3646,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    \n    readonly string ApiKey = Variable(\u0022api_key\u0022);\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    string Source =\u003E \u0022https://api.nuget.org/v3/index.json\u0022;\n    \n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    AbsolutePath ProjectToPackDirectory =\u003E RootDirectory / \u0022src\u0022 / \u0022Serilog.Sinks.NewRelicInsights\u0022 / \u0022Serilog.Sinks.NewRelicInsights.csproj\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .Description(\u0022Packages artifacts to nuget\u0022)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            Console.Out.WriteLine($\u0022Setting version: {GitVersion.NuGetVersionV2}\u0022);\n            DotNetPack(settings =\u003E settings\n                .SetProject(ProjectToPackDirectory)\n                .SetConfiguration(Configuration)\n                .SetNoBuild(true)\n                .SetNoRestore(true)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Publish Nuget Package\u0022)\n        .After(Pack)\n        .DependsOn(Pack)\n        .OnlyWhenDynamic(() =\u003E !string.IsNullOrWhiteSpace(ApiKey))\n        .Executes(() =\u003E\n        {\n            GlobFiles(ArtifactsDirectory, \u0022*.nupkg\u0022).NotEmpty()\n                .ForEach(pkg =\u003E DotNetNuGetPush(settings =\u003E settings\n                    .SetTargetPath(pkg)\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)));\n        });\n}\n"
  },
  {
    "Id": 188484067,
    "FirstIndexed": "2020-04-25T15:47:03.6116727+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631659+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431419+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937291+02:00",
    "Name": "Nuke.Build.GitExtensions",
    "Owner": "jajvisser",
    "HtmlUrl": "https://github.com/jajvisser/Nuke.Build.GitExtensions",
    "Description": "Extra helper functions to help determine which projects have changed from a baseline in GIT",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/jajvisser/Nuke.Build.GitExtensions/blob/master/build/Build.cs",
    "BuildFileSize": 7678,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing GitPackager.Nuke.Tools.Constants;\nusing LibGit2Sharp;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Configuration = Nuke.Common.Configuration;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static GitPackager.Nuke.Tools.GitPackagerTasks;\nusing static GitPackager.Nuke.Tools.GitTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.BuildServers;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    // Default build action\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    // Description fields\n    const string Description = \u0022Nuke Build to help filter projects based on a baseline tag. This also clone its own .git directory. Based on the Cake GitPackager.\u0022;\n    const string Author = \u0022Joris Visser\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [Parameter] string BuildVersion;\n\n    [Parameter] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] readonly string ApiKey;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    #region Default build tasks\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n    \n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            if (TeamCity.Instance != null)\n            {\n                BuildVersion = TeamCity.Instance.BuildNumber;\n                Logger.Info($\u0022{BuildVersion} is used as a buildserver\u0022);\n            }\n\n            DotNetBuild(o =\u003E o.SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(BuildVersion)\n                .SetFileVersion(BuildVersion)\n                .SetInformationalVersion(BuildVersion));\n        });\n    \n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            if (TeamCity.Instance != null)\n            {\n                BuildVersion = TeamCity.Instance.BuildNumber;\n                Logger.Info($\u0022{BuildVersion} is used as a buildserver\u0022);\n            }\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetDescription(Description)\n                .SetAuthors(Author)\n                .SetPackageReleaseNotes(GetReleaseNotes())\n                .SetPackageLicenseUrl(\u0022https://licenses.nuget.org/MIT\u0022)\n                .SetPackageRequireLicenseAcceptance(false)\n                .SetConfiguration(Configuration)\n                .SetVersion(BuildVersion)\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    static string GetReleaseNotes()\n    {\n        var assembly = Assembly.GetExecutingAssembly();\n        var resourceName = \u0022ReleaseNotes.txt\u0022;\n\n        var notes = assembly.GetManifestResourceNames();\n        \n        using (var stream = assembly.GetManifestResourceStream(resourceName))\n        using (var reader = new StreamReader(stream))\n        {\n            return reader.ReadToEnd();\n        }\n    }\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Source)\n        .Executes(() =\u003E\n        {\n            if (TeamCity.Instance != null)\n            {\n                BuildVersion = TeamCity.Instance.BuildNumber;\n                Logger.Info($\u0022{BuildVersion} is used as a buildserver\u0022);\n            }\n\n            DotNetNuGetPush(s =\u003E s\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(\n                        OutputDirectory.GlobFiles( $\u0022*{BuildVersion}.nupkg\u0022).NotEmpty(),\n                        (cs, v) =\u003E cs.SetTargetPath(v)), degreeOfParallelism: 5, completeOnFailure: true);\n        });\n\n    Target Tag =\u003E _ =\u003E _\n        .Requires(() =\u003E GitUsername)\n        .Requires(() =\u003E GitPassword)\n        .Executes(() =\u003E\n        {\n            var tempTag = Guid.NewGuid().ToString();\n\n            // Create tag\n            CreateTag(tempTag, RootDirectory, Repository, (url, fromUrl, types) =\u003E new UsernamePasswordCredentials { Password = GitPassword, Username = GitUsername});\n\n            // Delete tag\n            DeleteTag(tempTag, RootDirectory, Repository, (url, fromUrl, types) =\u003E new UsernamePasswordCredentials { Password = GitPassword, Username = GitUsername });\n        });\n\n#endregion\n\n    #region Test case of git diff\n\n    [Parameter]\n    readonly string Repository = \u0022https://github.com/jajvisser/Nuke.Build.GitExtensions.git\u0022;\n    [Parameter]\n    readonly string GitUsername;\n    [Parameter]\n    readonly string GitPassword;\n\n    Target TestGitBaseline =\u003E _ =\u003E _\n        .Requires(() =\u003E Repository)\n        .Requires(() =\u003E GitUsername)\n        .Requires(() =\u003E GitPassword)\n        .Executes(() =\u003E\n        {\n            Logger.Info(\u0022Testing baseline with branch test-branch\u0022);\n\n            // Diff from remote baseline\n            DiffFromBaseline(RootDirectory, \u0022baseline\u0022, \u0022test-branch\u0022, (changes) =\u003E\n            {\n                var added = changes.Added.Select(s =\u003E s.Path);\n                Debug.Assert(added.Contains(\u0022test-file.txt\u0022));\n            }, (url, x, y) =\u003E new UsernamePasswordCredentials() {Username = GitUsername, Password = GitPassword});\n\n            Logger.Info(\u0022Testing baseline with current branch\u0022);\n\n            // Diff from remote baseline\n            DiffFromBaseline(RootDirectory, \u0022baseline\u0022, (changes) =\u003E\n            {\n                var added = changes.Added.Select(s =\u003E s.Path);\n                Debug.Assert(added.Contains(\u0022test-file.txt\u0022));\n            }, (url, x, y) =\u003E new UsernamePasswordCredentials() {Username = GitUsername, Password = GitPassword});\n        });\n\n    Target TestGitTasks =\u003E _ =\u003E _\n        .DependsOn(TestGitBaseline)\n        .Requires(() =\u003E Repository)\n        .Requires(() =\u003E GitUsername)\n        .Requires(() =\u003E GitPassword)\n        .Executes(() =\u003E\n        {\n            // Reset test scenario\n            DeleteTag(\u0022test-tag\u0022, RootDirectory, Repository, (url, x, y) =\u003E new UsernamePasswordCredentials() { Username = GitUsername, Password = GitPassword });\n\n            // Create tag\n            CreateTag(\u0022test-tag\u0022, RootDirectory, Repository, (url, x, y) =\u003E new UsernamePasswordCredentials() { Username = GitUsername, Password = GitPassword });\n\n            // Delete tag\n            DeleteTag(\u0022test-tag\u0022, RootDirectory, Repository, (url, x, y) =\u003E new UsernamePasswordCredentials() { Username = GitUsername, Password = GitPassword });\n\n            // RecreateTag\n            ResetTag(\u0022test-tag\u0022, RootDirectory, Repository, (url, x, y) =\u003E new UsernamePasswordCredentials() { Username = GitUsername, Password = GitPassword });\n        });\n\n    Target TestGit =\u003E _ =\u003E _\n        .DependsOn(TestGitTasks)\n        .Executes(() =\u003E { });\n\n    #endregion\n}\n"
  },
  {
    "Id": 188492055,
    "FirstIndexed": "2020-04-25T15:47:03.611675+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1632052+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843143+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937302+02:00",
    "Name": "BlayerUI",
    "Owner": "detachmode",
    "HtmlUrl": "https://github.com/detachmode/BlayerUI",
    "Description": "A cross-platform language agnostic UI framework",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/detachmode/BlayerUI/blob/master/build/Build.cs",
    "BuildFileSize": 1865,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 188915757,
    "FirstIndexed": "2020-04-25T15:47:03.6115777+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162531+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431436+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "Microsoft.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Microsoft.Extensions",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 189212695,
    "FirstIndexed": "2020-04-25T15:50:44.7361488+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631972+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434815+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940539+02:00",
    "Name": "DotnetBlayer",
    "Owner": "detachmode",
    "HtmlUrl": "https://github.com/detachmode/DotnetBlayer",
    "Description": "A easy to use framework for creating cross plattform UIs  - powered by Blazor",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/detachmode/DotnetBlayer/blob/master/build/Build.cs",
    "BuildFileSize": 4649,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.PublishSubtree);\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022gh-pages\u0022;\n    AbsolutePath TestDirectory =\u003E RootDirectory / \u0022src\u0022 / \u0022test\u0022;\n    AbsolutePath ProjectClientSide =\u003E RootDirectory / \u0022src\u0022 / \u0022Blayer.ClientSide\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n\n            try\n            {\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022 worktree remove gh-pages\u0022).WaitForExit();\n            }\n            catch (System.Exception)\n            {\n\n            }\n\n            SourceDirectory.GlobDirectories(\u0022**/*/bin\u0022, \u0022**/*/obj\u0022).ForEach(DeleteDirectory);\n            DeleteDirectory(\u0022_site\u0022);\n            EnsureCleanDirectory(ArtifactsDirectory);\n\n\n        });\n\n\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(ProjectClientSide));\n\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            // DotNetTest(s =\u003E s\n            // .SetArgumentConfigurator(a =\u003E a\n            //     .Add(\u0022/p:CollectCoverage=true\u0022)\n            //     .Add(\u0022/p:CoverletOutputFormat=\\\\\\\u0022opencover,lcov\\\\\\\u0022\u0022)\n            //     .Add(\u0022/p:CoverletOutput=../lcov\u0022))\n            // .SetProjectFile(TestDirectory));\n        });\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n            .EnableNoBuild()\n            .SetOutput(ArtifactsDirectory)\n            .SetProject(ProjectClientSide));\n        });\n\n\n    Target PublishSubtree =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n\n\n            // var cmds = new[] {\n            //     (\u0022git\u0022, \u0022--version\u0022, \u0022.\u0022),\n            //     (\u0022git\u0022, \u0022worktree add _site gh-pages\u0022, \u0022.\u0022),\n            //     (\u0022echo\u0022, \u0022hello \u003E\u003E hi.txt\u0022, \u0022_site\u0022),\n            //     (\u0022git\u0022, \u0022add -A\u0022, \u0022_site\u0022),\n            //     (\u0022git\u0022, \u0022status\u0022, \u0022_site\u0022),\n\n            //     // \u0022git config user.email you@you.com\u0022,\n            //     // \u0022git config user.email you@you.com\u0022,\n            //     // \u0022git config user.name \\\u0022your name\\\u0022\u0022,\n            //     (\u0022git\u0022, \u0022commit -a -m \\\u0022Commit from Azure DevOps\\\u0022\u0022, \u0022_site\u0022),\n            //     (\u0022git\u0022, \u0022push\u0022, \u0022_site\u0022),\n            // };\n\n            try\n            {\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022worktree prune\u0022).WaitForExit();\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022worktree add _site gh-pages\u0022).WaitForExit();\n                // System.Console.WriteLine(\u0022Added Working Tree\u0022);\n                CopyDirectoryRecursively(\n                    ArtifactsDirectory / \u0022Blayer.ClientSide\u0022 / \u0022dist\u0022,\n                    RootDirectory / \u0022_site\u0022,\n                    DirectoryExistsPolicy.Merge, FileExistsPolicy.Overwrite);\n                System.Console.WriteLine(\u0022Copied Recusively\u0022);\n\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022add -A\u0022, \u0022_site\u0022).WaitForExit();\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022status\u0022, \u0022_site\u0022).WaitForExit();\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022 commit -m \\\u0022commit from nuke\\\u0022\u0022, \u0022_site\u0022).WaitForExit();\n                ProcessTasks.StartProcess(\u0022git\u0022, \u0022push\u0022, \u0022_site\u0022).WaitForExit();\n            }\n            catch (Exception ex)\n            {\n                Logger.Log(LogLevel.Error, ex.ToString());\n                throw;\n            }\n            finally\n            {\n                //   ProcessTasks.StartProcess(\u0022git\u0022, \u0022worktree remove gh-pages\u0022).WaitForExit();\n            }\n\n        });\n\n}\n"
  },
  {
    "Id": 189934096,
    "FirstIndexed": "2020-04-25T15:47:03.6114867+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624946+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431447+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937314+02:00",
    "Name": "Rocket.Timer",
    "Owner": "RLittlesII",
    "HtmlUrl": "https://github.com/RLittlesII/Rocket.Timer",
    "Description": "An app to show using ReactiveUI on Xamarin.Mac",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RLittlesII/Rocket.Timer/blob/master/.build/Build.cs",
    "BuildFileSize": 927,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Rocket.Surgery.Nuke.Xamarin;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : MacBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _.DependsOn(XamarinMac);\n}\n"
  },
  {
    "Id": 190263509,
    "FirstIndexed": "2020-04-25T15:47:03.6116705+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163204+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431459+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937319+02:00",
    "Name": "geldapp2",
    "Owner": "thomai-d",
    "HtmlUrl": "https://github.com/thomai-d/geldapp2",
    "Description": "Web based expense tracking system",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "_prebuild/Build.cs",
    "BuildFileUrl": "https://github.com/thomai-d/geldapp2/blob/master/_prebuild/Build.cs",
    "BuildFileSize": 6038,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Run);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    private string _nugetVersionV2;\n    private string _fullSemVer;\n    private string _versionDate;\n\n    Target GitVersion =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E IsLocalBuild)\n        .Executes(() =\u003E\n        {\n            var gitv = GitVersionTasks.GitVersion().Result;\n            _nugetVersionV2 = gitv.NuGetVersionV2;\n            _fullSemVer = gitv.FullSemVer;\n\n            Logger.Info($\u0022NuGetVersion: {_nugetVersionV2}\u0022);\n            Logger.Info($\u0022FullSemVer:   {_fullSemVer}\u0022);\n        });\n\n    Target GitVersionWorkaround =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E !IsLocalBuild)\n        .DependsOn(GitVersion)\n        .Executes(() =\u003E\n        {\n            // HACK: The Gitversion NuGet package currently seems broken for dotnetcore2.2. This is a workaround for my build server using the docker image of gitversion.\n            // [GitVersion] readonly GitVersion GitVersion;\n            var p = ProcessTasks.StartProcess(\u0022docker\u0022, $\u0022run --rm -v \\\u0022{SourceDirectory.Parent}:/repo\\\u0022 gittools/gitversion /repo\u0022);\n            p.WaitForExit();\n            var fullText = string.Join(\u0022\\n\u0022, p.Output.Select(o =\u003E o.Text));\n\n            _versionDate = DateTime.Now.ToString(\u0022yyyy-MM-dd HH:MM\u0022);\n\n            var gitversion = JObject.Parse(fullText);\n            _nugetVersionV2 = gitversion.SelectToken(\u0022NuGetVersionV2\u0022).Value\u003Cstring\u003E();\n            if (string.IsNullOrEmpty(_nugetVersionV2))\n            {\n                throw new Exception($\u0022Can\u0027t find NuGetVersionV2 in gitversion output: {fullText}\u0022);\n            }\n\n            _fullSemVer = gitversion.SelectToken(\u0022FullSemVer\u0022).Value\u003Cstring\u003E();\n            if (string.IsNullOrEmpty(_fullSemVer))\n            {\n                throw new Exception($\u0022Can\u0027t find FullSemVer in gitversion output: {fullText}\u0022);\n            }\n\n            Logger.Info($\u0022NuGetVersion: {_nugetVersionV2}\u0022);\n            Logger.Info($\u0022FullSemVer:   {_fullSemVer}\u0022);\n            Logger.Info($\u0022Date:         {_versionDate}\u0022);\n        });\n\n    Target UpdateCsProjVersions =\u003E _ =\u003E _\n        .DependsOn(GitVersionWorkaround)\n        .Executes(() =\u003E\n        {\n            foreach (var csproj in GlobFiles(SourceDirectory, \u0022**/*.csproj\u0022))\n            {\n                var doc = XElement.Load(csproj);\n                var version = doc.XPathSelectElement(\u0022/PropertyGroup/Version\u0022);\n                if (version != null)\n                {\n                    Logger.Info($\u0022Updating {csproj} version to {_fullSemVer}...\u0022);\n                    version.SetValue(_fullSemVer);\n                    doc.Save(csproj);\n                }\n                else\n                {\n                    throw new Exception($\u0022Can\u0027t update {csproj} version, since there\u0027s no /PropertyGroup/Version tag\u0022);\n                }\n            }\n        });\n\n    Target UpdateClientAppVersions =\u003E _ =\u003E _\n        .DependsOn(UpdateCsProjVersions)\n        .Executes(() =\u003E\n        {\n            // Replace json files\n            ReplaceJson(SourceDirectory / @\u0022GeldApp2\\ClientApp\\package.json\u0022, \u0022version\u0022, _nugetVersionV2);\n\n            var jsonVersionStr = $\u0022version: \u0027{_fullSemVer}\u0027\u0022;\n            var releaseDateStr = $\u0022versionDate: \u0027{_versionDate}\u0027\u0022;\n            ReplaceRegex(SourceDirectory / @\u0022GeldApp2\\ClientApp\\src\\environments\\environment.ts\u0022, \u0022version: \u0027.*?\u0027\u0022, jsonVersionStr);\n            ReplaceRegex(SourceDirectory / @\u0022GeldApp2\\ClientApp\\src\\environments\\environment.prod.ts\u0022, \u0022version: \u0027.*?\u0027\u0022, jsonVersionStr);\n            ReplaceRegex(SourceDirectory / @\u0022GeldApp2\\ClientApp\\src\\environments\\environment.ts\u0022, \u0022versionDate: \u0027.*?\u0027\u0022, releaseDateStr);\n            ReplaceRegex(SourceDirectory / @\u0022GeldApp2\\ClientApp\\src\\environments\\environment.prod.ts\u0022, \u0022versionDate: \u0027.*?\u0027\u0022, releaseDateStr);\n\n            // Application title\n            ReplaceRegex(SourceDirectory / @\u0022GeldApp2\\ClientApp\\src\\index.html\u0022, \u0022\u003Ctitle\u003E.*?\u003C/title\u003E\u0022, $\u0022\u003Ctitle\u003EGeldApp - v{_fullSemVer}\u003C/title\u003E\u0022);\n        });\n\n    Target Run =\u003E _ =\u003E _\n        .DependsOn(UpdateClientAppVersions)\n        .Executes(() =\u003E\n        {\n\n        });\n\n    private void ReplaceRegex(string path, string rx, string value)\n    {\n        Logger.Info($\u0022Updating {path}...\u0022);\n        var content = File.ReadAllText(path);\n        content = Regex.Replace(content, rx, value);\n        File.WriteAllText(path, content);\n    }\n\n    private void ReplaceJson(string path, string selector, string value)\n    {\n        Logger.Info($\u0022Updating {path}...\u0022);\n\n        JObject packageJson;\n        using (var pjs = new StreamReader(path))\n        using (var jts = new JsonTextReader(pjs))\n            packageJson = JObject.Load(jts);\n\n        packageJson.SelectToken(selector).Replace(value);\n        using (var jsw = new StreamWriter(path))\n        using (var jtw = new JsonTextWriter(jsw))\n        {\n            jtw.Formatting = Formatting.Indented;\n            packageJson.WriteTo(jtw);\n        }\n    }\n}\n"
  },
  {
    "Id": 191414182,
    "FirstIndexed": "2020-04-25T15:47:03.6116608+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162564+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843147+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937331+02:00",
    "Name": "ai",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/ai",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/ai/blob/master/build/Build.cs",
    "BuildFileSize": 253,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 191951336,
    "FirstIndexed": "2020-04-25T15:47:03.6116443+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631955+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431481+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937342+02:00",
    "Name": "kerberos-auth-egress-buildpack",
    "Owner": "alfusinigoj",
    "HtmlUrl": "https://github.com/alfusinigoj/kerberos-auth-egress-buildpack",
    "Description": "route-service-auth-egress-buildpack",
    "Archived": false,
    "Stars": 4,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/alfusinigoj/kerberos-auth-egress-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 8814,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing FileMode = System.IO.FileMode;\nusing ZipFile = System.IO.Compression.ZipFile;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public enum StackType\n    {\n        Windows,\n        Linux\n    }\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n    const string BuildpackProjectName = \u0022Pivotal.RouteService.Auth.Egress.Buildpack\u0022;\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\n    readonly StackType Stack = StackType.Windows;\n\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GitHubToken;\n\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;\n    string Framework =\u003E Stack == StackType.Windows ? \u0022net47\u0022 : \u0022netcoreapp2.2\u0022;\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteFile);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetRuntime(Runtime));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .Description(\u0022Compiles the buildpack\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info(Stack);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .Description(\u0022Execute tests\u0022)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\n            EnsureCleanDirectory(TemporaryDirectory);\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\n            var scriptsDirectory = RootDirectory / \u0022scripts\u0022;\n\n            var requiredAssembliesSourceDirectory = SourceDirectory / \u0022requiredAssemblies\u0022;\n            var requiredAssembliesTargetDirectory = workBinDirectory / \u0022requiredAssemblies\u0022;\n\n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            CopyDirectoryRecursively(requiredAssembliesSourceDirectory, requiredAssembliesTargetDirectory, DirectoryExistsPolicy.Merge);\n\n            var tempZipFile = TemporaryDirectory / PackageZipName;\n\n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\n            MakeFilesInZipUnixExecutable(tempZipFile);\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\n            Logger.Block(ArtifactsDirectory / PackageZipName);\n\n        });\n\n\n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\n        .DependsOn(Publish)\n        .Requires(() =\u003E GitHubToken)\n        .Executes(async () =\u003E\n        {\n            if (!GitRepository.IsGitHubRepository())\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n\n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\n            {\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\n            };\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n            var owner = gitIdParts[0];\n            var repoName = gitIdParts[1];\n\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n            Release release;\n            try\n            {\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\n            }\n            catch (NotFoundException)\n            {\n                var newRelease = new NewRelease(releaseName)\n                {\n                    Name = releaseName,\n                    Draft = false,\n                    Prerelease = false\n                };\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\n            }\n\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\n            if (existingAsset != null)\n            {\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n            }\n\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\n\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\n        });\n\n    public static void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\n    {\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\n        {\n            output.SetLevel(9);\n            ZipEntry entry;\n\n            while ((entry = input.GetNextEntry()) != null)\n            {\n                var outEntry = new ZipEntry(entry.Name);\n                outEntry.HostSystem = (int)HostSystemID.Unix;\n                outEntry.ExternalFileAttributes = -2115174400;\n                output.PutNextEntry(outEntry);\n                input.CopyTo(output);\n            }\n            output.Finish();\n            output.Flush();\n        }\n\n        DeleteFile(zipFile);\n        RenameFile(tmpFileName, zipFile, FileExistsPolicy.Overwrite);\n    }\n}\n"
  },
  {
    "Id": 192447751,
    "FirstIndexed": "2020-04-25T15:47:03.6116397+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631927+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431493+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937353+02:00",
    "Name": "PlayBuildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/PlayBuildpack",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/PlayBuildpack/blob/master/build/Build.cs",
    "BuildFileSize": 8499,
    "BuildFileContent": "using System;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing ICSharpCode.SharpZipLib.Zip;\r\nusing Nuke.Common;\r\nusing Nuke.Common.BuildServers;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing FileMode = System.IO.FileMode;\r\nusing ZipFile = System.IO.Compression.ZipFile;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public enum StackType\r\n    {\r\n        Windows,\r\n        Linux\r\n    }\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n    const string BuildpackProjectName = \u0022PlayBuildpack\u0022;\r\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    \r\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\r\n    readonly StackType Stack = StackType.Windows;\r\n    \r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;  \r\n    string Framework =\u003E Stack == StackType.Windows ? \u0022net47\u0022 : \u0022netcoreapp2.2\u0022;\r\n\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            //EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetRuntime(Runtime));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .Description(\u0022Compiles the buildpack\u0022)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            Logger.Info(Stack);\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n                .SetRuntime(Runtime)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n    \r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetPublish(s =\u003E s\r\n                .SetProject(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n                .SetRuntime(Runtime)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\r\n            EnsureCleanDirectory(TemporaryDirectory);\r\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\r\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\r\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\r\n            var scriptsDirectory = RootDirectory / \u0022scripts\u0022;\r\n            \r\n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n            var tempZipFile = TemporaryDirectory / PackageZipName;\r\n            \r\n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\r\n            MakeFilesInZipUnixExecutable(tempZipFile);\r\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\r\n            Logger.Block(ArtifactsDirectory / PackageZipName);\r\n\r\n        });\r\n    \r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            if (!GitRepository.IsGitHubRepository())\r\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\r\n            \r\n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\r\n            {\r\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n            };\r\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n            var owner = gitIdParts[0];\r\n            var repoName = gitIdParts[1];\r\n            \r\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n            Release release;\r\n            try\r\n            {\r\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n            }\r\n            catch (NotFoundException)\r\n            {\r\n                var newRelease = new NewRelease(releaseName)\r\n                {\r\n                    Name = releaseName, \r\n                    Draft = false, \r\n                    Prerelease = false\r\n                };\r\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n            }\r\n\r\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\r\n            if (existingAsset != null)\r\n            {\r\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n            }\r\n            \r\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\r\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\r\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n            \r\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n        });\r\n\r\n    public static void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\r\n    {\r\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\r\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\r\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\r\n        {\r\n            output.SetLevel(9);\r\n            ZipEntry entry;\r\n\t\t\r\n            while ((entry = input.GetNextEntry()) != null)\r\n            {\r\n                var outEntry = new ZipEntry(entry.Name);\r\n                outEntry.HostSystem = (int)HostSystemID.Unix;\r\n                outEntry.ExternalFileAttributes = -2115174400;\r\n                output.PutNextEntry(outEntry);\r\n                input.CopyTo(output);\r\n            }\r\n            output.Finish();\r\n            output.Flush();\r\n        }\r\n\r\n        DeleteFile(zipFile);\r\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\r\n    }\r\n}\r\n"
  },
  {
    "Id": 192468417,
    "FirstIndexed": "2020-04-25T15:50:44.7361425+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631915+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434809+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940522+02:00",
    "Name": "cf-staging-buildpack-simulator",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/cf-staging-buildpack-simulator",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/cf-staging-buildpack-simulator/blob/master/build/Build.cs",
    "BuildFileSize": 5475,
    "BuildFileContent": "using System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Security.Cryptography;\r\nusing System.Text;\r\nusing Microsoft.Build.Tasks;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Utilities;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.IO.CompressionTasks;\r\nusing static Nuke.Common.IO.HttpTasks;\r\nusing static Nuke.Common.Tooling.ProcessTasks;\r\n\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Stage);\r\n    \r\n    [Parameter()]\r\n    readonly string[] Buildpacks;\r\n    \r\n    [Parameter(\u0022Directory that would be be \u0027pushed\u0027 to PCF. This is the source app\u0022)]\r\n    readonly AbsolutePath PushDirectory;\r\n    AbsolutePath DropletDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    AbsolutePath ContainerPath =\u003E TemporaryDirectory / \u0022container\u0022;\r\n    AbsolutePath BuildDirectory =\u003E ContainerPath / \u0022build\u0022;\r\n    AbsolutePath DepsDirectory =\u003E ContainerPath / \u0022deps\u0022;\r\n    AbsolutePath CacheDirectory =\u003E ContainerPath / \u0022cache\u0022;\r\n    AbsolutePath ProfileDirectory =\u003E ContainerPath / \u0022profile.d\u0022; \r\n    AbsolutePath BuildpacksDirectory =\u003E ContainerPath / \u0022buildpacks\u0022; \r\n\r\n\r\n    Target Stage =\u003E _ =\u003E _\r\n        .Requires(() =\u003E Buildpacks)\r\n        .Requires(() =\u003E PushDirectory)\r\n        .Executes(() =\u003E\r\n        {\r\n            EnsureCleanDirectory(ContainerPath);\r\n            EnsureExistingDirectory(DepsDirectory);\r\n            EnsureExistingDirectory(CacheDirectory);\r\n            EnsureExistingDirectory(ProfileDirectory);\r\n            EnsureExistingDirectory(BuildpacksDirectory);\r\n\r\n            CopyDirectoryRecursively(PushDirectory, BuildDirectory);\r\n            for (int i = 0; i \u003C Buildpacks.Length; i\u002B\u002B)\r\n            {\r\n                var buildpackLoc = Buildpacks[i];\r\n                var buildpackDir = BuildpacksDirectory / i.ToString();\r\n                EnsureExistingDirectory(buildpackDir);\r\n                if (buildpackLoc.StartsWith(\u0022http\u0022))\r\n                {\r\n                    var buildpackHashName = GetMd5Hash(buildpackLoc) \u002B \u0022.zip\u0022;\r\n                    if (!FileExists(TemporaryDirectory / buildpackHashName))\r\n                    {\r\n                        HttpDownloadFile(buildpackLoc, TemporaryDirectory / buildpackHashName);\r\n                    }\r\n                    Uncompress(TemporaryDirectory / buildpackHashName, buildpackDir);\r\n                }\r\n                else\r\n                {\r\n                    Uncompress(buildpackLoc, buildpackDir);\r\n                }\r\n\r\n                var envVars = Environment.GetEnvironmentVariables().Cast\u003CDictionaryEntry\u003E().ToDictionary(x =\u003E x.Key.ToString(), x =\u003E x.Value.ToString());\r\n                envVars.Add(\u0022CF_STACK\u0022,\u0022windows\u0022);\r\n                \r\n                RunLifecycle(\u0022supply\u0022, buildpackDir, envVars, i);\r\n                \r\n                if (i == Buildpacks.Length - 1)\r\n                {\r\n                    RunLifecycle(\u0022finalize\u0022, buildpackDir, envVars, i);\r\n                }\r\n            }\r\n            EnsureCleanDirectory(DropletDirectory);\r\n            CopyDirectoryRecursively(BuildDirectory, DropletDirectory / \u0022app\u0022);\r\n            CopyDirectoryRecursively(BuildDirectory, DropletDirectory / \u0022profile.d\u0022);\r\n            Logger.Block($\u0022Droplet created in {DropletDirectory}\u0022);\r\n        });\r\n\r\n    void RunLifecycle(string lifecycle, AbsolutePath buildpackDir, Dictionary\u003Cstring,string\u003E envVars, int index)\r\n    {\r\n        var exePath = buildpackDir / \u0022bin\u0022 / $\u0022{lifecycle}.exe\u0022;\r\n        if (FileExists(exePath))\r\n        {\r\n            StartProcess(exePath, \r\n                    arguments: $\u0022{BuildDirectory} {CacheDirectory} {DepsDirectory} {index} {ProfileDirectory}\u0022, \r\n                    environmentVariables: envVars)\r\n                .WaitForExit();\r\n        }\r\n        else\r\n        {\r\n            StartProcess(\u0022powershell\u0022, \r\n                    arguments: $\u0022{buildpackDir / \u0022bin/finalize.bat\u0022} {BuildDirectory} {CacheDirectory} {DepsDirectory} {index} {ProfileDirectory}\u0022, \r\n                    environmentVariables: envVars)\r\n                .WaitForExit();\r\n        }\r\n        \r\n    }\r\n\r\n    static string GetMd5Hash(string input)\r\n    {\r\n        var md5Hash = MD5.Create();\r\n        // Convert the input string to a byte array and compute the hash.\r\n        byte[] data = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(input));\r\n\r\n        // Create a new Stringbuilder to collect the bytes\r\n        // and create a string.\r\n        StringBuilder sBuilder = new StringBuilder();\r\n\r\n        // Loop through each byte of the hashed data \r\n        // and format each one as a hexadecimal string.\r\n        for (int i = 0; i \u003C data.Length; i\u002B\u002B)\r\n        {\r\n            sBuilder.Append(data[i].ToString(\u0022x2\u0022));\r\n        }\r\n\r\n        // Return the hexadecimal string.\r\n        return sBuilder.ToString();\r\n    }\r\n}\r\n"
  },
  {
    "Id": 192855466,
    "FirstIndexed": "2020-04-25T15:47:03.6116346+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630925+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431504+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937365+02:00",
    "Name": "MetaProject",
    "Owner": "OpenMacroBoard",
    "HtmlUrl": "https://github.com/OpenMacroBoard/MetaProject",
    "Description": "This repo simplifies the development process and references the other repos as submodules",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/OpenMacroBoard/MetaProject/blob/master/build/Build.cs",
    "BuildFileSize": 4380,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Xml.Linq;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[SuppressMessage(\u0022Code Quality\u0022, \u0022IDE0051:Remove unused private members\u0022, Justification = \u0022It\u0027s OK for build scripts\u0022)]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Release\u0027\u0022)]\n    readonly Configuration Configuration = Configuration.Release;\n\n    [Solution]\n    readonly Solution Solution;\n\n    AbsolutePath SourceDirectory\n        =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath OutputDirectory\n        =\u003E RootDirectory / \u0022output\u0022;\n\n    readonly string[] ProjectsNames = new string[]\n    {\n        \u0022StreamDeckSharp\u0022,\n        \u0022OpenMacroBoard.SDK\u0022,\n        \u0022OpenMacroBoard.VirtualBoard\u0022\n    };\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Bleach =\u003E _ =\u003E _\n        .Before(Clean)\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            RunCodeInRoot(\u0022git\u0022, \u0022clean -xdf -e /build/bin/ -e /.tmp/build-attempt.log\u0022);\n            RunCodeInRoot(\u0022git\u0022, \u0022reset --hard\u0022);\n            RunCodeInRoot(\u0022git\u0022, \u0022submodule foreach --recursive \\\u0022git clean -xdf\\\u0022\u0022);\n            RunCodeInRoot(\u0022git\u0022, \u0022submodule foreach --recursive \\\u0022git reset --hard\\\u0022\u0022);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n\n            NuGetRestore(new NuGetRestoreSettings()\n                .SetTargetPath(Solution)\n            );\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            foreach (var projectName in ProjectsNames)\n            {\n                var project = Solution.GetProject(projectName);\n                var version = GetVersion(project);\n\n                MSBuild(s =\u003E s\n                    .SetTargetPath(project)\n                    .SetTargets(\u0022Rebuild\u0022)\n                    .SetFileVersion(version)\n                    .SetAssemblyVersion(version)\n                    .SetInformationalVersion(version)\n                    .SetConfiguration(Configuration)\n                    .SetMaxCpuCount(Environment.ProcessorCount)\n                    .SetNodeReuse(IsLocalBuild)\n                );\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            foreach (var projectName in ProjectsNames)\n            {\n                var project = Solution.GetProject(projectName);\n                var version = GetVersion(project);\n                var nuspecFile = Path.ChangeExtension(project, \u0022.nuspec\u0022);\n\n                NuGetPack(s =\u003E s\n                    .SetTargetPath(nuspecFile)\n                    .SetVersion(version)\n                    .SetConfiguration(Configuration)\n                    .SetOutputDirectory(OutputDirectory)\n                );\n            }\n        });\n\n    private string GetVersion(string project)\n    {\n        return XDocument\n            .Load(project)\n            .Descendants()\n            .Where(d =\u003E d.Name.LocalName == \u0022PropertyGroup\u0022)\n            .SelectMany(d =\u003E d\n                .Descendants()\n                .Where(x =\u003E x.Name.LocalName == \u0022Version\u0022)\n            )\n            .FirstOrDefault()\n            ?.Value;\n    }\n\n    private void RunCodeInRoot(string toolPath, string arguments)\n    {\n        var proc = ProcessTasks.StartProcess(toolPath,\n                workingDirectory: RootDirectory,\n                arguments: arguments\n            );\n\n        proc.WaitForExit();\n        proc.AssertZeroExitCode();\n    }\n}\n"
  },
  {
    "Id": 193197242,
    "FirstIndexed": "2020-04-25T15:47:03.6116227+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625498+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431516+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937376+02:00",
    "Name": "dotnet.templates",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/dotnet.templates",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/dotnet.templates/blob/master/.build/Build.cs",
    "BuildFileSize": 2491,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Nuke.Common.Tools;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\n\n[PublicAPI]\n// [CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        .DependsOn(Install)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n\n    public Target Install =\u003E _ =\u003E _\n        .After(Pack)\n        .DependsOn(Pack)\n        .OnlyWhenStatic(() =\u003E IsLocalBuild)\n        .Executes(() =\u003E\n        {\n\n            foreach (var item in NuGetPackageDirectory.GlobFiles(\u0022*.nupkg\u0022))\n            {\n                try\n                {\n                    DotNet(\u0022new --uninstall Rocket.Surgery.Templates\u0022);\n                }\n                catch { }\n                DotNet($\u0022new --install {item}\u0022);\n            }\n            // DotNet(\u0022new -u \u0022)\n            // try\n            // {\n            //     DotNetToolUninstall(x =\u003E x.EnableGlobal().SetPackageName(\u0022sync-central-versions\u0022)\n            //         .ResetVerbosity());\n            // }\n            // catch { }\n\n            // DotNetToolInstall(x =\u003E\n            //     x.EnableGlobal().SetVersion(GitVersion.SemVer).AddSources(NuGetPackageDirectory)\n            //         .SetPackageName(\u0022sync-central-versions\u0022));\n        });\n\n\n}\n"
  },
  {
    "Id": 193388548,
    "FirstIndexed": "2020-04-25T15:47:03.6116324+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631028+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431527+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937393+02:00",
    "Name": "nseed",
    "Owner": "nseedio",
    "HtmlUrl": "https://github.com/nseedio/nseed",
    "Description": "[The description is yet to come.]",
    "Archived": false,
    "Stars": 0,
    "Watchers": 3,
    "BuildFilePath": "build/private/NukeBuild/Build.cs",
    "BuildFileUrl": "https://github.com/nseedio/nseed/blob/master/build/private/NukeBuild/Build.cs",
    "BuildFileSize": 2817,
    "BuildFileContent": "using Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing System.IO.Compression;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Solution] readonly Solution solution;\r\n    //[GitRepository] readonly GitRepository gitRepository;\r\n    //[GitVersion] readonly GitVersion gitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\r\n    AbsolutePath TemplatesDirectory =\u003E RootDirectory / \u0022templates\u0022;\r\n    AbsolutePath NSeedCliDirectory =\u003E SourceDirectory / \u0022NSeed.Cli\u0022;\r\n    AbsolutePath TemplatesZipFile =\u003E NSeedCliDirectory / \u0022templates.zip\u0022;\r\n\r\n    void DeleteOutputFiles()\r\n    {\r\n        OutputDirectory.GlobFiles(\u0022*.nupkg\u0022, \u0022*.snupkg\u0022).ForEach(DeleteFile);\r\n    }\r\n\r\n    void CreateTemplatesZip()\r\n    {\r\n        DeleteFile(TemplatesZipFile);\r\n        ZipFile.CreateFromDirectory(TemplatesDirectory, TemplatesZipFile, CompressionLevel.Optimal, true);\r\n    }\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            DeleteOutputFiles();\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(solution));\r\n        });\r\n\r\n    Target CompressTemplates =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            CreateTemplatesZip();\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(CompressTemplates)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .EnableNoRestore()\r\n                .SetProjectFile(solution)\r\n                .SetConfiguration(configuration));\r\n        });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            DeleteOutputFiles();\r\n            DotNetPack(s =\u003E s\r\n                .EnableNoBuild()\r\n                .SetProject(solution)\r\n                .SetConfiguration(configuration)\r\n                .EnableIncludeSymbols()\r\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\r\n                .SetOutputDirectory(OutputDirectory));\r\n        });\r\n}"
  },
  {
    "Id": 193992435,
    "FirstIndexed": "2020-04-25T15:47:03.6113906+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624502+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431538+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937405+02:00",
    "Name": "AppMetrics.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/AppMetrics.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/AppMetrics.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 195163184,
    "FirstIndexed": "2020-04-25T15:47:03.6116255+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628342+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431544+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937422+02:00",
    "Name": "Nuke",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Nuke",
    "Description": "Integration with the nuke build system",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "src/Nuke/RocketBoosterBuild.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Nuke/blob/master/src/Nuke/RocketBoosterBuild.cs",
    "BuildFileSize": 13399,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing Rocket.Surgery.Nuke.Readme;\nusing Temp.CleanupCode;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing static Temp.CleanupCode.CleanupCodeTasks;\n#pragma warning disable CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.\n\nnamespace Rocket.Surgery.Nuke\n{\n    /// \u003Csummary\u003E\n    /// Base build plan and tasks\n    /// \u003C/summary\u003E\n    [PublicAPI]\n    [DotNetVerbosityMapping]\n    [MSBuildVerbosityMapping]\n    [NuGetVerbosityMapping]\n    public abstract class RocketBoosterBuild\u003CT\u003E : NukeBuild, IRocketBoosterBuild\u003CT\u003E\n        where T : Configuration\n    {\n        protected RocketBoosterBuild(Func\u003CT\u003E configurationDefault)\n        {\n            Configuration = configurationDefault();\n        }\n\n        /// \u003Csummary\u003E\n        /// The files to lint, if not given lints all files\n        /// \u003C/summary\u003E\n        [Parameter(\u0022The files to lint, if not given lints all files\u0022, Separator = \u0022 \u0022)]\n#pragma warning disable CA1819 // Properties should not return arrays\n        public string[] LintFiles { get; set; } = Array.Empty\u003Cstring\u003E();\n#pragma warning restore CA1819 // Properties should not return arrays\n\n        /// \u003Csummary\u003E\n        /// The files to lint, if not given lints all files\n        /// \u003C/summary\u003E\n        [Parameter(\u0022The profile to use for linting\u0022)]\n        public string LintProfile { get; set; } = \u0022Full Cleanup\u0022;\n\n        /// \u003Csummary\u003E\n        /// Applies code cleanup tasks\n        /// \u003C/summary\u003E\n        public Target Lint =\u003E _ =\u003E _\n           .Requires(() =\u003E LintFiles)\n           .Executes(\n                () =\u003E\n                {\n                    CleanupCode(\n                        x =\u003E x\n                           .SetTargetPath(Solution.Path)\n                           .SetProfile(LintProfile)\n                           .AddInclude(LintFiles)\n                    );\n                }\n            );\n\n        /// \u003Csummary\u003E\n        /// Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\n        /// \u003C/summary\u003E\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        public T Configuration { get; }\n\n        /// \u003Csummary\u003E\n        /// Force a clean build, otherwise leave some incremental build pieces\n        /// \u003C/summary\u003E\n        [Parameter(\u0022Force a clean build\u0022)]\n        public bool Force { get; }\n\n        /// \u003Csummary\u003E\n        /// The solution currently being build\n        /// \u003C/summary\u003E\n        [Solution]\n        public Solution Solution { get; }\n\n        /// \u003Csummary\u003E\n        /// The Git Repository currently being built\n        /// \u003C/summary\u003E\n        [GitRepository]\n        public GitRepository? GitRepository { get; }\n\n        /// \u003Csummary\u003E\n        /// The Git Version information either computed by GitVersion itself, or as defined by environment variables of the format\n        /// \u0060GITVERSION_*\u0060\n        /// \u003C/summary\u003E\n        [ComputedGitVersion]\n        public GitVersion? GitVersion { get; }\n\n        /// \u003Csummary\u003E\n        /// The readme updater that ensures that all the badges are in sync.\n        /// \u003C/summary\u003E\n        [Readme]\n        public ReadmeUpdater Readme { get; }\n\n        /// \u003Csummary\u003E\n        /// The directory where samples will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath SampleDirectory =\u003E RootDirectory / \u0022sample\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where sources will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where templates will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath TemplatesDirectory =\u003E RootDirectory / \u0022templates\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where tests will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath TestDirectory =\u003E DirectoryExists(RootDirectory / \u0022tests\u0022)\n            ? RootDirectory / \u0022tests\u0022\n            : RootDirectory / \u0022test\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where tests will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath TestsDirectory =\u003E TestDirectory;\n\n        /// \u003Csummary\u003E\n        /// The directory where artifacts are to be dropped\n        /// \u003C/summary\u003E\n        [Parameter(\u0022The directory where artifacts are to be dropped\u0022, Name = \u0022Artifacts\u0022)]\n        public AbsolutePath ArtifactsDirectory { get; } =\n            GetVariable\u003CAbsolutePath\u003E(\u0022Artifacts\u0022) ?? RootDirectory / \u0022artifacts\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where logs will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath LogsDirectory =\u003E ArtifactsDirectory / \u0022logs\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where test results will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath TestResultsDirectory =\u003E ArtifactsDirectory / \u0022test\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where nuget packages will be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath NuGetPackageDirectory =\u003E ArtifactsDirectory / \u0022nuget\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where publish output should be placed\n        /// \u003C/summary\u003E\n        public AbsolutePath PublishDirectory =\u003E ArtifactsDirectory / \u0022publish\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where packaged output should be placed (zip, webdeploy, etc)\n        /// \u003C/summary\u003E\n        public AbsolutePath OutputDirectory =\u003E ArtifactsDirectory / \u0022output\u0022;\n\n        /// \u003Csummary\u003E\n        /// The directory where coverage artifacts are to be dropped\n        /// \u003C/summary\u003E\n        [Parameter(\u0022The directory where coverage artifacts are to be dropped\u0022, Name = \u0022Coverage\u0022)]\n        public AbsolutePath CoverageDirectory { get; } =\n            GetVariable\u003CAbsolutePath\u003E(\u0022Coverage\u0022) ?? RootDirectory / \u0022coverage\u0022;\n\n        /// \u003Csummary\u003E\n        /// prints the build information.\n        /// \u003C/summary\u003E\n        public Target BuildVersion =\u003E _ =\u003E _\n           .Executes(\n                () =\u003E\n                {\n                    Logger.Info(\n                        \u0022Building version {0} of {1} ({2}) using version {3} of Nuke.\u0022,\n                        GitVersion.NuGetVersionV2 ?? GitVersion.NuGetVersion,\n                        Solution.Name,\n                        Configuration,\n                        typeof(NukeBuild).Assembly.GetVersionText()\n                    );\n                }\n            );\n\n        /// \u003Csummary\u003E\n        /// clean all artifact directories\n        /// \u003C/summary\u003E\n        public Target Clean =\u003E _ =\u003E _\n           .DependsOn(BuildVersion)\n           .Executes(\n                () =\u003E\n                {\n                    EnsureCleanDirectory(ArtifactsDirectory);\n                    EnsureExistingDirectory(LogsDirectory);\n                    EnsureExistingDirectory(TestResultsDirectory);\n                    EnsureExistingDirectory(NuGetPackageDirectory);\n                    EnsureExistingDirectory(PublishDirectory);\n                    EnsureExistingDirectory(OutputDirectory);\n                    EnsureCleanDirectory(CoverageDirectory);\n\n                    if (Force)\n                    {\n                        if (DirectoryExists(SampleDirectory))\n                        {\n                            SampleDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                        }\n\n                        if (DirectoryExists(SourceDirectory))\n                        {\n                            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                        }\n\n                        if (DirectoryExists(TemplatesDirectory))\n                        {\n                            TemplatesDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                        }\n\n                        if (DirectoryExists(TestDirectory))\n                        {\n                            TestDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                        }\n                    }\n                }\n            );\n\n\n        /// \u003Csummary\u003E\n        /// This will generate code coverage reports from emitted coverage data\n        /// \u003C/summary\u003E\n        public Target Generate_Code_Coverage_Reports =\u003E _ =\u003E _\n           .Description(\u0022Generates code coverage reports\u0022)\n           .Unlisted()\n           .OnlyWhenDynamic(() =\u003E CoverageDirectory.GlobFiles(\u0022**/*.cobertura.xml\u0022).Count \u003E 0)\n           .Executes(\n                () =\u003E\n                {\n                    var reports = CoverageDirectory.GlobFiles(\u0022**/*.cobertura.xml\u0022).Select(z =\u003E z.ToString());\n                    // TEMP work around for issue in nuke\n                    var toolPath =\n#if NETSTANDARD2_1\n                    ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.dll\u0022, framework: \u0022netcoreapp3.0\u0022);\n#else\n                        ToolPathResolver.GetPackageExecutable(\n                            \u0022ReportGenerator\u0022,\n                            \u0022ReportGenerator.dll\u0022,\n                            framework: \u0022netcoreapp2.1\u0022\n                        );\n#endif\n                    ReportGenerator(\n                        s =\u003E s\n                           .SetToolPath(toolPath)\n                           .SetReports(reports)\n                           .SetTargetDirectory(CoverageDirectory / \u0022report\u0022)\n                           .SetReportTypes(ReportTypes.HtmlInline_AzurePipelines_Dark)\n                           .SetTag(GitVersion.InformationalVersion)\n                    );\n\n                    ReportGenerator(\n                        s =\u003E s\n                           .SetToolPath(toolPath)\n                           .SetReports(reports)\n                           .SetTargetDirectory(CoverageDirectory)\n                           .SetReportTypes(ReportTypes.Cobertura)\n                           .SetTag(GitVersion.InformationalVersion)\n                    );\n\n                    ReportGenerator(\n                        s =\u003E s\n                           .SetToolPath(toolPath)\n                           .SetReports(reports)\n                           .SetTargetDirectory(CoverageDirectory / \u0022badges\u0022)\n                           .SetReportTypes(ReportTypes.Badges)\n                           .SetTag(GitVersion.InformationalVersion)\n                    );\n\n                    ReportGenerator(\n                        s =\u003E s\n                           .SetToolPath(toolPath)\n                           .SetReports(reports)\n                           .SetTargetDirectory(CoverageDirectory / \u0022summary\u0022)\n                           .SetReportTypes(ReportTypes.HtmlSummary, ReportTypes.TextSummary)\n                           .SetTag(GitVersion.InformationalVersion)\n                    );\n\n                    CopyFile(\n                        CoverageDirectory / \u0022Cobertura.xml\u0022,\n                        CoverageDirectory / \u0022solution.cobertura\u0022,\n                        FileExistsPolicy.OverwriteIfNewer\n                    );\n                    CopyFile(\n                        CoverageDirectory / \u0022Cobertura.xml\u0022,\n                        CoverageDirectory / \u0022solution.xml\u0022,\n                        FileExistsPolicy.OverwriteIfNewer\n                    );\n                    RenameFile(\n                        CoverageDirectory / \u0022solution.xml\u0022,\n                        CoverageDirectory / \u0022cobertura.xml\u0022,\n                        FileExistsPolicy.OverwriteIfNewer\n                    );\n                }\n            );\n\n        /// \u003Csummary\u003E\n        /// Loops through the Readme to update sections that are automated to give nuget packages, build histories and more, while\n        /// keeping the rest of the readme correct.\n        /// \u003C/summary\u003E\n        public Target GenerateReadme =\u003E _ =\u003E _\n           .Unlisted()\n           .OnlyWhenDynamic(\n                () =\u003E IsLocalBuild \u0026\u0026 ( Force || InvokedTargets.Any(z =\u003E z.Name == nameof(GenerateReadme)) ||\n                    ExecutingTargets.Any(z =\u003E z.Name == nameof(GenerateReadme)) )\n            )\n           .Executes(\n                () =\u003E\n                {\n                    var readmeContent = File.ReadAllText(RootDirectory / \u0022Readme.md\u0022);\n                    readmeContent = Readme.Process(readmeContent, this);\n                    File.WriteAllText(RootDirectory / \u0022Readme.md\u0022, readmeContent);\n                }\n            );\n    }\n\n    /// \u003Csummary\u003E\n    /// Base build plan and tasks.\n    /// \u003C/summary\u003E\n    /// \u003Cseealso cref=\u0022NukeBuild\u0022 /\u003E\n    /// \u003Cseealso cref=\u0022IRocketBoosterBuild{T}\u0022 /\u003E\n    public abstract class RocketBoosterBuild : RocketBoosterBuild\u003CConfiguration\u003E\n    {\n        /// \u003Csummary\u003E\n        /// Initializes a new instance of the \u003Csee cref=\u0022RocketBoosterBuild\u0022/\u003E class.\n        /// \u003C/summary\u003E\n        protected RocketBoosterBuild()\n            : base(() =\u003E IsLocalBuild ? Configuration.Debug : Configuration.Release) { }\n    }\n}"
  },
  {
    "Id": 195958944,
    "FirstIndexed": "2020-04-25T15:47:03.6115339+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631602+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431555+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937444+02:00",
    "Name": "miNationalrot",
    "Owner": "minationalrot",
    "HtmlUrl": "https://github.com/minationalrot/miNationalrot",
    "Description": "Die Nationalratswahlen App",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/minationalrot/miNationalrot/blob/master/build/Build.cs",
    "BuildFileSize": 5065,
    "BuildFileContent": "\n\nusing System;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\n\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.PushGhPages);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] string GitHub_PAT;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022nuketests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    AbsolutePath PublishDirectory =\u003E RootDirectory / \u0022../publish\u0022;\n\n    AbsolutePath DistributionDirectory =\u003E PublishDirectory / @\u0022miNationalrot\u0022 / @\u0022dist\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            //TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(TestsDirectory);\n            EnsureCleanDirectory(PublishDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s=\u003Es.SetOutput(TestsDirectory));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GetAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPublish( s=\u003Es\n                .SetConfiguration(\u0022Release\u0022)\n                .SetOutput(PublishDirectory)\n                //.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                //.SetAssemblyVersion(GitVersion.FullSemVer.Replace(\u0022\u002B\u0022,\u0022.\u0022))\n                .SetAssemblyVersion(GetAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                //.SetNoBuild(true)\n            );\n        });\n\n\n    public string GetAssemblyVersion()\n    {\n        var main = \u00220\u0022;\n        var stamp = DateTime.Now;\n        var month = (stamp.Year-2000) *100 \u002B stamp.Month;\n        var day = stamp.Day;\n        var rev = GitVersion.BuildMetaData;\n\n        return $\u0022{main}.{month}.{day}.{rev}\u0022;\n    }\n\n    Target PushGhPages =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n            if (GitHub_PAT == null)\n            {\n                GitTasks.Git(\u0022init\u0022, DistributionDirectory);\n                GitTasks.Git(\u0022checkout -b gh-pages\u0022, DistributionDirectory);\n                GitTasks.Git(\u0022add -A\u0022, DistributionDirectory);\n                GitTasks.Git($\u0022commit -m \\\u0022commit ver {GitVersion.FullSemVer}\\\u0022\u0022, DistributionDirectory);\n                GitTasks.Git(\u0022push -f  https://github.com/minationalrot/miNationalrot.git gh-pages\u0022, DistributionDirectory);\n            }\n            else\n            {\n                GitTasks.Git(@\u0022config --global user.name OserRemo\u0022, DistributionDirectory);\n                GitTasks.Git(@\u0022config --global user.email remo.oser@osisa.com\u0022, DistributionDirectory);\n                GitTasks.Git(\u0022init\u0022, DistributionDirectory);\n                GitTasks.Git(\u0022checkout -b gh-pages\u0022, DistributionDirectory);\n                GitTasks.Git(\u0022add -A\u0022, DistributionDirectory);\n                GitTasks.Git($\u0022commit -m \\\u0022commit ver {GitVersion.FullSemVer}\\\u0022\u0022, DistributionDirectory);\n                GitTasks.Git($\u0022push -f  https://{GitHub_PAT}@github.com/minationalrot/miNationalrot.git gh-pages\u0022, DistributionDirectory);\n\n            }\n        });\n\n}\n"
  },
  {
    "Id": 196201979,
    "FirstIndexed": "2020-04-25T15:47:03.6115698+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163179+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431567+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937456+02:00",
    "Name": "MinimalCef",
    "Owner": "pkudrel",
    "HtmlUrl": "https://github.com/pkudrel/MinimalCef",
    "Description": "Minimal winforms Cef example",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "src/build/Build.cs",
    "BuildFileUrl": "https://github.com/pkudrel/MinimalCef/blob/master/src/build/Build.cs",
    "BuildFileSize": 9184,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing AbcVersionTool;\nusing Helpers;\nusing Helpers.Azure;\nusing Helpers.Syrup;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    [Parameter(\u0022Build counter from outside environment\u0022)]\n    readonly int BuildCounter;\n\n    readonly DateTime BuildDate = DateTime.UtcNow;\n\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [GitRepository] readonly GitRepository GitRepository;\n\n    readonly bool IsAzureDevOps = string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\u0022AGENT_NAME\u0022)) == false;\n\n    [Solution] readonly Solution Solution;\n\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath ToolsDir =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath DevDir =\u003E RootDirectory / \u0022dev\u0022;\n    AbsolutePath LibzPath =\u003E ToolsDir / \u0022LibZ.Tool\u0022 / \u0022tools\u0022 / \u0022libz.exe\u0022;\n    AbsolutePath ZipPath =\u003E ToolsDir / \u00227zip\u0022 / \u00227za.exe\u0022;\n    AbsolutePath NugetPath =\u003E ToolsDir / \u0022nuget.exe\u0022;\n    AbsolutePath TmpBuild =\u003E TemporaryDirectory / \u0022build\u0022;\n    AbsolutePath ArtifactsDir =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath SourceDir =\u003E RootDirectory / \u0022src\u0022;\n\n    AbcVersion AbcVersion =\u003E AbcVersionFactory.Create(BuildCounter, BuildDate);\n\n\n    ProductInfo ProductInfo =\u003E new ProductInfo\n    {\n        Company = \u0022Deneblab\u0022,\n        Copyright = $\u0022Deneblab \u00A9 {DateTime.UtcNow.Year}\u0022\n    };\n\n    /// Projects\n    Project MinimalCefProject =\u003E Solution.GetProject(\u0022MinimalCef\u0022).NotNull();\n\n    List\u003CProjectDefinition\u003E Projects =\u003E new List\u003CProjectDefinition\u003E\n    {\n        new ProjectDefinition\n        {\n            Name = MinimalCefProject.Name,\n            Dir = MinimalCefProject.Name,\n            Exe = \u0022MinimalCef.exe\u0022,\n            DstExe = \u0022MinimalCef.exe\u0022,\n            AzureContainerName = \u0022application-minimal-cef\u0022,\n            Project = MinimalCefProject\n        }\n    };\n\n    Target Information =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var b = AbcVersion;\n            Logger.Normal($\u0022Host: \u0027{Host}\u0027\u0022);\n            Logger.Normal($\u0022Version: \u0027{b.SemVersion}\u0027\u0022);\n            Logger.Normal($\u0022Date: \u0027{b.DateTime:s}Z\u0027\u0022);\n            Logger.Normal($\u0022FullVersion: \u0027{b.InformationalVersion}\u0027\u0022);\n            Logger.Normal($\u0022env:Agent.Name: \u0027{Environment.GetEnvironmentVariable(\u0022AGENT_NAME\u0022)}\u0027\u0022);\n            Logger.Normal(\n                $\u0022env:Build.ArtifactStagingDirectory: \u0027{Environment.GetEnvironmentVariable(\u0022BUILD_ARTIFACTSTAGINGDIRECTORY\u0022)}\u0027\u0022);\n        });\n\n\n    Target ConfigureAzureDevOps =\u003E _ =\u003E _\n        .DependsOn(Information)\n        .OnlyWhenStatic(() =\u003E IsAzureDevOps)\n        .Executes(() =\u003E\n        {\n            Logger.Normal($\u0022Set version to AzureDevOps: {AbcVersion.SemVersion}\u0022);\n            // https://github.com/microsoft/azure-pipelines-tasks/blob/master/docs/authoring/commands.md\n            Logger.Normal($\u0022##vso[build.updatebuildnumber]{AbcVersion.SemVersion}\u0022);\n        });\n\n    Target Configure =\u003E _ =\u003E _\n        .DependsOn(ConfigureAzureDevOps);\n\n\n    Target CheckTools =\u003E _ =\u003E _\n        .DependsOn(Configure)\n        .Executes(() =\u003E\n        {\n            Downloader.DownloadIfNotExists(\u0022https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\u0022, NugetPath,\n                \u0022Nuget\u0022);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(CheckTools)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(TmpBuild);\n            GlobDirectories(TmpBuild, \u0022**/*\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDir);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022restore  {Solution.Path}\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n\n    Target MakeSyrup =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            var project = Projects.FirstOrDefault(x =\u003E x.Project == MinimalCefProject);\n            BuildFn(project);\n            MargeFn(project);\n        });\n\n\n\n\n\n    Target Zip =\u003E _ =\u003E _\n        .DependsOn(MakeSyrup)\n        .Executes(() =\u003E\n\n        {\n            var p = Projects.FirstOrDefault(x =\u003E x.Project == MinimalCefProject);\n            if (p == null) return;\n            var tmpMerge = TmpBuild / CommonDir.Merge / p.Dir;\n            var tmpZip = TmpBuild / CommonDir.Zip / p.Dir;\n\n            var tmpReady = TmpBuild / CommonDir.Ready;\n            var fileName = $\u0022{p.Name}-{AbcVersion.SemVersion}.zip\u0022;\n\n            EnsureExistingDirectory(tmpZip);\n            EnsureExistingDirectory(tmpReady);\n\n\n            using (var process = ProcessTasks.StartProcess(\n                ZipPath,\n                $\u0022a {fileName} {tmpMerge / p.Exe}\u0022,\n                tmpZip))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Zip report generation process exited with some errors.\u0022);\n            }\n        });\n\n\n\n\n\n    Target PublishLocalStandalone =\u003E _ =\u003E _\n        .DependsOn(MakeSyrup)\n        .Executes(() =\u003E\n        {\n            var p = Projects.FirstOrDefault(x =\u003E x.Project == MinimalCefProject);\n            if (p == null) return;\n            var tmpMerge = TmpBuild / CommonDir.Merge / p.Dir;\n            var tmpMergeFile = tmpMerge / p.Exe;\n            var devStandalone = DevDir / \u0022app.standolone\u0022;\n            var devStandaloneFile = devStandalone / p.Exe;\n            EnsureExistingDirectory(devStandalone);\n            CopyFile(tmpMergeFile, devStandaloneFile, FileExistsPolicy.Overwrite);\n        });\n\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn( Zip, PublishLocal);\n\n\n    Target PublishLocal =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E IsAzureDevOps == false)\n        .DependsOn(PublishLocalStandalone);\n\n\n    \n    void BuildFn(ProjectDefinition p)\n    {\n        var buildOut = TmpBuild / CommonDir.Build / p.Dir;\n        var projectFile = p.Project.Path;\n        var projectDir = Path.GetDirectoryName(projectFile);\n        EnsureExistingDirectory(buildOut);\n        Logger.Normal($\u0022Build; Project file: {projectFile}\u0022);\n        Logger.Normal($\u0022Build; Project dir: {projectDir}\u0022);\n        Logger.Normal($\u0022Build; Out dir: {buildOut}\u0022);\n        Logger.Normal($\u0022Build; Target: {Configuration}\u0022);\n        Logger.Normal($\u0022Build; Target: {GitRepository.Branch}\u0022);\n\n        AssemblyTools.Patch(projectDir, AbcVersion, p, ProductInfo);\n\n        try\n        {\n            MSBuild(s =\u003E s\n                .SetProjectFile(projectFile)\n                .SetOutDir(buildOut)\n                .SetVerbosity(MSBuildVerbosity.Quiet)\n                .SetConfiguration(Configuration)\n                .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        }\n        finally\n        {\n            AssemblyTools.RollbackOriginalFiles(projectDir);\n        }\n    }\n\n    void MargeFn(ProjectDefinition p)\n    {\n\n        var doNotMarge = new[]\n        {\n            \u0022build.dll\u0022, \u0022libcef.dll\u0022, \u0022chrome_elf.dll\u0022, \u0022d3dcompiler_47.dll\u0022,\n            \u0022libEGL.dll\u0022, \u0022libGLESv2.dll\u0022, \u0022CefSharp.dll\u0022, \u0022CefSharp.Core.dll\u0022,\n            \u0022CefSharp.BrowserSubprocess.Core.dll\u0022\n        };\n        var exclude = string.Join(\u0027 \u0027, doNotMarge.Select(x =\u003E $\u0022--exclude={x}\u0022));\n\n        var buildOut = TmpBuild / CommonDir.Build / p.Dir;\n        var margeOut = TmpBuild / CommonDir.Merge / p.Dir;\n\n        EnsureExistingDirectory(margeOut);\n        CopyDirectoryRecursively(buildOut, margeOut, DirectoryExistsPolicy.Merge);\n\n        using (var process = ProcessTasks.StartProcess(\n            LibzPath,\n            $\u0022inject-dll --assembly {p.Exe} --include *.dll {exclude} --move\u0022,\n            margeOut))\n        {\n            process.AssertWaitForExit();\n            ControlFlow.AssertWarn(process.ExitCode == 0,\n                \u0022Libz report generation process exited with some errors.\u0022);\n        }\n    }\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n}"
  },
  {
    "Id": 196894538,
    "FirstIndexed": "2020-04-25T15:50:44.7361266+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631762+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434787+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940511+02:00",
    "Name": "LibHac.Nand",
    "Owner": "Thealexbarney",
    "HtmlUrl": "https://github.com/Thealexbarney/LibHac.Nand",
    "Description": null,
    "Archived": false,
    "Stars": 3,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Thealexbarney/LibHac.Nand/blob/master/build/Build.cs",
    "BuildFileSize": 23387,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Xml.Linq;\nusing ICSharpCode.SharpZipLib.Zip;\nusing ILRepacking;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.SignTool;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nnamespace LibHacBuild\n{\n    partial class Build : NukeBuild\n    {\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Results);\n\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        public readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n        [Parameter(\u0022Build only .NET Core targets if true. Default is false on Windows\u0022)]\n        public readonly bool DoCoreBuildOnly;\n\n        [Solution(\u0022LibHac.sln\u0022)] readonly Solution _solution;\n        [GitRepository] readonly GitRepository _gitRepository;\n        [GitVersion] readonly GitVersion _gitVersion;\n\n        AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n        AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n        AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n        AbsolutePath SignedArtifactsDirectory =\u003E ArtifactsDirectory / \u0022signed\u0022;\n        AbsolutePath TempDirectory =\u003E RootDirectory / \u0022.tmp\u0022;\n        AbsolutePath CliCoreDir =\u003E TempDirectory / \u0022hactoolnet_netcoreapp2.1\u0022;\n        AbsolutePath CliFrameworkDir =\u003E TempDirectory / \u0022hactoolnet_net46\u0022;\n        AbsolutePath CliNativeDir =\u003E TempDirectory / \u0022hactoolnet_native\u0022;\n        AbsolutePath CliFrameworkZip =\u003E ArtifactsDirectory / \u0022hactoolnet.zip\u0022;\n        AbsolutePath CliCoreZip =\u003E ArtifactsDirectory / \u0022hactoolnet_netcore.zip\u0022;\n        AbsolutePath NugetConfig =\u003E RootDirectory / \u0022nuget.config\u0022;\n\n        AbsolutePath CliMergedExe =\u003E ArtifactsDirectory / \u0022hactoolnet.exe\u0022;\n        AbsolutePath CliNativeExe =\u003E ArtifactsDirectory / \u0022hactoolnet_native.exe\u0022;\n\n        Project LibHacProject =\u003E _solution.GetProject(\u0022LibHac\u0022).NotNull();\n        Project LibHacTestProject =\u003E _solution.GetProject(\u0022LibHac.Tests\u0022).NotNull();\n        Project HactoolnetProject =\u003E _solution.GetProject(\u0022hactoolnet\u0022).NotNull();\n\n        string AppVeyorVersion { get; set; }\n        Dictionary\u003Cstring, object\u003E VersionProps { get; set; } = new Dictionary\u003Cstring, object\u003E();\n\n        private const string MyGetSource = \u0022https://dotnet.myget.org/F/dotnet-core/api/v3/index.json\u0022;\n        const string CertFileName = \u0022cert.pfx\u0022;\n\n        private bool IsMasterBranch =\u003E _gitVersion?.BranchName.Equals(\u0022master\u0022) ?? false;\n\n        Target SetVersion =\u003E _ =\u003E _\n            .OnlyWhenStatic(() =\u003E _gitRepository != null)\n            .Executes(() =\u003E\n            {\n                AppVeyorVersion = $\u0022{_gitVersion.AssemblySemVer}\u0022;\n                if (!string.IsNullOrWhiteSpace(_gitVersion.PreReleaseTag))\n                {\n                    AppVeyorVersion \u002B= $\u0022-{_gitVersion.PreReleaseTag}\u002B{_gitVersion.Sha.Substring(0, 8)}\u0022;\n                }\n\n                string suffix = _gitVersion.PreReleaseTag;\n\n                if (!string.IsNullOrWhiteSpace(suffix))\n                {\n                    if (!_gitRepository.IsOnMasterBranch())\n                    {\n                        suffix = $\u0022-{suffix}\u0022;\n                    }\n\n                    suffix \u002B= $\u0022\u002B{_gitVersion.Sha.Substring(0, 8)}\u0022;\n                }\n\n                VersionProps = new Dictionary\u003Cstring, object\u003E\n                {\n                    [\u0022VersionPrefix\u0022] = _gitVersion.AssemblySemVer,\n                    [\u0022VersionSuffix\u0022] = suffix\n                };\n\n                Console.WriteLine($\u0022Building version {AppVeyorVersion}\u0022);\n\n                if (Host == HostType.AppVeyor)\n                {\n                    SetAppVeyorVersion(AppVeyorVersion);\n                }\n            });\n\n        Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                List\u003Cstring\u003E toDelete = GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022)\n                    .Concat(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022)).ToList();\n\n                foreach (string dir in toDelete)\n                {\n                    DeleteDirectory(dir);\n                }\n\n                EnsureCleanDirectory(ArtifactsDirectory);\n                EnsureCleanDirectory(CliCoreDir);\n                EnsureCleanDirectory(CliFrameworkDir);\n                EnsureCleanDirectory(CliNativeDir);\n            });\n\n        Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestoreSettings settings = new DotNetRestoreSettings()\n                    .SetProjectFile(_solution);\n\n                DotNetRestore(s =\u003E settings);\n            });\n\n        Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore, SetVersion)\n            .Executes(() =\u003E\n            {\n                DotNetBuildSettings buildSettings = new DotNetBuildSettings()\n                    .SetProjectFile(_solution)\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration)\n                    .SetProperties(VersionProps)\n                    .SetProperty(\u0022BuildType\u0022, \u0022Release\u0022);\n\n                if (DoCoreBuildOnly) buildSettings = buildSettings.SetFramework(\u0022netcoreapp2.1\u0022);\n\n                DotNetBuild(s =\u003E buildSettings);\n\n                DotNetPublishSettings publishSettings = new DotNetPublishSettings()\n                    .EnableNoRestore()\n                    .SetConfiguration(Configuration);\n\n                DotNetPublish(s =\u003E publishSettings\n                    .SetProject(HactoolnetProject)\n                    .SetFramework(\u0022netcoreapp2.1\u0022)\n                    .SetOutput(CliCoreDir)\n                    .SetProperties(VersionProps));\n\n                if (!DoCoreBuildOnly)\n                {\n                    DotNetPublish(s =\u003E publishSettings\n                        .SetProject(HactoolnetProject)\n                        .SetFramework(\u0022net46\u0022)\n                        .SetOutput(CliFrameworkDir)\n                        .SetProperties(VersionProps));\n                }\n\n                // Hack around OS newline differences\n                if (EnvironmentInfo.IsUnix)\n                {\n                    foreach (string filename in Directory.EnumerateFiles(CliCoreDir, \u0022*.json\u0022))\n                    {\n                        ReplaceLineEndings(filename);\n                    }\n                }\n            });\n\n        Target Pack =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                DotNetPackSettings settings = new DotNetPackSettings()\n                    .SetProject(LibHacProject)\n                    .EnableNoBuild()\n                    .SetConfiguration(Configuration)\n                    .EnableIncludeSymbols()\n                    .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                    .SetOutputDirectory(ArtifactsDirectory)\n                    .SetProperties(VersionProps);\n\n                if (DoCoreBuildOnly)\n                    settings = settings.SetProperty(\u0022TargetFrameworks\u0022, \u0022netcoreapp2.1\u0022);\n\n                DotNetPack(s =\u003E settings);\n\n                foreach (string filename in Directory.EnumerateFiles(ArtifactsDirectory, \u0022*.*nupkg\u0022))\n                {\n                    RepackNugetPackage(filename);\n                }\n\n                if (Host != HostType.AppVeyor) return;\n\n                foreach (string filename in Directory.EnumerateFiles(ArtifactsDirectory, \u0022*.*nupkg\u0022))\n                {\n                    PushArtifact(filename);\n                }\n            });\n\n        Target Merge =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .OnlyWhenStatic(() =\u003E !DoCoreBuildOnly)\n            .Executes(() =\u003E\n            {\n                string[] libraries = Directory.GetFiles(CliFrameworkDir, \u0022*.dll\u0022);\n                var cliList = new List\u003Cstring\u003E { CliFrameworkDir / \u0022hactoolnet.exe\u0022 };\n                cliList.AddRange(libraries);\n\n                var cliOptions = new RepackOptions\n                {\n                    OutputFile = CliMergedExe,\n                    InputAssemblies = cliList.ToArray(),\n                    SearchDirectories = new[] { \u0022.\u0022 }\n                };\n\n                new ILRepack(cliOptions).Repack();\n\n                foreach (AbsolutePath file in ArtifactsDirectory.GlobFiles(\u0022*.exe.config\u0022))\n                {\n                    File.Delete(file);\n                }\n\n                if (Host == HostType.AppVeyor)\n                {\n                    PushArtifact(CliMergedExe);\n                }\n            });\n\n        Target Test =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n            {\n                DotNetTestSettings settings = new DotNetTestSettings()\n                    .SetProjectFile(LibHacTestProject)\n                    .EnableNoBuild()\n                    .SetConfiguration(Configuration);\n\n                if (DoCoreBuildOnly) settings = settings.SetFramework(\u0022netcoreapp2.1\u0022);\n\n                DotNetTest(s =\u003E settings);\n            });\n\n        Target Zip =\u003E _ =\u003E _\n            .DependsOn(Pack)\n            .Executes(() =\u003E\n            {\n                string[] namesFx = Directory.EnumerateFiles(CliFrameworkDir, \u0022*.exe\u0022)\n                    .Concat(Directory.EnumerateFiles(CliFrameworkDir, \u0022*.dll\u0022))\n                    .ToArray();\n\n                string[] namesCore = Directory.EnumerateFiles(CliCoreDir, \u0022*.json\u0022)\n                    .Concat(Directory.EnumerateFiles(CliCoreDir, \u0022*.dll\u0022))\n                    .ToArray();\n\n                if (!DoCoreBuildOnly)\n                {\n                    ZipFiles(CliFrameworkZip, namesFx);\n                    Console.WriteLine($\u0022Created {CliFrameworkZip}\u0022);\n                }\n\n                ZipFiles(CliCoreZip, namesCore);\n                Console.WriteLine($\u0022Created {CliCoreZip}\u0022);\n\n                if (Host == HostType.AppVeyor)\n                {\n                    PushArtifact(CliFrameworkZip);\n                    PushArtifact(CliCoreZip);\n                    PushArtifact(CliMergedExe);\n                }\n            });\n\n        Target Publish =\u003E _ =\u003E _\n            .DependsOn(Test)\n            .OnlyWhenStatic(() =\u003E AppVeyor.Instance != null \u0026\u0026 AppVeyor.Instance.PullRequestTitle == null)\n            .Executes(() =\u003E\n            {\n                AbsolutePath nupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).Single();\n                AbsolutePath snupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.snupkg\u0022).Single();\n\n                string apiKey = EnvironmentInfo.Variable(\u0022myget_api_key\u0022);\n                DotNetNuGetPushSettings settings = new DotNetNuGetPushSettings()\n                    .SetApiKey(apiKey)\n                    .SetSymbolApiKey(apiKey)\n                    .SetSource(\u0022https://www.myget.org/F/libhac/api/v2/package\u0022)\n                    .SetSymbolSource(\u0022https://www.myget.org/F/libhac/symbols/api/v2/package\u0022);\n\n                DotNetNuGetPush(settings.SetTargetPath(nupkgFile));\n                DotNetNuGetPush(settings.SetTargetPath(snupkgFile));\n            });\n\n        [SuppressMessage(\u0022ReSharper\u0022, \u0022PossibleNullReferenceException\u0022)]\n        Target Native =\u003E _ =\u003E _\n            .DependsOn(SetVersion)\n            .OnlyWhenStatic(() =\u003E AppVeyor.Instance != null \u0026\u0026 IsMasterBranch)\n            .Executes(() =\u003E\n            {\n                AbsolutePath nativeProject = HactoolnetProject.Path.Parent / \u0022hactoolnet_native.csproj\u0022;\n\n                try\n                {\n                    File.Copy(HactoolnetProject, nativeProject, true);\n                    DotNet(\u0022new nuget --force\u0022);\n\n                    XDocument doc = XDocument.Load(NugetConfig);\n                    doc.Element(\u0022configuration\u0022).Element(\u0022packageSources\u0022).Add(new XElement(\u0022add\u0022,\n                        new XAttribute(\u0022key\u0022, \u0022myget\u0022), new XAttribute(\u0022value\u0022, MyGetSource)));\n\n                    doc.Save(NugetConfig);\n\n                    DotNet($\u0022add {nativeProject} package Microsoft.DotNet.ILCompiler --version 1.0.0-alpha-*\u0022);\n\n                    DotNetPublishSettings publishSettings = new DotNetPublishSettings()\n                        .SetConfiguration(Configuration);\n\n                    DotNetPublish(s =\u003E publishSettings\n                        .SetProject(nativeProject)\n                        .SetFramework(\u0022netcoreapp2.1\u0022)\n                        .SetRuntime(\u0022win-x64\u0022)\n                        .SetOutput(CliNativeDir)\n                        .SetProperties(VersionProps));\n\n                    AbsolutePath tempExe = CliNativeDir / \u0022hactoolnet_native.exe\u0022;\n\n                    File.Copy(tempExe, CliNativeExe, true);\n\n                    if (Host == HostType.AppVeyor)\n                    {\n                        AbsolutePath zipFile = CliNativeExe.Parent / \u0022hactoolnet_native.zip\u0022;\n                        ZipFiles(zipFile, new[] { CliNativeExe.ToString() });\n\n                        PushArtifact(zipFile);\n                    }\n                }\n                finally\n                {\n                    File.Delete(nativeProject);\n                    File.Delete(NugetConfig);\n                }\n            });\n\n        Target Results =\u003E _ =\u003E _\n            .DependsOn(Test, Zip, Merge, Sign, Native, Publish)\n            .Executes(() =\u003E\n            {\n                Console.WriteLine(\u0022SHA-1:\u0022);\n                using (SHA1 sha = SHA1.Create())\n                {\n                    foreach (string filename in Directory.EnumerateFiles(ArtifactsDirectory))\n                    {\n                        using (var stream = new FileStream(filename, FileMode.Open))\n                        {\n                            string hash = BitConverter.ToString(sha.ComputeHash(stream)).Replace(\u0022-\u0022, \u0022\u0022);\n                            Console.WriteLine($\u0022{hash} - {Path.GetFileName(filename)}\u0022);\n                        }\n                    }\n                }\n            });\n\n        Target Sign =\u003E _ =\u003E _\n            .DependsOn(Test, Zip, Merge)\n            .OnlyWhenStatic(() =\u003E !DoCoreBuildOnly)\n            .OnlyWhenStatic(() =\u003E File.Exists(CertFileName))\n            .Executes(() =\u003E\n            {\n                string pwd = ReadPassword();\n\n                if (pwd == string.Empty)\n                {\n                    Console.WriteLine(\u0022Skipping sign task\u0022);\n                    return;\n                }\n\n                SignAndReZip(pwd);\n            });\n\n        public static void ZipFiles(string outFile, IEnumerable\u003Cstring\u003E files)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                foreach (string file in files)\n                {\n                    var entry = new ZipEntry(Path.GetFileName(file));\n                    entry.DateTime = DateTime.UnixEpoch;\n\n                    using (FileStream fs = File.OpenRead(file))\n                    {\n                        entry.Size = fs.Length;\n                        s.PutNextEntry(entry);\n                        fs.CopyTo(s);\n                    }\n                }\n            }\n        }\n\n        public static void ZipDirectory(string outFile, string directory)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                foreach (string filePath in Directory.EnumerateFiles(directory, \u0022*\u0022, SearchOption.AllDirectories))\n                {\n                    string relativePath = Path.GetRelativePath(directory, filePath);\n\n                    var entry = new ZipEntry(relativePath);\n                    entry.DateTime = DateTime.UnixEpoch;\n\n                    using (FileStream fs = File.OpenRead(filePath))\n                    {\n                        entry.Size = fs.Length;\n                        s.PutNextEntry(entry);\n                        fs.CopyTo(s);\n                    }\n                }\n            }\n        }\n\n        public static void ZipDirectory(string outFile, string directory, IEnumerable\u003Cstring\u003E files)\n        {\n            using (var s = new ZipOutputStream(File.Create(outFile)))\n            {\n                s.SetLevel(9);\n\n                foreach (string filePath in files)\n                {\n                    string absolutePath = Path.Combine(directory, filePath);\n\n                    var entry = new ZipEntry(filePath);\n                    entry.DateTime = DateTime.UnixEpoch;\n\n                    using (FileStream fs = File.OpenRead(absolutePath))\n                    {\n                        entry.Size = fs.Length;\n                        s.PutNextEntry(entry);\n                        fs.CopyTo(s);\n                    }\n                }\n            }\n        }\n\n        public static void UnzipFiles(string zipFile, string outDir)\n        {\n            using (var s = new ZipInputStream(File.OpenRead(zipFile)))\n            {\n                ZipEntry entry;\n                while ((entry = s.GetNextEntry()) != null)\n                {\n                    string outPath = Path.Combine(outDir, entry.Name);\n\n                    string directoryName = Path.GetDirectoryName(outPath);\n                    string fileName = Path.GetFileName(outPath);\n\n                    if (!string.IsNullOrWhiteSpace(directoryName))\n                    {\n                        Directory.CreateDirectory(directoryName);\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(fileName))\n                    {\n                        using (FileStream outFile = File.Create(outPath))\n                        {\n                            s.CopyTo(outFile);\n                        }\n                    }\n                }\n            }\n        }\n\n        public static void PushArtifact(string path)\n        {\n            if (!File.Exists(path))\n            {\n                Console.WriteLine($\u0022Unable to add artifact {path}\u0022);\n            }\n\n            var psi = new ProcessStartInfo\n            {\n                FileName = \u0022appveyor\u0022,\n                Arguments = $\u0022PushArtifact \\\u0022{path}\\\u0022\u0022,\n                UseShellExecute = false,\n                RedirectStandardOutput = true,\n                RedirectStandardError = true\n            };\n\n            var proc = new Process\n            {\n                StartInfo = psi\n            };\n\n            proc.Start();\n\n            proc.WaitForExit();\n\n            Console.WriteLine($\u0022Added AppVeyor artifact {path}\u0022);\n        }\n\n        public static void SetAppVeyorVersion(string version)\n        {\n            var psi = new ProcessStartInfo\n            {\n                FileName = \u0022appveyor\u0022,\n                Arguments = $\u0022UpdateBuild -Version \\\u0022{version}\\\u0022\u0022,\n                UseShellExecute = false,\n                RedirectStandardOutput = true,\n                RedirectStandardError = true\n            };\n\n            var proc = new Process\n            {\n                StartInfo = psi\n            };\n\n            proc.Start();\n\n            proc.WaitForExit();\n        }\n\n        public static void ReplaceLineEndings(string filename)\n        {\n            string text = File.ReadAllText(filename);\n            File.WriteAllText(filename, Regex.Replace(text, @\u0022\\r\\n|\\n\\r|\\n|\\r\u0022, \u0022\\r\\n\u0022));\n        }\n\n        public static void SignAssemblies(string password, params string[] fileNames)\n        {\n            SignToolSettings settings = new SignToolSettings()\n                .SetFileDigestAlgorithm(\u0022SHA256\u0022)\n                .SetFile(CertFileName)\n                .SetFiles(fileNames)\n                .SetPassword(password)\n                .SetTimestampServerDigestAlgorithm(\u0022SHA256\u0022)\n                .SetRfc3161TimestampServerUrl(\u0022http://timestamp.digicert.com\u0022);\n\n            SignToolTasks.SignTool(settings);\n        }\n\n        public void SignAndReZip(string password)\n        {\n            AbsolutePath nupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).Single();\n            AbsolutePath snupkgFile = ArtifactsDirectory.GlobFiles(\u0022*.snupkg\u0022).Single();\n            AbsolutePath nupkgDir = TempDirectory / (\u0022sign_\u0022 \u002B Path.GetFileName(nupkgFile));\n            AbsolutePath netFxDir = TempDirectory / (\u0022sign_\u0022 \u002B Path.GetFileName(CliFrameworkZip));\n            AbsolutePath coreFxDir = TempDirectory / (\u0022sign_\u0022 \u002B Path.GetFileName(CliCoreZip));\n            AbsolutePath signedMergedExe = SignedArtifactsDirectory / Path.GetFileName(CliMergedExe);\n\n            try\n            {\n                UnzipFiles(CliFrameworkZip, netFxDir);\n                UnzipFiles(CliCoreZip, coreFxDir);\n                List\u003Cstring\u003E pkgFileList = UnzipPackage(nupkgFile, nupkgDir);\n\n                var toSign = new List\u003CAbsolutePath\u003E();\n                toSign.AddRange(nupkgDir.GlobFiles(\u0022**/LibHac.dll\u0022));\n                toSign.Add(netFxDir / \u0022hactoolnet.exe\u0022);\n                toSign.Add(coreFxDir / \u0022hactoolnet.dll\u0022);\n                toSign.Add(signedMergedExe);\n\n                Directory.CreateDirectory(SignedArtifactsDirectory);\n                File.Copy(CliMergedExe, signedMergedExe, true);\n\n                SignAssemblies(password, toSign.Select(x =\u003E x.ToString()).ToArray());\n\n                // Avoid having multiple signed versions of the same file\n                File.Copy(nupkgDir / \u0022lib\u0022 / \u0022net46\u0022 / \u0022LibHac.dll\u0022, netFxDir / \u0022LibHac.dll\u0022, true);\n                File.Copy(nupkgDir / \u0022lib\u0022 / \u0022netcoreapp2.1\u0022 / \u0022LibHac.dll\u0022, coreFxDir / \u0022LibHac.dll\u0022, true);\n\n                ZipDirectory(SignedArtifactsDirectory / Path.GetFileName(nupkgFile), nupkgDir, pkgFileList);\n                ZipDirectory(SignedArtifactsDirectory / Path.GetFileName(CliFrameworkZip), netFxDir);\n                ZipDirectory(SignedArtifactsDirectory / Path.GetFileName(CliCoreZip), coreFxDir);\n\n                File.Copy(snupkgFile, SignedArtifactsDirectory / Path.GetFileName(snupkgFile));\n\n                SignNupkg(SignedArtifactsDirectory / Path.GetFileName(nupkgFile), password);\n                SignNupkg(SignedArtifactsDirectory / Path.GetFileName(snupkgFile), password);\n            }\n            catch (Exception)\n            {\n                Directory.Delete(SignedArtifactsDirectory, true);\n                throw;\n            }\n            finally\n            {\n                Directory.Delete(nupkgDir, true);\n                Directory.Delete(netFxDir, true);\n                Directory.Delete(coreFxDir, true);\n            }\n        }\n\n        public static string ReadPassword()\n        {\n            var pwd = new StringBuilder();\n            ConsoleKeyInfo key;\n\n            Console.Write(\u0022Enter certificate password (Empty password to skip): \u0022);\n            do\n            {\n                key = Console.ReadKey(true);\n\n                // Ignore any key out of range.\n                if (((int)key.Key) \u003E= \u0027!\u0027 \u0026\u0026 ((int)key.Key \u003C= \u0027~\u0027))\n                {\n                    // Append the character to the password.\n                    pwd.Append(key.KeyChar);\n                    Console.Write(\u0022*\u0022);\n                }\n\n                // Exit if Enter key is pressed.\n            } while (key.Key != ConsoleKey.Enter);\n\n            Console.WriteLine();\n\n            return pwd.ToString();\n        }\n    }\n}\n"
  },
  {
    "Id": 198123201,
    "FirstIndexed": "2020-04-25T15:47:03.6115504+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625236+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431578+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937467+02:00",
    "Name": "AspNetCore.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/AspNetCore.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/AspNetCore.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 198468465,
    "FirstIndexed": "2020-04-25T15:47:03.6115459+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625207+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431589+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "NodaTime.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/NodaTime.Extensions",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 198492991,
    "FirstIndexed": "2020-04-25T15:47:03.6115413+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625179+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431595+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937479+02:00",
    "Name": "Quests",
    "Owner": "paulalves",
    "HtmlUrl": "https://github.com/paulalves/Quests",
    "Description": "A quest is a basic progression mechanic in which you earn points that contribute toward an end goal.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "tools/nuke/Build.cs",
    "BuildFileUrl": "https://github.com/paulalves/Quests/blob/master/tools/nuke/Build.cs",
    "BuildFileSize": 5236,
    "BuildFileContent": "// ReSharper disable All\r\n\r\nusing System.CodeDom;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.OpenCover;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing SqlClient;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\n\r\n[ExcludeFromCodeCoverage]\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild {\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    [Parameter(\u0022The host name used to reach the database.\u0022)] readonly string MigrateSqlHostname;\r\n\r\n    [Parameter(\u0022The password used to log in into the database.\u0022)] readonly string MigrateSqlPassword;\r\n\r\n    [Parameter(\u0022The provider id used to run migrations, and execute SQL builder actions.\u0022)]\r\n    readonly string MigrateSqlProviderId;\r\n\r\n    [Parameter(\u0022The user name used to log in into the database.\u0022)] readonly string MigrateSqlUser;\r\n\r\n    [Solution] readonly Solution Solution;\r\n\r\n    [Parameter] readonly string SonarKey;\r\n\r\n    [Parameter] readonly string SonarLogin;\r\n\r\n    [Parameter] readonly string SonarOrg;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobFiles(\u0022**/*opencover.xml\u0022).ForEach(DeleteFile);\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022, \u0022**/TestResults\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(OutputDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    Target InstallTools =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetToolInstall(d =\u003E d.EnableGlobal().SetPackageName(\u0022dotnet-sonarscanner\u0022));\r\n            DotNetToolInstall(d =\u003E d.EnableGlobal().SetPackageName(\u0022FluentMigrator.DotNet.Cli\u0022));\r\n        });\r\n\r\n    Target Migrate =\u003E _ =\u003E _\r\n        .Requires(() =\u003E MigrateSqlUser)\r\n        .Requires(() =\u003E MigrateSqlHostname)\r\n        .Requires(() =\u003E MigrateSqlPassword)\r\n        .Requires(() =\u003E MigrateSqlProviderId)\r\n        .DependsOn(Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNet(SqlBuilder\r\n                .By(MigrateSqlProviderId)\r\n                .BuildCommandUp(SourceDirectory,\r\n                    new SqlBuilderOptions(\r\n                        MigrateSqlUser, MigrateSqlPassword, MigrateSqlHostname, isMaster: false\r\n                    ))\r\n            );\r\n        });\r\n\r\n    Target Run =\u003E _ =\u003E _\r\n        .DependsOn(Test)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRun(p =\u003E p.SetProjectFile(\u0022src/PlayGames.Quests.WebApp/PlayGames.Quests.WebApp.csproj\u0022));\r\n        });\r\n\r\n    Target Test =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetTest(t =\u003E t\r\n                .SetProjectFile(Solution)\r\n                .ToggleRunCodeAnalysis()\r\n                .EnableRunCodeAnalysis()\r\n                .AddProperty(\u0022CollectCoverage\u0022, \u0022true\u0022)\r\n                .AddProperty(\u0022CoverletOutputFormat\u0022, \u0022opencover\u0022)\r\n                .AddProperty(\u0022CoverletOutput\u0022, \u0022./coverage\u0022)\r\n                .SetDataCollector(\u0022Code Coverage\u0022)\r\n                .SetConfiguration(Configuration)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    Target BeginAnalysis =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNet(\r\n                $\u0022SonarScanner begin /k:\\\u0022{SonarKey}\\\u0022 /o:\\\u0022{SonarOrg}\\\u0022 /d:sonar.cs.opencover.reportsPaths=\\\u0022{string.Join(\u0022,\u0022, SourceDirectory.GlobFiles(\u0022**/*.opencover.xml\u0022))}\\\u0022 /d:sonar.host.url=\\\u0022https://sonarcloud.io\\\u0022 /d:sonar.login=\\\u0022{SonarLogin}\\\u0022\u0022);\r\n        });\r\n\r\n\r\n    Target Analysis =\u003E _ =\u003E _\r\n        .DependsOn(BeginAnalysis)\r\n        .Requires(() =\u003E SonarKey)\r\n        .Requires(() =\u003E SonarOrg)\r\n        .Requires(() =\u003E SonarLogin)\r\n        .Executes(Test);\r\n\r\n    Target EndAnalysis =\u003E _ =\u003E _\r\n        .TriggeredBy(Analysis)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNet($\u0022SonarScanner end /d:sonar.login=\\\u0022{SonarLogin}\\\u0022\u0022);\r\n        });\r\n\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n}"
  },
  {
    "Id": 199115323,
    "FirstIndexed": "2020-04-25T15:47:03.6115243+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630351+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431607+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893749+02:00",
    "Name": "NukeTest",
    "Owner": "Fubuchi",
    "HtmlUrl": "https://github.com/Fubuchi/NukeTest",
    "Description": "Test how create a C# solution with NUKE ",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Fubuchi/NukeTest/blob/master/build/Build.cs",
    "BuildFileSize": 4905,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.NUnit;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.ReportGenerator;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.GitHub.ChangeLogExtensions;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n  public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n  [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n  readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n  [Solution] readonly Solution Solution;\n  [GitRepository] readonly GitRepository GitRepository;\n  [GitVersion] readonly GitVersion GitVersion;\n\n  AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n  AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n  AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n  AbsolutePath TestResultDirectory =\u003E OutputDirectory / \u0022test-result\u0022;\n  AbsolutePath PackDirectory =\u003E OutputDirectory / \u0022dist\u0022;\n\n  string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n  Target CleanAll =\u003E _ =\u003E _\n      .DependsOn(Clean)\n      .DependsOn(CleanTestResult)\n      .Executes(() =\u003E { });\n\n  Target Clean =\u003E _ =\u003E _\n      .Before(Restore)\n      .Executes(() =\u003E\n      {\n        SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n      });\n\n  Target CleanTestResult =\u003E _ =\u003E _\n      .Executes(() =\u003E\n      {\n        TestResultDirectory.GlobFiles(\u0022*\u0022).ForEach(DeleteFile);\n      });\n\n  Target Restore =\u003E _ =\u003E _\n      .Executes(() =\u003E\n      {\n        DotNetRestore(s =\u003E s\n              .SetProjectFile(Solution));\n      });\n\n  Target Compile =\u003E _ =\u003E _\n      .DependsOn(Restore)\n      .Executes(() =\u003E\n      {\n        DotNetBuild(s =\u003E s\n          .SetProjectFile(Solution)\n          .SetConfiguration(Configuration)\n          .SetAssemblyVersion(GitVersion.AssemblySemVer)\n          .SetFileVersion(GitVersion.AssemblySemFileVer)\n          .SetInformationalVersion(GitVersion.InformationalVersion)\n          .EnableNoRestore());\n      });\n\n  Target Pack =\u003E _ =\u003E _\n      .DependsOn(Compile)\n      .Executes(() =\u003E\n      {\n        var changeLog = GetCompleteChangeLog(ChangeLogFile)\n          .EscapeStringPropertyForMsBuild();\n\n        DotNetPack(x =\u003E x\n          .SetConfiguration(Configuration)\n          .SetPackageReleaseNotes(changeLog)\n          .EnableNoBuild()\n          .SetOutputDirectory(PackDirectory)\n          .SetVersion(GitVersion.NuGetVersion));\n      });\n\n  Target Test =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .DependsOn(CleanTestResult)\n    .Executes(() =\u003E\n    {\n      var testProjects = GlobFiles(TestsDirectory, \u0022**/*.csproj\u0022);\n      testProjects\n        .NotEmpty()\n        .ForEach(testProject =\u003E\n        {\n          var projectDirectory = Path.GetDirectoryName(testProject);\n          var projectName = Path.GetFileNameWithoutExtension(testProject);\n          var current = DateTime.Now.ToString(\u0022yyyyMMddHHmmssfff\u0022);\n          DotNetTest(x =\u003E x\n            .SetNoBuild(true)\n            .SetProjectFile(testProject)\n            .SetTestAdapterPath(\u0022.\u0022)\n            .SetResultsDirectory(TestResultDirectory)\n            .SetLogger($\u0022trx;LogFileName={$\u0022test_{projectName}_{current}.xml\u0022}\u0022));\n        });\n    });\n\n  Target Coverage =\u003E _ =\u003E _\n    .DependsOn(Compile)\n    .DependsOn(CleanTestResult)\n    .Executes(() =\u003E\n    {\n      var testProjects = GlobFiles(TestsDirectory, \u0022**/*.csproj\u0022).ToList();\n      var dotnetPath = ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022);\n      testProjects\n        .NotEmpty()\n        .ForEach(testProject =\u003E\n        {\n          var projectDirectory = Path.GetDirectoryName(testProject);\n          var projectName = Path.GetFileNameWithoutExtension(testProject);\n          var dllPath = GlobFiles(projectDirectory, $\u0022**/*/{projectName}.dll\u0022).First();\n          var current = DateTime.Now.ToString(\u0022yyyyMMddHHmmssfff\u0022);\n\n          CoverletTasks.Coverlet(s =\u003E s\n            .SetAssembly(dllPath)\n            .SetTarget(dotnetPath)\n            .SetTargetArgs(new[]{\n              \u0022test\u0022,\n              projectDirectory,\n              \u0022--no-build\u0022\n            })\n            .SetOutput(TestResultDirectory / $\u0022{projectName}_{current}.xml\u0022)\n            .SetFormat(CoverletOutputFormat.cobertura));\n        });\n      ReportGeneratorTasks.ReportGenerator(s =\u003E s\n            .SetTargetDirectory(TestResultDirectory)\n            .SetReports(TestResultDirectory / \u0022*.xml\u0022));\n    });\n\n\n}\n"
  },
  {
    "Id": 199333306,
    "FirstIndexed": "2020-04-25T15:47:03.6115385+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625168+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431618+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937501+02:00",
    "Name": "ReactiveUI.Plugins.Popup",
    "Owner": "RLittlesII",
    "HtmlUrl": "https://github.com/RLittlesII/ReactiveUI.Plugins.Popup",
    "Description": "ReactiveUI extension of Rg.Plugins.Popup for better framework integration",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RLittlesII/ReactiveUI.Plugins.Popup/blob/master/.build/Build.cs",
    "BuildFileSize": 731,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Program : DotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CProgram\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _.DependsOn(DotNetCore);\n}\n\n"
  },
  {
    "Id": 199650397,
    "FirstIndexed": "2020-04-25T15:47:03.6115288+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631676+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431629+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937513+02:00",
    "Name": "GradeView",
    "Owner": "osisa",
    "HtmlUrl": "https://github.com/osisa/GradeView",
    "Description": "Schnupperstifte ",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/osisa/GradeView/blob/master/build/Build.cs",
    "BuildFileSize": 2943,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022../artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n       .DependsOn(Compile)\n       .Executes(() =\u003E\n       {\n           DotNetPublish(s =\u003E s\n               .SetConfiguration(Configuration.Release)\n              \n               .SetOutput(ArtifactsDirectory));\n       });\n\n    Target PushGhPages =\u003E _ =\u003E _\n      .DependsOn(Publish)\n      .Executes(() =\u003E\n      {\n          Nuke.Common.GitTool.Git(s =\u003E s\n              .SetConfiguration(Configuration.Release)\n\n              .SetOutput(ArtifactsDirectory));\n      });\n\n}\n"
  },
  {
    "Id": 200071790,
    "FirstIndexed": "2020-04-25T15:47:03.6114913+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631141+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431641+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937524+02:00",
    "Name": "web-fls-quiz",
    "Owner": "vkamiansky",
    "HtmlUrl": "https://github.com/vkamiansky/web-fls-quiz",
    "Description": "A simple quiz platform. A small quiz website.",
    "Archived": false,
    "Stars": 3,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/vkamiansky/web-fls-quiz/blob/master/build/Build.cs",
    "BuildFileSize": 5237,
    "BuildFileContent": "using System;\nusing Nuke.Docker;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.BuildServers;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Docker.DockerTasks;\n\nnamespace Build\n{\n    [CheckBuildProjectConfigurations]\n    [UnsetVisualStudioEnvironmentVariables]\n    class BuildRoot : NukeBuild\n    {\n        public static int Main() =\u003E Execute\u003CBuildRoot\u003E(x =\u003E x.Compile);\n\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n        [Parameter(\u0022Docker Hub username for publishing docker images\u0022)] readonly string DockerUser;\n        [Parameter(\u0022Docker Hub password for publishing docker images\u0022)] readonly string DockerPass;\n\n        [Solution] readonly Solution Solution;\n        [GitRepository] readonly GitRepository GitRepository;\n        [GitVersion] readonly GitVersion GitVersion;\n\n        AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n        readonly string DockerImageName = \u0022vkamiansky/flsquiz\u0022;\n\n        Target ScenarioDetails =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                Console.WriteLine(IsLocalBuild ? \u0022Local build.\u0022 : \u0022Server build.\u0022);\n                if (!IsLocalBuild)\n                {\n                    Console.WriteLine(\u0022AppVeyor environment status details:\u0022);\n                    Console.WriteLine($\u0022Repository branch: {AppVeyor.Instance?.RepositoryBranch}\u0022);\n                    if (AppVeyor.Instance.RepositoryTag)\n                    {\n                        Console.WriteLine($\u0022Repository tag: {AppVeyor.Instance?.RepositoryTagName}\u0022);\n                    }\n                }\n                Console.WriteLine(string.IsNullOrWhiteSpace(DockerUser) ? \u0022(-) Docker user not specified.\u0022 : \u0022(V) Docker user specified.\u0022);\n                Console.WriteLine(string.IsNullOrWhiteSpace(DockerPass) ? \u0022(-) Docker password not specified.\u0022 : \u0022(V) Docker password specified.\u0022);\n            });\n\n        Target Clean =\u003E _ =\u003E _\n            .Before(Restore)\n            .Executes(() =\u003E\n            {\n                SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            });\n\n        Target MakeBundle =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                var scriptsDirectory = SourceDirectory / \u0022web-fls-quiz\u0022 / \u0022wwwroot\u0022 / \u0022scripts\u0022;\n                var componentsDirectory = scriptsDirectory / \u0022apps\u0022 / \u0022quiz\u0022 / \u0022components\u0022;\n                BundleMaker.Run(\n                    scriptsDirectory,\n                    componentsDirectory,\n                    \u0022components-bundle.js\u0022);\n            });\n\n        Target Restore =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                DotNetRestore(s =\u003E s\n                    .SetProjectFile(Solution));\n            });\n\n        Target Compile =\u003E _ =\u003E _\n            .OnlyWhenDynamic(() =\u003E IsLocalBuild || !AppVeyor.Instance.RepositoryTag)\n            .DependsOn(ScenarioDetails, Restore, MakeBundle)\n            .WhenSkipped(DependencyBehavior.Skip)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E s\n                    .SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                    .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                    .EnableNoRestore());\n            });\n\n        Target BuildDockerImage =\u003E _ =\u003E _\n            .OnlyWhenDynamic(() =\u003E IsLocalBuild || AppVeyor.Instance.RepositoryTag)\n            .DependsOn(ScenarioDetails, MakeBundle)\n            .WhenSkipped(DependencyBehavior.Skip)\n            .Executes(() =\u003E\n            {\n                DockerBuild(x =\u003E x\n                    .SetPath(SourceDirectory / \u0022web-fls-quiz\u0022)\n                    .SetFile(SourceDirectory / \u0022web-fls-quiz\u0022 / \u0022Dockerfile\u0022)\n                    .SetTag(DockerImageName \u002B \u0022:\u0022 \u002B AppVeyor.Instance.RepositoryTagName)\n                );\n            });\n\n        Target PublishDockerImage =\u003E _ =\u003E _\n            .OnlyWhenDynamic(() =\u003E IsLocalBuild || AppVeyor.Instance.RepositoryTag,\n                             () =\u003E AppVeyor.Instance.RepositoryBranch == \u0022master\u0022,\n                             () =\u003E !string.IsNullOrWhiteSpace(AppVeyor.Instance.RepositoryTagName))\n            .Requires(() =\u003E DockerUser)\n            .Requires(() =\u003E DockerPass)\n            .DependsOn(BuildDockerImage)\n            .WhenSkipped(DependencyBehavior.Skip)\n            .Executes(() =\u003E\n            {\n                DockerLogin(x =\u003E x\n                    .SetUsername(DockerUser)\n                    .SetPassword(DockerPass)\n                    );\n\n                DockerPush(x =\u003E x\n                    .SetName(DockerImageName \u002B \u0022:\u0022 \u002B AppVeyor.Instance.RepositoryTagName)\n                    );\n            });\n    }\n}"
  },
  {
    "Id": 200323561,
    "FirstIndexed": "2020-04-25T15:47:03.6115265+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625111+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431646+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "AutomationCompanion",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/AutomationCompanion",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 201053186,
    "FirstIndexed": "2020-04-25T15:47:03.6111886+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630521+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431658+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893753+02:00",
    "Name": "Nyxie",
    "Owner": "avivasolutionsnl",
    "HtmlUrl": "https://github.com/avivasolutionsnl/Nyxie",
    "Description": "Nyxie is a #Sitecore Commerce plugin that adds a bunch of qualifications and promotions ",
    "Archived": false,
    "Stars": 5,
    "Watchers": 3,
    "BuildFilePath": "nuke/Build.cs",
    "BuildFileUrl": "https://github.com/avivasolutionsnl/Nyxie/blob/master/nuke/Build.cs",
    "BuildFileSize": 5240,
    "BuildFileContent": "using System;\nusing System.Linq;\n\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.Xunit;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing static Nuke.GitHub.GitHubTasks;\nusing static CourierTasks;\n\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] string GitHubAuthenticationToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target RunTests =\u003E _ =\u003E _\n       .DependsOn(Compile)\n       .Executes(() =\u003E\n       {\n           var unitTestDlls = SourceDirectory.GlobFiles(\n               $\u0022*Tests/bin/{Configuration}/*/*.Tests.dll\u0022);\n\n           Xunit2(x =\u003E x.AddTargetAssemblies(unitTestDlls.Select(x =\u003E x.ToString()))\n                                    .SetFramework(\u0022net471\u0022)\n                                    .AddResultReport(Xunit2ResultFormat.Xml, OutputDirectory / \u0022testresults.xml\u0022));\n       });\n\n    Target Package =\u003E _ =\u003E _\n       .DependsOn(RunTests)\n       .Executes(() =\u003E\n       {\n           Courier(c =\u003E c.SetTargetFolder(RootDirectory / \u0022unicorn\u0022)\n                         .SetOutputPackage(OutputDirectory / $\u0022Nyxie-{GitVersion.AssemblySemVer}.update\u0022)\n                         .SetRainbowFormat(true));\n\n           DotNetPack(s =\u003E s.SetProject(SourceDirectory / \u0022Nyxie.Plugin.Promotions/Nyxie.Plugin.Promotions.csproj\u0022)\n                            .SetVersion(GitVersion.AssemblySemVer)\n                            .SetOutputDirectory(OutputDirectory));\n       });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Package)\n        .Requires(() =\u003E GitHubAuthenticationToken)\n        .OnlyWhenStatic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n        .Executes(async () =\u003E\n        {\n            var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n            var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n            var latestChangeLog = changeLogSectionEntries\n                .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n            var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n            var packages = GlobFiles(OutputDirectory, \u0022*.nupkg\u0022, \u0022*.update\u0022)\n                                .NotEmpty(\u0022No packages found\u0022)\n                                .ToArray();\n\n            await PublishRelease(c =\u003E c.SetArtifactPaths(packages)\n                                 .SetCommitSha(GitVersion.Sha)\n                                 .SetReleaseNotes(completeChangeLog)\n                                 .SetRepositoryName(repositoryInfo.repositoryName)\n                                 .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                                 .SetTag(releaseTag)\n                                 .SetToken(GitHubAuthenticationToken));\n        });\n\n}\n"
  },
  {
    "Id": 201521563,
    "FirstIndexed": "2020-04-25T15:47:03.6114446+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631346+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431669+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937541+02:00",
    "Name": "tcc_lang_backend",
    "Owner": "viniciustozzi",
    "HtmlUrl": "https://github.com/viniciustozzi/tcc_lang_backend",
    "Description": "Backend for TCC Facens 2019",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/viniciustozzi/tcc_lang_backend/blob/master/build/Build.cs",
    "BuildFileSize": 3383,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Docker;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Docker.DockerTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    AbsolutePath Dockerfile =\u003E RootDirectory / \u0022build/Dockerfile\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .DisableSelfContained()\n                .SetOutput(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetConfiguration(\u0022Release\u0022));\n        });\n\n    Target DBuild =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n            DockerBuild(s =\u003E s\n                .SetFile(Dockerfile)\n                .SetWorkingDirectory(OutputDirectory)\n                .SetTag($\u0022{Solution.Name.ToLower()}:{GitVersion.GetNormalizedAssemblyVersion()}\u0022)\n                .SetPath(\u0022.\u0022)\n            );\n        });\n\n    Target Run =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetRun(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022TccLangBackend.Api\u0022).Path)\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetEnvironmentVariable(\u0022ASPNETCORE_URLS\u0022, \u0022http://0.0.0.0:5000\u0022)\n                .SetEnvironmentVariable(\u0022ASPNETCORE_ENVIRONMENT\u0022, \u0022Development\u0022));\n        });\n\n    Target Migrate =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNet(\u0022ef database update\u0022, Solution.GetProject(\u0022TccLangBackend.Api\u0022)?.Directory);\n        });\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n}"
  },
  {
    "Id": 201833313,
    "FirstIndexed": "2020-04-25T15:47:03.6115146+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1625037+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431681+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937553+02:00",
    "Name": "Meta",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Meta",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Meta/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 202184588,
    "FirstIndexed": "2020-04-25T15:50:44.7361044+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631585+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843477+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940494+02:00",
    "Name": "TSVDExamples",
    "Owner": "SpectrumLi",
    "HtmlUrl": "https://github.com/SpectrumLi/TSVDExamples",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "DateTimeExtensions/build/Build.cs",
    "BuildFileUrl": "https://github.com/SpectrumLi/TSVDExamples/blob/master/DateTimeExtensions/build/Build.cs",
    "BuildFileSize": 2378,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.EnvironmentInfo;\nusing System.IO;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.BuildServers;\n\nclass Build : NukeBuild\n{\n    // Console application entry. Also defines the default target.\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    // Auto-injection fields:\n    // [GitVersion] readonly GitVersion GitVersion;\n    //  - Semantic versioning. Must have \u0027GitVersion.CommandLine\u0027 referenced.\n    // [GitRepository] readonly GitRepository GitRepository;\n    //  - Parses origin, branch name and head from git config.\n    // [Parameter] readonly string MyGetApiKey;\n    //  - Returns command-line arguments and environment variables.\n\n    public bool IsTagged =\u003E AppVeyor.Instance?.RepositoryTag ?? false;\n\n    int Revision =\u003E AppVeyor.Instance?.BuildNumber ?? 1;\n\n    public string RevisionString =\u003E IsTagged ? null : $\u0022rev{Revision:D4}\u0022;\n\n    public string ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    public string OutputDirectory =\u003E RootDirectory / \u0022.output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                EnsureCleanDirectory(OutputDirectory);\n                EnsureCleanDirectory(ArtifactsDirectory);\n            });\n\n    Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore();\n            });\n\n    Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(s =\u003E s\n                    .SetVersionSuffix(RevisionString));\n            });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetProject(RootDirectory / \u0022src\u0022 / \u0022DateTimeExtensions\u0022)\n                .SetVersionSuffix(RevisionString));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(RootDirectory / \u0022tests\u0022 / \u0022DateTimeExtensions.Tests\u0022));\n        });\n}\n"
  },
  {
    "Id": 202559189,
    "FirstIndexed": "2020-04-25T15:50:44.7360083+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630675+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434696+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894042+02:00",
    "Name": "ForTea",
    "Owner": "JetBrains",
    "HtmlUrl": "https://github.com/JetBrains/ForTea",
    "Description": null,
    "Archived": false,
    "Stars": 28,
    "Watchers": 20,
    "BuildFilePath": "Backend/build/Build.cs",
    "BuildFileUrl": "https://github.com/JetBrains/ForTea/blob/master/Backend/build/Build.cs",
    "BuildFileSize": 4086,
    "BuildFileContent": "using System;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\n[CheckBuildProjectConfigurations]\ninternal class Build : NukeBuild\n{\n\t[NotNull]\n\tprivate static Regex ReSharperSdkVersionRegex { get; } =\n\t\tnew Regex(\u0022\u003CReSharperSdkVersion\u003E(?\u003Cversion\u003E.*)\u003C/ReSharperSdkVersion\u003E\u0022);\n\n\t[Parameter]\n\tpublic readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Parameter] public readonly string NuGetSource = \u0022https://plugins.jetbrains.com/\u0022;\n\t[Parameter] public readonly string WaveVersion;\n\t[Parameter] public readonly string NuGetApiKey;\n\t[Solution] private readonly Solution Solution;\n\tprivate const string MainProjectName = \u0022ForTea.ReSharperPlugin\u0022;\n\tprivate AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022artifacts\u0022 / Configuration;\n\n\t[NotNull]\n\tpublic Target Compile =\u003E target =\u003E target\n\t\t.Requires(() =\u003E !File.Exists(RootDirectory / \u0022RiderSdkPackageVersion.props\u0022))\n\t\t.Executes(() =\u003E DotNetTasks.DotNetBuild(settings =\u003E settings\n\t\t\t.SetConfiguration(Configuration)\n\t\t\t.SetProjectFile(Solution)));\n\n\t[NotNull]\n\tpublic Target Pack =\u003E target =\u003E target\n\t\t.DependsOn(Compile)\n\t\t.Executes(() =\u003E NuGetPack(settings =\u003E settings\n\t\t\t.SetTargetPath(RootDirectory / \u0022ForTea.nuspec\u0022)\n\t\t\t.SetOutputDirectory(OutputDirectory)\n\t\t\t.SetProperty(\u0022jetBrainsYearSpan\u0022, GetJetBrainsYearSpan())\n\t\t\t.SetProperty(\u0022releaseNotes\u0022, GetLatestReleaseNotes())\n\t\t\t.SetProperty(\u0022configuration\u0022, Configuration.ToString())\n\t\t\t.SetProperty(\u0022sdkVersion\u0022, GetReSharperSdkVersion())\n\t\t\t.SetProperty(\u0022wave\u0022, GetOrSelectWaveVersion())\n\t\t\t.EnableNoPackageAnalysis()));\n\n\t[NotNull]\n\tpublic Target Push =\u003E target =\u003E target\n\t\t.DependsOn(Pack)\n\t\t.Requires(() =\u003E NuGetApiKey)\n\t\t.Requires(() =\u003E Configuration.Release.Equals(Configuration))\n\t\t.Requires(() =\u003E GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).Count == 1)\n\t\t.Executes(() =\u003E NuGetPush(settings =\u003E settings\n\t\t\t.SetTargetPath(GlobFiles(OutputDirectory, \u0022*.nupkg\u0022).Single())\n\t\t\t.SetSource(NuGetSource)\n\t\t\t.SetApiKey(NuGetApiKey)));\n\n\t[NotNull]\n\tprivate string GetJetBrainsYearSpan()\n\t{\n\t\tconst int startYear = 2019;\n\t\tint currentYear = DateTime.Now.Year;\n\t\tstring startYearString = startYear.ToString(CultureInfo.InvariantCulture);\n\t\tif (currentYear == startYear) return startYearString;\n\t\tstring currentYearString = currentYear.ToString(CultureInfo.InvariantCulture);\n\t\treturn $\u0022{startYearString}-{currentYearString}\u0022;\n\t}\n\n\t[NotNull]\n\tprivate static string GetLatestReleaseNotes() =\u003E File\n\t\t.ReadAllLines(RootDirectory.Parent / \u0022CHANGELOG.md\u0022)\n\t\t.SkipWhile(x =\u003E !x.StartsWith(\u0022##\u0022, StringComparison.Ordinal))\n\t\t.Skip(1)\n\t\t.TakeWhile(x =\u003E !string.IsNullOrWhiteSpace(x))\n\t\t.Select(x =\u003E $\u0022\\u2022{x.TrimStart(\u0027-\u0027)}\u0022)\n\t\t.JoinNewLine();\n\n\t[NotNull]\n\tprivate static string GetReSharperSdkVersion() =\u003E File\n\t\t.ReadLines(RootDirectory / \u0022targets\u0022 / \u0022ReSharperPluginTargets.targets\u0022)\n\t\t.Select(line =\u003E ReSharperSdkVersionRegex.Match(line))\n\t\t.Single(match =\u003E match.Success)\n\t\t.Groups[\u0022version\u0022]\n\t\t.Value;\n\n\t[NotNull]\n\tprivate string GetOrSelectWaveVersion()\n\t{\n\t\tif (WaveVersion != null)\n\t\t{\n\t\t\tConsole.WriteLine($\u0022Building for given wave version: {WaveVersion}\u0022);\n\t\t\treturn WaveVersion;\n\t\t}\n\n\t\tstring selected = NuGetPackageResolver\n\t\t\t.GetLocalInstalledPackages(RootDirectory / MainProjectName / (MainProjectName \u002B \u0022.csproj\u0022))\n\t\t\t.Where(x =\u003E x.Id == \u0022Wave\u0022)\n\t\t\t.OrderByDescending(x =\u003E x.Version.Version)\n\t\t\t.FirstOrDefault()\n\t\t\t.NotNull(\u0022There\u0027s no R# installed and no wave version is given. Please, pass wave version as an argument: \u0027--waveVersion 193.0\u0027\u0022)\n\t\t\t.Version\n\t\t\t.Version\n\t\t\t.ToString(2);\n\t\tConsole.WriteLine($\u0022No WaveVersion is given. Auto-detected version:{selected}\u0022);\n\t\treturn selected;\n\t}\n\n\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n}\n"
  },
  {
    "Id": 203414193,
    "FirstIndexed": "2020-04-25T15:47:03.6115123+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631557+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431686+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937564+02:00",
    "Name": "GreatView",
    "Owner": "maske-one",
    "HtmlUrl": "https://github.com/maske-one/GreatView",
    "Description": "GradeView updated to .NetCore Version Preview 8",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/maske-one/GreatView/blob/master/build/Build.cs",
    "BuildFileSize": 2699,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022../artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n       .DependsOn(Compile)\n       .Executes(() =\u003E\n       {\n           DotNetPublish(s =\u003E s\n               .SetConfiguration(Configuration.Release)\n              \n               .SetOutput(ArtifactsDirectory));\n       });\n\n}\n"
  },
  {
    "Id": 203591854,
    "FirstIndexed": "2020-04-25T15:47:03.61151+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.16315+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431703+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937575+02:00",
    "Name": "kubectl-version-manager",
    "Owner": "buehler",
    "HtmlUrl": "https://github.com/buehler/kubectl-version-manager",
    "Description": "KVM (kvm) is a version manager for kubectl versions. (like nvm or any other *vm)",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/buehler/kubectl-version-manager/blob/master/build/Build.cs",
    "BuildFileSize": 3470,
    "BuildFileContent": "using System.Collections.Generic;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Semver;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Version number that is built.\u0022)] readonly string Version = \u00220.0.0\u0022;\n\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    IEnumerable\u003Cstring\u003E Runtimes = new[] { \u0022linux-x64\u0022, \u0022linux-musl-x64\u0022, \u0022osx-x64\u0022, \u0022win-x64\u0022 };\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n            DotNetClean(s =\u003E s.SetProject(Solution).SetConfiguration(Configuration));\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E DotNetBuild(s =\u003E s\n            .SetProjectFile(Solution)\n            .SetConfiguration(Configuration)\n            .EnableNoRestore())\n        );\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E DotNetPublish(s =\u003E s\n            .SetProject(Solution)\n            .SetConfiguration(Configuration)\n            .AddProperty(\u0022PublishSingleFile\u0022, true)\n            .SetVersion(Version)\n            .SetAssemblyVersion(Version)\n            .SetFileVersion(Version)\n            .SetInformationalVersion(Version)\n            .CombineWith(\n                Runtimes,\n                (settings, runtime) =\u003E settings\n                    .SetRuntime(runtime)\n                    .SetOutput(ArtifactsDirectory / runtime))));\n\n    Target Ci =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E Version != \u00220.0.0\u0022 \u0026\u0026 SemVersion.Parse(Version, true) != null)\n        .DependsOn(Publish)\n        .Executes(() =\u003E\n        {\n            var zip = new FastZip();\n            foreach (var runtime in Runtimes)\n            {\n                Logger.Info($\u0022Create zip for {runtime} v{Version}.\u0022);\n                zip.CreateZip(\n                    $\u0022{ArtifactsDirectory / runtime}-v{Version}.zip\u0022,\n                    ArtifactsDirectory / runtime,\n                    false,\n                    \u0022-.pdb\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 204432653,
    "FirstIndexed": "2020-04-25T15:47:03.6114793+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.16249+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431726+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "SmartAppartment",
    "Owner": "tatarincev",
    "HtmlUrl": "https://github.com/tatarincev/SmartAppartment",
    "Description": "Contains technical assessment  projects",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 204836105,
    "FirstIndexed": "2020-04-25T15:50:44.735155+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622363+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433313+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939083+02:00",
    "Name": "ReactiveUI.Showroom",
    "Owner": "RLittlesII",
    "HtmlUrl": "https://github.com/RLittlesII/ReactiveUI.Showroom",
    "Description": "A repository to show case the features of the ReactiveUI platform.",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RLittlesII/ReactiveUI.Showroom/blob/master/.build/Build.cs",
    "BuildFileSize": 1892,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Rocket.Surgery.Nuke;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Rocket.Surgery.Nuke.Xamarin;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\ninternal class Showroom : XamariniOSBuild, IXamariniOSBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CShowroom\u003E(x =\u003E x.Default);\n\n    public override AbsolutePath InfoPlist { get; } = RootDirectory / \u0022src\u0022 / \u0022iOS\u0022 / \u0022info.plist\u0022;\n\n    public override string BaseBundleIdentifier { get; } = \u0022com.reactiveui.showroom\u0022;\n\n    private Target Default =\u003E _ =\u003E _\n        .DependsOn(XamariniOS);\n\n    public Target Restore =\u003E _ =\u003E _\n        .With(this, XamariniOSBuild.Restore);\n\n    public Target ModifyInfoPlist =\u003E _ =\u003E _\n        .With(this, XamariniOSBuild.ModifyInfoPlist);\n\n    public Target Build =\u003E _ =\u003E _\n        .With(this, XamariniOSBuild.Build)\n        .DependsOn(ModifyInfoPlist);\n\n    public Target Test =\u003E _ =\u003E _\n        .With(this, XamariniOSBuild.Test);\n\n    public Target Package =\u003E _ =\u003E _\n        .With(this, XamariniOSBuild.Package);\n\n    public Target XamariniOS =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(ModifyInfoPlist)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Package);\n}"
  },
  {
    "Id": 205710795,
    "FirstIndexed": "2020-04-25T15:47:03.6111579+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630464+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431737+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937581+02:00",
    "Name": "CSharp-Fundamentals",
    "Owner": "jubayerarefin",
    "HtmlUrl": "https://github.com/jubayerarefin/CSharp-Fundamentals",
    "Description": "Learning CSharp",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/jubayerarefin/CSharp-Fundamentals/blob/master/build/Build.cs",
    "BuildFileSize": 2436,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 206656058,
    "FirstIndexed": "2020-04-25T15:47:03.6114844+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630732+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431749+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937592+02:00",
    "Name": "web-config-transform-buildpack",
    "Owner": "cloudfoundry-community",
    "HtmlUrl": "https://github.com/cloudfoundry-community/web-config-transform-buildpack",
    "Description": null,
    "Archived": false,
    "Stars": 3,
    "Watchers": 62,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/cloudfoundry-community/web-config-transform-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 8933,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.BuildServers;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing FileMode = System.IO.FileMode;\nusing ZipFile = System.IO.Compression.ZipFile;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public enum StackType\n    {\n        Windows,\n        Linux\n    }\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n    const string BuildpackProjectName = \u0022Web.Config.Transform.Buildpack\u0022;\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    \n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\n    readonly StackType Stack = StackType.Windows;\n    \n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GitHubToken;\n\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;  \n    string Framework =\u003E Stack == StackType.Windows ? \u0022net47\u0022 : \u0022netcoreapp2.2\u0022;\n\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetRuntime(Runtime));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .Description(\u0022Compiles the buildpack\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Info(Stack);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                // .SetAssemblyVersion(\u00221.0.0.0\u0022)\n                // .SetFileVersion(\u00221.0.0.0\u0022)\n                // .SetInformationalVersion(\u00221.0.0.0\u0022)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .SetNoBuild(IsLocalBuild)\n                .ResetVerbosity()\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .CombineWith(\n                    Solution.GetProjects(\u0022*Tests\u0022), (cs, v) =\u003E cs\n                        .SetProjectFile(v)));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetFramework(Framework)\n                .SetRuntime(Runtime)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\n            EnsureCleanDirectory(TemporaryDirectory);\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\n            var scriptsDirectory = RootDirectory / \u0022scripts\u0022;\n            \n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n            var tempZipFile = TemporaryDirectory / PackageZipName;\n            \n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\n            MakeFilesInZipUnixExecutable(tempZipFile);\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\n            Logger.Block(ArtifactsDirectory / PackageZipName);\n\n        });\n    \n\n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\n        .DependsOn(Publish)\n        .Requires(() =\u003E GitHubToken)\n        .Executes(async () =\u003E\n        {\n            if (!GitRepository.IsGitHubRepository())\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n            \n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\n            {\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\n            };\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n            var owner = gitIdParts[0];\n            var repoName = gitIdParts[1];\n            \n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n            Release release;\n            try\n            {\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\n            }\n            catch (NotFoundException)\n            {\n                var newRelease = new NewRelease(releaseName)\n                {\n                    Name = releaseName, \n                    Draft = false, \n                    Prerelease = false\n                };\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\n            }\n\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\n            if (existingAsset != null)\n            {\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n            }\n            \n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\n            \n            Logger.Block(releaseAsset.BrowserDownloadUrl);\n        });\n\n    public static void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\n    {\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\n        {\n            output.SetLevel(9);\n            ZipEntry entry;\n\t\t\n            while ((entry = input.GetNextEntry()) != null)\n            {\n                var outEntry = new ZipEntry(entry.Name);\n                outEntry.HostSystem = (int)HostSystemID.Unix;\n                outEntry.ExternalFileAttributes = -2115174400;\n                output.PutNextEntry(outEntry);\n                input.CopyTo(output);\n            }\n            output.Finish();\n            output.Flush();\n        }\n\n        DeleteFile(zipFile);\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\n    }\n}\n"
  },
  {
    "Id": 208378554,
    "FirstIndexed": "2020-04-25T15:47:03.6112876+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630692+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431783+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937604+02:00",
    "Name": "BlazorState",
    "Owner": "BerserkerDotNet",
    "HtmlUrl": "https://github.com/BerserkerDotNet/BlazorState",
    "Description": "Yet Another Blazor Redux implementation",
    "Archived": false,
    "Stars": 11,
    "Watchers": 4,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BerserkerDotNet/BlazorState/blob/master/build/Build.cs",
    "BuildFileSize": 2861,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022BlazorState.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .EnableIncludeSymbols()\n                .EnableIncludeSource()\n                .SetOutputDirectory(ArtifactsDirectory));\n        });\n\n}\n"
  },
  {
    "Id": 208785037,
    "FirstIndexed": "2020-04-25T15:47:03.6114816+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624917+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431794+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "TestApp",
    "Owner": "akak1977",
    "HtmlUrl": "https://github.com/akak1977/TestApp",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 209029115,
    "FirstIndexed": "2020-04-25T15:47:03.611477+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630903+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431806+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937615+02:00",
    "Name": "FinHub",
    "Owner": "mindaugasdirg",
    "HtmlUrl": "https://github.com/mindaugasdirg/FinHub",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mindaugasdirg/FinHub/blob/master/build/Build.cs",
    "BuildFileSize": 2890,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .EnableLogOutput());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(\u0022FinHub\u0022);\n            DotNetPublish(s =\u003E s\n                .SetProject(project)\n                .SetConfiguration(Configuration)\n                .SetFramework(project.GetTargetFrameworks().FirstOrDefault())\n                .SetOutput(OutputDirectory)\n                .EnableLogOutput());\n        });\n}\n"
  },
  {
    "Id": 209622169,
    "FirstIndexed": "2020-04-25T15:47:03.6114748+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631488+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431817+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937626+02:00",
    "Name": "NukeTest1",
    "Owner": "paul42",
    "HtmlUrl": "https://github.com/paul42/NukeTest1",
    "Description": "creating a repo to request help for codegen issues",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/paul42/NukeTest1/blob/master/build/Build.cs",
    "BuildFileSize": 1715,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 209628894,
    "FirstIndexed": "2020-04-25T15:50:44.7360925+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631477+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434758+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940482+02:00",
    "Name": "nuke-gitversion",
    "Owner": "david-driscoll",
    "HtmlUrl": "https://github.com/david-driscoll/nuke-gitversion",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/david-driscoll/nuke-gitversion/blob/master/build/Build.cs",
    "BuildFileSize": 1445,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Clean);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            Logger.Warn(GitVersion.SemVer);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n        });\n\n}\n"
  },
  {
    "Id": 211341720,
    "FirstIndexed": "2020-04-25T15:47:03.6113672+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631079+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431828+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937638+02:00",
    "Name": "datatent",
    "Owner": "sebfischer83",
    "HtmlUrl": "https://github.com/sebfischer83/datatent",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/sebfischer83/datatent/blob/master/build/Build.cs",
    "BuildFileSize": 4847,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing Nuke.Common;\nusing Nuke.Common.ChangeLog;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.CoverallsNet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitReleaseManager;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n//[AzurePipelines(AzurePipelinesImage.WindowsLatest,  InvokedTargets = new []{ nameof(PublishCoverage) })]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Explicit framework to build\u0022)] readonly string Framework = null;\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    [CI] readonly AzurePipelines AzurePipelines;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    IEnumerable\u003Cstring\u003E ChangeLogSectionNotes =\u003E ExtractChangelogSectionNotes(ChangeLogFile);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetFramework(Framework)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022Datatent.Core.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetLogger(\u0022trx\u0022)\n                .SetLogOutput(true)\n                .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, true)\n                    .Add(\u0022/p:CoverletOutput={0}/\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n                .SetResultsDirectory(ArtifactsDirectory / \u0022tests\u0022));\n        });\n\n\n    Target PublishCoverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n\n            if (System.Runtime.InteropServices.RuntimeInformation\n                .IsOSPlatform(OSPlatform.Windows) \u0026\u0026 !IsLocalBuild)\n            {\n                DotNetToolUpdate(settings =\u003E settings\n                    .SetGlobal(true)\n                    .SetPackageName(\u0022Codecov.Tool\u0022));\n                ProcessTasks.StartProcess(\u0022codecov.exe\u0022, \n                    arguments: $\u0022-f \\\u0022{ArtifactsDirectory / \u0022coverage/coverage.cobertura.xml\u0022}\\\u0022 -t 8532ee50-6d63-4a1a-a36f-ad2741eb3e40\u0022);\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(PublishCoverage)\n        .Produces(OutputDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution.GetProject(\u0022Datatent.Core\u0022))\n                .SetNoBuild(true)\n                .SetConfiguration(Configuration)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangeLogFile, GitRepository))\n            );\n        });\n}\n"
  },
  {
    "Id": 211718020,
    "FirstIndexed": "2020-04-25T15:47:03.6114418+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163142+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843184+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937644+02:00",
    "Name": "ChromiumWebBrowser",
    "Owner": "pkudrel",
    "HtmlUrl": "https://github.com/pkudrel/ChromiumWebBrowser",
    "Description": "Simple chromium web browser",
    "Archived": false,
    "Stars": 1,
    "Watchers": 2,
    "BuildFilePath": "src/build/Build.cs",
    "BuildFileUrl": "https://github.com/pkudrel/ChromiumWebBrowser/blob/production/src/build/Build.cs",
    "BuildFileSize": 9253,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing AbcVersionTool;\nusing Helpers;\nusing Helpers.Syrup;\nusing Models;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[Serializable]\nclass Build : NukeBuild\n{\n    [Parameter(\u0022Build counter from outside environment\u0022)] readonly int BuildCounter;\n\n    readonly DateTime BuildDate = DateTime.UtcNow;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    readonly bool IsAzureDevOps = string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\u0022AGENT_NAME\u0022)) == false;\n\n    [Solution(\u0022src\\\\ChromiumWebBrowser.sln\u0022)] readonly Solution Solution;\n\n    bool IsTeamCity = string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\u0022TEAMCITY_VERSION\u0022)) == false;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    string Configuration =\u003E IsTeamCity ? \u0022Release\u0022 : \u0022Debug\u0022;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDir =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath TmpBuild =\u003E TemporaryDirectory / \u0022build\u0022;\n    AbsolutePath ToolsDir =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath LibzPath =\u003E ToolsDir / \u0022LibZ.Tool\u0022 / \u0022tools\u0022 / \u0022libz.exe\u0022;\n    AbsolutePath NugetPath =\u003E ToolsDir / \u0022nuget.exe\u0022;\n    AbsolutePath SourceDir =\u003E RootDirectory / \u0022src\u0022;\n    Project ChromiumWebBrowserProject =\u003E Solution.GetProject(\u0022ChromiumWebBrowser\u0022).NotNull();\n\n\n    ProductInfo ProductInfo =\u003E new ProductInfo\n    {\n        Company = \u0022Deneblab\u0022,\n        Copyright = $\u0022Deneblab (c) {DateTime.UtcNow.Year}\u0022\n    };\n\n\n    List\u003CProjectDefinition\u003E Projects =\u003E new List\u003CProjectDefinition\u003E\n    {\n        new ProjectDefinition\n        {\n            Name = \u0022ChromiumWebBrowser\u0022,\n            Dir = \u0022ChromiumWebBrowser\u0022,\n            Exe = \u0022ChromiumWebBrowser.exe\u0022,\n            DstExe = \u0022ChromiumWebBrowser.exe\u0022,\n            AzureContainerName = \u0022application-chromium-webbrowser\u0022,\n            Project = ChromiumWebBrowserProject\n        }\n    };\n\n    AbcVersion Version =\u003E AbcVersionFactory.Create(BuildCounter, BuildDate);\n\n    Target Information =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var b = Version;\n            Logger.Info($\u0022Host: \u0027{Host}\u0027\u0022);\n            Logger.Info($\u0022Version: \u0027{b.SemVersion}\u0027\u0022);\n            Logger.Info($\u0022Date: \u0027{b.DateTime:s}Z\u0027\u0022);\n            Logger.Info($\u0022FullVersion: \u0027{b.InformationalVersion}\u0027\u0022);\n        });\n\n\n    Target ConfigureAzureDevOps =\u003E _ =\u003E _\n        .DependsOn(Information)\n        .OnlyWhenStatic(() =\u003E IsAzureDevOps)\n        .Executes(() =\u003E\n        {\n            Logger.Normal($\u0022Set version to AzureDevOps: {Version.SemVersion}\u0022);\n            // https://github.com/microsoft/azure-pipelines-tasks/blob/master/docs/authoring/commands.md\n            Logger.Normal($\u0022##vso[build.updatebuildnumber]{Version.SemVersion}\u0022);\n        });\n\n\n    Target Configure =\u003E _ =\u003E _\n        .DependsOn(ConfigureAzureDevOps);\n\n\n    Target CheckTools =\u003E _ =\u003E _\n        .DependsOn(Configure)\n        .Executes(() =\u003E\n        {\n            Downloader.DownloadIfNotExists(\u0022https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\u0022, NugetPath,\n                \u0022Nuget\u0022);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(CheckTools)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(TmpBuild);\n            GlobDirectories(TmpBuild, \u0022**/*\u0022)\n                .ToList()\n                .ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDir);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022restore  {Solution.Path}\u0022,\n                SourceDir))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget restore report generation process exited with some errors.\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n\n        {\n            foreach (var p in Projects)\n            {\n                var buildOut = TmpBuild / CommonDir.Build / p.Dir;\n                var projectFile = p.Project.Path;\n                var projectDir = Path.GetDirectoryName(projectFile);\n                EnsureExistingDirectory(buildOut);\n                Logger.Info($\u0022Build; Project file: {projectFile}\u0022);\n                Logger.Info($\u0022Build; Project dir: {projectDir}\u0022);\n                Logger.Info($\u0022Build; Out dir: {buildOut}\u0022);\n                Logger.Info($\u0022Build; Configuration: {Configuration}\u0022);\n\n\n                try\n                {\n                    AssemblyTools.Patch(projectDir, Version, p, ProductInfo);\n\n                    MSBuild(s =\u003E s\n                        .SetProjectFile(projectFile)\n                        .SetOutDir(buildOut)\n                        .SetVerbosity(MSBuildVerbosity.Quiet)\n                        .SetConfiguration(Configuration)\n                        .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                        .SetMaxCpuCount(Environment.ProcessorCount)\n                        .SetNodeReuse(IsLocalBuild));\n                }\n                finally\n                {\n                    AssemblyTools.RollbackOriginalFiles(projectDir);\n                }\n            }\n        });\n\n\n    Target Marge =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n\n        {\n            foreach (var p in Projects)\n            {\n                var buildOut = TmpBuild / CommonDir.Build / p.Dir;\n                var margeOut = TmpBuild / CommonDir.Merge / p.Dir;\n\n                EnsureExistingDirectory(margeOut);\n                CopyDirectoryRecursively(buildOut, margeOut, DirectoryExistsPolicy.Merge);\n\n                using (var process = ProcessTasks.StartProcess(\n                    LibzPath,\n                    $\u0022inject-dll --assembly {p.Exe} --include *.dll --move\u0022,\n                    margeOut))\n                {\n                    process.AssertWaitForExit();\n                    ControlFlow.AssertWarn(process.ExitCode == 0,\n                        \u0022Libz report generation process exited with some errors.\u0022);\n                }\n            }\n        });\n\n    Target CopyToReady =\u003E _ =\u003E _\n        .DependsOn(Marge)\n        .Executes(() =\u003E\n        {\n            var readOut = TmpBuild / CommonDir.Ready;\n            var srcBuild = SourceDir / \u0022build\u0022;\n            EnsureExistingDirectory(readOut);\n\n            foreach (var p in Projects)\n            {\n                var margeOut = TmpBuild / CommonDir.Merge / p.Dir;\n\n                var configsDir = SourceDir / \u0022build\u0022 / \u0022configs\u0022;\n                EnsureExistingDirectory(readOut);\n                CopyFile(margeOut / p.Exe,\n                    readOut / p.Exe,\n                    FileExistsPolicy.Overwrite);\n            }\n\n\n            //var nlog = srcBuild / \u0022nlog\u0022 / \u0022main\u0022;\n            //CopyDirectoryRecursively(nlog, readOut, DirectoryExistsPolicy.Merge);\n        });\n\n    Target Nuget =\u003E _ =\u003E _\n        .DependsOn(CopyToReady)\n        .Executes(() =\u003E\n\n        {\n            var nugetTmpOut = TmpBuild / \u0022nugetTmp\u0022;\n            var srcBuild = SourceDir / \u0022build\u0022;\n            var tmpReady = TmpBuild / CommonDir.Ready;\n            var nugetDir = TmpBuild / \u0022nuget\u0022;\n            var tmpMain = nugetTmpOut / \u0022main\u0022;\n\n            EnsureExistingDirectory(nugetTmpOut);\n\n            // copy main files\n            CopyDirectoryRecursively(tmpReady, tmpMain, DirectoryExistsPolicy.Merge);\n\n            // syrup scripts\n            var src1 = srcBuild / \u0022syrup\u0022;\n            var dst1 = nugetTmpOut / \u0022_syrup\u0022;\n            EnsureExistingDirectory(dst1);\n            CopyDirectoryRecursively(src1, dst1, DirectoryExistsPolicy.Merge);\n\n            // nuget definition\n            var srcNugetFile = srcBuild / \u0022nuget\u0022 / \u0022nuget.nuspec\u0022;\n            var dstNugetFile = nugetTmpOut / \u0022LukeSearch.nuspec\u0022;\n            var text = File.ReadAllText(srcNugetFile);\n            var r = text.Replace(\u0022{Version}\u0022, Version.NugetVersion);\n            File.WriteAllText(dstNugetFile, r, Encoding.UTF8);\n\n            // create nuget\n            using (var process = ProcessTasks.StartProcess(\n                NugetPath,\n                $\u0022pack {dstNugetFile} -OutputDirectory {nugetDir} -NoPackageAnalysis\u0022,\n                nugetTmpOut))\n            {\n                process.AssertWaitForExit();\n                ControlFlow.AssertWarn(process.ExitCode == 0,\n                    \u0022Nuget report generation process exited with some errors.\u0022);\n            }\n\n            var nugetFiles = GlobFiles(nugetDir, \u0022*.nupkg\u0022);\n\n            foreach (var file in nugetFiles) SyrupTools.MakeSyrupFile(file, Version, \u0022LukeSearch\u0022);\n        });\n\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Nuget, PublishLocal);\n\n\n    Target PublishLocal =\u003E _ =\u003E _\n        .DependsOn(Nuget)\n        .Executes(() =\u003E\n        {\n        });\n\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n}"
  },
  {
    "Id": 212134346,
    "FirstIndexed": "2020-04-25T15:47:03.6113877+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631124+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431845+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937655+02:00",
    "Name": "pcf-ers-dotnetcore-workshop",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/pcf-ers-dotnetcore-workshop",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/pcf-ers-dotnetcore-workshop/blob/master/build/Build.cs",
    "BuildFileSize": 9875,
    "BuildFileContent": "using System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.CloudFoundry;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.Git;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.CloudFoundry.CloudFoundryTasks;\r\n\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n//[AzureDevopsConfigurationGenerator(\r\n//    VcsTriggeredTargets = new[]{\u0022Pack\u0022}\r\n//)]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E();\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    string Runtime =\u003E \u0022netcoreapp2.2\u0022;\r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    [Solution] readonly Solution Solution;\r\n\r\n    [GitRepository] GitRepository GitRepository;\r\n//    [GitVersion] public GitVersion GitVersion { get; set; }\r\n\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n    [Parameter(\u0022Cloud Foundry Username\u0022)]\r\n    readonly string CfUsername;\r\n    [Parameter(\u0022Cloud Foundry Password\u0022)]\r\n    readonly string CfPassword;\r\n    [Parameter(\u0022Cloud Foundry Endpoint\u0022)]\r\n    readonly string CfApiEndpoint;\r\n    [Parameter(\u0022Cloud Foundry Org\u0022)]\r\n    readonly string CfOrg;\r\n    [Parameter(\u0022Cloud Foundry Space\u0022)]\r\n    readonly string CfSpace;\r\n    [Parameter(\u0022Number of apps (for distributed tracing)\u0022)]\r\n    readonly int AppsCount = 3;    \r\n    [Parameter(\u0022Type of database plan (default: db-small)\u0022)]\r\n    readonly string DbPlan = \u0022db-small\u0022;\r\n\r\n    [Parameter(\u0022Skip logging in Cloud Foundry and use the current logged in session\u0022)] \r\n    readonly bool CfSkipLogin;\r\n\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    AbsolutePath PublishDirectory =\u003E RootDirectory / \u0022src\u0022 / \u0022Articulate.UI\u0022 / \u0022bin\u0022 / Configuration / \u0022netcoreapp2.2\u0022 / \u0022publish\u0022;\r\n    string PackageZipName =\u003E $\u0022articulate-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    // Target Serialize =\u003E _ =\u003E _\r\n    //     .Executes(() =\u003E File.WriteAllText(ArtifactsDirectory / \u0022state.json\u0022, JsonConvert.SerializeObject(this, Formatting.Indented, new JsonSerializerSettings(){ ContractResolver = new MyContractResolver()})));\r\n    \r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Publishes the project to a folder which is ready to be deployed to target machines\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            Logger.Info(GitVersion == null);\r\n            Logger.Info(GitVersion.NuGetVersionV2);\r\n            DotNetPublish(s =\u003E s\r\n                .SetProject(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\r\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\r\n                .SetInformationalVersion(GitVersion.InformationalVersion));\r\n        });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Publish)\r\n        .Description(\u0022Publishes the project and creates a zip package in artfiacts folder\u0022)\r\n        .Produces(ArtifactsDirectory)\r\n        .Executes(() =\u003E\r\n        {\r\n            Directory.CreateDirectory(ArtifactsDirectory);\r\n            DeleteFile(ArtifactsDirectory / PackageZipName);\r\n            ZipFile.CreateFromDirectory(PublishDirectory, ArtifactsDirectory / PackageZipName);\r\n            Logger.Block(ArtifactsDirectory / PackageZipName);\r\n        });\r\n\r\n    Target CfLogin =\u003E _ =\u003E _\r\n        .OnlyWhenStatic(() =\u003E !CfSkipLogin)\r\n        .Requires(() =\u003E CfUsername, () =\u003E CfPassword, () =\u003E CfApiEndpoint)\r\n        .Unlisted()\r\n        .Executes(() =\u003E\r\n        {\r\n            CloudFoundryApi(c =\u003E c.SetUrl(CfApiEndpoint));\r\n            CloudFoundryAuth(c =\u003E c\r\n                .SetUsername(CfUsername)\r\n                .SetPassword(CfPassword));\r\n        });\r\n    \r\n    Target Deploy =\u003E _ =\u003E _\r\n        .DependsOn(CfLogin)\r\n        .After(Pack)\r\n        .Requires(() =\u003E CfSpace, () =\u003E CfOrg)\r\n        .Description(\u0022Deploys to Cloud Foundry\u0022)\r\n        .Executes(async () =\u003E\r\n        {\r\n            string appName = \u0022ers1\u0022;\r\n            \r\n            var names = Enumerable.Range(1, AppsCount).Select(x =\u003E $\u0022ers{x}\u0022).ToArray();;\r\n            CloudFoundryCreateSpace(c =\u003E c\r\n                .SetOrg(CfOrg)\r\n                .SetSpace(CfSpace));\r\n            CloudFoundryTarget(c =\u003E c\r\n                .SetSpace(CfSpace)\r\n                .SetOrg(CfOrg));\r\n            CloudFoundryCreateService(c =\u003E c\r\n                .SetService(\u0022p-service-registry\u0022)\r\n                .SetPlan(CfApiEndpoint?.Contains(\u0022api.run.pivotal.io\u0022) ?? false ? \u0022trial\u0022 : \u0022standard\u0022)\r\n                .SetInstanceName(\u0022eureka\u0022));\r\n            CloudFoundryCreateService(c =\u003E c\r\n                .SetService(\u0022p.mysql\u0022)\r\n                .SetPlan(DbPlan)\r\n                .SetInstanceName(\u0022mysql\u0022));\r\n            CloudFoundryPush(c =\u003E c\r\n                .SetRandomRoute(true)\r\n                .SetPath(ArtifactsDirectory / PackageZipName)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 1);\r\n            await CloudFoundryEnsureServiceReady(\u0022eureka\u0022);\r\n            await CloudFoundryEnsureServiceReady(\u0022mysql\u0022);\r\n            CloudFoundryBindService(c =\u003E c\r\n                .SetServiceInstance(\u0022eureka\u0022)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 5);\r\n            CloudFoundryBindService(c =\u003E c\r\n                .SetServiceInstance(\u0022mysql\u0022)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 5);\r\n            CloudFoundryRestart(c =\u003E c\r\n                .SetAppName(appName)\r\n                .CombineWith(names,(cs,v) =\u003E cs.SetAppName(v)), degreeOfParallelism: 5);\r\n        });\r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads the artifact\u0022)\r\n        .DependsOn(Pack)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            if (!GitRepository.IsGitHubRepository())\r\n                ControlFlow.Fail(\u0022Only supported when git repo remote is github\u0022);\r\n            if(!IsGitPushedToRemote)\r\n                ControlFlow.Fail(\u0022Your local git repo has not been pushed to remote. Can\u0027t create release until source is upload\u0022);\r\n            var client = new GitHubClient(new ProductHeaderValue(\u0022nuke-build\u0022))\r\n            {\r\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n            };\r\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n            var owner = gitIdParts[0];\r\n            var repoName = gitIdParts[1];\r\n            \r\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n            Release release;\r\n            try\r\n            {\r\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n            }\r\n            catch (NotFoundException)\r\n            {\r\n                var newRelease = new NewRelease(releaseName)\r\n                {\r\n                    Name = releaseName, \r\n                    Draft = false, \r\n                    Prerelease = false\r\n                };\r\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n            }\r\n\r\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\r\n            if (existingAsset != null)\r\n            {\r\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n            }\r\n            \r\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\r\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, File.OpenRead(zipPackageLocation), null);\r\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n            \r\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n        });\r\n    \r\n    \r\n    \r\n    bool IsGitPushedToRemote =\u003E GitTasks\r\n        .Git(\u0022status\u0022)\r\n        .Select(x =\u003E x.Text)\r\n        .Count(x =\u003E x.Contains(\u0022nothing to commit, working tree clean\u0022) || x.StartsWith(\u0022Your branch is up to date with\u0022)) == 2;\r\n}\r\n"
  },
  {
    "Id": 213087430,
    "FirstIndexed": "2020-04-25T15:47:03.6114253+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631278+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431857+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937666+02:00",
    "Name": "BooruViewer",
    "Owner": "BooruViewer",
    "HtmlUrl": "https://github.com/BooruViewer/BooruViewer",
    "Description": null,
    "Archived": false,
    "Stars": 5,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BooruViewer/BooruViewer/blob/master/build/Build.cs",
    "BuildFileSize": 3899,
    "BuildFileContent": "using System;\nusing System.IO.Compression;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = Configuration.Release;\n\n    [Parameter(\u0022Run the IL Linker against the published app\u0022)] readonly Boolean Linker = true;\n    [Parameter(\u0022Should the app be published as a single file\u0022)] readonly Boolean SingleFile = true;\n\n    [Parameter(\u0022The project to publish\u0022)] readonly String Project = \u0022BooruViewer Server\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022 / \u0022Server\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(Project);\n            var runtimes = new[] {\u0022win-x64\u0022, \u0022linux-x64\u0022};\n            var r2r = new[] {true, false};\n\n            var builds = new ValueTuple\u003CString, Boolean\u003E[runtimes.Length];\n\n            for (var i = 0; i \u003C runtimes.Length; i\u002B\u002B)\n            {\n                builds[i] = (runtimes[i], r2r[i]);\n            }\n\n            DotNetPublish(o =\u003E o.EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetProject(project)\n                .SetSelfContained(true)\n                .SetProperty(\u0022PublishSingleFile\u0022, SingleFile)\n                .SetProperty(\u0022PublishTrimmed\u0022, Linker)\n                .CombineWith(builds, (o2, build) =\u003E o2\n                    .SetRuntime(build.Item1)\n                    .SetOutput(ArtifactsDirectory / \u0022BooruViewer\u0022 / build.Item1)\n                    .SetProperty(\u0022PublishReadyToRun\u0022, build.Item2)));\n\n            foreach (var runtime in runtimes)\n            {\n                CompressionTasks.CompressZip(ArtifactsDirectory / \u0022BooruViewer\u0022 / runtime, ArtifactsDirectory / $\u0022BooruViewer {runtime} ({GitVersion.BranchName.Replace(\u0022/\u0022, \u0022-\u0022)}-{GitVersion.Sha}).zip\u0022, null, CompressionLevel.Optimal);\n            }\n        });\n}\n"
  },
  {
    "Id": 214424189,
    "FirstIndexed": "2020-04-25T15:50:44.7351823+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629998+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843333+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939106+02:00",
    "Name": "DemoEngine",
    "Owner": "DemoBytom",
    "HtmlUrl": "https://github.com/DemoBytom/DemoEngine",
    "Description": "Simple game engine written in C#, .NET Core 3.1 and DirectX",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/DemoBytom/DemoEngine/blob/develop/build/Build.cs",
    "BuildFileSize": 13147,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing BuildExtensions;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.CoverallsNet;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.InspectCode;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ControlFlow;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.CoverallsNet.CoverallsNetTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Git.GitTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\nnamespace BuildScript\n{\n    [CheckBuildProjectConfigurations]\n    [UnsetVisualStudioEnvironmentVariables]\n    [GitHubActionsV2(\n        \u0022CI\u0022,\n        GitHubActionsImage.WindowsLatest,\n        On = new[]\n        {\n            GitHubActionsTrigger.Push\n        },\n        InvokedTargets = new[]\n        {\n            nameof(Clean),\n            nameof(Compile),\n            nameof(Test),\n            nameof(Publish)\n        },\n        ImportGitHubTokenAs = nameof(GitHubToken),\n        ImportSecrets = new[]\n        {\n            nameof(CoverallsToken)\n        })]\n    internal partial class Build : NukeBuild\n    {\n        /* Install Global Tool\n         * - $ dotnet tool install Nuke.GlobalTool --global\n         *\n         * To run the build using Global Tool\n         * - $ nuke Full\n         *\n         * To run the build using powershell, without Global Tool\n         * - PS\u003E .\\build.ps1 Full\n         *\n         * To run the build using shell, without Global Tool\n         * - $ ./build.sh Full\n         *\n         * Support plugins are available for:\n         * - JetBrains ReSharper https://nuke.build/resharper\n         * - JetBrains Rider https://nuke.build/rider\n         * - Microsoft VisualStudio https://nuke.build/visualstudio\n         * - Microsoft VSCode https://nuke.build/vscode\n         * */\n\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        public readonly Configuration Config = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n        [Parameter(\u0022GitHub token\u0022)]\n        public readonly string GitHubToken = string.Empty;\n\n        [Parameter(\u0022Self contained application rids\u0022)]\n        public readonly string[] RIDs = Array.Empty\u003Cstring\u003E();\n\n        [Parameter(\u0022Coveralls token\u0022)]\n        public readonly string? CoverallsToken = null;\n\n        [Parameter(\u0022Coveralls jobId\u0022)]\n        public readonly string? CoverallsJobID = EnvironmentInfo.Variables switch\n        {\n            var gh when gh.TryGetValue(\u0022GITHUB_RUN_ID\u0022, out var ghid) =\u003E ghid,\n            var nuke when nuke.TryGetValue(\u0022NUKE_RUN_ID\u0022, out var nukeid) =\u003E nukeid,\n            _ =\u003E null\n        };\n\n        [Solution] private readonly Solution _solution = default!;\n        [GitRepository] private readonly GitRepository _gitRepository = default!;\n\n        //[GitVersion] private readonly GitVersion _gitVersion = default!;\n        private GitVersion _gitVersion = default!;\n\n        private AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n        private AbsolutePath TestDirectory =\u003E RootDirectory / \u0022test\u0022;\n        private AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n        private Project[] TestProjects =\u003E _solution.GetProjects(\u0022*.UTs\u0022).ToArray();\n\n        private const string MASTER_BRANCH = \u0022master\u0022;\n        private const string DEVELOP_BRANCH = \u0022develop\u0022;\n        private const string RELEASE_BRANCH_PREFIX = \u0022release\u0022;\n        private const string HOTFIX_BRANCH_PREFIX = \u0022hotfix\u0022;\n\n        protected override void OnBuildInitialized()\n        {\n            base.OnBuildInitialized();\n            var resp = Git(\u0022rev-parse --is-shallow-repository\u0022);\n            if (bool.TryParse(resp.FirstOrDefault().Text, out var isShallow) \u0026\u0026 isShallow)\n            {\n                Logger.Info(\u0022Unshallowing the repository\u0022);\n                Git(\u0022fetch origin \u002Brefs/heads/*:refs/remotes/origin/* --unshallow --quiet\u0022);\n            }\n\n            Git(\u0022fetch --all --tags --quiet\u0022);\n            _gitVersion = GitVersionTasks\n                .GitVersion(s =\u003E s\n                    .SetNoFetch(false)\n                    .SetNoCache(true)\n                    .SetVerbosity(GitVersionVerbosity.debug)\n                    .SetFramework(\u0022netcoreapp3.1\u0022)\n                    .DisableLogOutput())\n                .Result;\n        }\n\n        private Target Clean =\u003E _ =\u003E _\n            .Before(Restore, Compile, Test, Publish)\n            .Executes(() =\u003E\n            {\n                if (!Debugger.IsAttached)\n                {\n                    SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                    TestDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                }\n                EnsureCleanDirectory(ArtifactsDirectory);\n            });\n\n        private Target Restore =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                DotNetRestore(_ =\u003E _\n                    .SetProjectFile(_solution));\n            });\n\n        private Target Compile =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(_ =\u003E _\n                    .SetProjectFile(_solution)\n                    .SetNoRestore(ExecutingTargets.Contains(Restore))\n                    .SetConfiguration(Config)\n                    .SetAssemblyVersion(_gitVersion.AssemblySemVer)\n                    .SetFileVersion(_gitVersion.AssemblySemFileVer)\n                    .SetInformationalVersion(_gitVersion.InformationalVersion)\n                    .EnableNoRestore());\n            });\n\n        private Target Test =\u003E _ =\u003E _\n            .DependsOn(Compile)\n            .OnlyWhenDynamic(() =\u003E TestProjects.Length \u003E 0)\n            //.Produces(\n            //    ArtifactsDirectory / \u0022*.trx\u0022,\n            //    ArtifactsDirectory / \u0022*.xml\u0022)\n            .Executes(() =\u003E\n            {\n                DotNetTest(_ =\u003E _\n                    .SetConfiguration(Config)\n                        .SetNoRestore(ExecutingTargets.Contains(Restore))\n                        .SetNoBuild(ExecutingTargets.Contains(Compile))\n                        .SetProperty(\u0022CollectCoverage\u0022, propertyValue: true)\n                        .SetProperty(\u0022CoverletOutputFormat\u0022, \u0022opencover\u0022)\n                    //.SetProperty(\u0022ExcludeByFile\u0022, \u0022*.Generated.cs\u0022)\n                    .SetResultsDirectory(ArtifactsDirectory)\n                    .CombineWith(TestProjects, (oo, testProj) =\u003E oo\n                        .SetProjectFile(testProj)\n                        .SetLogger($\u0022trx;LogFileName={testProj.Name}.trx\u0022)\n                        //.SetLogger($\u0022xunit;LogFileName={testProj.Name}.xml\u0022)\n                        .SetProperty(\u0022CoverletOutput\u0022, ArtifactsDirectory / $\u0022{testProj.Name}.xml\u0022)),\n                    degreeOfParallelism: TestProjects.Length,\n                    completeOnFailure: true);\n            });\n\n        private Target Coverage =\u003E _ =\u003E _\n            .TriggeredBy(Test)\n            .DependsOn(Test)\n            .Produces(ArtifactsDirectory / \u0022coverage.zip\u0022)\n            .Executes(() =\u003E\n            {\n                ReportGenerator(_ =\u003E _\n                    .SetFramework(\u0022netcoreapp3.0\u0022)\n                    .SetReports(ArtifactsDirectory / \u0022*.xml\u0022)\n                    .SetReportTypes(ReportTypes.HtmlInline)\n                    .SetTargetDirectory(ArtifactsDirectory / \u0022coverage\u0022));\n\n                if (ExecutingTargets.Contains(UploadCoveralls))\n                {\n                    ReportGenerator(_ =\u003E _\n                        .SetFramework(\u0022netcoreapp3.0\u0022)\n                        .SetReports(ArtifactsDirectory / \u0022*.xml\u0022)\n                        .SetReportTypes(ReportTypes.Xml)\n                        .SetTargetDirectory(ArtifactsDirectory / \u0022coveralls\u0022));\n                }\n\n                CompressZip(\n                    directory: ArtifactsDirectory / \u0022coverage\u0022,\n                    archiveFile: ArtifactsDirectory / \u0022coverage.zip\u0022,\n                    fileMode: FileMode.Create);\n            });\n\n        private Target Publish =\u003E _ =\u003E _\n            .DependsOn(Compile, Test)\n            .After(Test)\n            .Produces(\n                ArtifactsDirectory / \u0022Demo.Engine.zip\u0022,\n                ArtifactsDirectory / \u0022Demo.Engine.win10-x64.zip\u0022)\n            .Executes(() =\u003E\n            {\n                //A runtime dependant version is also currently generated by default and exposed to CI artifacts\n                PublishApp(\u0022Demo.Engine\u0022);\n\n                //We generate a self contained, \u0022one file\u0022, trimmed version for Windows 10 x64 by default\n                //Any other can be generated as well, but aren\u0027t currently supported so aren\u0027t exposed to CI artifacts\n                foreach (var rid in RIDs.Concat(\u0022win10-x64\u0022))\n                {\n                    PublishApp(\u0022Demo.Engine\u0022, rid);\n                }\n            });\n\n        private Target UploadCoveralls =\u003E _ =\u003E _\n            .TriggeredBy(Test)\n            .DependsOn(Test, Coverage)\n            .OnlyWhenStatic(() =\u003E IsServerBuild || Debugger.IsAttached)\n            .OnlyWhenDynamic(() =\u003E GitHasCleanWorkingCopy())\n            .Requires(() =\u003E CoverallsToken)\n            .Requires(() =\u003E CoverallsJobID)\n            .Executes(() =\u003E\n            {\n                var gitShow = Git(\u0022show -s --format=%H%n%cN%n%ce%n%B\u0022);\n                Assert(gitShow.Count \u003E= 4, \u0022wrong GIT show return!\u0022);\n\n                var commitID = gitShow.ElementAt(0).Text;\n                var authorName = gitShow.ElementAt(1).Text;\n                var authorMail = gitShow.ElementAt(2).Text;\n\n                var commitBody = string\n                    .Join(\n                        Environment.NewLine,\n                        gitShow\n                            .ToArray()[3..]\n                            .Select(o =\u003E o.Text))\n                    .Trim();\n\n                CoverallsNet(toolSettings =\u003E toolSettings\n                    .SetDryRun(Debugger.IsAttached)\n                    .SetRepoToken(CoverallsToken)\n                    .SetUserRelativePaths(true)\n                    .SetCommitBranch(_gitRepository.Branch)\n                    .SetCommitId(commitID)\n                    .SetCommitAuthor(authorName)\n                    .SetCommitEmail(authorMail)\n                    .SetCommitMessage(commitBody)\n                    .SetInput(ArtifactsDirectory / \u0022coveralls\u0022)\n                    .SetArgumentConfigurator(argumentConfigurator =\u003E\n                        argumentConfigurator\n                            .Add(\u0022--jobId\u0022)\n                            .Add(CoverallsJobID)\n                            .Add(\u0022--reportgenerator\u0022))\n                    );\n            });\n\n        private void PublishApp(string projectName, string? rid = null)\n        {\n            AbsolutePath outputDir;\n            if (string.IsNullOrEmpty(rid))\n            {\n                outputDir = ArtifactsDirectory / projectName;\n                Logger.Info($\u0022Publishing {projectName} into {outputDir}\u0022);\n            }\n            else\n            {\n                outputDir = ArtifactsDirectory / $\u0022{projectName}.{rid}\u0022;\n                Logger.Info($\u0022Publishing {projectName} for {rid} into {outputDir}\u0022);\n            }\n\n            DotNetPublish(_ =\u003E _\n                        .SetProject(_solution.GetProject(projectName))\n                        .SetConfiguration(Config)\n                        .SetAssemblyVersion(_gitVersion.AssemblySemVer)\n                        .SetFileVersion(_gitVersion.AssemblySemFileVer)\n                        .SetInformationalVersion(_gitVersion.InformationalVersion)\n                        .SetOutput(outputDir)\n                        .When(string.IsNullOrEmpty(rid), _ =\u003E _\n                            .SetNoRestore(ExecutingTargets.Contains(Restore))\n                            .SetNoBuild(ExecutingTargets.Contains(Compile)))\n                        .When(!string.IsNullOrEmpty(rid), _ =\u003E _\n                            .SetNoRestore(false)\n                            .SetNoBuild(false)\n                            .SetSelfContained(true)\n                            .SetProperty(\u0022PublishSingleFile\u0022, true)\n                            .SetProperty(\u0022PublishTrimmed\u0022, true)\n                            .SetRuntime(rid)));\n\n            CompressZip(\n                directory: outputDir,\n                archiveFile: $\u0022{outputDir}.zip\u0022,\n                compressionLevel: CompressionLevel.Optimal,\n                fileMode: FileMode.Create);\n        }\n\n        private Target Full =\u003E _ =\u003E _.DependsOn(Clean, Compile, Test, Publish).Unlisted();\n    }\n}"
  },
  {
    "Id": 214629249,
    "FirstIndexed": "2020-04-25T15:47:03.6114298+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631306+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431868+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937678+02:00",
    "Name": "nuke-demo",
    "Owner": "SalahEddin",
    "HtmlUrl": "https://github.com/SalahEddin/nuke-demo",
    "Description": "POC for NUKE build system",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "nukeBuild/Build.cs",
    "BuildFileUrl": "https://github.com/SalahEddin/nuke-demo/blob/master/nukeBuild/Build.cs",
    "BuildFileSize": 2296,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 215111555,
    "FirstIndexed": "2020-04-25T15:47:03.6114207+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163125+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431874+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937689+02:00",
    "Name": "SitecoreSearchFields",
    "Owner": "Barsonax",
    "HtmlUrl": "https://github.com/Barsonax/SitecoreSearchFields",
    "Description": "Custom fields for sitecore that work well with search",
    "Archived": false,
    "Stars": 1,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Barsonax/SitecoreSearchFields/blob/master/build/Build.cs",
    "BuildFileSize": 2117,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Tools.VSTest;\nusing Nuke.Common.Tooling;\n\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Common.Tools.VSTest.VSTestTasks;\n\nclass Build : NukeBuild\n{\n    [Parameter(\u0022The folder where the build output is copied to\u0022)]\n    static readonly AbsolutePath OutputDirectory = RootDirectory / \u0022buildoutput\u0022;\n\n    public static AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    public AbsolutePath BuildOutputDirectory =\u003E OutputDirectory;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildBackend);\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target NugetRestore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            NuGetRestore(c =\u003E c\n                .SetTargetPath(Solution)\n             );\n        });\n\n    Target BuildBackend =\u003E _ =\u003E _\n    .DependsOn(NugetRestore)\n    .After(Clean)\n    .Executes(() =\u003E\n    {\n        MSBuild(s =\u003E s\n            .SetProjectFile(Solution.Path)\n            .SetTargets(\u0022Build\u0022)\n            .SetVerbosity(MSBuildVerbosity.Quiet)\n            .SetConfiguration(Configuration)\n            .SetNodeReuse(false)\n            .SetMaxCpuCount(4)\n            .AddProperty(\u0022DeployOnBuild\u0022, true)\n            .AddProperty(\u0022DeployDefaultTarget\u0022, \u0022WebPublish\u0022)\n            .AddProperty(\u0022SkipExtraFilesOnServer\u0022, true)\n            .AddProperty(\u0022WebPublishMethod\u0022, \u0022FileSystem\u0022)\n            .AddProperty(\u0022publishUrl\u0022, BuildOutputDirectory)\n        );\n    });\n}\n"
  },
  {
    "Id": 215188850,
    "FirstIndexed": "2020-04-25T15:47:03.6114276+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631295+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431885+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "AzurePipelinesTest",
    "Owner": "BerserkerDotNet",
    "HtmlUrl": "https://github.com/BerserkerDotNet/AzurePipelinesTest",
    "Description": null,
    "Archived": true,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 215976910,
    "FirstIndexed": "2020-04-25T15:47:03.6114179+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631238+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431897+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937695+02:00",
    "Name": "how-to-use-git-hooks-for-csharp-projects",
    "Owner": "moerwald",
    "HtmlUrl": "https://github.com/moerwald/how-to-use-git-hooks-for-csharp-projects",
    "Description": "Describes how to use GIT hooks for automatic compiling and automatic run of unit tests.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/moerwald/how-to-use-git-hooks-for-csharp-projects/blob/master/build/Build.cs",
    "BuildFileSize": 2525,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022, \u0022**/TestResults\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(c =\u003E c\n                .SetProjectFile(Solution)\n                .SetOutput(OutputDirectory));\n        });\n\n}\n"
  },
  {
    "Id": 216037990,
    "FirstIndexed": "2020-04-25T15:47:03.6114133+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631227+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431908+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937712+02:00",
    "Name": "BitwiseExtensions",
    "Owner": "iarovyi",
    "HtmlUrl": "https://github.com/iarovyi/BitwiseExtensions",
    "Description": "Educational bitwise extentions",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/iarovyi/BitwiseExtensions/blob/master/build/Build.cs",
    "BuildFileSize": 3309,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing Microsoft.Build.Tasks;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Path to artifacts directory\u0022)]\n    readonly string ArtifactsDir = \u0022./.artifacts\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    //[GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E (AbsolutePath)Path.GetFullPath(ArtifactsDir);\n    AbsolutePath PublishProjectDirectory =\u003E SourceDirectory \n                                            / \u0022BitwiseExtensions.DemoConsole/BitwiseExtensions.DemoConsole.csproj\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                /*/.SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)*/\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(o =\u003E o\n                .SetProjectFile(Solution));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .EnableIncludeSymbols()\n                .SetOutputDirectory(ArtifactsDirectory)\n                /*.SetVersion(GitVersion.NuGetVersionV2)*/);\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetNoBuild(true)\n                .SetOutput(ArtifactsDirectory)\n                .SetProject(PublishProjectDirectory)\n                .SetConfiguration(Configuration));\n        });\n}\n"
  },
  {
    "Id": 216277354,
    "FirstIndexed": "2020-04-25T15:50:44.7360703+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631267+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434735+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894046+02:00",
    "Name": "rsg-wyam-nuke",
    "Owner": "david-driscoll",
    "HtmlUrl": "https://github.com/david-driscoll/rsg-wyam-nuke",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/david-driscoll/rsg-wyam-nuke/blob/master/.build/Build.cs",
    "BuildFileSize": 9409,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Utilities.Collections;\nusing Wyam.Core.Execution;\nusing System.Diagnostics;\nusing Octokit.Reactive;\nusing Octokit;\nusing System.Reactive.Linq;\nusing System.IO;\nusing Buildalyzer;\nusing System.Reactive.Concurrency;\nusing YamlDotNet.Serialization;\nusing System.Collections.Generic;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Nuke.Common.Tooling;\n\n[UnsetVisualStudioEnvironmentVariables]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    public IEnumerable\u003CPackageSpec\u003E PackageSpecs =\u003E GlobFiles(RootDirectory / \u0022packages\u0022, \u0022*.yml\u0022, \u0022*.yaml\u0022)\n        .Select(File.ReadAllText)\n        .Select(x =\u003E new DeserializerBuilder().Build().Deserialize\u003CPackageSpec\u003E(x))\n        .ToArray();\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(RefreshPackages)\n        .Executes(() =\u003E\n        {\n            var projectDirectory = TemporaryDirectory / \u0022_project\u0022;\n            var packagesDirectory = TemporaryDirectory / \u0022_packages\u0022;\n            var project = projectDirectory / \u0022project.csproj\u0022;\n            EnsureExistingDirectory(projectDirectory);\n            EnsureExistingDirectory(packagesDirectory);\n            if (!FileExists(project))\n            {\n                System.IO.File.WriteAllText(\n                    project,\n                    @\u0022\n                    \u003CProject Sdk=\u0022\u0022Microsoft.NET.Sdk\u0022\u0022\u003E\n                        \u003CPropertyGroup\u003E\n                            \u003CTargetFramework\u003Enetcoreapp3.0\u003C/TargetFramework\u003E\n                        \u003C/PropertyGroup\u003E\n                    \u003C/Project\u003E\u0022\n                );\n\n                foreach (var packageSpec in PackageSpecs)\n                {\n                    DotNet($\u0022add package {packageSpec.Name} --no-restore\u0022, projectDirectory);\n                }\n            }\n\n            try\n            {\n                DotNetRestore(x =\u003E x\n                    .EnableNoDependencies()\n                    .SetPackageDirectory(packagesDirectory)\n                    .SetWorkingDirectory(projectDirectory)\n                );\n            }\n            catch { }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            Wyam.Common.Tracing.Trace.AddListener(new NukeTraceListener());\n            Wyam.Common.Tracing.Trace.Level = SourceLevels.All;\n            var engine = new Engine();\n            new WyamConfiguration(engine, this);\n            engine.Execute();\n        });\n\n    Target Preview =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Wyam.Common.Tracing.Trace.AddListener(new NukeTraceListener());\n            Wyam.Common.Tracing.Trace.Level = SourceLevels.All;\n            var engine = new Engine();\n            new WyamConfiguration(engine, this);\n            PreviewServer.Preview(engine, this);\n        });\n\n    [Parameter(\u0022Github Token - To use when syncing packages\u0022)]\n    readonly string GithubToken = EnvironmentInfo.GetVariable\u003Cstring\u003E(\u0022GITHUB_TOKEN\u0022) ?? string.Empty;\n\n    Target RefreshPackages =\u003E _ =\u003E _\n        .Executes(async () =\u003E\n        {\n            var client = string.IsNullOrWhiteSpace(GithubToken)\n                ? new ObservableGitHubClient(new ProductHeaderValue(\u0022internaltooling.to.update.repo\u0022))\n                : new ObservableGitHubClient(new ProductHeaderValue(\u0022internaltooling.to.update.repo\u0022), new Octokit.Internal.InMemoryCredentialStore(new Credentials(GithubToken)));\n            var repos = client.Repository.GetAllForOrg(\u0022RocketSurgeonsGuild\u0022);\n\n            var clonedRepos = repos\n                .Where(repo =\u003E !repo.Archived)\n                .Where(repo =\u003E !(IsLocalBuild \u0026\u0026 DirectoryExists(TemporaryDirectory / repo.Name)))\n                .Select(repo =\u003E\n                {\n                    var path = TemporaryDirectory / repo.Name;\n                    Process.Start(new ProcessStartInfo(\u0022git\u0022, $\u0022clone --depth 1 --single-branch {repo.CloneUrl} {path }\u0022)\n                    {\n                        CreateNoWindow = true\n                    }).WaitForExit();\n                    return (path, repo);\n                });\n\n            var solutions = clonedRepos.SelectMany((x =\u003E\n            {\n                var (path, repo) = x;\n\n                return Directory.EnumerateFiles(path, \u0022*.sln\u0022)\n                    .ToObservable()\n                    .Select(solutionFilePath =\u003E (path, repo, solutionFilePath));\n            }));\n\n            var projects = solutions\n                .Select(x =\u003E\n                {\n                    var analyzerManager = new AnalyzerManager(x.solutionFilePath);\n                    return (x.path, x.repo, x.solutionFilePath, analyzerManager);\n                })\n                .SelectMany(x =\u003E\n                {\n                    var (path, repo, solutionFilePath, analyzerManager) = x;\n                    return analyzerManager.Projects\n                        .Where(z =\u003E z.Key.Contains(\u0022/src/\u0022) || z.Key.Contains(@\u0022\\src\\\u0022))\n\n                        //.Where(x =\u003E x.Key.Contains(\u0022Essentials\u0022))\n                        .Select(project =\u003E\n                        {\n                            return (path, repo, solutionFilePath, analyzerManager, projectFilePath: project.Key, project: project.Value, projectBuild: project.Value.Build().First());\n                        })\n                        .ToObservable();\n                })\n                .Distinct(x =\u003E x.projectFilePath);\n\n            await projects\n            .SubscribeOn(NewThreadScheduler.Default)\n            .ForEachAsync(x =\u003E\n            {\n                var assemblyTitle = x.projectBuild.GetProperty(\u0022AssemblyTitle\u0022);\n                var projectUrl = x.projectBuild.GetProperty(\u0022PackageProjectUrl\u0022);\n                var authors = (x.projectBuild.GetProperty(\u0022Authors\u0022) ?? \u0022\u0022).Split(\u0027,\u0027);\n                var copyright = x.projectBuild.GetProperty(\u0022Copyright\u0022);\n\n                var assemblyName = x.projectBuild.GetProperty(\u0022AssemblyName\u0022);\n                var tags = (x.projectBuild.GetProperty(\u0022PackageTags\u0022) ?? \u0022\u0022).Split(\u0027;\u0027);\n                var targetFrameworks = (x.projectBuild.GetProperty(\u0022TargetFrameworks\u0022) ?? x.projectBuild.GetProperty(\u0022TargetFramework\u0022)).Split(\u0027;\u0027);\n                var description = x.projectBuild.GetProperty(\u0022PackageDescription\u0022);\n\n                var serializer = new SerializerBuilder().Build();\n                var categories = new List\u003Cstring\u003E();\n                if (x.repo.Name.Contains(\u0022.Extensions\u0022))\n                {\n                    categories.Add(\u0022Extensions\u0022);\n                }\n                if (assemblyName.Contains(\u0022.Extensions\u0022))\n                {\n                    categories.Add(\u0022Extensions\u0022);\n                }\n                if (assemblyName.Contains(\u0022.Abstractions\u0022))\n                {\n                    categories.Add(\u0022Abstractions\u0022);\n                }\n                if (assemblyName.Contains(\u0022.AspNetCore\u0022))\n                {\n                    categories.Add(\u0022AspNetCore\u0022);\n                }\n                if (assemblyName.Contains(\u0022.Hosting\u0022))\n                {\n                    categories.Add(\u0022Hosting\u0022);\n                }\n                var yaml = serializer.Serialize(new\n                {\n                    Name = assemblyName,\n                    NuGet = assemblyName,\n                    Assemblies = new[] { $\u0022/**/{assemblyName}.dll\u0022 },\n                    Repository = x.repo.HtmlUrl,\n                    GitName = x.repo.Name,\n                    GitUrl = x.repo.CloneUrl,\n                    Author = x.projectBuild.GetProperty(\u0022Authors\u0022) ?? \u0022\u0022,\n                    Description = description,\n                    Categories = categories.Concat(new[] {\n            x.repo.Name.Replace(\u0022.Extensions\u0022, \u0022\u0022),\n            assemblyName.Replace(\u0022.Extensions\u0022, \u0022\u0022).Replace(\u0022.Abstractions\u0022, \u0022\u0022).Split(\u0027.\u0027).Last()\n                    }).Distinct().OrderBy(z =\u003E z)\n                });\n\n                File.WriteAllText(Path.Combine(RootDirectory / \u0022packages\u0022, assemblyName.ToLower() \u002B \u0022.yml\u0022), yaml);\n                Logger.Info(yaml);\n\n                //\tnew { assemblyTitle, assemblyName, authors, copyright, repositoryUrl, tags, targetFrameworks, description, projectUrl }.Dump();\n            });\n        });\n}\n\nclass PackageSpec\n{\n    public string Name { get; set; }\n    public string NuGet { get; set; }\n    public bool Prerelease { get; set; }\n    public List\u003Cstring\u003E Assemblies { get; set; }\n    public string Repository { get; set; }\n    public string GitName { get; set; }\n    public string GitUrl { get; set; }\n    public string Author { get; set; }\n    public string Description { get; set; }\n    public List\u003Cstring\u003E Categories { get; set; }\n}\n"
  },
  {
    "Id": 216690115,
    "FirstIndexed": "2020-04-25T15:47:03.6114156+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631067+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431919+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937717+02:00",
    "Name": "Components",
    "Owner": "Beffyman",
    "HtmlUrl": "https://github.com/Beffyman/Components",
    "Description": "Basic ECS for those small use cases",
    "Archived": false,
    "Stars": 1,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Beffyman/Components/blob/master/build/Build.cs",
    "BuildFileSize": 7423,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelines(\n\tAzurePipelinesImage.WindowsLatest,\n\tAzurePipelinesImage.UbuntuLatest,\n\t//AzurePipelinesImage.MacOsLatest,\n\tInvokedTargets = new[] { nameof(Pack), nameof(Report), nameof(Performance) },\n\tExcludedTargets = new string[] { nameof(Clean) },\n\tNonEntryTargets = new string[] { nameof(Restore), nameof(Test), nameof(Label) })]\npublic partial class Build : NukeBuild\n{\n\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[Solution] readonly Solution Solution;\n\t[GitRepository] readonly GitRepository GitRepository;\n\t[GitVersion] readonly GitVersion GitVersion;\n\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\tAbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\tAbsolutePath SamplesDirectory =\u003E RootDirectory / \u0022samples\u0022;\n\tAbsolutePath BenchmarksDirectory =\u003E RootDirectory / \u0022benchmarks\u0022;\n\n\tstring BenchmarksProjectName =\u003E \u0022Beffyman.Components.Benchmarks\u0022;\n\tAbsolutePath BenchmarksProjectDirectory =\u003E BenchmarksDirectory / BenchmarksProjectName;\n\tAbsolutePath BenchmarksProject =\u003E BenchmarksProjectDirectory / $\u0022{BenchmarksProjectName}.csproj\u0022;\n\tAbsolutePath BenchmarksProjectArtifactsDirectory =\u003E BenchmarksProjectDirectory / \u0022BenchmarkDotNet.Artifacts\u0022;\n\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\t//AbsolutePath NugetArtifactsDirectory =\u003E ArtifactsDirectory / \u0022Nuget\u0022;\n\t//AbsolutePath TestArtifactsDirectory =\u003E ArtifactsDirectory / \u0022Tests\u0022;\n\tAbsolutePath PerformanceArtifactsDirectory =\u003E ArtifactsDirectory / \u0022Performance\u0022;\n\n\n\tstring CodeCoverageFile =\u003E \u0022coverage.cobertura.xml\u0022;\n\tint CodeCoverageRequirement =\u003E 90;\n\tstring ReportsOutput =\u003E \u0022Reports\u0022;\n\n\n\tTarget Label =\u003E _ =\u003E _\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tAzurePipelines.Instance?.UpdateBuildNumber(GitVersion.NuGetVersionV2);\n\t\t});\n\n\tTarget Clean =\u003E _ =\u003E _\n\t\t.Before(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tSamplesDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tBenchmarksDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tTestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\t\tEnsureCleanDirectory(ArtifactsDirectory);\n\t\t});\n\n\tTarget Restore =\u003E _ =\u003E _\n\t\t.After(Label)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetRestore(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution));\n\t\t});\n\n\tTarget Compile =\u003E _ =\u003E _\n\t\t.DependsOn(Label)\n\t\t.DependsOn(Restore)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tDotNetBuild(s =\u003E s\n\t\t\t\t.SetProjectFile(Solution)\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t.EnableNoRestore());\n\t\t});\n\n\tTarget Pack =\u003E _ =\u003E _\n\t\t.DependsOn(Label)\n\t\t.DependsOn(Compile)\n\t\t.Produces(ArtifactsDirectory / \u0022*nupkg\u0022)\n\t\t.Produces(ArtifactsDirectory / \u0022*snupkg\u0022)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\t//EnsureExistingDirectory(NugetArtifactsDirectory);\n\t\t\tEnsureExistingDirectory(ArtifactsDirectory);\n\n\t\t\tDotNetPack(s =\u003E s.SetProject(Solution)\n\t\t\t\t\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t\t\t\t.SetNoBuild(AzurePipelines.Instance == null)\n\t\t\t\t\t.EnableIncludeSource()\n\t\t\t\t\t.EnableIncludeSymbols()\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t\t.SetOutputDirectory(ArtifactsDirectory));\n\t\t});\n\n\n\tTarget Test =\u003E _ =\u003E _\n\t\t.After(Label)\n\t\t.DependsOn(Compile)\n\t\t.Produces(ArtifactsDirectory / \u0022*.trx\u0022)\n\t\t.Produces(ArtifactsDirectory / CodeCoverageFile)\n\t\t//.Produces(TestArtifactsDirectory / \u0022*.trx\u0022)\n\t\t//.Produces(TestArtifactsDirectory / CodeCoverageFile)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\t//EnsureExistingDirectory(TestArtifactsDirectory);\n\t\t\tEnsureExistingDirectory(ArtifactsDirectory);\n\n\t\t\tTestsDirectory.GlobFiles(\u0022**/*.csproj\u0022).ForEach(csproj =\u003E\n\t\t\t{\n\t\t\t\tvar projectName = Path.GetFileNameWithoutExtension(csproj);\n\t\t\t\tAbsolutePath coverageOutput = ArtifactsDirectory / $\u0022{projectName}\u0022;\n\t\t\t\t//AbsolutePath coverageOutput = TestArtifactsDirectory / $\u0022{projectName}\u0022;\n\n\t\t\t\tDotNetTest(s =\u003E s.SetConfiguration(Configuration)\n\t\t\t\t\t.SetNoBuild(AzurePipelines.Instance == null)\n\t\t\t\t\t.SetLogger(\u0022trx\u0022)\n\t\t\t\t\t//.SetResultsDirectory(TestArtifactsDirectory)\n\t\t\t\t\t.SetResultsDirectory(ArtifactsDirectory)\n\t\t\t\t\t.SetArgumentConfigurator(arguments =\u003E\n\t\t\t\t\t\targuments.Add(\u0022/p:CollectCoverage={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t\t\t\t.Add(\u0022/p:CoverletOutput={0}/\u0022, coverageOutput)\n\t\t\t\t\t\t\t\t//.Add(\u0022/p:Threshold={0}\u0022, CodeCoverageRequirement)\n\t\t\t\t\t\t\t\t.Add(\u0022/p:Exclude=\\\u0022[xunit*]*%2c[*.Tests]*\\\u0022\u0022)\n\t\t\t\t\t\t\t\t.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n\t\t\t\t\t\t\t\t.Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n\t\t\t\t\t.SetProjectFile(csproj));\n\n\t\t\t\tFileExists(coverageOutput);\n\t\t\t});\n\n\t\t\t//var trxFiles = TestArtifactsDirectory.GlobFiles(\u0022*.trx\u0022).Select(x =\u003E new FileInfo(x));\n\n\t\t\tAzurePipelines.Instance?.PublishTestResults(AzurePipelines.Instance?.BuildNumber, \u0022XUnit\u0022, ArtifactsDirectory.GlobFiles(\u0022*.trx\u0022).Select(x =\u003E x.ToString()), mergeResults: true);\n\n\t\t});\n\n\tTarget Report =\u003E _ =\u003E _\n\t\t.DependsOn(Label)\n\t\t.DependsOn(Compile)\n\t\t.DependsOn(Test)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tvar coverageFiles = TestsDirectory.GlobFiles(\u0022**/*.csproj\u0022)\n\t\t\t\t//.Select(csproj =\u003E (string)(TestArtifactsDirectory / $\u0022{Path.GetFileNameWithoutExtension(csproj)}\u0022))\n\t\t\t\t.Select(csproj =\u003E (string)(ArtifactsDirectory / $\u0022{Path.GetFileNameWithoutExtension(csproj)}\u0022))\n\t\t\t\t.ToArray();\n\n\t\t\tforeach (var coverageFolder in coverageFiles)\n\t\t\t{\n\t\t\t\tvar reportFolder = Path.Combine(coverageFolder, ReportsOutput);\n\t\t\t\tvar coverage = Path.Combine(coverageFolder, CodeCoverageFile);\n\n\t\t\t\tReportGenerator(s =\u003E s.SetReports(coverage)\n\t\t\t\t\t\t\t.SetTargetDirectory(reportFolder)\n\t\t\t\t\t\t\t.SetFramework(\u0022netcoreapp3.0\u0022)\n\t\t\t\t\t\t\t.SetTag(GitVersion.NuGetVersionV2)\n\t\t\t\t\t\t\t.SetReportTypes(ReportTypes.HtmlInline_AzurePipelines_Dark));\n\t\t\t}\n\t\t});\n\n\tTarget Performance =\u003E _ =\u003E _\n\t\t.DependsOn(Label)\n\t\t.DependsOn(Clean)\n\t\t.DependsOn(Compile)\n\t\t.Produces(PerformanceArtifactsDirectory)\n\t\t.Executes(() =\u003E\n\t\t{\n\t\t\tEnsureExistingDirectory(PerformanceArtifactsDirectory);\n\n\t\t\tDotNetRun(s =\u003E s.SetConfiguration(Configuration.Release)\n\t\t\t\t.SetWorkingDirectory(BenchmarksProjectDirectory)\n\t\t\t\t.AddEnvironmentVariable(\u0022CUSTOM_SDK_PATH\u0022, DotNetPath)\n\t\t\t\t.SetProjectFile(BenchmarksProject));\n\n\t\t\tCopyDirectoryRecursively(BenchmarksProjectArtifactsDirectory, PerformanceArtifactsDirectory, Nuke.Common.IO.DirectoryExistsPolicy.Merge, Nuke.Common.IO.FileExistsPolicy.Overwrite);\n\t\t});\n}\n"
  },
  {
    "Id": 216883277,
    "FirstIndexed": "2020-04-25T15:47:03.6114111+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629696+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431931+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937729+02:00",
    "Name": "Svg.Skia",
    "Owner": "wieslawsoltes",
    "HtmlUrl": "https://github.com/wieslawsoltes/Svg.Skia",
    "Description": "An SVG rendering library.",
    "Archived": false,
    "Stars": 47,
    "Watchers": 7,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/wieslawsoltes/Svg.Skia/blob/master/build/build/Build.cs",
    "BuildFileSize": 3766,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing Nuke.Common.IO;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution]\n    readonly Solution Solution;\n\n    [GitRepository]\n    readonly GitRepository GitRepository;\n\n    [Parameter(\u0022configuration\u0022)]\n    public string Configuration { get; set; }\n\n    [Parameter(\u0022version-suffix\u0022)]\n    public string VersionSuffix { get; set; }\n\n    [Parameter(\u0022publish-framework\u0022)]\n    public string PublishFramework { get; set; }\n\n    [Parameter(\u0022publish-runtime\u0022)]\n    public string PublishRuntime { get; set; }\n\n    [Parameter(\u0022publish-project\u0022)]\n    public string PublishProject { get; set; }\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        Configuration = Configuration ?? \u0022Release\u0022;\n        VersionSuffix = VersionSuffix ?? \u0022\u0022;\n    }\n\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\n    {\n        foreach (var directory in directories)\n        {\n            DeleteDirectory(directory);\n        }\n    }\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            DeleteDirectories(GlobDirectories(TestsDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022NuGet\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E PublishRuntime)\n        .Requires(() =\u003E PublishFramework)\n        .Requires(() =\u003E PublishProject)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(s =\u003E s\n                .SetProject(Solution.GetProject(PublishProject))\n                .SetConfiguration(Configuration)\n                .SetVersionSuffix(VersionSuffix)\n                .SetFramework(PublishFramework)\n                .SetRuntime(PublishRuntime)\n                .SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\n        });\n}\n"
  },
  {
    "Id": 217007229,
    "FirstIndexed": "2020-04-25T15:47:03.6114088+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163121+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431942+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893774+02:00",
    "Name": "TryGitActions",
    "Owner": "windischb",
    "HtmlUrl": "https://github.com/windischb/TryGitActions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/windischb/TryGitActions/blob/master/build/Build.cs",
    "BuildFileSize": 2138,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.GetNormalizedAssemblyVersion())\n                .SetFileVersion(GitVersion.GetNormalizedFileVersion())\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 218505816,
    "FirstIndexed": "2020-04-25T15:50:44.7360396+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630959+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843473+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940448+02:00",
    "Name": "PureCleanBuild",
    "Owner": "nicholas-james-king",
    "HtmlUrl": "https://github.com/nicholas-james-king/PureCleanBuild",
    "Description": "VS extention that Deletes the bin/obj folder for each project in the solution",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "PureCleanBuild/NukeBuild.cs",
    "BuildFileUrl": "https://github.com/nicholas-james-king/PureCleanBuild/blob/master/PureCleanBuild/NukeBuild.cs",
    "BuildFileSize": 8902,
    "BuildFileContent": "\uFEFFusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.Design;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Windows.Forms;\nusing EnvDTE;\nusing Microsoft.VisualStudio;\nusing Microsoft.VisualStudio.Shell;\nusing Microsoft.VisualStudio.Shell.Interop;\n\nusing Task = System.Threading.Tasks.Task;\n\nnamespace PureCleanBuild\n{\n  /// \u003Csummary\u003E\n  /// Command handler\n  /// \u003C/summary\u003E\n  internal sealed class NukeBuild\n  {\n    /// \u003Csummary\u003E\n    /// Command ID.\n    /// \u003C/summary\u003E\n    public const int CommandId = 0x0100;\n\n    /// \u003Csummary\u003E\n    /// Command menu group (command set GUID).\n    /// \u003C/summary\u003E\n    public static readonly Guid CommandSet = new Guid(\u0022b24c565c-4581-4b74-8b45-7d8ff8ef285b\u0022);\n\n    /// \u003Csummary\u003E\n    /// VS Package that provides this command, not null.\n    /// \u003C/summary\u003E\n    private readonly AsyncPackage package;\n\n    public struct Summary\n    {\n      public int ProjectsCleaned;\n      public int FoldersRemoved;\n      public int FilesDeleted;\n\n      public override string ToString()\n      {\n        return $\u0022Top Level Files Deleted: {FilesDeleted}\\r\\nDirectories Removed: {FoldersRemoved}\\r\\nProjects Cleaned: {ProjectsCleaned}\\r\\n\u0022;\n      }\n    }\n\n    /// \u003Csummary\u003E\n    /// Initializes a new instance of the \u003Csee cref=\u0022NukeBuild\u0022/\u003E class.\n    /// Adds our command handlers for menu (commands must exist in the command table file)\n    /// \u003C/summary\u003E\n    /// \u003Cparam name=\u0022package\u0022\u003EOwner package, not null.\u003C/param\u003E\n    /// \u003Cparam name=\u0022commandService\u0022\u003ECommand service to add command to, not null.\u003C/param\u003E\n    private NukeBuild(AsyncPackage package, OleMenuCommandService commandService)\n    {\n      this.package = package ?? throw new ArgumentNullException(nameof(package));\n      commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n\n      var menuCommandId = new CommandID(CommandSet, CommandId);\n      var menuItem = new MenuCommand(this.Execute, menuCommandId);\n      commandService.AddCommand(menuItem);\n    }\n\n    /// \u003Csummary\u003E\n    /// Gets the instance of the command.\n    /// \u003C/summary\u003E\n    public static NukeBuild Instance\n    {\n      get;\n      private set;\n    }\n\n    /// \u003Csummary\u003E\n    /// Gets the service provider from the owner package.\n    /// \u003C/summary\u003E\n    private Microsoft.VisualStudio.Shell.IAsyncServiceProvider ServiceProvider =\u003E this.package;\n\n    /// \u003Csummary\u003E\n    /// Initializes the singleton instance of the command.\n    /// \u003C/summary\u003E\n    /// \u003Cparam name=\u0022package\u0022\u003EOwner package, not null.\u003C/param\u003E\n    public static async Task InitializeAsync(AsyncPackage package)\n    {\n      // Switch to the main thread - the call to AddCommand in Command1\u0027s constructor requires\n      // the UI thread.\n      await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(package.DisposalToken);\n\n      var commandService = await package.GetServiceAsync((typeof(IMenuCommandService))) as OleMenuCommandService;\n      Instance = new NukeBuild(package, commandService);\n    }\n\n    /// \u003Csummary\u003E\n    /// This function is the callback used to execute the command when the menu item is clicked.\n    /// See the constructor to see how the menu item is associated with this function using\n    /// OleMenuCommandService service and MenuCommand class.\n    /// \u003C/summary\u003E\n    /// \u003Cparam name=\u0022sender\u0022\u003EEvent sender.\u003C/param\u003E\n    /// \u003Cparam name=\u0022e\u0022\u003EEvent args.\u003C/param\u003E\n    private void Execute(object sender, EventArgs e)\n    {\n      ThreadHelper.ThrowIfNotOnUIThread();\n\n      var verbose = false;\n\n#if DEBUG\n      verbose = true;\n#endif\n\n      package.JoinableTaskFactory.Run(async () =\u003E\n      {\n        await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync();\n\n        var solution = (await package.GetServiceAsync(typeof(IVsSolution)) as IVsSolution);\n        var outputWin = (await package.GetServiceAsync(typeof(SVsOutputWindow)) as IVsOutputWindow);\n\n        outputWin.GetPane(VSConstants.OutputWindowPaneGuid.BuildOutputPane_guid, out var buildPane);\n\n        var summary = new Summary\n        {\n          ProjectsCleaned = 0,\n          FoldersRemoved = 0,\n          FilesDeleted = 0\n        };\n\n        buildPane.Activate();\n\n        Action\u003Cstring\u003E output = (s) =\u003E\n        {\n          buildPane.OutputString($\u0022{s}\\r\\n\u0022);\n        };\n\n        try\n        {\n          output(\u0022--- Beginning Build Nuke ---\u0022);\n\n          foreach (var prj in GetProjects(solution))\n          {\n            if (!string.IsNullOrEmpty(prj.FileName))\n            {\n              var paths = GetTargetPaths(prj.Properties.Item(\u0022FullPath\u0022).Value.ToString());\n\n              try\n              {\n                paths.ForEach(p =\u003E \n                {\n                  package.JoinableTaskFactory.Run(async () =\u003E\n                    {\n                      await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync();\n\n                      while (Directory.Exists(p))\n                      {\n                        var di = new DirectoryInfo(p);\n\n                        foreach (var file in di.GetFiles())\n                        {\n                          try\n                          {\n                            file.Delete();\n                            summary.FilesDeleted\u002B\u002B;\n\n                            if(verbose)\n                              output($\u0022Removed file \u0027{file.FullName}\u0027\u0022);\n                          }\n                          catch (Exception ex)\n                          {\n                            output($\u0022Delete Failed ({ex.Message}) for file \u0027{file.FullName}\u0027\u0022);\n                          }\n                        }\n\n                        foreach (var dir in di.GetDirectories())\n                        {\n                          try\n                          {\n                            dir.Delete(true);\n                            \n                            if (verbose)\n                              output($\u0022Removed directory \u0027{dir.FullName}\u0027\u0022);\n                          }\n                          catch (Exception ex)\n                          {\n                            output($\u0022Delete Failed ({ex.Message}) for directory \u0027{dir.FullName}\u0027\u0022);\n                          }\n                        }\n\n                        try\n                        {\n                          Directory.Delete(p);\n                          summary.FoldersRemoved\u002B\u002B;\n\n                          if (verbose)\n                            output($\u0022Removed directory \u0027{p}\u0027\u0022);\n                        }\n                        catch (Exception ex)\n                        {\n                          output($\u0022Delete Failed ({ex.Message}) for directory \u0027{p}\u0027\u0022);\n                        }\n                      }\n                    });\n                });\n\n                summary.ProjectsCleaned\u002B\u002B;\n              }\n              catch (UnauthorizedAccessException)\n              {\n                MessageBox.Show(\u0022Your current user does not have permissions to delete the bin/obj folders try restarting Visual Studio as administrator.\u0022, \u0022Something has gone wrong :(\u0022);\n              }\n              catch (Exception)\n              {\n                MessageBox.Show(\u0022Something has gone wrong, please try again.\u0022);\n              }\n            }\n          }\n          output(\u0022--- Build Nuke Completed ---\u0022);\n          output(summary.ToString());\n        }\n        catch (Exception ex)\n        {\n\n        }\n      });\n    }\n\n    public static List\u003Cstring\u003E GetTargetPaths(string path)\n    {\n      return new List\u003Cstring\u003E\n      {\n        Path.Combine(path, \u0022bin\u0022),\n        Path.Combine(path, \u0022obj\u0022)\n      };\n    }\n\n    public static IEnumerable\u003CProject\u003E GetProjects(IVsSolution solution)\n    {\n      foreach (var h in GetProjectsInSolution(solution))\n      {\n        var project = GetDTEProject(h);\n        if (project != null)\n          yield return project;\n      }\n    }\n\n    public static IEnumerable\u003CIVsHierarchy\u003E GetProjectsInSolution(IVsSolution solution)\n    {\n      return GetProjectsInSolution(solution, __VSENUMPROJFLAGS.EPF_LOADEDINSOLUTION);\n    }\n\n    public static IEnumerable\u003CIVsHierarchy\u003E GetProjectsInSolution(IVsSolution solution, __VSENUMPROJFLAGS flags)\n    {\n      if (solution == null)\n        yield break;\n\n      var guid = Guid.Empty;\n\n      solution.GetProjectEnum((uint)flags, ref guid, out var enumHierarchies);\n\n      if (enumHierarchies == null)\n        yield break;\n\n      var hierarchy = new IVsHierarchy[1];\n\n      while (enumHierarchies.Next(1, hierarchy, out var fetched) == VSConstants.S_OK \u0026\u0026 fetched == 1)\n      {\n        if (hierarchy.Length \u003E 0 \u0026\u0026 hierarchy[0] != null)\n          yield return hierarchy[0];\n      }\n    }\n\n    public static Project GetDTEProject(IVsHierarchy hierarchy)\n    {\n      if (hierarchy == null)\n        throw new ArgumentNullException(nameof(hierarchy));\n\n      hierarchy.GetProperty(VSConstants.VSITEMID_ROOT, (int)__VSHPROPID.VSHPROPID_ExtObject, out var obj);\n\n      return obj as Project;\n    }\n  }\n}"
  },
  {
    "Id": 219125637,
    "FirstIndexed": "2020-04-25T15:47:03.6114008+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631164+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431948+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937752+02:00",
    "Name": "apexvox-demo",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/apexvox-demo",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/matkoch/apexvox-demo/blob/master/build/Build.cs",
    "BuildFileSize": 3062,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ControlFlow;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\n    \u0022deployment\u0022,\n    GitHubActionsImage.WindowsLatest,\n    InvokedTargets = new[] {nameof(Push)},\n    On = new[] {GitHubActionsTrigger.Push},\n    ImportSecrets = new[] {nameof(ApiKey)})]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            // dotnet MyApp.sln\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVerbosity(DotNetVerbosity.Diagnostic));\n        });\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution)\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    [Parameter] readonly string ApiKey;\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E\n        {\n            var packages = OutputDirectory.GlobFiles(\u0022*.nupkg\u0022);\n            Assert(packages.Count \u003E 0, \u0022packages.Count \u003E 0\u0022);\n\n            DotNetNuGetPush(_ =\u003E _\n                .SetSource(\u0022https://www.myget.org/F/matkoch/api/v2/package\u0022)\n                .SetApiKey(ApiKey)\n                .CombineWith(packages, (_, v) =\u003E _\n                    .SetTargetPath(v)));\n\n        });\n}"
  },
  {
    "Id": 219415182,
    "FirstIndexed": "2020-04-25T15:47:03.6113149+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630772+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431959+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937763+02:00",
    "Name": "envoy-csharp-control-plane",
    "Owner": "ahmelsayed",
    "HtmlUrl": "https://github.com/ahmelsayed/envoy-csharp-control-plane",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ahmelsayed/envoy-csharp-control-plane/blob/master/build/Build.cs",
    "BuildFileSize": 3309,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\n    \u0022Build\u0022,\n    GitHubActionsImage.UbuntuLatest,\n    GitHubActionsImage.WindowsLatest,\n    On = new[] { GitHubActionsTrigger.Push },\n    InvokedTargets = new[] { nameof(Compile), nameof(Publish) })]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetTest(_ =\u003E _\n                .SetProjectFile(TestsDirectory / \u0022Envoy.Control.Tests\u0022 / \u0022Envoy.Control.Tests.csproj\u0022)\n                .EnableNoRestore());\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            EnsureExistingDirectory(ArtifactsDirectory);\n            DotNetPublish(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Envoy.Control\u0022 / \u0022Envoy.Control.csproj\u0022)\n                .SetOutput(ArtifactsDirectory)\n                .SetRuntime(\u0022linux-x64\u0022));\n        });\n}\n"
  },
  {
    "Id": 219930404,
    "FirstIndexed": "2020-04-25T15:47:03.6113718+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631113+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431971+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937769+02:00",
    "Name": "Drdit.Html",
    "Owner": "volkovku",
    "HtmlUrl": "https://github.com/volkovku/Drdit.Html",
    "Description": "Lightweight, embedded, DSL-based HTML templates.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/volkovku/Drdit.Html/blob/master/build/Build.cs",
    "BuildFileSize": 2809,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution)\n            );\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore()\n            );\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(OutputDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution)\n                .SetNoBuild(ExecutingTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2)\n            );\n        });\n}"
  },
  {
    "Id": 219939626,
    "FirstIndexed": "2020-04-25T15:47:03.6111624+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628097+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431982+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893778+02:00",
    "Name": "Revit_mprCopySheetsToOpenDocuments",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprCopySheetsToOpenDocuments",
    "Description": "Batch copy sheets to open documents",
    "Archived": false,
    "Stars": 0,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprCopySheetsToOpenDocuments/blob/master/build/Build.cs",
    "BuildFileSize": 2617,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220061232,
    "FirstIndexed": "2020-04-25T15:47:03.6109332+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628581+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431988+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937791+02:00",
    "Name": "AutoCAD_mpTxtCopyPaste",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpTxtCopyPaste",
    "Description": "Fast copying of single line or multiline text content, mleaders, dimensions or table cells",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpTxtCopyPaste/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220448823,
    "FirstIndexed": "2020-04-25T15:47:03.6111977+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628126+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8431999+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937803+02:00",
    "Name": "Revit_mprFamilyDuplicateFixer",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprFamilyDuplicateFixer",
    "Description": "Automate Duplicate Family Correction",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprFamilyDuplicateFixer/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220450082,
    "FirstIndexed": "2020-04-25T15:47:03.6112051+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628137+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843201+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937814+02:00",
    "Name": "Revit_mprCleaner",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprCleaner",
    "Description": "Remove objects of certain categories from the model with the ability to remove unused elements",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprCleaner/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220465826,
    "FirstIndexed": "2020-04-25T15:47:03.610919+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628399+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432022+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937826+02:00",
    "Name": "AutoCAD_mpStripMtext",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpStripMtext",
    "Description": "Remove specified formatting from multiline text",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpStripMtext/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220595278,
    "FirstIndexed": "2020-04-25T15:47:03.6109429+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628638+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432033+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937837+02:00",
    "Name": "AutoCAD_mpTables",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpTables",
    "Description": "Plugin of inserting AutoCAD tables into the drawing according to GOST/DSTU/STB or from the specified file",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpTables/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220700858,
    "FirstIndexed": "2020-04-25T15:47:03.6111932+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628735+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432045+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937848+02:00",
    "Name": "AutoCAD_mpFormats",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpFormats",
    "Description": "Plugin of inserting in the drawing formats according to GOST 2.301-68/ISO 216",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpFormats/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220836808,
    "FirstIndexed": "2020-04-25T15:47:03.6111175+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629122+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432056+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937854+02:00",
    "Name": "Core_AutoCAD_Modules",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Core_AutoCAD_Modules",
    "Description": " ModPlus initialization loading module in AutoCAD",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Core_AutoCAD_Modules/blob/master/build/Build.cs",
    "BuildFileSize": 2614,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E \u0022ModPlus\u0022;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022ExtDll \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 220851755,
    "FirstIndexed": "2020-04-25T15:47:03.611365+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624428+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432067+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937865+02:00",
    "Name": "MSBuild.Targets",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/MSBuild.Targets",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/MSBuild.Targets/blob/master/.build/Build.cs",
    "BuildFileSize": 1742,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing JetBrains.Annotations;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}\n"
  },
  {
    "Id": 220998453,
    "FirstIndexed": "2020-04-25T15:47:03.6113621+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630971+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432079+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937877+02:00",
    "Name": "certificate-buildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/certificate-buildpack",
    "Description": null,
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/certificate-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 10569,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing ICSharpCode.SharpZipLib.Zip;\r\nusing Microsoft.Build.Tasks;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing FileMode = System.IO.FileMode;\r\nusing ZipFile = System.IO.Compression.ZipFile;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public enum StackType\r\n    {\r\n        Windows,\r\n        Linux\r\n    }\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n    const string BuildpackProjectName = \u0022DotnetCoreCertificateBuildpack\u0022;\r\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    \r\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\r\n    readonly StackType Stack = StackType.Windows;\r\n    \r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;  \r\n    string Framework =\u003E Stack == StackType.Windows ? \u0022net472\u0022 : \u0022netcoreapp3.0\u0022;\r\n\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    \r\n    string[] LifecycleHooks = {\u0022detect\u0022, \u0022supply\u0022, \u0022release\u0022, \u0022finalize\u0022};\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DoClean();\r\n            //EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    void DoClean()\r\n    {\r\n        SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n    }\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetRuntime(Runtime));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .Description(\u0022Compiles the buildpack\u0022)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            \r\n            Logger.Info(Stack);\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n                .SetRuntime(Runtime)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n    \r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\r\n            EnsureCleanDirectory(TemporaryDirectory);\r\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\r\n            var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\r\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\r\n            \r\n            \r\n            DotNetPublish(s =\u003E s\r\n                .SetProject(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n                .SetRuntime(Runtime)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                //.SetProperties(new Dictionary\u003Cstring,object\u003E{{\u0022TrimUnusedDependencies\u0022,\u0022true\u0022}})\r\n                .EnableNoRestore());\r\n\r\n\r\n\r\n            var lifecycleBinaries = Solution.GetProjects(\u0022Lifecycle*\u0022)\r\n                .Select(x =\u003E x.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022)\r\n                .SelectMany(x =\u003E Directory.GetFiles(x).Where(path =\u003E LifecycleHooks.Any(hook =\u003E Path.GetFileName(path).StartsWith(hook))));\r\n\r\n            foreach (var lifecycleBinary in lifecycleBinaries)\r\n            {\r\n                CopyFileToDirectory(lifecycleBinary, workBinDirectory, FileExistsPolicy.OverwriteIfNewer);\r\n            }\r\n            \r\n            CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n//            CopyDirectoryRecursively(scriptsDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n            var tempZipFile = TemporaryDirectory / PackageZipName;\r\n            \r\n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile);\r\n            MakeFilesInZipUnixExecutable(tempZipFile);\r\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\r\n            Logger.Block(ArtifactsDirectory / PackageZipName);\r\n\r\n        });\r\n    \r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            if (!GitRepository.IsGitHubRepository())\r\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\r\n            \r\n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\r\n            {\r\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n            };\r\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n            var owner = gitIdParts[0];\r\n            var repoName = gitIdParts[1];\r\n            \r\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n            Release release;\r\n            try\r\n            {\r\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n            }\r\n            catch (NotFoundException)\r\n            {\r\n                var newRelease = new NewRelease(releaseName)\r\n                {\r\n                    Name = releaseName, \r\n                    Draft = false, \r\n                    Prerelease = false\r\n                };\r\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n            }\r\n\r\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\r\n            if (existingAsset != null)\r\n            {\r\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n            }\r\n            \r\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\r\n            var stream = File.OpenRead(zipPackageLocation);\r\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, stream, TimeSpan.FromHours(1));\r\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n            \r\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n        });\r\n\r\n    public void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\r\n    {\r\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\r\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\r\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\r\n        {\r\n            output.SetLevel(9);\r\n            ZipEntry entry;\r\n\t\t\r\n            while ((entry = input.GetNextEntry()) != null)\r\n            {\r\n                var outEntry = new ZipEntry(entry.Name);\r\n                outEntry.HostSystem = (int)HostSystemID.Unix;\r\n                var entryAttributes =  ZipEntryAttributes.ReadOwner | ZipEntryAttributes.ReadOther | ZipEntryAttributes.ReadGroup;\r\n//                if (LifecycleHooks.Any(hook =\u003E entry.Name.EndsWith(hook)))\r\n                    entryAttributes = entryAttributes | ZipEntryAttributes.ExecuteOwner | ZipEntryAttributes.ExecuteOther | ZipEntryAttributes.ExecuteGroup;\r\n                entryAttributes = entryAttributes | (entry.IsDirectory ? ZipEntryAttributes.Directory : ZipEntryAttributes.Regular);\r\n//                outEntry.ExternalFileAttributes = -2115174400;\r\n                outEntry.ExternalFileAttributes = (int) (entryAttributes) \u003C\u003C 16;\r\n                output.PutNextEntry(outEntry);\r\n                input.CopyTo(output);\r\n            }\r\n            output.Finish();\r\n            output.Flush();\r\n        }\r\n\r\n        DeleteFile(zipFile);\r\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\r\n    }\r\n    \r\n    [Flags]\r\n    enum ZipEntryAttributes\r\n    {\r\n        ExecuteOther = 1,\r\n        WriteOther = 2,\r\n        ReadOther = 4,\r\n\t\r\n        ExecuteGroup = 8,\r\n        WriteGroup = 16,\r\n        ReadGroup = 32,\r\n\r\n        ExecuteOwner = 64,\r\n        WriteOwner = 128,\r\n        ReadOwner = 256,\r\n\r\n        Sticky = 512, // S_ISVTX\r\n        SetGroupIdOnExecution = 1024,\r\n        SetUserIdOnExecution = 2048,\r\n\r\n        //This is the file type constant of a block-oriented device file.\r\n        NamedPipe = 4096,\r\n        CharacterSpecial = 8192,\r\n        Directory = 16384,\r\n        Block = 24576,\r\n        Regular = 32768,\r\n        SymbolicLink = 40960,\r\n        Socket = 49152,\r\n\t\r\n    }\r\n}\r\n"
  },
  {
    "Id": 221046794,
    "FirstIndexed": "2020-04-25T15:50:44.7357893+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628388+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434548+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.894026+02:00",
    "Name": "book-store",
    "Owner": "lillo42",
    "HtmlUrl": "https://github.com/lillo42/book-store",
    "Description": "Sample of Book Store",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "users/build/Build.cs",
    "BuildFileUrl": "https://github.com/lillo42/book-store/blob/master/users/build/Build.cs",
    "BuildFileSize": 4484,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing Microsoft.VisualBasic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Docker.DockerTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022test\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetClean(s =\u003E s.SetProject(Solution));\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s.SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .DependsOn(UnitTest)\n        .DependsOn(AcceptanceTest)\n        .Executes(() =\u003E\n        {\n\n        });\n\n    Target UnitTest =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var unitTest = Solution.AllProjects.Where(x =\u003E x.Name.EndsWith(\u0022Test\u0022) \u0026\u0026 !x.Name.Contains(\u0022Acceptance\u0022));\n            foreach (var unit in unitTest)\n            {\n                DotNetTest(s =\u003E s\n                    .SetProjectFile(unit)\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore()\n                    .EnableNoBuild()\n                    .EnableCollectCoverage());\n            }\n            \n        });\n    \n    Target AcceptanceTest =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DockerComposeUp();\n            Thread.Sleep(60_000);\n            \n            try\n            {\n                var unitTest = Solution.AllProjects.Where(x =\u003E x.Name.EndsWith(\u0022Test\u0022) \u0026\u0026 x.Name.Contains(\u0022Acceptance\u0022));\n                foreach (var unit in unitTest)\n                {\n                    DotNetTest(s =\u003E s\n                        .SetProjectFile(unit)\n                        .SetConfiguration(Configuration)\n                        .AddEnvironmentVariable(\u0022Host\u0022, \u0022localhost:5100\u0022)\n                        .EnableNoRestore()\n                        .EnableNoBuild());\n                }\n            }\n            finally\n            {\n                DockerComposeDown();\n            }\n        });\n\n        static void DockerComposeUp()\n        {\n            ProcessTasks.StartProcess(\u0022docker-compose\u0022, \u0022up -d --build\u0022, RootDirectory.Parent);\n        }\n        \n        static void DockerComposeDown()\n        {\n            ProcessTasks.StartProcess(\u0022docker-compose\u0022, \u0022down\u0022, RootDirectory.Parent);\n        }\n}\n"
  },
  {
    "Id": 221293943,
    "FirstIndexed": "2020-04-25T15:47:03.6112+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630533+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843209+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937888+02:00",
    "Name": "Core_Revit_Modules",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Core_Revit_Modules",
    "Description": " ModPlus initialization loading module in Revit",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Core_Revit_Modules/blob/master/build/Build.cs",
    "BuildFileSize": 2555,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E \u0022ModPlus_Revit\u0022;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022ExtDll \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 221541618,
    "FirstIndexed": "2020-04-25T15:47:03.6113599+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1631011+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432101+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.89379+02:00",
    "Name": "MyNukeTestLibrary",
    "Owner": "sebfischer83",
    "HtmlUrl": "https://github.com/sebfischer83/MyNukeTestLibrary",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/sebfischer83/MyNukeTestLibrary/blob/master/build/Build.cs",
    "BuildFileSize": 3047,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022MyNukeTestLibrary.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetLogger(\u0022trx\u0022)\n                .SetLogOutput(true)\n                .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, true)\n                    .Add(\u0022/p:CoverletOutput={0}/\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n                .SetResultsDirectory(ArtifactsDirectory / \u0022tests\u0022));\n        });\n\n}\n"
  },
  {
    "Id": 221630204,
    "FirstIndexed": "2020-04-25T15:47:03.6113576+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163105+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432113+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937911+02:00",
    "Name": "nuke-calc",
    "Owner": "codeminic",
    "HtmlUrl": "https://github.com/codeminic/nuke-calc",
    "Description": "A simply project built with nuke",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/codeminic/nuke-calc/blob/master/build/Build.cs",
    "BuildFileSize": 2272,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 221993891,
    "FirstIndexed": "2020-04-25T15:47:03.6113553+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162997+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432124+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937922+02:00",
    "Name": "DiabLaunch",
    "Owner": "t081as",
    "HtmlUrl": "https://github.com/t081as/DiabLaunch",
    "Description": "Diablo 2 full screen launcher; mirror of the official repository https://gitlab.com/tobiaskoch/DiabLaunch",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/t081as/DiabLaunch/blob/master/build/Build.cs",
    "BuildFileSize": 4698,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing static Mjolnir.Build.PackageNameTasks;\nusing static Mjolnir.Build.IO.TextTasks;\nusing static Mjolnir.Build.VCS.GitVersionTasks;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build\u0022)]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Parameter(\u0022The build number provided by the continuous integration system\u0022)]\n    readonly ulong Buildnumber = 0;\n\n    [Solution]\n    readonly Solution Solution;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string shortVersion = \u00220.0.0\u0022;\n    string version = \u00220.0.0.0\u0022;\n    string semanticVersion = \u00220.0.0\u002BXXXXXXXX\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetClean();\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Version =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            (string shortVersion, string version, string semanticVersion) = GetGitTagVersion(RootDirectory, Buildnumber);\n\n            Logger.Info($\u0022Version: {version}\u0022);\n            Logger.Info($\u0022Short Version: {shortVersion}\u0022);\n            Logger.Info($\u0022Semantic Version: {semanticVersion}\u0022);\n            Logger.Info($\u0022Buildnumber: {Buildnumber}\u0022);\n\n            if (Configuration == Configuration.Release)\n            {\n                this.shortVersion = shortVersion;\n                this.version = version;\n                this.semanticVersion = semanticVersion;\n            }\n            else\n            {\n                Logger.Info(\u0022Debug build - skipping version\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore, Version)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(semanticVersion)\n                .SetAssemblyVersion(version)\n                .SetFileVersion(version)\n                .EnableNoRestore());\n\n            CopyFile(RootDirectory / \u0022AUTHORS.txt\u0022, OutputDirectory / \u0022AUTHORS.txt\u0022);\n            CopyFile(RootDirectory / \u0022CHANGELOG.md\u0022, OutputDirectory / \u0022CHANGELOG.txt\u0022);\n            CopyFile(RootDirectory / \u0022LICENSE.md\u0022, OutputDirectory / \u0022LICENSE.txt\u0022);\n\n            AbsolutePath readmePath = OutputDirectory / \u0022README.txt\u0022;\n            CopyFile(RootDirectory / \u0022USAGE.md\u0022, readmePath);\n\n            ReplaceInFile(readmePath, (\u0022{{VERSION_SEMATIC}}\u0022, semanticVersion), (\u0022{{VERSION_SHORT}}\u0022, shortVersion), (\u0022{{VERSION}}\u0022, version));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            if (Configuration == Configuration.Release)\n            {\n                RootDirectory.GlobFiles(\u0022*.zip\u0022).ForEach(DeleteFile);\n                OutputDirectory.GlobFiles(\u0022*.dev.*\u0022).ForEach(DeleteFile);\n                OutputDirectory.GlobFiles(\u0022*.deps.json\u0022).ForEach(DeleteFile); // If there are any dependencies they will be shipped\n                DeleteFile(OutputDirectory / \u0022DiabLaunch.xml\u0022); // Remove source code documentation xml\n\n                string archiveFileName;\n\n                if (semanticVersion.Contains(DevMarker, StringComparison.InvariantCultureIgnoreCase))\n                {\n                    archiveFileName = $\u0022{GenerateBinaryPackageName(\u0022DiabLaunch\u0022, semanticVersion, Mjolnir.Build.OperatingSystem.Windows, Mjolnir.Build.Architecture.X64)}.zip\u0022;\n                }\n                else\n                {\n                    archiveFileName = $\u0022{GenerateBinaryPackageName(\u0022DiabLaunch\u0022, shortVersion, Mjolnir.Build.OperatingSystem.Windows, Mjolnir.Build.Architecture.X64)}.zip\u0022;\n                }\n\n                CompressionTasks.CompressZip(OutputDirectory, RootDirectory / archiveFileName, null, System.IO.Compression.CompressionLevel.Optimal, System.IO.FileMode.CreateNew);\n            }\n            else\n            {\n                Logger.Info(\u0022Debug build - skipping pack\u0022);\n            }\n        });\n}"
  },
  {
    "Id": 222156678,
    "FirstIndexed": "2020-04-25T15:47:03.611113+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628427+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843213+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937934+02:00",
    "Name": "AutoCAD_mpDwgBase",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDwgBase",
    "Description": "Base of various blocks and drawings",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDwgBase/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 222214157,
    "FirstIndexed": "2020-04-25T15:47:03.6110805+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629844+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432141+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937945+02:00",
    "Name": "AutoCAD_mpMultiScale",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpMultiScale",
    "Description": "Plugin allows you to scale each of the selected objects relative to themselves",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpMultiScale/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 222296019,
    "FirstIndexed": "2020-04-25T15:47:03.6111551+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628109+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432153+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937956+02:00",
    "Name": "Revit_mprFastViewCut",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprFastViewCut",
    "Description": "Quickly create a crop view by specifying a rectangular crop area",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprFastViewCut/blob/master/build/Build.cs",
    "BuildFileSize": 2617,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 222726010,
    "FirstIndexed": "2020-04-25T15:47:03.6108689+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628166+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432164+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937968+02:00",
    "Name": "Revit_mmOrderMarking",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mmOrderMarking",
    "Description": "Adding numbering to the mark of elements with the possibility of marking in the schedules",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mmOrderMarking/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 222771894,
    "FirstIndexed": "2020-04-25T15:47:03.6113508+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630982+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843217+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937973+02:00",
    "Name": "meet-webwindow-example",
    "Owner": "VictorioBerra",
    "HtmlUrl": "https://github.com/VictorioBerra/meet-webwindow-example",
    "Description": "https://blog.stevensanderson.com/2019/11/18/2019-11-18-webwindow-a-cross-platform-webview-for-dotnet-core/",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/VictorioBerra/meet-webwindow-example/blob/master/build/Build.cs",
    "BuildFileSize": 2774,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    Project PublishProject =\u003E Solution.GetProject(nameOrFullPath: \u0022WebWindowExample\u0022);\n    \n    string runtime = \u0022win-x64\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetRuntime(runtime)\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetRuntime(runtime)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(_ =\u003E _\n                .SetProject(PublishProject)\n                .SetConfiguration(Configuration)\n                .SetOutput(ArtifactsDirectory)\n                .SetRuntime(runtime)\n                .EnableSelfContained()\n                .EnableNoBuild()\n                .EnableNoRestore()\n                );\n        });\n\n}\n"
  },
  {
    "Id": 223261013,
    "FirstIndexed": "2020-04-25T15:47:03.610969+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628723+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432181+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937985+02:00",
    "Name": "AutoCAD_mpPlinesEdit",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpPlinesEdit",
    "Description": "Collection of various plugins for working with polylines",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpPlinesEdit/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 223558624,
    "FirstIndexed": "2020-04-25T15:47:03.6113456+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630914+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432193+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8937996+02:00",
    "Name": "RedBoard",
    "Owner": "mastorm",
    "HtmlUrl": "https://github.com/mastorm/RedBoard",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mastorm/RedBoard/blob/master/build/Build.cs",
    "BuildFileSize": 2407,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.Npm;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildReactApp);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ReactApp =\u003E RootDirectory / \u0022src\u0022 / \u0022frontend\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target RestoreReactApp =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            NpmTasks.Npm(\u0022install\u0022, ReactApp);\n        });\n    \n    Target BuildReactApp =\u003E _ =\u003E _\n        .DependsOn(RestoreReactApp)\n        .Executes(() =\u003E\n        {\n            NpmTasks.Npm(\u0022run build\u0022, ReactApp);\n        });\n}\n"
  },
  {
    "Id": 223751468,
    "FirstIndexed": "2020-04-25T15:50:44.735266+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630942+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433393+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939168+02:00",
    "Name": "MGP-Evolution",
    "Owner": "mgp-evolution",
    "HtmlUrl": "https://github.com/mgp-evolution/MGP-Evolution",
    "Description": "MGP Evolution is a next gen Meta Gameplay Framework based on DDD and Event Sourcing principles.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mgp-evolution/MGP-Evolution/blob/master/build/Build.cs",
    "BuildFileSize": 2668,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tooling;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(OutputDirectory)\n                .CombineWith(Solution.GetProjects(\u0022*Tests\u0022), (ts, p) =\u003E ts.SetProjectFile(p))\n            );\n        });\n}\n"
  },
  {
    "Id": 224712323,
    "FirstIndexed": "2020-04-25T15:47:03.6109639+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628678+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432204+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938008+02:00",
    "Name": "AutoCAD_mpRotAtt",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpRotAtt",
    "Description": "Plugin is used to change the rotation angle of attributes in the selected blocks",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpRotAtt/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 224725139,
    "FirstIndexed": "2020-04-25T15:47:03.6109616+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628666+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843221+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938013+02:00",
    "Name": "AutoCAD_mpTxtCenter",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpTxtCenter",
    "Description": "Plugin allows you to create a single line text or align the existing one in the middle between two specified points",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpTxtCenter/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 224983255,
    "FirstIndexed": "2020-04-25T15:47:03.6109582+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628655+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432221+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938025+02:00",
    "Name": "AutoCAD_mpMeshes",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpMeshes",
    "Description": "Selection and calculation of the mass of reinforcing meshes according to normative documents",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpMeshes/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 224989192,
    "FirstIndexed": "2020-04-25T15:47:03.6109406+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628626+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432232+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938036+02:00",
    "Name": "AutoCAD_mpDimJustif",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDimJustif",
    "Description": "Aligning the extension or dimension lines along the specified straight line",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDimJustif/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 225130729,
    "FirstIndexed": "2020-04-25T15:50:44.7351169+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628763+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843329+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893906+02:00",
    "Name": "AutoCAD_mpSummLength",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpSummLength",
    "Description": "Gets and displays the number and sum of the lengths of selected lines, polylines, circles, arcs and splines",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpSummLength/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 225273778,
    "FirstIndexed": "2020-04-25T15:47:03.6113291+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630703+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432238+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938047+02:00",
    "Name": "spa-buildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/spa-buildpack",
    "Description": null,
    "Archived": false,
    "Stars": 3,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/spa-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 14407,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Text;\r\nusing Force.Crc32;\r\nusing ICSharpCode.SharpZipLib.Zip;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing FileMode = System.IO.FileMode;\r\nusing ZipFile = System.IO.Compression.ZipFile;\r\n\r\n[assembly: InternalsVisibleTo(\u0022SpaBuildpackTests\u0022)]\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public enum StackType\r\n    {\r\n        Windows,\r\n        Linux\r\n    }\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n    const string BuildpackProjectName = \u0022SpaBuildpack\u0022;\r\n    string PackageZipName =\u003E $\u0022{BuildpackProjectName}-{Runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    \r\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is \u0027windows\u0027\u0022)]\r\n    readonly StackType Stack = StackType.Linux;\r\n    \r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    [Parameter(\u0022Application directory against which buildpack will be applied\u0022)]\r\n    readonly string ApplicationDirectory;\r\n\r\n    string Runtime =\u003E Stack == StackType.Windows ? \u0022win-x64\u0022 : \u0022linux-x64\u0022;  \r\n    string Framework =\u003E Stack == StackType.Windows ? \u0022net472\u0022 : \u0022netcoreapp3.0\u0022;\r\n\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    \r\n    string[] LifecycleHooks = {\u0022detect\u0022, \u0022supply\u0022, \u0022release\u0022, \u0022finalize\u0022};\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DoClean();\r\n            //EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    void DoClean()\r\n    {\r\n        SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n    }\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Description(\u0022Restores NuGet dependencies for the buildpack\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetRuntime(Runtime));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .Description(\u0022Compiles the buildpack\u0022)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            \r\n            Logger.Info(Stack);\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n                .SetRuntime(Runtime)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n    \r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\r\n        .DependsOn(Restore, Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            var workDirectory = TemporaryDirectory / \u0022pack\u0022;\r\n            EnsureCleanDirectory(TemporaryDirectory);\r\n            var buildpackProject = Solution.GetProject(BuildpackProjectName);\r\n            var launcherProject = Solution.GetProject(\u0022SpaLauncher\u0022);\r\n            var buildpackPublishDir = buildpackProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\r\n            var launcherPublishDir = launcherProject.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022;\r\n            var workBinDirectory = workDirectory / \u0022bin\u0022;\r\n            var launcherDirectory = workDirectory / \u0022launcher\u0022;\r\n            \r\n            \r\n            DotNetPublish(s =\u003E s\r\n                .SetProject(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n                .SetRuntime(Runtime)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                //.SetProperties(new Dictionary\u003Cstring,object\u003E{{\u0022TrimUnusedDependencies\u0022,\u0022true\u0022}})\r\n                .EnableNoRestore());\r\n\r\n\r\n\r\n            var lifecycleBinaries = Solution.GetProjects(\u0022Lifecycle*\u0022)\r\n                .Select(x =\u003E x.Directory / \u0022bin\u0022 / Configuration / Framework / Runtime / \u0022publish\u0022)\r\n                .SelectMany(x =\u003E Directory.GetFiles(x).Where(path =\u003E LifecycleHooks.Any(hook =\u003E Path.GetFileName(path).StartsWith(hook))));\r\n\r\n            foreach (var lifecycleBinary in lifecycleBinaries)\r\n            {\r\n                CopyFileToDirectory(lifecycleBinary, workBinDirectory, FileExistsPolicy.OverwriteIfNewer);\r\n            }\r\n            \r\n            CopyDirectoryRecursively(buildpackPublishDir, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n            CopyDirectoryRecursively(launcherPublishDir, launcherDirectory, DirectoryExistsPolicy.Merge);\r\n            var commonFiles = GetCommonFiles(buildpackPublishDir, launcherDirectory);\r\n            var commonFilesManifest = workDirectory / \u0022commonFiles.txt\u0022;\r\n            using (var fileStream = File.Create(commonFilesManifest))\r\n            {\r\n                using var fsw = new StreamWriter(fileStream);\r\n                foreach (var file in commonFiles)\r\n                {\r\n                    fsw.WriteLine(Path.GetFileName(file.Item2));\r\n                    File.Delete(file.Item2);\r\n                }\r\n            }\r\n\r\n            var tempZipFile = TemporaryDirectory / PackageZipName;\r\n            \r\n            ZipFile.CreateFromDirectory(workDirectory, tempZipFile, CompressionLevel.NoCompression, false);\r\n            MakeFilesInZipUnixExecutable(tempZipFile);\r\n            CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\r\n            Logger.Block(ArtifactsDirectory / PackageZipName);\r\n\r\n        });\r\n    \r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or ammends existing) and uploads buildpack artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            if (!GitRepository.IsGitHubRepository())\r\n                throw new Exception(\u0022Only supported when git repo remote is github\u0022);\r\n            \r\n            var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\r\n            {\r\n                Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n            };\r\n            var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n            var owner = gitIdParts[0];\r\n            var repoName = gitIdParts[1];\r\n            \r\n            var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n            Release release;\r\n            try\r\n            {\r\n                release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n            }\r\n            catch (NotFoundException)\r\n            {\r\n                var newRelease = new NewRelease(releaseName)\r\n                {\r\n                    Name = releaseName, \r\n                    Draft = false, \r\n                    Prerelease = false\r\n                };\r\n                release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n            }\r\n\r\n            var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == PackageZipName);\r\n            if (existingAsset != null)\r\n            {\r\n                await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n            }\r\n            \r\n            var zipPackageLocation = ArtifactsDirectory / PackageZipName;\r\n            var stream = File.OpenRead(zipPackageLocation);\r\n            var releaseAssetUpload = new ReleaseAssetUpload(PackageZipName, \u0022application/zip\u0022, stream, TimeSpan.FromHours(1));\r\n            var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n            \r\n            Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n        });\r\n\r\n    Target Detect =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027detect\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Executes(async () =\u003E\r\n        {\r\n            try\r\n            {\r\n                DotNetRun(s =\u003E s\r\n                    .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Detect\u0022).Path)\r\n                    .SetApplicationArguments(ApplicationDirectory)\r\n                    .SetConfiguration(Configuration)\r\n                    .SetFramework(Framework)\r\n                );\r\n                Logger.Block($\u0022Detect returned \u0027true\u0027\u0022);\r\n            }\r\n            catch (ProcessException)\r\n            {\r\n                Logger.Block($\u0022Detect returned \u0027false\u0027\u0022);\r\n            }\r\n\r\n        });\r\n\r\n    Target Supply =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027supply\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Executes(async () =\u003E\r\n        {\r\n            \r\n            var home = (AbsolutePath)Path.GetTempPath() / Guid.NewGuid().ToString();\r\n            var app = home / \u0022app\u0022;\r\n            var deps = home / \u0022deps\u0022;\r\n            var index = 0;\r\n            var cache = home / \u0022cache\u0022;\r\n            CopyDirectoryRecursively(ApplicationDirectory, app);\r\n            \r\n            DotNetRun(s =\u003E s\r\n                .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Supply\u0022).Path)\r\n                .SetApplicationArguments($\u0022{app} {cache} {app} {deps} {index}\u0022)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(Framework)\r\n            );\r\n            Logger.Block($\u0022Buildpack applied. Droplet is available in {home}\u0022);\r\n\r\n        });\r\n\r\n    public void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\r\n    {\r\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\r\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\r\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\r\n        {\r\n            output.SetLevel(9);\r\n            ZipEntry entry;\r\n\t\t\r\n            while ((entry = input.GetNextEntry()) != null)\r\n            {\r\n                var outEntry = new ZipEntry(entry.Name);\r\n                outEntry.HostSystem = (int)HostSystemID.Unix;\r\n                var entryAttributes =  \r\n                    ZipEntryAttributes.ReadOwner | \r\n                    ZipEntryAttributes.ReadOther | \r\n                    ZipEntryAttributes.ReadGroup |\r\n                    ZipEntryAttributes.ExecuteOwner | \r\n                    ZipEntryAttributes.ExecuteOther | \r\n                    ZipEntryAttributes.ExecuteGroup;\r\n                entryAttributes = entryAttributes | (entry.IsDirectory ? ZipEntryAttributes.Directory : ZipEntryAttributes.Regular);\r\n                outEntry.ExternalFileAttributes = (int) (entryAttributes) \u003C\u003C 16; // https://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute\r\n                output.PutNextEntry(outEntry);\r\n                input.CopyTo(output);\r\n            }\r\n            output.Finish();\r\n            output.Flush();\r\n        }\r\n\r\n        DeleteFile(zipFile);\r\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\r\n    }\r\n\r\n    public void ExtractCommonFiles(string dir1, string dir2, string commonDir)\r\n    {\r\n        var files = GetCommonFiles(dir1, dir2);\r\n        Directory.CreateDirectory(commonDir);\r\n        foreach (var file in files)\r\n        {\r\n            var fileName = Path.GetFileName(file.Item1);\r\n            MoveFile(file.Item1, Path.Combine(commonDir, fileName));\r\n            DeleteFile(file.Item2);\r\n        }\r\n    }\r\n    public List\u003CTuple\u003Cstring, string\u003E\u003E GetCommonFiles(string dir1, string dir2)\r\n    {\r\n        var common = new List\u003CTuple\u003Cstring,string\u003E\u003E();\r\n\r\n        var dir1Info = new DirectoryInfo(dir1);\r\n        var dir2Info = new DirectoryInfo(dir2);\r\n        foreach(var file in  dir1Info.GetFiles())\r\n        {\r\n            var otherFile = new FileInfo(Path.Combine(dir2Info.FullName, file.Name));\r\n\t\t\r\n            if(File.Exists(otherFile.FullName) \u0026\u0026 file.Length == otherFile.Length \u0026\u0026 Crc32Algorithm.Compute(File.ReadAllBytes(file.FullName)) == Crc32Algorithm.Compute(File.ReadAllBytes(otherFile.FullName)))\r\n            {\r\n                common.Add(Tuple.Create(file.FullName, otherFile.FullName));\r\n            }\r\n        }\r\n\r\n        return common;\r\n    }\r\n    \r\n    [Flags]\r\n    enum ZipEntryAttributes\r\n    {\r\n        ExecuteOther = 1,\r\n        WriteOther = 2,\r\n        ReadOther = 4,\r\n\t\r\n        ExecuteGroup = 8,\r\n        WriteGroup = 16,\r\n        ReadGroup = 32,\r\n\r\n        ExecuteOwner = 64,\r\n        WriteOwner = 128,\r\n        ReadOwner = 256,\r\n\r\n        Sticky = 512, // S_ISVTX\r\n        SetGroupIdOnExecution = 1024,\r\n        SetUserIdOnExecution = 2048,\r\n\r\n        //This is the file type constant of a block-oriented device file.\r\n        NamedPipe = 4096,\r\n        CharacterSpecial = 8192,\r\n        Directory = 16384,\r\n        Block = 24576,\r\n        Regular = 32768,\r\n        SymbolicLink = 40960,\r\n        Socket = 49152,\r\n\t\r\n    }\r\n}\r\n"
  },
  {
    "Id": 225901996,
    "FirstIndexed": "2020-04-25T15:47:03.6113263+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630857+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432249+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938059+02:00",
    "Name": "Nuke-Core-POC",
    "Owner": "archernc",
    "HtmlUrl": "https://github.com/archernc/Nuke-Core-POC",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/archernc/Nuke-Core-POC/blob/master/build/Build.cs",
    "BuildFileSize": 11402,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.TeamCity;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotCover;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.InspectCode;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Tools.Octopus;\nusing Nuke.Common.Tools.Paket;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.InspectCode.InspectCodeTasks;\n//using static Nuke.Common.Tools.NuGet.NuGetTasks;\nusing static Nuke.Common.Tools.Octopus.OctopusTasks;\nusing static Nuke.Common.Tools.Paket.PaketTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n\t/// Support plugins are available for:\n\t///   - JetBrains ReSharper        https://nuke.build/resharper\n\t///   - JetBrains Rider            https://nuke.build/rider\n\t///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n\t///   - Microsoft VSCode           https://nuke.build/vscode\n\n\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Octo_Create_Release);\n\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t[CI] readonly TeamCity TeamCity;\n\t[GitRepository] readonly GitRepository GitRepository;\n\n\t[Solution] readonly Solution Solution;\n\t[GitVersion] readonly GitVersion GitVersion;\n\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\tAbsolutePath NuGetOutputDirectory =\u003E ArtifactsDirectory / \u0022NuGet\u0022;\n\tAbsolutePath OctopusOutputDirectory =\u003E ArtifactsDirectory / \u0022Octo\u0022;\n\tAbsolutePath PublishedOutput =\u003E ArtifactsDirectory / \u0022published-app\u0022;\n\n\treadonly string NUGET_SERVER_KEY = Environment.GetEnvironmentVariable(\u0022NUGET_SERVER_KEY\u0022);\n\treadonly string NUGET_SERVER_URL = Environment.GetEnvironmentVariable(\u0022NUGET_SERVER_URL\u0022);\n\treadonly string OCTOPACK_PUBLISH_APIKEY = Environment.GetEnvironmentVariable(\u0022OCTOPACK_PUBLISH_APIKEY\u0022);\n\treadonly string OCTOPUS_DEPLOY_SERVER = Environment.GetEnvironmentVariable(\u0022OCTOPUS_DEPLOY_SERVER\u0022); //TODO: convert to SSL\n\treadonly string OCTOPUS_PROJECT_NAME = Environment.GetEnvironmentVariable(\u0022OCTOPUS_PROJECT_NAME\u0022);// ?? \u0022Nuke.Core\u0022;\n\n\t/// \u003Csummary\u003E\n\t/// Runs JetBrains.ReSharper code analysis\n\t/// \u003C/summary\u003E\n\tTarget Analysis =\u003E _ =\u003E _\n\t.DependsOn(Restore)\n\t.Executes(() =\u003E\n\t{\n\t\tInspectCode(_ =\u003E _\n\t\t\t.SetTargetPath(Solution)\n\t\t\t.SetOutput($\u0022{ArtifactsDirectory}/inspectCode.xml\u0022)\n\t\t\t//.AddExtensions(\n\t\t\t//    \u0022EtherealCode.ReSpeller\u0022,\n\t\t\t//    \u0022PowerToys.CyclomaticComplexity\u0022,\n\t\t\t//    \u0022ReSharper.ImplicitNullability\u0022,\n\t\t\t//    \u0022ReSharper.SerializationInspections\u0022,\n\t\t\t//    \u0022ReSharper.XmlDocInspections\u0022)\n\t\t\t);\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// Removes previously built artifacts\n\t/// \u003C/summary\u003E\n\tTarget Clean =\u003E _ =\u003E _\n\t.Before(Restore)\n\t.Executes(() =\u003E\n\t{\n\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n\t\tEnsureCleanDirectory(ArtifactsDirectory);\n\t\tDotNetClean();\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// This will restore all paket references\n\t/// \u003C/summary\u003E\n\tTarget Restore =\u003E _ =\u003E _.Executes(() =\u003E DotNetRestore(_ =\u003E _.SetProjectFile(Solution)));\n\n\t/// \u003Csummary\u003E\n\t/// Build\n\t/// \u003C/summary\u003E\n\tTarget Compile =\u003E _ =\u003E _\n\t.DependsOn(Restore)\n\t.Executes(() =\u003E\n\t{\n\t\tDotNetBuild(_ =\u003E _\n\t\t\t.SetProjectFile(Solution)\n\t\t\t.SetConfiguration(Configuration)\n\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t.EnableNoRestore() // Doesn\u0027t perform an implicit restore during build\n\t\t);\n\t});\n\n\t// http://www.nuke.build/docs/authoring-builds/ci-integration.html#partitioning\n\t[Partition(2)] readonly Partition TestPartition;\n\t/// \u003Csummary\u003E\n\t/// Runs all tests and generates report file(s)\n\t/// \u003C/summary\u003E\n\tTarget Test =\u003E _ =\u003E _\n\t.DependsOn(Compile)\n\t.Produces($\u0022{ArtifactsDirectory}/*.trx\u0022)\n\t.Produces($\u0022{ArtifactsDirectory}/*.xml\u0022)\n\t.Partition(() =\u003E TestPartition)\n\t.Executes(() =\u003E\n\t{\n\t\tDotNetTest(_ =\u003E _\n\t\t\t.SetConfiguration(Configuration)\n\t\t\t.SetNoBuild(InvokedTargets.Contains(Compile))\n\t\t\t.ResetVerbosity()\n\t\t\t.SetResultsDirectory(ArtifactsDirectory)\n\t\t\t.When(InvokedTargets.Contains(Coverage) || IsServerBuild,\n\t\t\t\t_ =\u003E _\n\t\t\t\t.SetProperty(\u0022CollectCoverage\u0022, propertyValue: true)\n\t\t\t\t// CoverletOutputFormat: json (default), lcov, opencover, cobertura, teamcity\n\t\t\t\t.SetProperty(\u0022CoverletOutputFormat\u0022, \u0022teamcity%2copencover\u0022)\n\t\t\t\t//.EnableCollectCoverage()\n\t\t\t\t//.SetCoverletOutputFormat(CoverletOutputFormat.teamcity)\n\t\t\t\t.When(IsServerBuild, _ =\u003E _\n\t\t\t\t\t.SetProperty(\u0022UseSourceLink\u0022, propertyValue: true)\n\t\t\t\t\t//.EnableUseSourceLink()\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t.CombineWith(TestPartition.GetCurrent(Solution.GetProjects(\u0022*.UnitTest\u0022)), (_, v) =\u003E _\n\t\t\t\t.SetProjectFile(v)\n\t\t\t\t.SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\n\t\t\t\t.When(InvokedTargets.Contains(Coverage) || IsServerBuild,\n\t\t\t\t\t_ =\u003E _\n\t\t\t\t\t.SetProperty(\u0022CoverletOutput\u0022, $\u0022{ArtifactsDirectory}/{v.Name}.xml\u0022)\n\t\t\t\t\t//.SetCoverletOutput(ArtifactsDirectory / $\u0022{v.Name}.xml\u0022)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t});\n\n\tstring CoverageReportDirectory =\u003E $\u0022{ArtifactsDirectory}/coverage-report\u0022;\n\tstring CoverageReportArchive =\u003E $\u0022{ArtifactsDirectory}/coverage-report.zip\u0022;\n\t/// \u003Csummary\u003E\n\t/// Generates code coverage reports based on \u003Csee cref=\u0022Test\u0022\u003ETest\u003C/see\u003E results\n\t/// \u003C/summary\u003E\n\tTarget Coverage =\u003E _ =\u003E _\n\t.DependsOn(Test)\n\t//.TriggeredBy(Test)\n\t.Produces(CoverageReportArchive)\n\t.Executes(() =\u003E\n\t{\n\t\tvar files = ArtifactsDirectory.GlobFiles(\u0022*.xml\u0022);\n\t\tif (files.Any())\n\t\t{\n\t\t\tReportGenerator(_ =\u003E _\n\t\t\t\t.SetReports(files.Select(f =\u003E f.ToString()).ToArray())\n\t\t\t\t.SetReportTypes(ReportTypes.Html, ReportTypes.TeamCitySummary, ReportTypes.TextSummary)\n\t\t\t\t.SetTargetDirectory(CoverageReportDirectory)\n\t\t\t);\n\n\t\t\tCompressZip(\n\t\t\t\tdirectory: CoverageReportDirectory,\n\t\t\t\tarchiveFile: CoverageReportArchive,\n\t\t\t\tfileMode: FileMode.Create);\n\t\t}\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// Creates NuGet package(s) that can be pushed to NuGet server.\n\t/// Implements Paket\n\t/// \u003C/summary\u003E\n\tTarget NuGet_Pack =\u003E _ =\u003E _\n\t.DependsOn(Test)\n\t.Produces($\u0022{NuGetOutputDirectory}/*.nupkg\u0022)\n\t.Executes(() =\u003E\n\t{\n\t\tPaketPack(_ =\u003E _\n\t\t\t.SetToolPath($\u0022{RootDirectory}/.paket/paket.exe\u0022)\n\t\t\t.SetLockDependencies(true)\n\t\t\t.SetBuildConfiguration(Configuration)\n\t\t\t.SetPackageVersion(GitVersion.NuGetVersionV2)\n\t\t\t.SetOutputDirectory(NuGetOutputDirectory)\n\t\t);\n\n\t\t//DotNetPack(_ =\u003E _\n\t\t//\t.SetProject(Solution)\n\t\t//\t.SetNoBuild(ExecutingTargets.Contains(Compile))\n\t\t//\t.SetConfiguration(Configuration)\n\t\t//\t.SetOutputDirectory(NuGetOutputDirectory)\n\t\t//\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t//\t//.SetPackageReleaseNotes(GetNuGetReleaseNotes($\u0022{RootDirectory}/CHANGELOG.md\u0022, GitRepository))\n\t\t//);\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// Pushes all packages generated from \u003Csee cref=\u0022NuGet_Pack\u0022\u003ENuGet_Pack\u003C/see\u003E to the NuGet repository\n\t/// Implements DotNetNuGet\n\t/// \u003C/summary\u003E\n\tTarget NuGet_Push =\u003E _ =\u003E _\n\t.DependsOn(NuGet_Pack)\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(NUGET_SERVER_KEY))\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(NUGET_SERVER_URL))\n\t.Executes(() =\u003E\n\t{\n\t\tvar packages = NuGetOutputDirectory.GlobFiles(\u0022*.nupkg\u0022);\n\t\tif (packages.Any())\n\t\t{\n\t\t\tDotNetNuGetPush(_ =\u003E _\n\t\t\t\t.SetApiKey(NUGET_SERVER_KEY)\n\t\t\t\t.SetSource(NUGET_SERVER_URL)\n\t\t\t\t.CombineWith(packages, (_, v) =\u003E _.SetTargetPath(v)),\n\t\t\t\tdegreeOfParallelism: 5,\n\t\t\t\tcompleteOnFailure: true\n\t\t\t);\n\n\t\t\t//NuGetPush(_ =\u003E _\n\t\t\t//\t.SetApiKey(NUGET_SERVER_KEY)\n\t\t\t//\t.SetSource(NUGET_SERVER_URL)\n\t\t\t//\t.CombineWith(packages, (_, v) =\u003E _.SetTargetPath(v)),\n\t\t\t//\tdegreeOfParallelism: 5,\n\t\t\t//\tcompleteOnFailure: true\n\t\t\t//);\n\n\t\t\t//PaketPush(_ =\u003E _\n\t\t\t//\t.SetToolPath($\u0022{RootDirectory}/.paket/paket.exe\u0022)\n\t\t\t//\t.SetApiKey(NUGET_SERVER_KEY)\n\t\t\t//\t.SetUrl(NUGET_SERVER_URL)\n\t\t\t//\t.CombineWith(packages, (_, v) =\u003E _.SetFile(v)),\n\t\t\t//\tdegreeOfParallelism: 5,\n\t\t\t//\tcompleteOnFailure: true\n\t\t\t//);\n\t\t}\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// Uses \u003CPropertyGroup\u003E\u003CIsPublishable\u003E...\u003C/IsPublishable\u003E\u003C/PropertyGroup\u003E from the .csproj file\n\t/// Default == true\n\t/// Explicitly set to false for projects that do not need to be published\n\t/// \u003C/summary\u003E\n\tTarget Publish =\u003E _ =\u003E _\n\t.DependsOn(Test)\n\t.Executes(() =\u003E\n\t{\n\t\t// Note: Solution.Projects only returns projects with no SolutionFolder property set\n\t\tSolution.AllProjects\n\t\t\t.Where(p =\u003E p.GetProperty(\u0022IsPublishable\u0022).EqualsOrdinalIgnoreCase(\u0022true\u0022))\n\t\t\t.ForEach(p =\u003E\n\t\t\t{\n\t\t\t\tDotNetPublish(_ =\u003E _\n\t\t\t\t\t.SetWorkingDirectory(p.Directory)\n\t\t\t\t\t.SetNoRestore(ExecutingTargets.Contains(Restore))\n\t\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t\t.SetOutput($\u0022{PublishedOutput}/{p.Name}\u0022)\n\t\t\t\t);\n\t\t\t});\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// Generates NuGet packages for Octopus Deploy\n\t/// \u003C/summary\u003E\n\tTarget Octo_Pack =\u003E _ =\u003E _\n\t.DependsOn(Publish)\n\t.Produces($\u0022{OctopusOutputDirectory}/*.nupkg\u0022)\n\t.Executes(() =\u003E\n\t{\n\t\tvar apps = PublishedOutput.GlobDirectories(\u0022*\u0022);\n\t\tOctopusPack(_ =\u003E _\n\t\t.SetOutputFolder(OctopusOutputDirectory)\n\t\t.SetVersion(GitVersion.NuGetVersionV2)\n\t\t.SetOverwrite(true) // keeps from failing the build\n\t\t.CombineWith(apps, (_, v) =\u003E\n\t\t{\n\t\t\tstring appName = new DirectoryInfo(v).Name;\n\t\t\treturn _.SetBasePath(v).SetTitle(appName).SetId(appName);\n\t\t})\n\t\t);\n\t\t//TODO: Docker packages may need a different process\n\t});\n\n\t/// \u003Csummary\u003E\n\t/// Pushes all packages generated from \u003Csee cref=\u0022Octo_Pack\u0022\u003EOcto_Pack\u003C/see\u003E to the Octopus repository\n\t/// \u003C/summary\u003E\n\tTarget Octo_Push =\u003E _ =\u003E _\n\t.DependsOn(Octo_Pack)\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(OCTOPUS_DEPLOY_SERVER))\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(OCTOPACK_PUBLISH_APIKEY))\n\t.Executes(() =\u003E\n\t{\n\t\tvar packages = OctopusOutputDirectory.GlobFiles(\u0022*.nupkg\u0022);\n\t\tif (packages.Any())\n\t\t{\n\t\t\tOctopusPush(_ =\u003E _\n\t\t\t.SetServer(OCTOPUS_DEPLOY_SERVER)\n\t\t\t.SetApiKey(OCTOPACK_PUBLISH_APIKEY)\n\t\t\t.EnableReplaceExisting() // keeps from failing the build\n\t\t\t.CombineWith(packages, (_, v) =\u003E _.SetPackage(v))\n\t\t\t);\n\t\t}\n\t});\n\n\n\tTarget Octo_Create_Release =\u003E _ =\u003E _\n\t.DependsOn(Octo_Push)\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(OCTOPUS_DEPLOY_SERVER))\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(OCTOPACK_PUBLISH_APIKEY))\n\t.Requires(() =\u003E !string.IsNullOrWhiteSpace(OCTOPUS_PROJECT_NAME))\n\t.Executes(() =\u003E\n\t{\n\t\tOctopusCreateRelease(_ =\u003E _\n\t\t.SetServer(OCTOPUS_DEPLOY_SERVER)\n\t\t.SetApiKey(OCTOPACK_PUBLISH_APIKEY)\n\t\t.SetProject(OCTOPUS_PROJECT_NAME)\n\t\t.SetEnableServiceMessages(true)\n\t\t.SetDefaultPackageVersion(GitVersion.NuGetVersionV2)\n\t\t.SetVersion($\u0022{GitVersion.NuGetVersionV2}.i\u0022) //auto increment the release version number to allow TC to create duplicate code releases #extreme_edge_case\n\t\t.SetReleaseNotes(\u0022\u0022) //TODO: grab the commit comments\n\t\t);\n\t});\n}\n"
  },
  {
    "Id": 225911778,
    "FirstIndexed": "2020-04-25T15:47:03.6112028+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628177+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432261+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893807+02:00",
    "Name": "Revit_mprTools",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprTools",
    "Description": "A collection of small auxiliary plugins",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprTools/blob/master/build/Build.cs",
    "BuildFileSize": 2617,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226181438,
    "FirstIndexed": "2020-04-25T15:47:03.6108712+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628194+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432272+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938082+02:00",
    "Name": "Revit_mprNestedFamilyParamsTransfer",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprNestedFamilyParamsTransfer",
    "Description": "Plugin allows you to simplify the work of establishing a associating between the parameters of nested families with the parameters of the parent family",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprNestedFamilyParamsTransfer/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226297327,
    "FirstIndexed": "2020-04-25T15:47:03.6113217+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630391+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432284+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938087+02:00",
    "Name": "fplbot",
    "Owner": "fplbot",
    "HtmlUrl": "https://github.com/fplbot/fplbot",
    "Description": "\uD83E\uDD16Slackbot for Fantasy Premier League",
    "Archived": false,
    "Stars": 1,
    "Watchers": 4,
    "BuildFilePath": "build/TheNukeBuild.cs",
    "BuildFileUrl": "https://github.com/fplbot/fplbot/blob/master/build/TheNukeBuild.cs",
    "BuildFileSize": 6690,
    "BuildFileContent": "using System;\nusing Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Docker;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Docker.DockerTasks;\n\n\nnamespace FplBot.Build\n{\n    [CheckBuildProjectConfigurations]\n    [UnsetVisualStudioEnvironmentVariables]\n    // [GitHubActions(\u0022CI\u0022, \n    //     GitHubActionsImage.Ubuntu1604, \n    //     GitHubActionsImage.WindowsLatest, \n    //     On = new[]\n    //     {\n    //         GitHubActionsTrigger.Push,\n    //     },\n    //     OnPushBranches = new []{ \u0022master\u0022 },\n    //     InvokedTargets = new []{nameof(Pack), nameof(BuildDockerImage)} ,\n    //     ImportSecrets = new []\n    //     {\n    //         \u0022fpl__login\u0022, // needed for integration tests\n    //         \u0022fpl__password\u0022, // needed for integration tests\n    //     })]\n    // [GitHubActions(\u0022Release\u0022, \n    //     GitHubActionsImage.Ubuntu1604, \n    //     On = new[]\n    //     {\n    //         GitHubActionsTrigger.Push,\n    //     },\n    //     OnPushBranches = new []{ \u0022master\u0022 },\n    //     InvokedTargets = new []{ nameof(PushDockerImage) },\n    //     ImportSecrets = new []\n    //     {\n    //         \u0022fpl__login\u0022, // needed for integration tests\n    //         \u0022fpl__password\u0022, // needed for integration tests\n    //         \u0022DockerHub_Username\u0022,\n    //         \u0022DockerHub_Password\u0022\n    //     })]\n    class TheNukeBuild : NukeBuild\n    {\n        /// Support plugins are available for:\n        ///   - JetBrains ReSharper        https://nuke.build/resharper\n        ///   - JetBrains Rider            https://nuke.build/rider\n        ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n        ///   - Microsoft VSCode           https://nuke.build/vscode\n\n        public static int Main () =\u003E Execute\u003CTheNukeBuild\u003E(x =\u003E x.PackFplClient);\n\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n        readonly Configuration Configuration = Configuration.Debug;\n\n        [Solution] readonly Solution Solution;\n        [GitRepository] readonly GitRepository GitRepository;\n\n        AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n        AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022releases\u0022;\n\n        Target Clean =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                EnsureCleanDirectory(OutputDirectory);\n            });\n\n        Target Restore =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Executes(() =\u003E\n            {\n                DotNetRestore(_ =\u003E _\n                    .SetProjectFile(Solution));\n            });\n\n        Target Build =\u003E _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n            {\n                DotNetBuild(_ =\u003E _\n                    .SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore());\n            });\n        \n        Target Test =\u003E _ =\u003E _\n            .DependsOn(Build)\n            .Executes(() =\u003E\n            {\n                DotNetTest(_ =\u003E _\n                    .SetProjectFile(Solution.GetProject(\u0022FplBot.Tests\u0022))\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore()\n                    .EnableNoBuild());\n            });\n\n        string FplClient = \u0022Fpl.Client\u0022;\n        string FplClientVersion = \u00220.3.4\u0022;\n        \n        string FplBotSlackExtension = \u0022Slackbot.Net.Extensions.FplBot\u0022;\n        string FplBotSlackExtensionVersion = \u00220.4.0-preview001\u0022;\n        \n        Target PackFplClient =\u003E _ =\u003E _\n            .DependsOn(Test)\n            .Executes(() =\u003E\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject(Solution.GetProject(FplClient))\n                    .SetConfiguration(Configuration)\n                    .SetVersion(FplClientVersion)\n                    .SetOutputDirectory(OutputDirectory)\n                    .EnableNoRestore()\n                    .EnableNoBuild());\n            });\n        \n        Target PackExtension =\u003E _ =\u003E _\n            .DependsOn(Test)\n            .Executes(() =\u003E\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject($\u0022{SourceDirectory}/{FplBotSlackExtension}/{FplBotSlackExtension}.Release.csproj\u0022)\n                    .SetConfiguration(Configuration)\n                    .SetVersion(FplBotSlackExtensionVersion)\n                    .SetOutputDirectory(OutputDirectory));\n            });\n\n        Target PublishFplClient =\u003E _ =\u003E _\n            .DependsOn(PackFplClient)\n            .Executes(() =\u003E\n            {\n                DotNetNuGetPush(_ =\u003E _\n                    .SetTargetPath($\u0022{OutputDirectory}/{FplClient}.{FplClientVersion}.nupkg\u0022)\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                    .SetApiKey(Environment.GetEnvironmentVariable(\u0022NUGET_API_KEY\u0022)));\n            });\n        \n        Target PublishSlackbotExtension =\u003E _ =\u003E _\n            .DependsOn(PackExtension)\n            .Executes(() =\u003E\n            {\n                DotNetNuGetPush(_ =\u003E _\n                    .SetTargetPath($\u0022{OutputDirectory}/{FplBotSlackExtension}.{FplBotSlackExtensionVersion}.nupkg\u0022)\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                    .SetApiKey(Environment.GetEnvironmentVariable(\u0022NUGET_API_KEY\u0022)));\n            });\n        \n        Target BuildDockerImage =\u003E _ =\u003E _\n            .DependsOn(Test)\n            .Executes(() =\u003E\n            {\n                DockerBuild(_ =\u003E _\n                    .SetWorkingDirectory(Solution.Directory)\n                    .SetTag(\u0022fplbot/fplbot:latest\u0022)\n                    .SetPath(\u0022.\u0022)\n                );\n            });\n        \n        Target PushDockerImage =\u003E _ =\u003E _\n            .DependsOn(BuildDockerImage)\n            .Executes(() =\u003E\n            {\n                \n                var username = Environment.GetEnvironmentVariable(\u0022DockerHub_Username\u0022);\n                var password = Environment.GetEnvironmentVariable(\u0022DockerHub_Password\u0022);\n                \n                DockerLogin(_ =\u003E _\n                    .SetArgumentConfigurator(_ =\u003E {\n                        _.Add(\u0022-u {value}\u0022, username);\n                        _.Add(\u0022-p {value}\u0022, password, secret:true);\n                        return _;\n                    }));\n                DockerPush(_ =\u003E _.SetName(\u0022fplbot/fplbot:latest\u0022));\n            });\n    }\n}\n"
  },
  {
    "Id": 226484264,
    "FirstIndexed": "2020-04-25T15:47:03.6111198+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630083+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432289+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938099+02:00",
    "Name": "Timerek",
    "Owner": "pkudrel",
    "HtmlUrl": "https://github.com/pkudrel/Timerek",
    "Description": "A Windows application for hibernation or system shutdown after period of time",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/pkudrel/Timerek/blob/master/build/Build.cs",
    "BuildFileSize": 1987,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 226526557,
    "FirstIndexed": "2020-04-25T15:47:03.6113195+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630829+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432301+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893811+02:00",
    "Name": "Container.Deployed.Test",
    "Owner": "chivandikwa",
    "HtmlUrl": "https://github.com/chivandikwa/Container.Deployed.Test",
    "Description": "This is a ASP.NET Core test project for pipeline to build docker container via Jenkins, load to registry and then deploy via Rancher. This sample will also use EnvKey to manage secrets.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/chivandikwa/Container.Deployed.Test/blob/master/build/Build.cs",
    "BuildFileSize": 3107,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Docker;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nusing static Nuke.Docker.DockerBuildSettings;\nusing static Nuke.Docker.DockerTasks;\nusing LogLevel = Nuke.Common.LogLevel;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PullRequestDockerFile =\u003E RootDirectory / \u0022Dockerfile.pullrequest\u0022;\n    AbsolutePath ReleaseDockerFile =\u003E RootDirectory / \u0022Container.Deployed.Test/Dockerfile\u0022;\n    AbsolutePath ReleaseProjectDirectory =\u003E RootDirectory / \u0022Container.Deployed.Test\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target PullRequest =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Logger.Log(LogLevel.Warning, \u0022Creating Docker Image...\u0022);\n\n            DockerBuild(s =\u003E s\n                .AddLabel(\u0022pull-request\u0022)\n                .AddTag(\u0022pull-request\u0022)\n                .SetFile(PullRequestDockerFile)\n                .SetForceRm(true)\n                .SetPath(RootDirectory)\n            );\n        });\n\n    Target Release =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Logger.Log(LogLevel.Warning, \u0022Creating Docker Image...\u0022);\n\n            DockerBuild(s =\u003E s\n                .AddLabel(\u0022release\u0022)\n                .AddTag(\u0022localhost:5000/release\u0022)\n                .SetFile(ReleaseDockerFile)\n                .SetForceRm(true)\n                .SetPath(ReleaseProjectDirectory)\n            );\n\n            DockerPush(settings =\u003E settings.SetName(\u0022localhost:5000/release\u0022));\n        });\n\n}\n"
  },
  {
    "Id": 226544124,
    "FirstIndexed": "2020-04-25T15:50:44.7350936+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628456+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433273+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939043+02:00",
    "Name": "AutoCAD_mpPrToTable",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpPrToTable",
    "Description": "Plugin allows you to fill the specification table with the selected ModPlus products",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpPrToTable/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226554251,
    "FirstIndexed": "2020-04-25T15:47:03.6109377+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628609+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432312+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938121+02:00",
    "Name": "AutoCAD_mpHandDim",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpHandDim",
    "Description": "Color highlight, restore or delete dimensions with an override value",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpHandDim/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226721771,
    "FirstIndexed": "2020-04-25T15:47:03.6109355+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628598+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432323+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938133+02:00",
    "Name": "AutoCAD_mpDbViewer",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDbViewer",
    "Description": "Plugin for viewing the normative base",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDbViewer/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226723109,
    "FirstIndexed": "2020-04-25T15:47:03.6109309+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628564+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432329+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938144+02:00",
    "Name": "AutoCAD_mpRemoveAnnotScale",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpRemoveAnnotScale",
    "Description": "Clears the list of annotative scales in the selected annotative objects, leaving the current scale",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpRemoveAnnotScale/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226929509,
    "FirstIndexed": "2020-04-25T15:47:03.6109264+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628484+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843234+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938156+02:00",
    "Name": "AutoCAD_mpDrawOrderByLayer",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDrawOrderByLayer",
    "Description": "Plugin serves to change the draworder according to the layers",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDrawOrderByLayer/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226932157,
    "FirstIndexed": "2020-04-25T15:47:03.6109713+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629184+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432352+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938167+02:00",
    "Name": "AutoCAD_mpDocTemplates",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDocTemplates",
    "Description": "Plugin allows you to create templates of the text part of the section according to \u0022Resolution of the Russian Federation No.87\u0022 with the title page according to GOST R 21.1101-2013",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpDocTemplates/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 226949505,
    "FirstIndexed": "2020-04-25T15:47:03.6113126+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630743+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432363+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938178+02:00",
    "Name": "NukeBuildIssueWithCore31",
    "Owner": "JoshClose",
    "HtmlUrl": "https://github.com/JoshClose/NukeBuildIssueWithCore31",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/JoshClose/NukeBuildIssueWithCore31/blob/master/build/Build.cs",
    "BuildFileSize": 3299,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    //[GitRepository] readonly GitRepository GitRepository;\n    //[GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                //.SetAssemblyVersion(GitVersion.AssemblySemVer)\n                //.SetFileVersion(GitVersion.AssemblySemFileVer)\n                //.SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Restore)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Produces(OutputDirectory)\n        .Executes(() =\u003E\n        {\n            var projects = new[] { Solution.GetProject(\u0022AspNetCoreMvc31ReactRedux\u0022) };\n\n            DotNetPublish(_ =\u003E _\n                .SetConfiguration(Configuration)\n                //.SetAssemblyVersion(GitVersion.AssemblySemVer)\n                //.SetFileVersion(GitVersion.AssemblySemFileVer)\n                //.SetInformationalVersion(GitVersion.InformationalVersion)\n                .CombineWith(\n                    from project in projects\n                    from framework in project.GetTargetFrameworks()\n                    from runtime in new[] { \u0022ubuntu.18.04-x64\u0022 }\n                    select new { project, framework, runtime }, (cs, v) =\u003E cs\n                        .SetOutput(OutputDirectory / v.project.Name)\n                        .SetProject(v.project)\n                        .SetFramework(v.framework)\n                        .SetRuntime(v.runtime)\n                )\n            );\n        });\n\n}\n"
  },
  {
    "Id": 227035868,
    "FirstIndexed": "2020-04-25T15:47:03.6112813+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629714+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432375+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893819+02:00",
    "Name": "Revit_zfiFamilyRenameTool",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_zfiFamilyRenameTool",
    "Description": "Batch renaming of parameter names, type names, parameter values \u200B\u200Bin the specified families",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_zfiFamilyRenameTool/blob/master/build/Build.cs",
    "BuildFileSize": 2589,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Normal($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 227277132,
    "FirstIndexed": "2020-04-25T15:47:03.6113075+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624161+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432386+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938195+02:00",
    "Name": "ObservR",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/ObservR",
    "Description": "An observable MeditR port",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/ObservR/blob/master/.build/Build.cs",
    "BuildFileSize": 936,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;using static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : DotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _.DependsOn(DotNetCore);\n}\n"
  },
  {
    "Id": 227393314,
    "FirstIndexed": "2020-04-25T15:47:03.6112905+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162993+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432392+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938207+02:00",
    "Name": "Eventfully",
    "Owner": "cfrenzel",
    "HtmlUrl": "https://github.com/cfrenzel/Eventfully",
    "Description": "Lightweight Reliable Messaging Framework using Outbox Pattern / EFCore / AzureServiceBus",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/cfrenzel/Eventfully/blob/master/build/Build.cs",
    "BuildFileSize": 8166,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    [Parameter] string NugetApiUrl = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] string NugetApiKey;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath AnalyzerDirectory =\u003E RootDirectory / \u0022analyzers\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath NugetDirectory =\u003E ArtifactsDirectory / \u0022nuget\u0022;\n    \n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            AnalyzerDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n\n\n    Target Pack =\u003E _ =\u003E _\n        //.DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            int commitNum = 0;\n            string NuGetVersionCustom = GitVersion.NuGetVersionV2;\n\n            //if it\u0027s not a tagged release - append the commit number to the package version\n            //tagged commits on master have versions\n            // - v0.3.0-beta\n            //other commits have\n            // - v0.3.0-beta1\n\n            if (Int32.TryParse(GitVersion.CommitsSinceVersionSource, out commitNum))\n                NuGetVersionCustom = commitNum \u003E 0 ? NuGetVersionCustom \u002B $\u0022{commitNum}\u0022 : NuGetVersionCustom;\n\n            DotNetPack(s =\u003E s\n               .SetProject(Solution.GetProject(\u0022Eventfully.Core.Analyzers\u0022))\n               .SetConfiguration(Configuration)\n               .EnableNoBuild()\n               .EnableNoRestore()\n               .SetVersion(NuGetVersionCustom)\n               .SetDescription(\u0022Lightweight Reliable Messaging Framework with Outbox\u0022)\n               .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice\u0022)\n               .SetNoDependencies(true)\n               .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022Eventfully.Core\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(NuGetVersionCustom)\n                .SetDescription(\u0022Lightweight Reliable Messaging Framework with Outbox\u0022)\n                .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice\u0022)\n                .SetNoDependencies(true)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022Eventfully.Extensions.Microsoft.DependencyInjection\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(NuGetVersionCustom)\n                .SetDescription(\u0022Lightweight Reliable Messaging Framework with Outbox\u0022)\n                .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice\u0022)\n                .SetNoDependencies(true)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n          \n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022Eventfully.EFCoreOutbox\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(NuGetVersionCustom)\n                .SetDescription(\u0022EFcore based Outbox for Eventfully\u0022)\n                .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice outbox\u0022)\n                .SetNoDependencies(true)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022Eventfully.Transports.AzureServiceBus\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(NuGetVersionCustom)\n                .SetDescription(\u0022AzureServiceBus Transport for Eventfully\u0022)\n                .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice\u0022)\n                .SetNoDependencies(true)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022Eventfully.AzureKeyVault\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(NuGetVersionCustom)\n                .SetDescription(\u0022AzureKeyVault KeyProvider for Messaging\u0022)\n                .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice azurekeyvault\u0022)\n                .SetNoDependencies(true)\n                .SetOutputDirectory(NugetDirectory));\n\n            DotNetPack(s =\u003E s\n               .SetProject(Solution.GetProject(\u0022Eventfully.Semaphore.SqlServer\u0022))\n               .SetConfiguration(Configuration)\n               .EnableNoBuild()\n               .EnableNoRestore()\n               .SetVersion(NuGetVersionCustom)\n               .SetDescription(\u0022Simple client managed shared access control with timeout using sql server table row and optimistic concurrency\u0022)\n               .SetPackageTags(\u0022messaging servicebus cqrs distributed azureservicebus efcore ddd microservice azurekeyvault\u0022)\n               .SetNoDependencies(true)\n               .SetOutputDirectory(NugetDirectory));\n        });\n\n\n    Target Push =\u003E _ =\u003E _\n       //.DependsOn(Pack)\n       .Requires(() =\u003E NugetApiUrl)\n       .Requires(() =\u003E NugetApiKey)\n       .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n       .Executes(() =\u003E\n       {\n           GlobFiles(NugetDirectory, \u0022*.nupkg\u0022)\n               .NotEmpty()\n               .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n               .ForEach(x =\u003E\n               {\n                   DotNetNuGetPush(s =\u003E s\n                       .SetTargetPath(x)\n                       .SetSource(NugetApiUrl)\n                       .SetApiKey(NugetApiKey)\n                   );\n               });\n       });\n}\n"
  },
  {
    "Id": 227457400,
    "FirstIndexed": "2020-04-25T15:47:03.6109235+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628467+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432403+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938218+02:00",
    "Name": "AutoCAD_mpPrPosition",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpPrPosition",
    "Description": "Plugin adds/removes a position to the selected products and allows position marking of the item",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpPrPosition/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 227523731,
    "FirstIndexed": "2020-04-25T15:47:03.6109212+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628444+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432414+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938229+02:00",
    "Name": "AutoCAD_mpBlkReplace",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpBlkReplace",
    "Description": "Plugin allows quick replacement of blocks in the drawing with a sample block",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpBlkReplace/blob/master/build/Build.cs",
    "BuildFileSize": 2593,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 227527529,
    "FirstIndexed": "2020-04-25T15:47:03.6108786+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628257+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432426+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938241+02:00",
    "Name": "Revit_ostViewIn3D",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_ostViewIn3D",
    "Description": "Cuts the selected elements in the view cube, with the possibility of specifying the size of the view cube",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_ostViewIn3D/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 228399605,
    "FirstIndexed": "2020-04-25T15:47:03.610874+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628234+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432437+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938252+02:00",
    "Name": "Revit_mmRebarSolidAndVisible",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mmRebarSolidAndVisible",
    "Description": "Change the state of the visibility of the rebar (view unobscured and veiw as solid)",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mmRebarSolidAndVisible/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 228537694,
    "FirstIndexed": "2020-04-25T15:47:03.6108763+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628245+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432443+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938264+02:00",
    "Name": "Revit_whshScheduleLookup",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_whshScheduleLookup",
    "Description": "Search for schedules in a project that contain the specified value",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_whshScheduleLookup/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 229055573,
    "FirstIndexed": "2020-04-25T15:47:03.6111909+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629657+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432454+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938269+02:00",
    "Name": "Revit_mprExteriorPlanDimensions",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprExteriorPlanDimensions",
    "Description": "External dimensions on the floor plan",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprExteriorPlanDimensions/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 229253303,
    "FirstIndexed": "2020-04-25T15:47:03.6112074+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628217+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432466+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938281+02:00",
    "Name": "Revit_mprDimBias",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprDimBias",
    "Description": "Automatic movement of the dimension value that falls on the dimension lines",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprDimBias/blob/master/build/Build.cs",
    "BuildFileSize": 2617,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 229485022,
    "FirstIndexed": "2020-04-25T15:47:03.6112842+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1624104+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432477+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "snotify",
    "Owner": "MalachiAustin",
    "HtmlUrl": "https://github.com/MalachiAustin/snotify",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 229612600,
    "FirstIndexed": "2020-04-25T15:47:03.6111647+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629173+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432488+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938298+02:00",
    "Name": "Ubiety.Logging.Core",
    "Owner": "ubiety",
    "HtmlUrl": "https://github.com/ubiety/Ubiety.Logging.Core",
    "Description": "Logging interface for libraries",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ubiety/Ubiety.Logging.Core/blob/master/build/Build.cs",
    "BuildFileSize": 5342,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.DotNetSonarScanner;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.DotNetSonarScanner.DotNetSonarScannerTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly bool? Cover = true;\n    [GitRepository] readonly GitRepository GitRepository;\n    [Parameter] readonly string NuGetKey;\n\n    [GitVersion(DisableOnUnix = true)] readonly GitVersion GitVersion;\n\n    readonly string NuGetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n\n    [Parameter] readonly string SonarKey;\n    readonly string SonarProjectKey = \u0022ubiety_Ubiety.Logging.Core\u0022;\n\n    Project UbietyLoggingCoreProject =\u003E Solution.GetProject(\u0022Ubiety.Logging.Core\u0022);\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            var settings = new DotNetBuildSettings()\n                .SetProjectFile(UbietyLoggingCoreProject)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore();\n\n            DotNetBuild(settings);\n        });\n\n    Target SonarBegin =\u003E _ =\u003E _\n        .Before(Compile)\n        .Requires(() =\u003E SonarKey)\n        .Unlisted()\n        .Executes(() =\u003E\n        {\n            DotNetSonarScannerBegin(s =\u003E s\n                .SetLogin(SonarKey)\n                .SetProjectKey(SonarProjectKey)\n                .SetOrganization(\u0022ubiety\u0022)\n                .SetServer(\u0022https://sonarcloud.io\u0022)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOpenCoverPaths(ArtifactsDirectory / \u0022coverage.opencover.xml\u0022));\n        });\n\n    Target SonarEnd =\u003E _ =\u003E _\n        .After(Test)\n        .After(Compile)\n        .DependsOn(SonarBegin)\n        .Requires(() =\u003E SonarKey)\n        .Unlisted()\n        .Executes(() =\u003E\n        {\n            DotNetSonarScannerEnd(s =\u003E s.SetLogin(SonarKey));\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetArgumentConfigurator(args =\u003E args.Add(\u0022/p:CollectCoverage={0}\u0022, Cover)\n                    .Add(\u0022/p:CoverletOutput={0}\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022opencover\u0022)\n                    .Add(\u0022/p:Exclude={0}\u0022, \u0022[xunit.*]*\u0022)));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        // .After(Test)\n        .DependsOn(Compile)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .EnableNoBuild()\n                .SetProject(UbietyLoggingCoreProject)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n\n    Target PublishNuGet =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E NuGetKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .OnlyWhenStatic(() =\u003E IsMaster())\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                    .SetApiKey(NuGetKey)\n                    .SetSource(NuGetSource)\n                    .CombineWith(\n                        ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022).NotEmpty(), (cs, v) =\u003E\n                            cs.SetTargetPath(v)),\n                5,\n                true);\n        });\n\n    Target Appveyor =\u003E _ =\u003E _\n        .DependsOn(SonarEnd, PublishNuGet);\n\n    private bool IsMaster()\n    {\n        return GitRepository.Branch?.ContainsOrdinalIgnoreCase(\u0022master\u0022) ?? false;\n    }\n\n    private bool IsDevelop()\n    {\n        return GitRepository.Branch?.ContainsOrdinalIgnoreCase(\u0022develop\u0022) ?? false;\n    }\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n}\n"
  },
  {
    "Id": 229983533,
    "FirstIndexed": "2020-04-25T15:47:03.6110356+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629628+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432494+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938309+02:00",
    "Name": "Revit_mprCADmanager",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprCADmanager",
    "Description": "Manage all imports of dwg files in the current document",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprCADmanager/blob/master/build/Build.cs",
    "BuildFileSize": 2578,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 230147050,
    "FirstIndexed": "2020-04-25T15:47:03.6112461+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630607+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432505+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938321+02:00",
    "Name": "AutoCAD_mpESKD",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpESKD",
    "Description": "A collection of plugins that creates intelligent objects for drawing up drawings according to the rules of ESKD",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpESKD/blob/master/build/Build.cs",
    "BuildFileSize": 2771,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Normal($\u0022Configuration: {configuration}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n\n}\n"
  },
  {
    "Id": 230155693,
    "FirstIndexed": "2020-04-25T15:50:44.7352443+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630647+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433381+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939157+02:00",
    "Name": "BlazorStorage",
    "Owner": "BerserkerDotNet",
    "HtmlUrl": "https://github.com/BerserkerDotNet/BlazorStorage",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BerserkerDotNet/BlazorStorage/blob/master/build/Build.cs",
    "BuildFileSize": 2201,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .EnableIncludeSymbols()\n                .EnableIncludeSource()\n                .SetOutputDirectory(ArtifactsDirectory));\n        });\n}\n"
  },
  {
    "Id": 230487754,
    "FirstIndexed": "2020-04-25T15:50:44.736002+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630618+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843469+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940408+02:00",
    "Name": "GamePleasureModelling",
    "Owner": "tmorgner",
    "HtmlUrl": "https://github.com/tmorgner/GamePleasureModelling",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "CsvHelper/build/Build.cs",
    "BuildFileUrl": "https://github.com/tmorgner/GamePleasureModelling/blob/master/CsvHelper/build/Build.cs",
    "BuildFileSize": 4540,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022NuGet server URL.\u0022)] readonly string NugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter(\u0022API Key for the NuGet server.\u0022)] readonly string NugetApiKey;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\t\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Project CsvHelperProject =\u003E Solution.GetProject(\u0022CsvHelper\u0022);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n\t\t\t);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .EnableNoRestore()\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t);\n\n            DotNetPublish(s =\u003E s\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\n\t\t\t\t.CombineWith(\n\t\t\t\t\tfrom project in new[] { CsvHelperProject }\n\t\t\t\t\tfrom framework in project.GetTargetFrameworks()\n                    select new { project, framework }, (cs, v) =\u003E cs\n\t\t\t\t\t\t.SetProject(v.project)\n\t\t\t\t\t\t.SetFramework(v.framework)\n\t\t\t\t)\n\t\t\t);\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .EnableNoBuild()\n            );\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean, Test)\n\t\t.Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .EnableNoRestore()\n                .EnableNoBuild()\n\t\t\t\t.SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2)\n\t\t\t\t.SetIncludeSymbols(true)\n\t\t\t\t.SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n            );\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n\t\t\t\t.SetSource(NugetSource)\n\t\t\t\t.SetApiKey(NugetApiKey)\n\t\t\t\t.CombineWith(ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022), (s, v) =\u003E s\n\t\t\t\t\t.SetTargetPath(v)\n\t\t\t\t)\n            );\n        });\n}\n"
  },
  {
    "Id": 230723487,
    "FirstIndexed": "2020-04-25T15:50:44.735729+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162779+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434514+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940232+02:00",
    "Name": "GameSystem",
    "Owner": "KonH",
    "HtmlUrl": "https://github.com/KonH/GameSystem",
    "Description": "Shared codebase for game projects to speed up prototyping \u0026 development process",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "BuildPipeline/Build.cs",
    "BuildFileUrl": "https://github.com/KonH/GameSystem/blob/master/BuildPipeline/Build.cs",
    "BuildFileSize": 7039,
    "BuildFileContent": "using System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nnamespace BuildPipeline {\n\t[UnsetVisualStudioEnvironmentVariables]\n\tclass Build : NukeBuild {\n\t\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.TestCommonDotNet);\n\n\t\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n\t\tpublic readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n\t\t[Parameter(\u0022Project to work with\u0022)] public readonly string TargetProject;\n\n\t\t[Parameter(\u0022Project to test\u0022)] public readonly string TestProject;\n\n\t\t[Parameter(\u0022Optional runtime to publish\u0022)]\n\t\tpublic readonly string TargetRuntime;\n\n\t\t[Parameter(\u0022Self-contained for publish\u0022)]\n\t\tpublic readonly bool? SelfContained;\n\n\t\t[Parameter(\u0022Path to Pi deploy directory on local machine\u0022)]\n\t\tpublic readonly string LocalPiHome;\n\n\t\t[Parameter(\u0022Service to work with\u0022)] public readonly string ServiceName;\n\n\t\t[Parameter(\u0022Ssh host for service management\u0022)]\n\t\tpublic readonly string SshHost;\n\n\t\t[Parameter(\u0022Ssh user for service management\u0022)]\n\t\tpublic readonly string SshUserName;\n\n\t\t[Parameter(\u0022Ssh password for service management\u0022)]\n\t\tpublic readonly string SshPassword;\n\n\t\t[Parameter(\u0022Unity build target\u0022)] public readonly string TargetBuildTarget;\n\n\t\tTarget CleanDotNet =\u003E _ =\u003E _\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tDotNetClean(new DotNetCleanSettings()\n\t\t\t\t\t.SetProject(TargetProject)\n\t\t\t\t\t.SetConfiguration(Configuration));\n\t\t\t});\n\n\t\tTarget RestoreDotNet =\u003E _ =\u003E _\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tDotNetRestore(new DotNetRestoreSettings()\n\t\t\t\t\t.SetProjectFile(TargetProject));\n\t\t\t});\n\n\t\tTarget CompileDotNet =\u003E _ =\u003E _\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.DependsOn(CleanDotNet, RestoreDotNet)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tDotNetBuild(new DotNetBuildSettings()\n\t\t\t\t\t.SetProjectFile(TargetProject)\n\t\t\t\t\t.SetConfiguration(Configuration));\n\t\t\t});\n\n\t\tTarget TestDotNet =\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tif ( string.IsNullOrEmpty(TestProject) ) {\n\t\t\t\t\tLogger.Info(\u0022Skip: no TestProject specified\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tDotNetTest(new DotNetTestSettings()\n\t\t\t\t\t.SetProjectFile(TestProject)\n\t\t\t\t\t.SetConfiguration(Configuration));\n\t\t\t});\n\n\t\tTarget TestCommonDotNet =\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tDotNetTest(new DotNetTestSettings()\n\t\t\t\t\t.SetProjectFile(\u0022Core.Common.Tests\u0022)\n\t\t\t\t\t.SetConfiguration(Configuration));\n\t\t\t});\n\n\t\tTarget PublishDotNet =\u003E _ =\u003E _\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.DependsOn(CompileDotNet)\n\t\t\t.DependsOn(TestCommonDotNet)\n\t\t\t.DependsOn(TestDotNet)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar settings = new DotNetPublishSettings()\n\t\t\t\t\t.SetProject(TargetProject)\n\t\t\t\t\t.SetConfiguration(Configuration);\n\t\t\t\tif ( TargetRuntime != null ) {\n\t\t\t\t\tsettings = settings.SetRuntime(TargetRuntime);\n\t\t\t\t}\n\t\t\t\tif ( SelfContained.GetValueOrDefault() ) {\n\t\t\t\t\tsettings = settings.SetSelfContained(SelfContained);\n\t\t\t\t\tsettings = settings.SetArgumentConfigurator(a =\u003E a.Add(\u0022/p:PublishSingleFile=true\u0022));\n\t\t\t\t}\n\t\t\t\tDotNetPublish(settings);\n\t\t\t});\n\n\t\tTarget DeployDotNet =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Deploy build result to target Pi directory root\u0022)\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.Requires(() =\u003E LocalPiHome)\n\t\t\t.DependsOn(PublishDotNet)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar buildConfigurationDir = RootDirectory / TargetProject / \u0022bin\u0022 / Configuration;\n\t\t\t\tvar buildDir              = DeployTarget.GetBuildDir(buildConfigurationDir);\n\t\t\t\tvar targetPath            = (AbsolutePath) LocalPiHome / TargetProject;\n\t\t\t\tvar sourceDirPath         = DeployTarget.GetPublishDir(TargetRuntime, buildDir);\n\t\t\t\tCopyDirectoryRecursively(sourceDirPath, targetPath,\n\t\t\t\t\tDirectoryExistsPolicy.Merge, FileExistsPolicy.OverwriteIfNewer);\n\t\t\t});\n\n\t\tTarget StopService =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Stop related service\u0022)\n\t\t\t.Requires(() =\u003E SshHost)\n\t\t\t.Requires(() =\u003E SshUserName)\n\t\t\t.Requires(() =\u003E SshPassword)\n\t\t\t.Requires(() =\u003E ServiceName)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar context = new ServiceTarget.ExecutionContext(SshHost, SshUserName, SshPassword);\n\t\t\t\tServiceTarget.StopService(context, ServiceName);\n\t\t\t});\n\n\t\tTarget StartService =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Start related service\u0022)\n\t\t\t.Requires(() =\u003E ServiceName)\n\t\t\t.Requires(() =\u003E SshHost)\n\t\t\t.Requires(() =\u003E SshUserName)\n\t\t\t.Requires(() =\u003E SshPassword)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar context = new ServiceTarget.ExecutionContext(SshHost, SshUserName, SshPassword);\n\t\t\t\tServiceTarget.StartService(context, ServiceName);\n\t\t\t});\n\n\t\tTarget Halt =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Halt remote host\u0022)\n\t\t\t.Requires(() =\u003E SshHost)\n\t\t\t.Requires(() =\u003E SshUserName)\n\t\t\t.Requires(() =\u003E SshPassword)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar context = new ServiceTarget.ExecutionContext(SshHost, SshUserName, SshPassword);\n\t\t\t\tServiceTarget.Halt(context);\n\t\t\t});\n\n\t\tTarget Reboot =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Reboot remote host\u0022)\n\t\t\t.Requires(() =\u003E SshHost)\n\t\t\t.Requires(() =\u003E SshUserName)\n\t\t\t.Requires(() =\u003E SshPassword)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar context = new ServiceTarget.ExecutionContext(SshHost, SshUserName, SshPassword);\n\t\t\t\tServiceTarget.Reboot(context);\n\t\t\t});\n\n\t\tTarget CleanUnity =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Remove Build directory\u0022)\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.Executes(() =\u003E { DeleteDirectory(RootDirectory / TargetProject / \u0022Build\u0022); });\n\n\t\tTarget BuildUnity =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Build Unity project\u0022)\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.Requires(() =\u003E TargetBuildTarget)\n\t\t\t.DependsOn(TestDotNet)\n\t\t\t.DependsOn(CleanUnity)\n\t\t\t.Executes(() =\u003E { UnityTarget.Build(RootDirectory / TargetProject, TargetBuildTarget); });\n\n\t\tTarget DeployUnity =\u003E _ =\u003E _\n\t\t\t.Description(\u0022Deploy Unity project build to target Pi static directory\u0022)\n\t\t\t.Requires(() =\u003E TargetProject)\n\t\t\t.Requires(() =\u003E LocalPiHome)\n\t\t\t.DependsOn(BuildUnity)\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar buildDir   = RootDirectory / TargetProject / \u0022Build\u0022;\n\t\t\t\tvar targetPath = (AbsolutePath) LocalPiHome / \u0022Static\u0022 / TargetProject;\n\t\t\t\tCopyDirectoryRecursively(buildDir, targetPath,\n\t\t\t\t\tDirectoryExistsPolicy.Merge, FileExistsPolicy.OverwriteIfNewer);\n\t\t\t});\n\n\t\tTarget CreateDiagrams =\u003E _ =\u003E _\n\t\t\t.Executes(() =\u003E {\n\t\t\t\tvar sourceDirectory = RootDirectory / \u0022Content\u0022 / \u0022Graphviz\u0022;\n\t\t\t\tvar targetDirectory = RootDirectory / \u0022Content\u0022 / \u0022Png\u0022;\n\t\t\t\tvar sourceFiles = Directory.GetFiles(sourceDirectory, \u0022*.gv\u0022, SearchOption.AllDirectories);\n\t\t\t\tforeach ( var sourceFile in sourceFiles ) {\n\t\t\t\t\tvar relativePath = Path.GetRelativePath(sourceDirectory, sourceFile);\n\t\t\t\t\tLogger.Info($\u0022Process file \u0027{relativePath}\u0027\u0022);\n\t\t\t\t\tvar targetPath = Path.ChangeExtension(targetDirectory / relativePath, \u0022png\u0022);\n\t\t\t\t\tvar directoryPath = Path.GetDirectoryName(targetPath);\n\t\t\t\t\tif ( !Directory.Exists(directoryPath) ) {\n\t\t\t\t\t\tDirectory.CreateDirectory(directoryPath);\n\t\t\t\t\t}\n\t\t\t\t\tProcessTasks.StartProcess(\u0022dot\u0022, $\u0022-Tpng {sourceFile} -o \\\u0022{targetPath}\\\u0022\u0022).WaitForExit();\n\t\t\t\t}\n\t\t\t});\n\t}\n}"
  },
  {
    "Id": 230788988,
    "FirstIndexed": "2020-04-25T15:47:03.6112165+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628752+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432517+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938326+02:00",
    "Name": "AutoCAD_mpLayoutManager",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/AutoCAD_mpLayoutManager",
    "Description": "Drawing layout manager displayed in the palette",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/AutoCAD_mpLayoutManager/blob/master/build/Build.cs",
    "BuildFileSize": 2650,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n\n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n                Logger.Success($\u0022Platform: {platform}\u0022);\n                \n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022A\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022AutoCAD \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 231210694,
    "FirstIndexed": "2020-04-25T15:47:03.6108029+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1621259+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432528+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "dinkum-coin-mining-service",
    "Owner": "Stu-P",
    "HtmlUrl": "https://github.com/Stu-P/dinkum-coin-mining-service",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 231369779,
    "FirstIndexed": "2020-04-25T15:47:03.6108524+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162147+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432534+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "dinkum-coin-blockchain-api",
    "Owner": "Stu-P",
    "HtmlUrl": "https://github.com/Stu-P/dinkum-coin-blockchain-api",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 231984475,
    "FirstIndexed": "2020-04-25T15:47:03.6111602+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622807+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432545+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938338+02:00",
    "Name": "Operational.MediatR",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Operational.MediatR",
    "Description": "Some of the good parts of the dotnet stack.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Operational.MediatR/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 232233939,
    "FirstIndexed": "2020-04-25T15:50:44.7359941+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.163055+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434679+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940397+02:00",
    "Name": "NukeBuildIssue",
    "Owner": "schappel",
    "HtmlUrl": "https://github.com/schappel/NukeBuildIssue",
    "Description": null,
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "BuildProject/Build.cs",
    "BuildFileUrl": "https://github.com/schappel/NukeBuildIssue/blob/master/BuildProject/Build.cs",
    "BuildFileSize": 637,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\n\nnamespace BuildProject\n{\n    [CheckBuildProjectConfigurations]\n    [UnsetVisualStudioEnvironmentVariables]\n    [DotNetVerbosityMapping]\n    [MSBuildVerbosityMapping]\n    public class Builder : NukeBuild\n    {\n        public static int Main() =\u003E Execute\u003CBuilder\u003E(x =\u003E x.Compile);\n        \n        [Solution]\n        protected readonly Solution Solution;\n       \n        Target Compile =\u003E _ =\u003E _\n            .Executes(() =\u003E\n                {\n                    \n                });\n    }\n}"
  },
  {
    "Id": 233254924,
    "FirstIndexed": "2020-04-25T15:47:03.6111954+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629913+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432557+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938349+02:00",
    "Name": "Mjolnir.Build",
    "Owner": "t081as",
    "HtmlUrl": "https://github.com/t081as/Mjolnir.Build",
    "Description": "Common library for .NET based build systems; mirror of the official repository https://gitlab.com/tobiaskoch/Mjolnir.Build",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/t081as/Mjolnir.Build/blob/master/build/Build.cs",
    "BuildFileSize": 8468,
    "BuildFileContent": "\uFEFF// The MIT License (MIT)\n//\n// Copyright \u00A9 2017-2020 Tobias Koch\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \u201CSoftware\u201D), to deal in the Software without\n// restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\nusing System.IO;\nusing System.Linq;\nusing static Mjolnir.Build.VCS.GitVersionTasks;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.ReportGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing System.Xml.Linq;\nusing System.Globalization;\nusing System;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Parameter]\n    readonly ulong Buildnumber = 0;\n\n    [Parameter]\n    readonly string Key = string.Empty;\n\n    [Solution]\n    readonly Solution Solution;\n\n    readonly string coverageFiles = \u0022**/TestResults/*/coverage.cobertura.xml\u0022;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string shortVersion = \u00220.0.0\u0022;\n    string version = \u00220.0.0.0\u0022;\n    string semanticVersion = \u00220.0.0\u002BXXXXXXXX\u0022;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobFiles(\u0022**/TestResults/TestResults.xml\u0022).ForEach(DeleteFile);\n\n            RootDirectory.GlobFiles(\u0022**/*.nupkg\u0022).ForEach(DeleteFile);\n            RootDirectory.GlobFiles(coverageFiles).ForEach(DeleteFile);\n\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Version =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            \n            (string shortVersion, string version, string semanticVersion) = GetGitTagVersion(RootDirectory, Buildnumber);\n\n            Logger.Info($\u0022Version: {version}\u0022);\n            Logger.Info($\u0022Short Version: {shortVersion}\u0022);\n            Logger.Info($\u0022Semantic Version: {semanticVersion}\u0022);\n            Logger.Info($\u0022Buildnumber: {Buildnumber}\u0022);\n\n            if (Configuration == Configuration.Release)\n            {\n                this.shortVersion = shortVersion;\n                this.version = version;\n                this.semanticVersion = semanticVersion;\n            }\n            else\n            {\n                Logger.Info(\u0022Debug build - skipping version\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .DependsOn(Version)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersion(semanticVersion)\n                .SetAssemblyVersion(version)\n                .SetFileVersion(version)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            string loggerConfiguration = $\u0022junit;LogFilePath={OutputDirectory / \u0022TestResults\u0022 / \u0022TestResults.xml\u0022};MethodFormat=Class;FailureBodyFormat=Verbose\u0022;\n\n            if (Configuration == Configuration.Release)\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .EnableNoBuild());\n            }\n            else\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .SetDataCollector(\u0022XPlat Code Coverage\u0022));\n\n                var reportFiles = RootDirectory / coverageFiles;\n\n                if (EnvironmentInfo.IsWin)\n                {\n                    ReportGenerator(_ =\u003E _\n                        .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, null, \u0022netcoreapp3.0\u0022))\n                        .SetReports(reportFiles)\n                        .SetTargetDirectory(OutputDirectory / \u0022coverage\u0022)\n                        .SetReportTypes(ReportTypes.TextSummary, ReportTypes.Html));\n\n                    Logger.Info(File.ReadAllText(OutputDirectory / \u0022coverage\u0022 / \u0022Summary.txt\u0022));\n                }\n                else\n                {\n                    var coverageFileNames = RootDirectory.GlobFiles(coverageFiles);\n\n                    double overallLineCoverage = 0;\n\n                    foreach (var coverageFileName in coverageFileNames)\n                    {\n                        XDocument xdoc = XDocument.Load(coverageFileName);\n                        double lineCoverage = double.Parse(xdoc.Descendants(\u0022coverage\u0022).FirstOrDefault().Attribute(\u0022line-rate\u0022).Value, CultureInfo.GetCultureInfo(\u0022en-US\u0022));\n\n                        overallLineCoverage \u002B= lineCoverage;\n                    }\n\n                    Logger.Info(\u0022Summary\u0022);\n                    Logger.Info($\u0022  Line coverage: {Math.Round(overallLineCoverage * 100, 2).ToString(CultureInfo.GetCultureInfo(\u0022en-US\u0022))}%\u0022);\n                    Logger.Info(\u0022End Summary\u0022);\n                }\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var projects = new string[]\n            {\n                RootDirectory / \u0022src\u0022 / \u0022Mjolnir.Build\u0022 / \u0022Mjolnir.Build.csproj\u0022\n            };\n\n            var changeLog = GetNuGetReleaseNotes(RootDirectory / \u0022CHANGELOG.md\u0022);\n\n            foreach (var project in projects)\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .EnableNoRestore()\n                    .SetVersion(semanticVersion)\n                    .SetAssemblyVersion(version)\n                    .SetFileVersion(version)\n                    .SetIncludeSource(true)\n                    .SetIncludeSymbols(true)\n                    .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                    .SetPackageReleaseNotes(changeLog)\n                    .SetOutputDirectory(OutputDirectory));\n            }\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E Key)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var generatedPackages = OutputDirectory.GlobFiles(\u0022*.nupkg\u0022)\n                .NotEmpty()\n                .Where(p =\u003E !p.ToString().EndsWith(\u0022.symbols.nupkg\u0022));\n\n            foreach (var package in generatedPackages)\n            {\n                Logger.Info($\u0022Pushing package {package}\u0022);\n\n                DotNetNuGetPush(_ =\u003E _\n                    .SetTargetPath(package)\n                    .SetApiKey(Key)\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022));\n            }\n        });\n}"
  },
  {
    "Id": 233255352,
    "FirstIndexed": "2020-04-25T15:50:44.7352239+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629952+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843337+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939145+02:00",
    "Name": "Mjolnir.UI",
    "Owner": "t081as",
    "HtmlUrl": "https://github.com/t081as/Mjolnir.UI",
    "Description": "Common library for .NET Windows Forms and Windows Presentation Foundation applications; mirror of the official repository https://gitlab.com/tobiaskoch/Mjolnir.UI",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/t081as/Mjolnir.UI/blob/master/build/Build.cs",
    "BuildFileSize": 8555,
    "BuildFileContent": "\uFEFF// The MIT License (MIT)\n//\n// Copyright \u00A9 2017-2020 Tobias Koch\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \u201CSoftware\u201D), to deal in the Software without\n// restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\nusing System.IO;\nusing System.Linq;\nusing static Mjolnir.Build.VCS.GitVersionTasks;\nusing Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.ReportGenerator;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\nusing System.Xml.Linq;\nusing System;\nusing System.Globalization;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Parameter]\n    readonly ulong Buildnumber = 0;\n\n    [Parameter]\n    readonly string Key = string.Empty;\n\n    [Solution]\n    readonly Solution Solution;\n\n    readonly string coverageFiles = \u0022**/TestResults/*/coverage.cobertura.xml\u0022;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    string shortVersion = \u00220.0.0\u0022;\n    string version = \u00220.0.0.0\u0022;\n    string semanticVersion = \u00220.0.0\u002BXXXXXXXX\u0022;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobFiles(\u0022**/TestResults/TestResults.xml\u0022).ForEach(DeleteFile);\n\n            RootDirectory.GlobFiles(\u0022**/*.nupkg\u0022).ForEach(DeleteFile);\n            RootDirectory.GlobFiles(coverageFiles).ForEach(DeleteFile);\n\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Version =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            \n            (string shortVersion, string version, string semanticVersion) = GetGitTagVersion(RootDirectory, Buildnumber);\n\n            Logger.Info($\u0022Version: {version}\u0022);\n            Logger.Info($\u0022Short Version: {shortVersion}\u0022);\n            Logger.Info($\u0022Semantic Version: {semanticVersion}\u0022);\n            Logger.Info($\u0022Buildnumber: {Buildnumber}\u0022);\n\n            if (Configuration == Configuration.Release)\n            {\n                this.shortVersion = shortVersion;\n                this.version = version;\n                this.semanticVersion = semanticVersion;\n            }\n            else\n            {\n                Logger.Info(\u0022Debug build - skipping version\u0022);\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .DependsOn(Version)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetVersion(semanticVersion)\n                .SetAssemblyVersion(version)\n                .SetFileVersion(version)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            string loggerConfiguration = $\u0022junit;LogFilePath={OutputDirectory / \u0022TestResults\u0022 / \u0022TestResults.xml\u0022};MethodFormat=Class;FailureBodyFormat=Verbose\u0022;\n\n            if (Configuration == Configuration.Release)\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .EnableNoBuild());\n            }\n            else\n            {\n                DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .SetLogger(loggerConfiguration)\n                .SetDataCollector(\u0022XPlat Code Coverage\u0022));\n\n                var reportFiles = RootDirectory / coverageFiles;\n\n                if (EnvironmentInfo.IsWin)\n                {\n                    ReportGenerator(_ =\u003E _\n                        .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, null, \u0022netcoreapp3.0\u0022))\n                        .SetReports(reportFiles)\n                        .SetTargetDirectory(OutputDirectory / \u0022coverage\u0022)\n                        .SetReportTypes(ReportTypes.TextSummary, ReportTypes.Html));\n\n                    Logger.Info(File.ReadAllText(OutputDirectory / \u0022coverage\u0022 / \u0022Summary.txt\u0022));\n                }\n                else\n                {\n                    var coverageFileNames = RootDirectory.GlobFiles(coverageFiles);\n\n                    double overallLineCoverage = 0;\n\n                    foreach (var coverageFileName in coverageFileNames)\n                    {\n                        XDocument xdoc = XDocument.Load(coverageFileName);\n                        double lineCoverage = double.Parse(xdoc.Descendants(\u0022coverage\u0022).FirstOrDefault().Attribute(\u0022line-rate\u0022).Value, CultureInfo.GetCultureInfo(\u0022en-US\u0022));\n\n                        overallLineCoverage \u002B= lineCoverage;\n                    }\n\n                    Logger.Info(\u0022Summary\u0022);\n                    Logger.Info($\u0022  Line coverage: {Math.Round(overallLineCoverage * 100, 2).ToString(CultureInfo.GetCultureInfo(\u0022en-US\u0022))}%\u0022);\n                    Logger.Info(\u0022End Summary\u0022);\n                }\n            }\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var projects = new string[]\n            {\n                RootDirectory / \u0022src\u0022 / \u0022Mjolnir.Forms\u0022 / \u0022Mjolnir.Forms.csproj\u0022,\n                RootDirectory / \u0022src\u0022 / \u0022Mjolnir.Windows\u0022 / \u0022Mjolnir.Windows.csproj\u0022,\n            };\n\n            var changeLog = GetNuGetReleaseNotes(RootDirectory / \u0022CHANGELOG.md\u0022);\n\n            foreach (var project in projects)\n            {\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .EnableNoRestore()\n                    .SetVersion(semanticVersion)\n                    .SetAssemblyVersion(version)\n                    .SetFileVersion(version)\n                    .SetIncludeSource(true)\n                    .SetIncludeSymbols(true)\n                    .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                    .SetPackageReleaseNotes(changeLog)\n                    .SetOutputDirectory(OutputDirectory));\n            }\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E Key)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var generatedPackages = OutputDirectory.GlobFiles(\u0022*.nupkg\u0022)\n                .NotEmpty()\n                .Where(p =\u003E !p.ToString().EndsWith(\u0022.symbols.nupkg\u0022));\n\n            foreach (var package in generatedPackages)\n            {\n                Logger.Info($\u0022Pushing package {package}\u0022);\n\n                DotNetNuGetPush(_ =\u003E _\n                    .SetTargetPath(package)\n                    .SetApiKey(Key)\n                    .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022));\n            }\n        });\n}"
  },
  {
    "Id": 233451128,
    "FirstIndexed": "2020-04-25T15:47:03.611167+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630493+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432568+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893836+02:00",
    "Name": "BlaECharts",
    "Owner": "sebfischer83",
    "HtmlUrl": "https://github.com/sebfischer83/BlaECharts",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/sebfischer83/BlaECharts/blob/master/build/Build.cs",
    "BuildFileSize": 2711,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    AbsolutePath PackageDirectory =\u003E RootDirectory / \u0022packages\u0022;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(_ =\u003E _\n                .SetConfiguration(\u0022Release\u0022)\n                .SetNoRestore(true)\n                .SetNoBuild(true));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Publish)\n        .Produces(PackageDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution.GetProject(\u0022BlaeCharts.Library\u0022))\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackageDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n\n}\n"
  },
  {
    "Id": 233474396,
    "FirstIndexed": "2020-04-25T15:50:44.7352199+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1623609+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433359+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939134+02:00",
    "Name": "Swashbuckle.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Swashbuckle.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Swashbuckle.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 234485683,
    "FirstIndexed": "2020-04-25T15:47:03.6110333+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629617+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432579+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938372+02:00",
    "Name": "blazor-wasm-test-012020",
    "Owner": "MichaelSL",
    "HtmlUrl": "https://github.com/MichaelSL/blazor-wasm-test-012020",
    "Description": "This is a demo WASM Blazor application. You can test regular C# expressions in your browser.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/MichaelSL/blazor-wasm-test-012020/blob/master/build/Build.cs",
    "BuildFileSize": 3835,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Docker;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Private docker registry URL (with protocol)\u0022)]\n    readonly string DockerPrivateRegistry;\n    [Parameter(\u0022Private Docker registry login\u0022)]\n    readonly string DockerLogin;\n    [Parameter(\u0022Private Docker registry password\u0022)]\n    readonly string DockerPassword;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022.artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    const string ArmTag = \u0022arm\u0022;\n    const string ImageName = \u0022regex-tester\u0022;\n    string ArmFullImageName\n    {\n        get\n        {\n            var name = $\u0022{Regex.Replace(DockerPrivateRegistry, @\u0022^https?\\:\\/\\/\u0022, string.Empty)}/{ImageName}:{ArmTag}\u0022;\n            Console.WriteLine($\u0022{nameof(ArmFullImageName)} = {name}\u0022);\n            return name;\n        }\n    }\n\n    Target BuildArmDockerContainer =\u003E _ =\u003E _\n        .NotNull(DockerPrivateRegistry)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var path = Solution.GetProject(\u0022BlazorWasmRegexTest.Server\u0022).Directory;\n            Console.WriteLine($\u0022Building Docker image in {path}\u0022);\n            DockerTasks.DockerBuild(c =\u003E c\n                .SetPath(Solution.Directory)\n                .SetFile(path / \u0022Dockerfile-Arm\u0022)\n                .SetTag(ArmFullImageName));\n        });\n\n    Target LoginToDockerRegistry =\u003E _ =\u003E _\n        .NotNull(DockerPrivateRegistry)\n        .NotNull(DockerPassword)\n        .NotNull(DockerLogin)\n        .Executes(() =\u003E\n        {\n            DockerTasks.DockerLogin(c =\u003E c\n                .SetServer(DockerPrivateRegistry)\n                .SetUsername(DockerLogin)\n                .SetPassword(DockerPassword));\n        });\n\n    Target PushArmDockerContainer =\u003E _ =\u003E _\n        .DependsOn(BuildArmDockerContainer, LoginToDockerRegistry)\n        .Executes(() =\u003E\n        {\n            DockerTasks.DockerPush(c =\u003E c\n                .SetName(ArmFullImageName));\n        });\n}\n"
  },
  {
    "Id": 234780896,
    "FirstIndexed": "2020-04-25T15:47:03.6111693+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622864+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432591+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938383+02:00",
    "Name": "sync-central-versions",
    "Owner": "david-driscoll",
    "HtmlUrl": "https://github.com/david-driscoll/sync-central-versions",
    "Description": "A small tool help with synchronizing packages versions when using MSBuild Central Package Versions",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/david-driscoll/sync-central-versions/blob/master/.build/Build.cs",
    "BuildFileSize": 2212,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Rocket.Surgery.Nuke.DotNetCore;\nusing Rocket.Surgery.Nuke;\nusing Nuke.Common.Tools;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\nclass Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    Target Default =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Build)\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        .DependsOn(Install)\n        ;\n\n    public new Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public new Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public new Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public new Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n\n    public Target Install =\u003E _ =\u003E _\n        .After(Pack)\n        .OnlyWhenStatic(() =\u003E IsLocalBuild)\n        .Executes(() =\u003E\n        {\n            try\n            {\n                DotNetToolUninstall(x =\u003E x.EnableGlobal().SetPackageName(\u0022sync-central-versions\u0022)\n                    .ResetVerbosity());\n            }\n            catch { }\n\n            DotNetToolInstall(x =\u003E\n                x.EnableGlobal().SetVersion(GitVersion.SemVer).AddSources(NuGetPackageDirectory)\n                    .SetPackageName(\u0022sync-central-versions\u0022));\n        });\n}\n"
  },
  {
    "Id": 235060698,
    "FirstIndexed": "2020-04-25T15:47:03.6108296+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627972+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432596+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938394+02:00",
    "Name": "cast-form",
    "Owner": "lillo42",
    "HtmlUrl": "https://github.com/lillo42/cast-form",
    "Description": "Object-Object mapper",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/lillo42/cast-form/blob/master/build/Build.cs",
    "BuildFileSize": 6240,
    "BuildFileContent": "using System.Collections.Generic;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\n[ShutdownDotNetBuildServerOnFinish]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Nuget API key\u0022, Name = \u0022api-key\u0022)] readonly string ApiKey;\n\n    [Parameter(\u0022NuGet Source for Packages\u0022, Name = \u0022nuget-source\u0022)]\n    readonly string NugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion(NoFetch = true)] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    \n    AbsolutePath PackageDirectory =\u003E ArtifactsDirectory / \u0022packages\u0022;\n    \n    AbsolutePath TestResultDirectory =\u003E ArtifactsDirectory / \u0022test-results\u0022;\n    \n    string CoverageReportDirectory =\u003E ArtifactsDirectory / \u0022coverage-report\u0022;\n    string CoverageReportArchive =\u003E ArtifactsDirectory / \u0022coverage-report.zip\u0022;\n    \n    IEnumerable\u003CProject\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Test\u0022);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetClean(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration));\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n    \n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Produces(TestResultDirectory / \u0022*.xml\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetResultsDirectory(TestResultDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .When(InvokedTargets.Contains(Coverage) || IsServerBuild, _ =\u003E _\n                    .EnableCollectCoverage()\n                    .SetCoverletOutputFormat(CoverletOutputFormat.opencover)\n                    .When(IsServerBuild, _ =\u003E _.EnableUseSourceLink()))\n                .CombineWith(TestProjects, (_, v) =\u003E _\n                    .SetProjectFile(v)\n                    .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\n                    .SetCoverletOutput(TestResultDirectory / $\u0022{v.Name}.xml\u0022)));\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .TriggeredBy(Test)\n        .Consumes(Test)\n        .Produces(CoverageReportArchive)\n        .Executes(() =\u003E\n        {\n            if (InvokedTargets.Contains(Coverage) || IsServerBuild)\n            {\n                ReportGenerator(_ =\u003E _\n                    .SetReports(TestResultDirectory / \u0022*.xml\u0022)\n                    .SetReportTypes(ReportTypes.HtmlInline)\n                    .SetTargetDirectory(CoverageReportDirectory)\n                    .SetFramework(\u0022netcoreapp2.1\u0022));\n\n                CompressZip(\n                    directory: CoverageReportDirectory,\n                    archiveFile: CoverageReportArchive,\n                    fileMode: FileMode.Create);\n            }\n        });\n\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(PackageDirectory / \u0022*.nupkg\u0022)\n        .Produces(PackageDirectory / \u0022*.snupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackageDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .EnableIncludeSource()\n                .EnableIncludeSymbols()\n                .EnableNoRestore());\n        });\n    \n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Test, Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                .SetApiKey(ApiKey)\n                .SetSkipDuplicate(true)\n                .SetSource(NugetSource));\n        });\n\n}\n"
  },
  {
    "Id": 235360051,
    "FirstIndexed": "2020-04-25T15:47:03.6109138+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627955+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432608+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938406+02:00",
    "Name": "DesignPatterns",
    "Owner": "DmitryMorozov228",
    "HtmlUrl": "https://github.com/DmitryMorozov228/DesignPatterns",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/DmitryMorozov228/DesignPatterns/blob/master/build/Build.cs",
    "BuildFileSize": 2998,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.GitVersion.GitVersionTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.LocalBuild);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n    BuildMetadata Metadata;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath NuGetPackagesDirectory =\u003E RootDirectory / \u0022packages\u0022;\n    \n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n            EnsureCleanDirectory(NuGetPackagesDirectory);\n            DotNetClean(o =\u003E o.SetConfiguration(Configuration)\n                .SetProject(Solution)\n            );\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(o =\u003E o.SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(o =\u003E o.SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n            );\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var version = GitVersion.SemVer;\n            NuGetTasks.NuGetPack(s =\u003E s\n                .SetTargetPath(RootDirectory / \u0022DesignPatterns.nuspec\u0022)\n                .SetVersion(version)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory));\n        });\n\n    Target CiSetBuildMetadata =\u003E _ =\u003E _\n        .Before(Package)\n        .Executes(() =\u003E\n        {\n            Metadata.SetToCi();\n        });\n\n    Target LocalBuild =\u003E _ =\u003E _.DependsOn(Package);\n    Target CiBuild =\u003E _ =\u003E _.DependsOn(CiSetBuildMetadata, Package);\n\n    protected override void OnBuildInitialized()\n    {\n        base.OnBuildInitialized();\n        var gitVersion = GitVersion(o =\u003E o.SetLogOutput(false).SetOutput(GitVersionOutput.json)).Result;\n        Metadata = new BuildMetadata(gitVersion);\n    }\n}\n"
  },
  {
    "Id": 235997881,
    "FirstIndexed": "2020-04-25T15:47:03.6111528+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622756+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432619+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938417+02:00",
    "Name": "Blazor.AzureB2C",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/Blazor.AzureB2C",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/Blazor.AzureB2C/blob/master/build/Build.cs",
    "BuildFileSize": 253,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 236027442,
    "FirstIndexed": "2020-04-25T15:50:44.7351914+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630072+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433342+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939117+02:00",
    "Name": "BunnyLand",
    "Owner": "geirsagberg",
    "HtmlUrl": "https://github.com/geirsagberg/BunnyLand",
    "Description": "Remake of classic 2D shooter Bunnyland",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/geirsagberg/BunnyLand/blob/master/build/Build.cs",
    "BuildFileSize": 3121,
    "BuildFileContent": "using System;\nusing System.IO;\nusing BunnyLand.ResourceGenerator;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    readonly string BunnyLandDesktopGLPath = \u0022BunnyLand.DesktopGL\u0022;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target GenerateResources =\u003E _ =\u003E _\n        .Executes(() =\u003E {\n            var contentPath = BunnyLandProjectRoot / \u0022Content\u0022;\n            var resourcesPath = BunnyLandProjectRoot / \u0022Resources\u0022;\n\n            void Generate(Action\u003Cstring, TextWriter\u003E write)\n            {\n                var className = write.Method.Name.Replace(\u0022Write\u0022, \u0022\u0022);\n                var destinationFile = resourcesPath / $\u0022{className}.generated.cs\u0022;\n                using var textWriter = File.CreateText(destinationFile);\n                write(contentPath, textWriter);\n            }\n\n            Generate(Generator.WriteTextures);\n            Generate(Generator.WriteSoundEffects);\n            Generate(Generator.WriteSpriteFonts);\n            Generate(Generator.WriteSongs);\n        });\n\n    Target Watch =\u003E _ =\u003E _\n        .Executes(() =\u003E {\n            DotNet(\u0022watch run\u0022, BunnyLandProjectRoot);\n        });\n\n    AbsolutePath BunnyLandProjectRoot =\u003E Solution.GetProject(BunnyLandDesktopGLPath)?.Directory;\n}\n"
  },
  {
    "Id": 236345033,
    "FirstIndexed": "2020-04-25T15:47:03.6111482+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622727+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432631+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938429+02:00",
    "Name": "FunctionAppBackend",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/FunctionAppBackend",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/FunctionAppBackend/blob/master/build/Build.cs",
    "BuildFileSize": 253,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 236717027,
    "FirstIndexed": "2020-04-25T15:47:03.61101+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629475+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432642+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938434+02:00",
    "Name": "UtilityDisposables",
    "Owner": "nloum",
    "HtmlUrl": "https://github.com/nloum/UtilityDisposables",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nloum/UtilityDisposables/blob/develop/build/Build.cs",
    "BuildFileSize": 4773,
    "BuildFileContent": "using System.Collections.Generic;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.CI.GitHubActions.Configuration;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\u0022dotnetcore\u0022,\n\tGitHubActionsImage.Ubuntu1804,\n\tImportSecrets = new[]{ \u0022NUGET_API_KEY\u0022 },\n\tAutoGenerate = true,\n\tOn = new [] { GitHubActionsTrigger.Push, GitHubActionsTrigger.PullRequest },\n\tInvokedTargets = new [] {\u0022Test\u0022, \u0022Push\u0022}\n\t)]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022NuGet server URL.\u0022)]\n\treadonly string NugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter(\u0022API Key for the NuGet server.\u0022)]\n\treadonly string NugetApiKey;\n\t[Parameter(\u0022Version to use for package.\u0022)]\n\treadonly string Version;\n\n    [Solution]\n\treadonly Solution Solution;\n    [GitRepository]\n\treadonly GitRepository GitRepository;\n    //[GitVersion]\n\t//readonly GitVersion GitVersion;\n\t\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Project UtilityDisposablesProject =\u003E Solution.GetProject(\u0022UtilityDisposables\u0022);\n    \n    IEnumerable\u003CProject\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Tests\u0022);\n    \n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n\t\t\t);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {   \n            DotNetBuild(s =\u003E s\n                .EnableNoRestore()\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(Version \u002B \u0022.0\u0022)\n                .SetFileVersion(Version)\n                .SetInformationalVersion(Version)\n\t\t\t);\n\n            DotNetPublish(s =\u003E s\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(Version \u002B \u0022.0\u0022)\n\t\t\t\t.SetFileVersion(Version)\n\t\t\t\t.SetInformationalVersion(Version)\n\t\t\t\t.CombineWith(\n\t\t\t\t\tfrom project in new[] { UtilityDisposablesProject }\n\t\t\t\t\tfrom framework in project.GetTargetFrameworks()\n                    select new { project, framework }, (cs, v) =\u003E cs\n\t\t\t\t\t\t.SetProject(v.project)\n\t\t\t\t\t\t.SetFramework(v.framework)\n\t\t\t\t)\n\t\t\t);\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n\t            .SetConfiguration(Configuration)\n\t            .EnableNoRestore()\n                .EnableNoBuild()\n\t            .CombineWith(\n\t\t            TestProjects, (cs, v) =\u003E cs\n\t\t\t            .SetProjectFile(v))\n            );\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean, Test)\n\t\t.Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .EnableNoRestore()\n                .EnableNoBuild()\n\t\t\t\t.SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(Version)\n\t\t\t\t.SetIncludeSymbols(true)\n\t\t\t\t.SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n            );\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n\t\t\t\t.SetSource(NugetSource)\n\t\t\t\t.SetApiKey(NugetApiKey)\n\t\t\t\t.SetSkipDuplicate(true)\n\t\t\t\t.CombineWith(ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022), (s, v) =\u003E s\n\t\t\t\t\t.SetTargetPath(v)\n\t\t\t\t)\n            );\n        });\n}\n"
  },
  {
    "Id": 236802897,
    "FirstIndexed": "2020-04-25T15:47:03.6111221+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630379+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432648+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938446+02:00",
    "Name": "config-server-buildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/config-server-buildpack",
    "Description": "Exposes values in config server as environmental variables on the container",
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/config-server-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 13271,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.IO.Compression;\r\nusing System.Linq;\r\nusing System.Runtime.CompilerServices;\r\nusing ICSharpCode.SharpZipLib.Zip;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing Octokit;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing FileMode = System.IO.FileMode;\r\nusing ZipFile = System.IO.Compression.ZipFile;\r\n\r\n[assembly: InternalsVisibleTo(\u0022ConfigServerBuildpackTests\u0022)]\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    [Flags]\r\n    public enum StackType\r\n    {\r\n        Windows = 1,\r\n        Linux = 2\r\n    }\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n    const string BuildpackProjectName = \u0022ConfigServerBuildpack\u0022;\r\n    string GetPackageZipName(string runtime) =\u003E $\u0022{BuildpackProjectName}-{runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n    \r\n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is both\u0022)]\r\n    readonly StackType Stack = StackType.Windows | StackType.Linux;\r\n    \r\n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\r\n    string GitHubToken;\r\n\r\n    [Parameter(\u0022Application directory against which buildpack will be applied\u0022)]\r\n    readonly string ApplicationDirectory;\r\n\r\n    IEnumerable\u003CPublishTarget\u003E PublishCombinations\r\n    {\r\n        get\r\n        {\r\n            if (Stack.HasFlag(StackType.Windows))\r\n                yield return new PublishTarget {Framework = \u0022net472\u0022, Runtime = \u0022win-x64\u0022};\r\n            if (Stack.HasFlag(StackType.Linux))\r\n                yield return new PublishTarget {Framework = \u0022netcoreapp3.0\u0022, Runtime = \u0022linux-x64\u0022};\r\n        }\r\n    }\r\n\r\n    bool IsMultipleStacks =\u003E ((Stack \u0026 (Stack - 1)) != 0);\r\n    \r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    \r\n    string[] LifecycleHooks = {\u0022detect\u0022, \u0022supply\u0022, \u0022release\u0022, \u0022finalize\u0022};\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .Description(\u0022Compiles the buildpack\u0022)\r\n        .DependsOn(Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            \r\n            Logger.Info(Stack);\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                \r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .CombineWith(PublishCombinations, (c, p) =\u003E c\r\n                    .SetFramework(p.Framework)\r\n                    .SetRuntime(p.Runtime)));\r\n        });\r\n    \r\n    Target Publish =\u003E _ =\u003E _\r\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\r\n        .DependsOn(Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var framework = publishCombination.Framework;\r\n                var runtime = publishCombination.Runtime;\r\n                var packageZipName = GetPackageZipName(runtime);\r\n                var workDirectory = TemporaryDirectory / \u0022pack\u0022;\r\n                EnsureCleanDirectory(TemporaryDirectory);\r\n                var buildpackProject = Solution.GetProject(BuildpackProjectName);\r\n                if(buildpackProject == null)\r\n                    throw new Exception($\u0022Unable to find project called {BuildpackProjectName} in solution {Solution.Name}\u0022);\r\n                var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022;\r\n                var workBinDirectory = workDirectory / \u0022bin\u0022;\r\n\r\n\r\n                DotNetPublish(s =\u003E s\r\n                    .SetProject(Solution)\r\n                    .SetConfiguration(Configuration)\r\n                    .SetFramework(framework)\r\n                    .SetRuntime(runtime)\r\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                );\r\n\r\n                var lifecycleBinaries = Solution.GetProjects(\u0022Lifecycle*\u0022)\r\n                    .Select(x =\u003E x.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022)\r\n                    .SelectMany(x =\u003E Directory.GetFiles(x).Where(path =\u003E LifecycleHooks.Any(hook =\u003E Path.GetFileName(path).StartsWith(hook))));\r\n\r\n                foreach (var lifecycleBinary in lifecycleBinaries)\r\n                {\r\n                    CopyFileToDirectory(lifecycleBinary, workBinDirectory, FileExistsPolicy.OverwriteIfNewer);\r\n                }\r\n\r\n                CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\r\n                var tempZipFile = TemporaryDirectory / packageZipName;\r\n\r\n                ZipFile.CreateFromDirectory(workDirectory, tempZipFile, CompressionLevel.NoCompression, false);\r\n                MakeFilesInZipUnixExecutable(tempZipFile);\r\n                CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\r\n                Logger.Block(ArtifactsDirectory / packageZipName);\r\n            }\r\n        });\r\n    \r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .Description(\u0022Creates a GitHub release (or amends existing) and uploads buildpack artifact\u0022)\r\n        .DependsOn(Publish)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Executes(async () =\u003E\r\n        {\r\n            foreach (var publishCombination in PublishCombinations)\r\n            {\r\n                var runtime = publishCombination.Runtime;\r\n                var packageZipName = GetPackageZipName(runtime);\r\n                if (!GitRepository.IsGitHubRepository())\r\n                    throw new Exception(\u0022Only supported when git repo remote is github\u0022);\r\n\r\n                var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\r\n                {\r\n                    Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\r\n                };\r\n                var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\r\n                var owner = gitIdParts[0];\r\n                var repoName = gitIdParts[1];\r\n\r\n                var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\r\n                Release release;\r\n                try\r\n                {\r\n                    release = await client.Repository.Release.Get(owner, repoName, releaseName);\r\n                }\r\n                catch (NotFoundException)\r\n                {\r\n                    var newRelease = new NewRelease(releaseName)\r\n                    {\r\n                        Name = releaseName,\r\n                        Draft = false,\r\n                        Prerelease = false\r\n                    };\r\n                    release = await client.Repository.Release.Create(owner, repoName, newRelease);\r\n                }\r\n\r\n                var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == packageZipName);\r\n                if (existingAsset != null)\r\n                {\r\n                    await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\r\n                }\r\n\r\n                var zipPackageLocation = ArtifactsDirectory / packageZipName;\r\n                var stream = File.OpenRead(zipPackageLocation);\r\n                var releaseAssetUpload = new ReleaseAssetUpload(packageZipName, \u0022application/zip\u0022, stream, TimeSpan.FromHours(1));\r\n                var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\r\n\r\n                Logger.Block(releaseAsset.BrowserDownloadUrl);\r\n            }\r\n        });\r\n\r\n    Target Detect =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027detect\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Requires(() =\u003E !IsMultipleStacks)\r\n        .Executes(() =\u003E\r\n        {\r\n            var framework = PublishCombinations.Single().Framework;\r\n            try\r\n            {\r\n                DotNetRun(s =\u003E s\r\n                    .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Detect\u0022).Path)\r\n                    .SetApplicationArguments(ApplicationDirectory)\r\n                    .SetConfiguration(Configuration)\r\n                    .SetFramework(framework));\r\n                Logger.Block(\u0022Detect returned \u0027true\u0027\u0022);\r\n            }\r\n            catch (ProcessException)\r\n            {\r\n                Logger.Block(\u0022Detect returned \u0027false\u0027\u0022);\r\n            }\r\n        });\r\n\r\n    Target Supply =\u003E _ =\u003E _\r\n        .Description(\u0022Invokes buildpack \u0027supply\u0027 lifecycle event\u0022)\r\n        .Requires(() =\u003E ApplicationDirectory)\r\n        .Requires(() =\u003E !IsMultipleStacks)\r\n        .Executes(() =\u003E\r\n        {\r\n            var framework = PublishCombinations.Single().Framework;\r\n            var home = (AbsolutePath)Path.GetTempPath() / Guid.NewGuid().ToString();\r\n            var app = home / \u0022app\u0022;\r\n            var deps = home / \u0022deps\u0022;\r\n            var index = 0;\r\n            var cache = home / \u0022cache\u0022;\r\n            CopyDirectoryRecursively(ApplicationDirectory, app);\r\n\r\n            DotNetRun(s =\u003E s\r\n                .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Supply\u0022).Path)\r\n                .SetApplicationArguments($\u0022{app} {cache} {app} {deps} {index}\u0022)\r\n                .SetConfiguration(Configuration)\r\n                .SetFramework(framework));\r\n            Logger.Block($\u0022Buildpack applied. Droplet is available in {home}\u0022);\r\n\r\n        });\r\n\r\n    public void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\r\n    {\r\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\r\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\r\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\r\n        {\r\n            output.SetLevel(9);\r\n            ZipEntry entry;\r\n\t\t\r\n            while ((entry = input.GetNextEntry()) != null)\r\n            {\r\n                var outEntry = new ZipEntry(entry.Name) {HostSystem = (int) HostSystemID.Unix};\r\n                var entryAttributes =  \r\n                    ZipEntryAttributes.ReadOwner | \r\n                    ZipEntryAttributes.ReadOther | \r\n                    ZipEntryAttributes.ReadGroup |\r\n                    ZipEntryAttributes.ExecuteOwner | \r\n                    ZipEntryAttributes.ExecuteOther | \r\n                    ZipEntryAttributes.ExecuteGroup;\r\n                entryAttributes = entryAttributes | (entry.IsDirectory ? ZipEntryAttributes.Directory : ZipEntryAttributes.Regular);\r\n                outEntry.ExternalFileAttributes = (int) (entryAttributes) \u003C\u003C 16; // https://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute\r\n                output.PutNextEntry(outEntry);\r\n                input.CopyTo(output);\r\n            }\r\n            output.Finish();\r\n            output.Flush();\r\n        }\r\n\r\n        DeleteFile(zipFile);\r\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\r\n    }\r\n    \r\n    [Flags]\r\n    enum ZipEntryAttributes\r\n    {\r\n        ExecuteOther = 1,\r\n        WriteOther = 2,\r\n        ReadOther = 4,\r\n\t\r\n        ExecuteGroup = 8,\r\n        WriteGroup = 16,\r\n        ReadGroup = 32,\r\n\r\n        ExecuteOwner = 64,\r\n        WriteOwner = 128,\r\n        ReadOwner = 256,\r\n\r\n        Sticky = 512, // S_ISVTX\r\n        SetGroupIdOnExecution = 1024,\r\n        SetUserIdOnExecution = 2048,\r\n\r\n        //This is the file type constant of a block-oriented device file.\r\n        NamedPipe = 4096,\r\n        CharacterSpecial = 8192,\r\n        Directory = 16384,\r\n        Block = 24576,\r\n        Regular = 32768,\r\n        SymbolicLink = 40960,\r\n        Socket = 49152\r\n\t\r\n    }\r\n    class PublishTarget\r\n    {\r\n        public string Framework { get; set; }\r\n        public string Runtime { get; set; }\r\n    }\r\n}\r\n"
  },
  {
    "Id": 237508659,
    "FirstIndexed": "2020-04-25T15:47:03.6111152+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1630055+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432659+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938457+02:00",
    "Name": "MyPonto.Client",
    "Owner": "Tieno",
    "HtmlUrl": "https://github.com/Tieno/MyPonto.Client",
    "Description": "MyPonto.Client is a C# Client for the MyPonto API",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Tieno/MyPonto.Client/blob/master/build/Build.cs",
    "BuildFileSize": 5560,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing NuGet.Common;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n     [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory = RootDirectory / \u0022MyPonto.Client\u0022;\n    AbsolutePath TestsDirectory =\u003E Solution.Directory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    String[] TestProjects\n    {\n        get { return GlobFiles(TestsDirectory / \u0022MyPonto.Tests\u0022, \u0022*.Tests.csproj\u0022).ToArray(); }\n    }\n    \n    [Parameter(\u0022NuGet Api Key\u0022,Name = \u0022NUGET_API_KEY\u0022)] readonly string NUGET_API_KEY;\n    [Parameter(\u0022NuGet Endpoint for Packages\u0022)] readonly string NUGET_ENDPOINT = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    private readonly string NugetProjectUrl = \u0022https://github.com/Tieno/MyPonto.Client\u0022;\n\n    [Parameter(\u0022MyPonto ClientId\u0022, Name = \u0022MYPONTO_CLIENTID\u0022)] readonly string MYPONTO_CLIENTID;\n    [Parameter(\u0022MyPonto ClientSecret\u0022, Name = \u0022MYPONTO_CLIENTSECRET\u0022)] readonly string MYPONTO_CLIENTSECRET;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            var test = GitVersion.AssemblySemVer;\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n\n                .EnableNoRestore());\n        });\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetProject(RootDirectory / \u0022MyPonto.Client\u0022 / \u0022MyPonto.Client.csproj\u0022)\n                .SetPackageProjectUrl(NugetProjectUrl)\n                //.SetIncludeSymbols(true)\n                .SetLogOutput(true)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                //\n            );\n\n        });\n\n    public bool CanPublishNuget()\n    {\n        Logger.Info($\u0022CanPublishNuget if on develop or master branch\u0022);\n        Logger.Info($\u0022GitRepo =\u003E {GitRepository.Branch}\u0022);\n        if (GitRepository.IsOnDevelopBranch())\n        {\n            return true;\n        }\n        if (GitRepository.IsOnMasterBranch())\n        {\n            return true;\n        }\n        switch (GitRepository.Branch)\n        {\n            case \u0022refs/heads/develop\u0022:\n            case \u0022refs/heads/master\u0022:\n                return true;\n            default:\n                return false;\n        }\n    }\n    Target Publish =\u003E _ =\u003E _\n        .OnlyWhenDynamic(() =\u003E CanPublishNuget())\n        .DependsOn(Test)\n        .DependsOn(Pack)\n        .Requires(() =\u003E NUGET_API_KEY)\n        .Requires(() =\u003E NUGET_ENDPOINT)\n        .Executes(() =\u003E\n   {\n\n\n       var packages = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022);\n       //add minor change\n       DotNetNuGetPush(_ =\u003E _\n               .SetSource(NUGET_ENDPOINT)\n               .SetApiKey(NUGET_API_KEY)\n               .SetLogOutput(true)\n               .CombineWith(\n                   packages, (_, v) =\u003E _\n                       .SetTargetPath(v)),\n           degreeOfParallelism: 5,\n           completeOnFailure: true);\n\n\n   });\n    Target Test =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E TestProjects.Length \u003E 0)\n        .DependsOn(Compile)\n        .Requires(() =\u003E MYPONTO_CLIENTID)\n        .Requires(() =\u003E MYPONTO_CLIENTSECRET)\n        .Executes(() =\u003E\n        {\n            foreach (var testProject in TestProjects)\n            {\n                DotNetTest(s =\u003E s.SetProjectFile(testProject).SetFilter(\u0022Category!=RunLocal\u0022).SetLogOutput(true)\n                    .SetListTests(true).SetVerbosity(DotNetVerbosity.Normal)\n                    \n                    .SetEnvironmentVariable(nameof(MYPONTO_CLIENTID), MYPONTO_CLIENTID)\n                    .SetEnvironmentVariable(nameof(MYPONTO_CLIENTSECRET), MYPONTO_CLIENTSECRET)\n                );\n            }\n          \n        });\n\n\n\n}\n"
  },
  {
    "Id": 237539117,
    "FirstIndexed": "2020-04-25T15:47:03.6110851+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629827+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843267+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938468+02:00",
    "Name": "Cloud.Framework",
    "Owner": "mariohines",
    "HtmlUrl": "https://github.com/mariohines/Cloud.Framework",
    "Description": "Simple solution to aid in cloud service development.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/mariohines/Cloud.Framework/blob/master/build/Build.cs",
    "BuildFileSize": 7447,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(@\u0022main\u0022, GitHubActionsImage.WindowsLatest,\n               GitHubActionsImage.Ubuntu1804,\n               GitHubActionsImage.MacOs1014,\n               AutoGenerate = true,\n               On = new[] {GitHubActionsTrigger.Push},\n               InvokedTargets = new[] {nameof(UnitTests), nameof(Pack)},\n               ImportGitHubTokenAs = nameof(GitHubToken))]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022API Key for publishing packages to GitHub Package Repository. This should be handled by the runner environment.\u0022)] \n    readonly string GitHubToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    const string Author = \u0022Mario S. Hines\u0022;\n    const string ProjectUrl = \u0022https://githumb.com/mariohines/Cloud.Framework\u0022;\n    const string CopyRight = \u0022Gigatech Software Consulting\u0022;\n    const string ChangeLogFile = \u0022ChangeLog.md\u0022;\n    const string PackagePushSource = \u0022https://nuget.pkg.github.com/mariohines/index.json\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n                        .Executes(() =\u003E\n                                  {\n                                      SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                                      TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n                                      EnsureCleanDirectory(ArtifactsDirectory);\n                                  });\n\n    Target Restore =\u003E _ =\u003E _\n                           .DependsOn(Clean)\n                           .Executes(() =\u003E\n                                     {\n                                         DotNetRestore(_ =\u003E _\n                                                           .SetProjectFile(Solution));\n                                     });\n\n    Target Compile =\u003E _ =\u003E _\n                           .DependsOn(Restore)\n                           .Executes(() =\u003E\n                                     {\n                                         DotNetBuild(_ =\u003E _\n                                                          .SetProjectFile(Solution)\n                                                          .SetConfiguration(Configuration)\n                                                          .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                                                          .SetFileVersion(GitVersion.AssemblySemFileVer)\n                                                          .SetInformationalVersion(GitVersion.InformationalVersion)\n                                                          .SetNoRestore(InvokedTargets.Contains(Restore)));\n                                     });\n\n    Target UnitTests =\u003E _ =\u003E _\n                             .DependsOn(Compile)\n                             .Executes(() =\u003E\n                                       {\n                                           DotNetTest(_ =\u003E _\n                                                           .SetWorkingDirectory(TestsDirectory)\n                                                           .SetProjectFile(Solution)\n                                                           .SetNoBuild(InvokedTargets.Contains(Compile)));\n                                       });\n\n    Target Pack =\u003E _ =\u003E _\n                        .DependsOn(Compile)\n                        .Executes(() =\u003E\n                                  {\n                                      Solution.Projects\n                                              .ForEach(project =\u003E\n                                                       {\n                                                           var currentChangeLogFile = project.Directory / ChangeLogFile;\n                                                           DotNetPack(_ =\u003E _\n                                                                           .SetConfiguration(Configuration)\n                                                                           .SetWorkingDirectory(project.Directory)\n                                                                           .SetOutputDirectory(ArtifactsDirectory)\n                                                                           .SetPackageProjectUrl(ProjectUrl)\n                                                                           .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n                                                                           .SetAuthors(Author)\n                                                                           .SetTitle(project.Name)\n                                                                           .SetCopyright(CopyRight)\n                                                                           .SetDescription(project.Name)\n                                                                           .SetPackageReleaseNotes(GetNuGetReleaseNotes(currentChangeLogFile, GitRepository))\n                                                                           .SetVersion(GitVersion.NuGetVersionV2));\n                                                       });\n                                  });\n\n    Target Push =\u003E _ =\u003E _\n                        .DependsOn(Pack)\n                        .Requires(() =\u003E GitHubToken)\n                        .Executes(() =\u003E\n                                  {\n                                      ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022)\n                                                        .NotEmpty()\n                                                        .ForEach(x =\u003E\n                                                                 {\n                                                                     DotNetNuGetPush(_ =\u003E _\n                                                                                          .SetTargetPath(x)\n                                                                                          .SetSource(PackagePushSource)\n                                                                                          .SetApiKey(GitHubToken));\n                                                                 });\n                                  });\n}"
  },
  {
    "Id": 237804426,
    "FirstIndexed": "2020-04-25T15:47:03.6111078+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629429+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432682+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893848+02:00",
    "Name": "Core",
    "Owner": "CreativeCodersTeam",
    "HtmlUrl": "https://github.com/CreativeCodersTeam/Core",
    "Description": "Core library for .Net",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/CreativeCodersTeam/Core/blob/develop/build/Build.cs",
    "BuildFileSize": 3313,
    "BuildFileContent": "using System;\nusing System.Diagnostics.CodeAnalysis;\nusing CreativeCoders.NukeBuild;\nusing CreativeCoders.NukeBuild.BuildActions;\nusing JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[SuppressMessage(\u0022ReSharper\u0022, \u0022ConvertToAutoProperty\u0022)]\nclass Build : NukeBuild, IBuildInfo\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    \n    [Parameter] string DevNuGetSource;\n    \n    [Parameter] string DevNuGetApiKey;\n    \n    [Parameter] string NuGetSource;\n    \n    [Parameter] string NuGetApiKey;\n\n    [Solution] readonly Solution Solution;\n\n    [GitRepository] readonly GitRepository GitRepository;\n\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    const string PackageProjectUrl = \u0022https://github.com/CreativeCodersTeam/Core\u0022; \n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .UseBuildAction\u003CCleanBuildAction\u003E(this);\n\n    Target Restore =\u003E _ =\u003E _\n        .Before(Compile)\n        .UseBuildAction\u003CRestoreBuildAction\u003E(this);\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .ProceedAfterFailure()\n        .UseBuildAction\u003CDotNetCompileBuildAction\u003E(this);\n\n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .UseBuildAction\u003CUnitTestAction\u003E(this,\n            x =\u003E x\n                .SetUnitTestsBasePath(\u0022UnitTests\u0022)\n                .SetProjectsPattern(\u0022**/*.csproj\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022test_results\u0022));\n    \n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(RunTests)\n        .UseBuildAction\u003CPackBuildAction\u003E(this, x =\u003E x\n            .SetPackageLicenseExpression(PackageLicenseExpressions.MIT)\n            .SetPackageProjectUrl(PackageProjectUrl)\n            .SetCopyright($\u0022{DateTime.Now.Year} CreativeCoders\u0022));\n\n    Target Rebuild =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Compile);\n\n    Target PushDevNuGet =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E DevNuGetSource)\n        .Requires(() =\u003E DevNuGetApiKey)\n        .UseBuildAction\u003CPushBuildAction\u003E(this, \n            x =\u003E x\n                .SetSource(DevNuGetSource)\n                .SetApiKey(DevNuGetApiKey));\n\n    Target PushNuGet =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E NuGetApiKey)\n        .UseBuildAction\u003CPushBuildAction\u003E(this,\n            x =\u003E x\n                .SetSource(NuGetSource)\n                .SetApiKey(NuGetApiKey));\n\n    Configuration IBuildInfo.Configuration =\u003E Configuration;\n\n    Solution IBuildInfo.Solution =\u003E Solution;\n\n    GitRepository IBuildInfo.GitRepository =\u003E GitRepository;\n\n    IVersionInfo IBuildInfo.VersionInfo =\u003E new GitVersionWrapper(GitVersion, \u00220.0.0\u0022, 1);\n\n    AbsolutePath IBuildInfo.SourceDirectory =\u003E SourceDirectory;\n\n    AbsolutePath IBuildInfo.ArtifactsDirectory =\u003E ArtifactsDirectory;\n}\n"
  },
  {
    "Id": 239022206,
    "FirstIndexed": "2020-04-25T15:47:03.6110635+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628553+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432693+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938491+02:00",
    "Name": "NMica",
    "Owner": "NMica",
    "HtmlUrl": "https://github.com/NMica/NMica",
    "Description": null,
    "Archived": false,
    "Stars": 36,
    "Watchers": 3,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/NMica/NMica/blob/master/build/Build.cs",
    "BuildFileSize": 6354,
    "BuildFileContent": "using System;\r\nusing System.Diagnostics;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.Docker;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Tools.NerdbankGitVersioning;\r\nusing static Nuke.Common.Tools.NerdbankGitVersioning.NerdbankGitVersioningTasks;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\r\nusing static Nuke.Common.ControlFlow;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Parameter(\u0022Framework to build against - netstandard2.0 or net472\u0022)]\r\n    readonly string Framework;\r\n    \r\n    [Solution] readonly Solution Solution;\r\n    \r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    AbsolutePath SamplesSolutionDir =\u003E Solution.Directory / \u0022Samples\u0022 / \u0022MultiProjectWebApp\u0022;\r\n\r\n    [Parameter(\u0022Determines if release branch will have pre-release tags applied to it. Default is false, meaning when cutting new version it is considered final (stable) package\u0022)]\r\n    readonly bool IsPreRelease = false;\r\n    [Parameter(\u0022Nuget ApiKey required in order to push packages\u0022)]\r\n    string NugetApiKey;\r\n\r\n    string NMicaProject =\u003E Solution.GetProject(\u0022NMica\u0022).Path;\r\n\r\n    [NerdbankGitVersioning] readonly NerdbankGitVersioning GitVersion;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            \r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(_ =\u003E _\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(_ =\u003E _\r\n                .SetProjectFile(Solution)\r\n                .SetFramework(Framework)\r\n                .SetConfiguration(Configuration)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .DependsOn(Clean,Compile)\r\n        .Description(\u0022Creates nuget package in artifacts directory\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            \r\n            EnsureCleanDirectory(TemporaryDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n            var dockerProject = Solution.GetProject(\u0022NMica\u0022).Directory;\r\n            var dockerCompileDir = dockerProject / \u0022bin\u0022 / Configuration;\r\n            \r\n            CopyDirectoryRecursively(dockerProject / \u0022nuget\u0022, TemporaryDirectory, DirectoryExistsPolicy.Merge);\r\n            CopyDirectoryRecursively(dockerCompileDir, TemporaryDirectory / \u0022tasks\u0022);\r\n\r\n            DotNetPack(_ =\u003E _\r\n                    .SetProject(Solution.Path)\r\n                    .DisableRunCodeAnalysis()\r\n                    .AddProperty(\u0022NuspecFile\u0022, TemporaryDirectory / \u0022NMica.nuspec\u0022)\r\n                    .AddProperty(\u0022NoPackageAnalysis\u0022, true)\r\n                    .AddProperty(\u0022NuspecProperties\u0022, $\u0022version={GitVersion.NuGetPackageVersion}\u0022)\r\n                    .SetOutputDirectory(ArtifactsDirectory));\r\n        });\r\n\r\n    Target Release =\u003E _ =\u003E _\r\n        .After(Publish,Test)\r\n        .OnlyWhenDynamic(() =\u003E string.IsNullOrEmpty(GitVersion.PrereleaseVersion)) // we don\u0027t publish non final releases to nuget.org - prerelease builds are available on azure artifacts feed\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetNuGetPush(_ =\u003E _\r\n                .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                .SetTargetPath(ArtifactsDirectory / $\u0022NMica.{GitVersion.NuGetPackageVersion}.nupkg\u0022)\r\n                .SetApiKey(NugetApiKey));\r\n        });\r\n\r\n    Target CleanNugetCache =\u003E _ =\u003E _\r\n        .DependsOn(Publish)\r\n        .Unlisted()\r\n        .Executes(() =\u003E\r\n        {\r\n            // for some reason dotnet is leaving locks on nuget dll after tests even after existing\r\n            // this is a dirty hack that kills every dotnet process except current one to release lock\r\n            foreach (var process in Process.GetProcesses()\r\n                .Where(x =\u003E x.ProcessName == \u0022dotnet\u0022 \u0026\u0026 x.Id != Process.GetCurrentProcess().Id))\r\n            {\r\n                process.Kill(true);\r\n            }\r\n                \r\n            var userFolder = (AbsolutePath) Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);\r\n            var nugetCacheFolder = userFolder / \u0022.nuget\u0022 / \u0022packages\u0022;\r\n            DeleteDirectory(nugetCacheFolder / \u0022NMica\u0022);\r\n            \r\n        });\r\n    \r\n\r\n    Target Test =\u003E _ =\u003E _\r\n        .After(Publish)\r\n        .Description(\u0022Executes test suite. Requires Docker\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            var testProject = RootDirectory / \u0022tests\u0022 / \u0022NMica.Tests\u0022 / \u0022NMica.Tests.csproj\u0022;\r\n            DotNetTest(_ =\u003E _\r\n                .SetProjectFile(testProject)\r\n                .SetWorkingDirectory(testProject.Parent));\r\n        });\r\n\r\n    Target CutReleaseBranch =\u003E _ =\u003E _\r\n        .Executes(() =\u003E NerdbankGitVersioningPrepareRelease(_ =\u003E _\r\n            .SetWorkingDirectory(RootDirectory)\r\n            .SetTag(IsPreRelease ? \u0022beta\u0022 : null)));\r\n\r\n    Target CI =\u003E _ =\u003E _\r\n        .Unlisted()\r\n        .Triggers(Publish, Test, Release)\r\n        .Executes(() =\u003E NerdbankGitVersioningCloud());\r\n}\r\n"
  },
  {
    "Id": 239455025,
    "FirstIndexed": "2020-04-25T15:47:03.6111056+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.16296+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432699+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938503+02:00",
    "Name": "Revit_mprCopyElementsToOpenDocuments",
    "Owner": "ModPlus-Software",
    "HtmlUrl": "https://github.com/ModPlus-Software/Revit_mprCopyElementsToOpenDocuments",
    "Description": "Batch elements copying to the opened documents",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ModPlus-Software/Revit_mprCopyElementsToOpenDocuments/blob/master/build/Build.cs",
    "BuildFileSize": 2618,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.MSBuild;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n     public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Solution] readonly Solution Solution;\n    \n    // If the solution name and the project (plugin) name are different, then indicate the project (plugin) name here\n    string PluginName =\u003E Solution.Name;\n\n    Target Compile =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var project = Solution.GetProject(PluginName);\n            if (project == null)\n                throw new FileNotFoundException(\u0022Not found!\u0022);\n\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            \n            var postBuild = Environment.GetEnvironmentVariable(\u0022ModPlusPostBuild\u0022);\n            var build = new List\u003Cstring\u003E();\n            foreach (var (_, c) in project.Configurations)\n            {\n                var configuration = c.Split(\u0022|\u0022)[0];\n                var platform = c.Split(\u0022|\u0022)[1];\n\n                if (configuration == \u0022Debug\u0022 || build.Contains(configuration))\n                    continue;\n\n                Logger.Success($\u0022Configuration: {configuration}\u0022);\n\n                build.Add(configuration);\n\n                MSBuild(_ =\u003E _\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Restore\u0022));\n                MSBuild(_ =\u003E _\n                    .DisableRestore()\n                    .SetProjectFile(project.Path)\n                    .SetConfiguration(configuration)\n                    .SetTargetPlatform(MSBuildTargetPlatform.x64)\n                    .SetTargets(\u0022Rebuild\u0022));\n\n                if (File.Exists(postBuild))\n                {\n                    var targetPath = Path.Combine(\n                        project.Directory, \n                        \u0022bin\u0022, \n                        platform,\n                        configuration, \n                        $\u0022{project.Name}_{configuration.Replace(\u0022R\u0022, string.Empty)}.dll\u0022);\n                    Logger.Success($\u0022TargetPath: {targetPath}\u0022);\n                    Process.Start(postBuild, $\u0022Revit \\\u0022{targetPath}\\\u0022 s\u0022);\n                }\n                else\n                    Logger.Warn(\u0022ModPlus PostBuild application not found\u0022);\n            }\n        });\n}\n"
  },
  {
    "Id": 239857371,
    "FirstIndexed": "2020-04-25T15:47:03.6111107+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629981+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843271+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938514+02:00",
    "Name": "OpenRedding",
    "Owner": "joey32793",
    "HtmlUrl": "https://github.com/joey32793/OpenRedding",
    "Description": "An open data portal for the City of Redding",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/joey32793/OpenRedding/blob/master/build/Build.cs",
    "BuildFileSize": 2445,
    "BuildFileContent": "// \u003Cauto-generated/\u003E\nusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 239939672,
    "FirstIndexed": "2020-04-25T15:47:03.6111016+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622511+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432722+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "VCModuleV3",
    "Owner": "mvktsk",
    "HtmlUrl": "https://github.com/mvktsk/VCModuleV3",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 240601928,
    "FirstIndexed": "2020-04-25T15:47:03.6110828+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629856+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432733+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938525+02:00",
    "Name": "Dangl.SevDeskExport",
    "Owner": "GeorgDangl",
    "HtmlUrl": "https://github.com/GeorgDangl/Dangl.SevDeskExport",
    "Description": "Data export from sevDesk",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/GeorgDangl/Dangl.SevDeskExport/blob/develop/build/Build.cs",
    "BuildFileSize": 9158,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DocFX;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.GitHub;\nusing Nuke.WebDocu;\nusing System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.TextTasks;\nusing static Nuke.Common.Tools.DocFX.DocFXTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.GitHub.GitHubTasks;\nusing static Nuke.WebDocu.WebDocuTasks;\n\n[GitHubActions(\n    \u0022continuous\u0022,\n    GitHubActionsImage.WindowsServer2019,\n    On = new[] { GitHubActionsTrigger.Push },\n    InvokedTargets = new[] { nameof(UploadDocumentation), nameof(PublishGitHubRelease) },\n    ImportGitHubTokenAs = nameof(GitHubAuthenticationToken),\n    AutoGenerate = false,\n    ImportSecrets = new[] { nameof(DocuApiKey) })]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter] readonly string DocuApiKey;\n    [Parameter] readonly string DocuBaseUrl = \u0022https://docs.dangl-it.com\u0022;\n    [Parameter] readonly string GitHubAuthenticationToken;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath DocFxFile =\u003E RootDirectory / \u0022docfx.json\u0022;\n    AbsolutePath ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(d =\u003E EnsureCleanDirectory(d));\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(d =\u003E EnsureCleanDirectory(d));\n            EnsureCleanDirectory(OutputDirectory);\n            EnsureCleanDocFxArtifactx();\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target GenerateVersionService =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            var buildDate = DateTime.UtcNow;\n            var filePath = SourceDirectory / \u0022Dangl.SevDeskExport\u0022 / \u0022VersionInfo.cs\u0022;\n\n            var currentDateUtc = $\u0022new DateTime({buildDate.Year}, {buildDate.Month}, {buildDate.Day}, {buildDate.Hour}, {buildDate.Minute}, {buildDate.Second}, DateTimeKind.Utc)\u0022;\n\n            var content = $@\u0022using System;\nnamespace Dangl.SevDeskExport\n{{\n#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member\n    // This file is automatically generated\n    [System.CodeDom.Compiler.GeneratedCode(\u0022\u0022GitVersionBuild\u0022\u0022, \u0022\u0022\u0022\u0022)]\n    public static class VersionInfo\n    {{\n        public static string Version =\u003E \u0022\u0022{GitVersion.NuGetVersionV2}\u0022\u0022;\n        public static string CommitInfo =\u003E \u0022\u0022{GitVersion.FullBuildMetaData}\u0022\u0022;\n        public static string CommitDate =\u003E \u0022\u0022{GitVersion.CommitDate}\u0022\u0022;\n        public static string CommitHash =\u003E \u0022\u0022{GitVersion.Sha}\u0022\u0022;\n        public static string InformationalVersion =\u003E \u0022\u0022{GitVersion.InformationalVersion}\u0022\u0022;\n        public static DateTime BuildDateUtc =\u003E {currentDateUtc};\n    }}\n}}\u0022;\n            WriteAllText(filePath, content);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(GenerateVersionService)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(GenerateVersionService)\n        .Executes(() =\u003E\n        {\n            foreach (var publishTarget in PublishTargets)\n            {\n                var tempPublishPath = OutputDirectory / \u0022TempPublish\u0022;\n                EnsureCleanDirectory(tempPublishPath);\n                var zipPath = OutputDirectory / $\u0022{publishTarget[0]}.zip\u0022;\n                DotNetPublish(x =\u003E x\n                    .SetWorkingDirectory(SourceDirectory / \u0022Dangl.SevDeskExport\u0022)\n                    .SetSelfContained(true)\n                    .SetConfiguration(Configuration.Release)\n                    .SetRuntime(publishTarget[1])\n                    .SetOutput(tempPublishPath)\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                    .When(publishTarget[1] == \u0022ubuntu-x64\u0022, c =\u003E c.SetArgumentConfigurator(a =\u003E a\n                       .Add(\u0022/p:PublishTrimmed=true\u0022)\n                       .Add(\u0022/p:PublishSingleFile=true\u0022)\n                       .Add(\u0022/p:DebugType=None\u0022)))\n                    .When(publishTarget[1] != \u0022ubuntu-x64\u0022, c =\u003E c.SetArgumentConfigurator(a =\u003E a\n                       .Add(\u0022/p:PublishTrimmed=true\u0022)\n                       .Add(\u0022/p:PublishSingleFile=true\u0022)\n                       .Add(\u0022/p:DebugType=None\u0022)\n                       .Add(\u0022/p:PublishReadyToRun=true\u0022)))\n                    );\n                ZipFile.CreateFromDirectory(tempPublishPath, zipPath);\n            }\n        });\n\n    string[][] PublishTargets =\u003E new string[][]\n             {\n                new [] { \u0022CLI_Windows_x86\u0022, \u0022win-x86\u0022},\n                new [] { \u0022CLI_Windows_x64\u0022, \u0022win-x64\u0022},\n                new [] { \u0022CLI_Linux_Ubuntu_x86\u0022, \u0022ubuntu-x64\u0022}\n             };\n\n    Target PublishGitHubRelease =\u003E _ =\u003E _\n         .Requires(() =\u003E GitHubAuthenticationToken)\n         .OnlyWhenDynamic(() =\u003E GitVersion.BranchName.Equals(\u0022master\u0022) || GitVersion.BranchName.Equals(\u0022origin/master\u0022))\n         .Executes(async () =\u003E\n         {\n             var releaseTag = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n\n             var changeLogSectionEntries = ExtractChangelogSectionNotes(ChangeLogFile);\n             var latestChangeLog = changeLogSectionEntries\n                 .Aggregate((c, n) =\u003E c \u002B Environment.NewLine \u002B n);\n             var completeChangeLog = $\u0022## {releaseTag}\u0022 \u002B Environment.NewLine \u002B latestChangeLog;\n\n             var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);\n\n             await PublishRelease(x =\u003E x\n                     .SetCommitSha(GitVersion.Sha)\n                     .SetReleaseNotes(completeChangeLog)\n                     .SetRepositoryName(repositoryInfo.repositoryName)\n                     .SetRepositoryOwner(repositoryInfo.gitHubOwner)\n                     .SetTag(releaseTag)\n                     .SetToken(GitHubAuthenticationToken));\n         });\n\n    Target BuildDocFxMetadata =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DocFXMetadata(x =\u003E x\n                .SetProjects(DocFxFile)\n                .SetLogLevel(DocFXLogLevel.Warning));\n        });\n\n    Target BuildDocumentation =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(BuildDocFxMetadata)\n        .Executes(() =\u003E\n        {\n            // Using README.md as index.md\n            if (File.Exists(RootDirectory / \u0022index.md\u0022))\n            {\n                File.Delete(RootDirectory / \u0022index.md\u0022);\n            }\n\n            File.Copy(RootDirectory / \u0022README.md\u0022, RootDirectory / \u0022index.md\u0022);\n\n            DocFXBuild(x =\u003E x\n                .SetConfigFile(DocFxFile)\n                .SetLogLevel(DocFXLogLevel.Warning));\n\n            File.Delete(RootDirectory / \u0022index.md\u0022);\n            EnsureCleanDocFxArtifactx();\n        });\n\n    void EnsureCleanDocFxArtifactx()\n    {\n        DeleteDirectory(RootDirectory / \u0022obj\u0022);\n    }\n\n    Target UploadDocumentation =\u003E _ =\u003E _\n         .DependsOn(BuildDocumentation)\n         .DependsOn(Publish)\n         .Requires(() =\u003E DocuApiKey)\n         .Requires(() =\u003E DocuBaseUrl)\n         .Executes(() =\u003E\n         {\n             var markdownChangelog = ReadAllText(ChangeLogFile);\n\n             WebDocu(s =\u003E s\n                 .SetDocuBaseUrl(DocuBaseUrl)\n                 .SetDocuApiKey(DocuApiKey)\n                 .SetSourceDirectory(OutputDirectory / \u0022docs\u0022)\n                 .SetVersion(GitVersion.NuGetVersion)\n                 .SetMarkdownChangelog(markdownChangelog)\n                 .SetAssetFilePaths(PublishTargets.Select(t =\u003E (OutputDirectory / $\u0022{t[0]}.zip\u0022).ToString()).ToArray())\n             );\n         });\n}\n"
  },
  {
    "Id": 240742768,
    "FirstIndexed": "2020-04-25T15:50:44.7359406+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629873+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434639+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940357+02:00",
    "Name": "Avalonia",
    "Owner": "ckayun",
    "HtmlUrl": "https://github.com/ckayun/Avalonia",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "nukebuild/Build.cs",
    "BuildFileUrl": "https://github.com/ckayun/Avalonia/blob/master/nukebuild/Build.cs",
    "BuildFileSize": 12140,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing System.Xml.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\nusing static Nuke.Common.Tools.VSWhere.VSWhereTasks;\n\n/*\n Before editing this file, install support plugin for your IDE,\n running and debugging a particular target (optionally without deps) would be way easier\n ReSharper/Rider - https://plugins.jetbrains.com/plugin/10803-nuke-support\n VSCode - https://marketplace.visualstudio.com/items?itemName=nuke.support\n \n */\n\npartial class Build : NukeBuild\n{\n    static Lazy\u003Cstring\u003E MsBuildExe = new Lazy\u003Cstring\u003E(() =\u003E\n    {\n        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            return null;\n\n        var msBuildDirectory = VSWhere(\u0022-latest -nologo -property installationPath -format value -prerelease\u0022).FirstOrDefault().Text;\n\n        if (!string.IsNullOrWhiteSpace(msBuildDirectory))\n        {\n            string msBuildExe = Path.Combine(msBuildDirectory, @\u0022MSBuild\\Current\\Bin\\MSBuild.exe\u0022);\n            if (!System.IO.File.Exists(msBuildExe))\n                msBuildExe = Path.Combine(msBuildDirectory, @\u0022MSBuild\\15.0\\Bin\\MSBuild.exe\u0022);\n\n            return msBuildExe;\n        }\n\n        return null;\n    }, false);\n\n    BuildParameters Parameters { get; set; }\n    protected override void OnBuildInitialized()\n    {\n        Parameters = new BuildParameters(this);\n        Information(\u0022Building version {0} of Avalonia ({1}) using version {2} of Nuke.\u0022, \n            Parameters.Version,\n            Parameters.Configuration,\n            typeof(NukeBuild).Assembly.GetName().Version.ToString());\n\n        if (Parameters.IsLocalBuild)\n        {\n            Information(\u0022Repository Name: \u0022 \u002B Parameters.RepositoryName);\n            Information(\u0022Repository Branch: \u0022 \u002B Parameters.RepositoryBranch);\n        }\n        Information(\u0022Configuration: \u0022 \u002B Parameters.Configuration);\n        Information(\u0022IsLocalBuild: \u0022 \u002B Parameters.IsLocalBuild);\n        Information(\u0022IsRunningOnUnix: \u0022 \u002B Parameters.IsRunningOnUnix);\n        Information(\u0022IsRunningOnWindows: \u0022 \u002B Parameters.IsRunningOnWindows);\n        Information(\u0022IsRunningOnAzure:\u0022 \u002B Parameters.IsRunningOnAzure);\n        Information(\u0022IsPullRequest: \u0022 \u002B Parameters.IsPullRequest);\n        Information(\u0022IsMainRepo: \u0022 \u002B Parameters.IsMainRepo);\n        Information(\u0022IsMasterBranch: \u0022 \u002B Parameters.IsMasterBranch);\n        Information(\u0022IsReleaseBranch: \u0022 \u002B Parameters.IsReleaseBranch);\n        Information(\u0022IsReleasable: \u0022 \u002B Parameters.IsReleasable);\n        Information(\u0022IsMyGetRelease: \u0022 \u002B Parameters.IsMyGetRelease);\n        Information(\u0022IsNuGetRelease: \u0022 \u002B Parameters.IsNuGetRelease);\n\n        void ExecWait(string preamble, string command, string args)\n        {\n            Console.WriteLine(preamble);\n            Process.Start(new ProcessStartInfo(command, args) {UseShellExecute = false}).WaitForExit();\n        }\n        ExecWait(\u0022dotnet version:\u0022, \u0022dotnet\u0022, \u0022--version\u0022);\n        if (Parameters.IsRunningOnUnix)\n            ExecWait(\u0022Mono version:\u0022, \u0022mono\u0022, \u0022--version\u0022);\n\n\n    }\n\n    IReadOnlyCollection\u003COutput\u003E MsBuildCommon(\n        string projectFile,\n        Configure\u003CMSBuildSettings\u003E configurator = null)\n    {\n        return MSBuild(projectFile, c =\u003E\n        {\n            // This is required for VS2019 image on Azure Pipelines\n            if (Parameters.IsRunningOnWindows \u0026\u0026 Parameters.IsRunningOnAzure)\n            {\n                var javaSdk = Environment.GetEnvironmentVariable(\u0022JAVA_HOME_8_X64\u0022);\n                if (javaSdk != null)\n                    c = c.AddProperty(\u0022JavaSdkDirectory\u0022, javaSdk);\n            }\n\n            c = c.AddProperty(\u0022PackageVersion\u0022, Parameters.Version)\n                .AddProperty(\u0022iOSRoslynPathHackRequired\u0022, \u0022true\u0022)\n                .SetToolPath(MsBuildExe.Value)\n                .SetConfiguration(Parameters.Configuration)\n                .SetVerbosity(MSBuildVerbosity.Minimal);\n            c = configurator?.Invoke(c) ?? c;\n            return c;\n        });\n    }\n    Target Clean =\u003E _ =\u003E _.Executes(() =\u003E\n    {\n        DeleteDirectories(Parameters.BuildDirs);\n        EnsureCleanDirectories(Parameters.BuildDirs);\n        EnsureCleanDirectory(Parameters.ArtifactsDir);\n        EnsureCleanDirectory(Parameters.NugetIntermediateRoot);\n        EnsureCleanDirectory(Parameters.NugetRoot);\n        EnsureCleanDirectory(Parameters.ZipRoot);\n        EnsureCleanDirectory(Parameters.TestResultsRoot);\n    });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            if (Parameters.IsRunningOnWindows)\n                MsBuildCommon(Parameters.MSBuildSolution, c =\u003E c\n                    .SetArgumentConfigurator(a =\u003E a.Add(\u0022/r\u0022))\n                    .AddTargets(\u0022Build\u0022)\n                );\n\n            else\n                DotNetBuild(Parameters.MSBuildSolution, c =\u003E c\n                    .AddProperty(\u0022PackageVersion\u0022, Parameters.Version)\n                    .SetConfiguration(Parameters.Configuration)\n                );\n        });\n    \n    void RunCoreTest(string project)\n    {\n        if(!project.EndsWith(\u0022.csproj\u0022))\n            project = System.IO.Path.Combine(project, System.IO.Path.GetFileName(project)\u002B\u0022.csproj\u0022);\n        Information(\u0022Running tests from \u0022 \u002B project);\n        XDocument xdoc;\n        using (var s = File.OpenRead(project))\n            xdoc = XDocument.Load(s);\n\n        List\u003Cstring\u003E frameworks = null;\n        var targets = xdoc.Root.Descendants(\u0022TargetFrameworks\u0022).FirstOrDefault();\n        if (targets != null)\n            frameworks = targets.Value.Split(\u0027;\u0027).Where(f =\u003E !string.IsNullOrWhiteSpace(f)).ToList();\n        else \n            frameworks = new List\u003Cstring\u003E {xdoc.Root.Descendants(\u0022TargetFramework\u0022).First().Value};\n        \n        foreach(var fw in frameworks)\n        {\n            if (fw.StartsWith(\u0022net4\u0022)\n                \u0026\u0026 RuntimeInformation.IsOSPlatform(OSPlatform.Linux) \n                \u0026\u0026 Environment.GetEnvironmentVariable(\u0022FORCE_LINUX_TESTS\u0022) != \u00221\u0022)\n            {\n                Information($\u0022Skipping {fw} tests on Linux - https://github.com/mono/mono/issues/13969\u0022);\n                continue;\n            }\n\n            Information(\u0022Running for \u0022 \u002B fw);\n            DotNetTest(c =\u003E\n            {\n                c = c\n                    .SetProjectFile(project)\n                    .SetConfiguration(Parameters.Configuration)\n                    .SetFramework(fw)\n                    .EnableNoBuild()\n                    .EnableNoRestore();\n                // NOTE: I can see that we could maybe add another extension method \u0022Switch\u0022 or \u0022If\u0022 to make this more  convenient\n                if (Parameters.PublishTestResults)\n                    c = c.SetLogger(\u0022trx\u0022).SetResultsDirectory(Parameters.TestResultsRoot);\n                return c;\n            });\n        }\n    }\n\n    Target RunCoreLibsTests =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E !Parameters.SkipTests)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            RunCoreTest(\u0022./tests/Avalonia.Animation.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Base.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Controls.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Controls.DataGrid.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Input.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Interactivity.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Layout.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Markup.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Markup.Xaml.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Styling.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Visuals.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.Skia.UnitTests\u0022);\n            RunCoreTest(\u0022./tests/Avalonia.ReactiveUI.UnitTests\u0022);\n        });\n\n    Target RunRenderTests =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E !Parameters.SkipTests)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            RunCoreTest(\u0022./tests/Avalonia.Skia.RenderTests/Avalonia.Skia.RenderTests.csproj\u0022);\n            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n                RunCoreTest(\u0022./tests/Avalonia.Direct2D1.RenderTests/Avalonia.Direct2D1.RenderTests.csproj\u0022);\n        });\n    \n    Target RunDesignerTests =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E !Parameters.SkipTests \u0026\u0026 Parameters.IsRunningOnWindows)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            RunCoreTest(\u0022./tests/Avalonia.DesignerSupport.Tests\u0022);\n        });\n\n    [PackageExecutable(\u0022JetBrains.dotMemoryUnit\u0022, \u0022dotMemoryUnit.exe\u0022)] readonly Tool DotMemoryUnit;\n\n    Target RunLeakTests =\u003E _ =\u003E _\n        .OnlyWhen(() =\u003E !Parameters.SkipTests \u0026\u0026 Parameters.IsRunningOnWindows)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var testAssembly = \u0022tests\\\\Avalonia.LeakTests\\\\bin\\\\Release\\\\net461\\\\Avalonia.LeakTests.dll\u0022;\n            DotMemoryUnit(\n                $\u0022{XunitPath.DoubleQuoteIfNeeded()} --propagate-exit-code -- {testAssembly}\u0022,\n                timeout: 120_000);\n        });\n\n    Target ZipFiles =\u003E _ =\u003E _\n        .After(CreateNugetPackages, Compile, RunCoreLibsTests, Package)    \n        .Executes(() =\u003E\n        {\n            var data = Parameters;\n            Zip(data.ZipCoreArtifacts, data.BinRoot);\n            Zip(data.ZipNuGetArtifacts, data.NugetRoot);\n            Zip(data.ZipTargetControlCatalogDesktopDir,\n                GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.dll\u0022).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.config\u0022)).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.so\u0022)).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.dylib\u0022)).Concat(\n                    GlobFiles(data.ZipSourceControlCatalogDesktopDir, \u0022*.exe\u0022)));\n        });\n\n    Target CreateIntermediateNugetPackages =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .After(RunTests)\n        .Executes(() =\u003E\n        {\n            if (Parameters.IsRunningOnWindows)\n\n                MsBuildCommon(Parameters.MSBuildSolution, c =\u003E c\n                    .AddTargets(\u0022Pack\u0022));\n            else\n                DotNetPack(Parameters.MSBuildSolution, c =\u003E\n                    c.SetConfiguration(Parameters.Configuration)\n                        .AddProperty(\u0022PackageVersion\u0022, Parameters.Version));\n        });\n\n    Target CreateNugetPackages =\u003E _ =\u003E _\n        .DependsOn(CreateIntermediateNugetPackages)\n        .Executes(() =\u003E\n        {\n            var config = Numerge.MergeConfiguration.LoadFile(RootDirectory / \u0022nukebuild\u0022 / \u0022numerge.config\u0022);\n            EnsureCleanDirectory(Parameters.NugetRoot);\n            if(!Numerge.NugetPackageMerger.Merge(Parameters.NugetIntermediateRoot, Parameters.NugetRoot, config,\n                new NumergeNukeLogger()))\n                throw new Exception(\u0022Package merge failed\u0022);\n        });\n    \n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(RunCoreLibsTests)\n        .DependsOn(RunRenderTests)\n        .DependsOn(RunDesignerTests)\n        .DependsOn(RunLeakTests);\n    \n    Target Package =\u003E _ =\u003E _\n        .DependsOn(RunTests)\n        .DependsOn(CreateNugetPackages);\n    \n    Target CiAzureLinux =\u003E _ =\u003E _\n        .DependsOn(RunTests);\n    \n    Target CiAzureOSX =\u003E _ =\u003E _\n        .DependsOn(Package)\n        .DependsOn(ZipFiles);\n    \n    Target CiAzureWindows =\u003E _ =\u003E _\n        .DependsOn(Package)\n        .DependsOn(ZipFiles);\n\n    \n    public static int Main() =\u003E\n        RuntimeInformation.IsOSPlatform(OSPlatform.Windows)\n            ? Execute\u003CBuild\u003E(x =\u003E x.Package)\n            : Execute\u003CBuild\u003E(x =\u003E x.RunTests);\n\n}\n"
  },
  {
    "Id": 240903974,
    "FirstIndexed": "2020-04-25T15:47:03.6107949+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627739+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432739+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938531+02:00",
    "Name": "Inferno",
    "Owner": "ingenerics",
    "HtmlUrl": "https://github.com/ingenerics/Inferno",
    "Description": "A framework designed for building reactive, composite WPF apps. ",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/ingenerics/Inferno/blob/master/build/Build.cs",
    "BuildFileSize": 5792,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.PackWpf);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetResultsDirectory(RootDirectory / \u0022.tmp\u0022 / \u0022testResults\u0022));\n        });\n\n    Target PackCore =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Inferno.Core\u0022 / \u0022Inferno.Core.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoDependencies()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    Target PackReactive =\u003E _ =\u003E _\n        .DependsOn(PackCore)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Inferno.Reactive\u0022 / \u0022Inferno.Reactive.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoDependencies()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    Target PackLifeCycle =\u003E _ =\u003E _\n        .DependsOn(PackReactive)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Inferno.LifeCycle\u0022 / \u0022Inferno.LifeCycle.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoDependencies()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    Target PackWpfShared =\u003E _ =\u003E _\n        .DependsOn(PackLifeCycle)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Inferno.Wpf.Shared\u0022 / \u0022Inferno.Wpf.Shared.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoDependencies()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    Target PackWpf =\u003E _ =\u003E _\n        .DependsOn(PackWpfShared)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Inferno.Wpf\u0022 / \u0022Inferno.Wpf.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoDependencies()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory));\n        });\n\n    Target PackWpfMetro =\u003E _ =\u003E _\n        .DependsOn(PackWpfShared)\n        .TriggeredBy(PackWpf)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(SourceDirectory / \u0022Inferno.Wpf.Metro\u0022 / \u0022Inferno.Wpf.Metro.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .EnableNoDependencies()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .SetOutputDirectory(OutputDirectory));\n        });\n}\n"
  },
  {
    "Id": 240974120,
    "FirstIndexed": "2020-04-25T15:47:03.6110777+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629816+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843275+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938542+02:00",
    "Name": "gitlab-ci-example-dotnetcore-windows",
    "Owner": "t081as",
    "HtmlUrl": "https://github.com/t081as/gitlab-ci-example-dotnetcore-windows",
    "Description": "This is a gitlab continuous integration example project compatible with the windows-based shared runners provided on gitlab.com building a .NET Core Windows Desktop project; mirror of the official repository https://gitlab.com/tobiaskoch/gitlab-ci-example-dotnetcore",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/BuildTargets.cs",
    "BuildFileUrl": "https://github.com/t081as/gitlab-ci-example-dotnetcore-windows/blob/master/build/BuildTargets.cs",
    "BuildFileSize": 6475,
    "BuildFileContent": "using System;\nusing System.IO;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass BuildTargets : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuildTargets\u003E(x =\u003E x.All);\n\n    [Parameter(\u0022Configuration to build\u0022)]\n    readonly Configuration Configuration = Configuration.Debug;\n\n    [Solution] readonly Solution Solution;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    AbsolutePath BuildDirectory =\u003E OutputDirectory / \u0022build\u0022;\n    AbsolutePath PublishDirectory =\u003E OutputDirectory / \u0022publish\u0022;\n    AbsolutePath CoverageDirectory =\u003E OutputDirectory / \u0022coverage\u0022;\n    AbsolutePath MainProjectFile =\u003E SourceDirectory / \u0022MyProject\u0022 / \u0022MyProject.csproj\u0022;\n\n    readonly string GlobCoverageFiles = \u0022**/TestResults/*/coverage.cobertura.xml\u0022;\n    readonly string GlobTestResultFiles = \u0022**/TestResults/TestResults.xml\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            RootDirectory.GlobFiles(GlobCoverageFiles).ForEach(DeleteFile);\n            RootDirectory.GlobFiles(GlobTestResultFiles).ForEach(DeleteFile);\n            RootDirectory.GlobFiles(\u0022*.zip\u0022).ForEach(DeleteFile);\n\n            EnsureCleanDirectory(BuildDirectory);\n            EnsureCleanDirectory(PublishDirectory);\n            EnsureCleanDirectory(CoverageDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n            DotNetClean();\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            if (Configuration == Configuration.Release)\n            {\n                DotNetBuild(_ =\u003E _\n                    .SetProjectFile(MainProjectFile)\n                    .SetOutputDirectory(BuildDirectory)\n                    .SetConfiguration(Configuration)\n                    .AddProperty(\u0022DebugType\u0022, \u0022None\u0022)\n                    .AddProperty(\u0022DebugSymbols\u0022, \u0022false\u0022)\n                    .EnableNoRestore());\n            }\n            else\n            {\n                DotNetBuild(_ =\u003E _\n                    .SetProjectFile(Solution)\n                    .SetOutputDirectory(BuildDirectory)\n                    .SetConfiguration(Configuration)\n                    .EnableNoRestore());\n            }\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenStatic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            string loggerConfiguration = $\u0022junit;LogFilePath={OutputDirectory / \u0022TestResults\u0022 / \u0022TestResults.xml\u0022};MethodFormat=Class;FailureBodyFormat=Verbose\u0022;\n\n            DotNetTest(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetLogger(loggerConfiguration) // MyProject.Tests.csproj, package JunitXml.TestLogger\n                .SetDataCollector(\u0022XPlat Code Coverage\u0022) // MyProject.Tests.csproj, package coverlet.collector\n                .EnableNoRestore());\n\n            if (IsWin)\n            {\n                ReportGenerator(_ =\u003E _ // Build.csproj, package ReportGenerator\n                    .SetToolPath(ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, null, \u0022netcoreapp3.0\u0022))\n                    .SetReports(RootDirectory / GlobCoverageFiles)\n                    .SetTargetDirectory(CoverageDirectory)\n                    .SetReportTypes(ReportTypes.TextSummary, ReportTypes.Html));\n\n                // Coverage information will be emitted to build log for\n                // coverage regex in .gitlab-ci.yml file\n                Logger.Info(File.ReadAllText(CoverageDirectory / \u0022Summary.txt\u0022));\n            }\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenStatic(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetPublish(_ =\u003E _\n                .SetConfiguration(Configuration)\n                .AddProperty(\u0022DebugType\u0022, \u0022None\u0022)\n                .AddProperty(\u0022DebugSymbols\u0022, \u0022false\u0022)\n                .SetProject(MainProjectFile)\n                .SetOutput(PublishDirectory / \u0022win-x64\u0022)\n                .EnableSelfContained()\n                .AddProperty(\u0022PublishSingleFile\u0022, \u0022true\u0022)\n                .AddProperty(\u0022PublishTrimmed\u0022, \u0022true\u0022)\n                .SetRuntime(\u0022win-x64\u0022));\n\n            DotNetPublish(_ =\u003E _\n                .SetConfiguration(Configuration)\n                .AddProperty(\u0022DebugType\u0022, \u0022None\u0022)\n                .AddProperty(\u0022DebugSymbols\u0022, \u0022false\u0022)\n                .SetProject(MainProjectFile)\n                .SetOutput(PublishDirectory / \u0022win-x86\u0022)\n                .EnableSelfContained()\n                .AddProperty(\u0022PublishSingleFile\u0022, \u0022true\u0022)\n                .AddProperty(\u0022PublishTrimmed\u0022, \u0022true\u0022)\n                .SetRuntime(\u0022win-x86\u0022));\n\n            CompressionTasks.CompressZip(\n                BuildDirectory,\n                RootDirectory / \u0022MyProject-windows-any.zip\u0022,\n                null,\n                System.IO.Compression.CompressionLevel.Optimal,\n                System.IO.FileMode.CreateNew);\n\n            CompressionTasks.CompressZip(\n                PublishDirectory / \u0022win-x64\u0022,\n                RootDirectory / \u0022MyProject-windows-amd64.zip\u0022,\n                null,\n                System.IO.Compression.CompressionLevel.Optimal,\n                System.IO.FileMode.CreateNew);\n\n            CompressionTasks.CompressZip(\n                PublishDirectory / \u0022win-x86\u0022,\n                RootDirectory / \u0022MyProject-windows-i386.zip\u0022,\n                null,\n                System.IO.Compression.CompressionLevel.Optimal,\n                System.IO.FileMode.CreateNew);\n        });\n\n    Target All =\u003E _ =\u003E _\n        .DependsOn(Publish, Test);\n\n}\n"
  },
  {
    "Id": 241074458,
    "FirstIndexed": "2020-04-25T15:47:03.610845+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628052+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432761+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938554+02:00",
    "Name": "printcenter",
    "Owner": "t1mur619533",
    "HtmlUrl": "https://github.com/t1mur619533/printcenter",
    "Description": "\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0434\u043B\u044F \u043A\u043E\u043D\u0442\u0440\u043E\u043B\u044F \u0437\u0430\u043A\u0430\u0437\u043E\u0432 \u0432 \u043E\u0442\u0434\u0435\u043B\u0435 \u043F\u0435\u0447\u0430\u0442\u0438",
    "Archived": false,
    "Stars": 3,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/t1mur619533/printcenter/blob/develop/build/Build.cs",
    "BuildFileSize": 2700,
    "BuildFileContent": "// ReSharper disable All\nusing System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    protected override void OnBuildInitialized() =\u003E\n        Logger.Info($\u0022Target {InvokedTargets.First().Name}. \u0022 \u002B\n                    $\u0022Configuration {Configuration}. \u0022 \u002B\n                    $\u0022Git branch {GitRepository.Branch}.\u0022);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(OutputDirectory)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 241760412,
    "FirstIndexed": "2020-04-25T15:47:03.6110657+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622403+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432773+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938565+02:00",
    "Name": "Blazor.FontAwesome5",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/Blazor.FontAwesome5",
    "Description": "Blazor integration with FontAwesome5 (free and pro)",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/Blazor.FontAwesome5/blob/master/.build/Build.cs",
    "BuildFileSize": 1734,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal partial class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 242237914,
    "FirstIndexed": "2020-04-25T15:50:44.7359275+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629742+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434627+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940346+02:00",
    "Name": "StandaloneDispatcher",
    "Owner": "ArXen42",
    "HtmlUrl": "https://github.com/ArXen42/StandaloneDispatcher",
    "Description": "Experimental attempt to write simple portable Dispatcher-like class ",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "StandaloneDispatcher/build/Build.cs",
    "BuildFileUrl": "https://github.com/ArXen42/StandaloneDispatcher/blob/master/StandaloneDispatcher/build/Build.cs",
    "BuildFileSize": 1887,
    "BuildFileContent": "using System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022NuGet Api Key\u0022)] readonly string   ApiKey;\n    [Solution]                   readonly Solution Solution;\n\n    Project      LibraryProject  =\u003E Solution.GetProject(\u0022StandaloneDispatcher\u0022);\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .After(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean, Restore)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(LibraryProject)\n                .SetConfiguration(Configuration.Release)\n                .SetOutputDirectory(OutputDirectory)\n            );\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(_ =\u003E _\n                .SetTargetPath(OutputDirectory.GlobFiles($\u0022{LibraryProject.Name}.*.nupkg\u0022).Single())\n                .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\n                .SetApiKey(ApiKey)\n            );\n        });\n}"
  },
  {
    "Id": 242303300,
    "FirstIndexed": "2020-04-25T15:47:03.6110071+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162923+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432784+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938571+02:00",
    "Name": "ghactions",
    "Owner": "bartoszlenar",
    "HtmlUrl": "https://github.com/bartoszlenar/ghactions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/bartoszlenar/ghactions/blob/master/build/Build.cs",
    "BuildFileSize": 14570,
    "BuildFileContent": "using System;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Tooling;\n\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    static class Metadata \n    {\n        public static string Title =\u003E \u0022Validot\u0022;\n\n        public static string Description =\u003E \u0022Tiny lib for great validations\u0022;\n\n        public static string Author =\u003E \u0022Bartosz Lenar\u0022;\n\n        public static string RepositoryUrl =\u003E \u0022http://github.com/bartoszlenar/Validot\u0022;\n\n        public static string PackageIconUrl =\u003E \u0022https://github.com/bartoszlenar/Validot/raw/master/logo/icon.png\u0022;\n\n        public static string PackageLicenceUrl =\u003E \u0022https://github.com/bartoszlenar/Validot/blob/master/LICENSE\u0022;\n\n        public static string[] Tags =\u003E new [] { \u0022validot\u0022, \u0022validation\u0022, \u0022validator\u0022, \u0022fluent\u0022, \u0022fluent-api\u0022 };\n    }\n\n    static readonly Regex SemVerRegex = new Regex(@\u0022^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\u002B([0-9a-zA-Z-]\u002B(?:\\.[0-9a-zA-Z-]\u002B)*))?$\u0022, RegexOptions.Compiled);\n\n    static readonly DateTimeOffset BuildTime = DateTimeOffset.UtcNow;\n    \n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter]\n    readonly Configuration Configuration = Configuration.Debug;\n    \n    [Parameter(\u0022dotnet framework id or SDK version (if SDK version is provided, the highest framework available is selected). Default value is \u0027netcoreapp3.1\u0027\u0022)]\n    readonly string DotNet;\n    \n    [Parameter(\u0022Version. Default value is \u00270.0.0-timestamp\u0027\u0022)]\n    readonly string Version;\n\n    [Parameter(\u0022NuGet API. Where to publish NuGet package. Default value is \u0027https://api.nuget.org/v3/index.json\u0027\u0022)]\n    readonly string NuGetApi;\n\n    [Parameter(\u0022NuGet API key, allows to publish NuGet package.\u0022)]\n    readonly string NuGetApiKey;\n\n    [Parameter(\u0022CodeCov API key, allows to publish code coverage.\u0022)]\n    readonly string CodeCovApiKey;\n    \n    [Parameter(\u0022Commit SHA\u0022)]\n    readonly string CommitSha;\n\n    [Solution] readonly Solution Solution;\n    \n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ToolsPath =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath TestsResultsDirectory =\u003E ArtifactsDirectory / \u0022tests\u0022;\n    AbsolutePath CodeCoverageDirectory =\u003E ArtifactsDirectory / \u0022coverage\u0022;\n    AbsolutePath CodeCoverageReportsDirectory =\u003E ArtifactsDirectory / \u0022coverage_reports\u0022;\n    AbsolutePath NuGetDirectory =\u003E ArtifactsDirectory / \u0022nuget\u0022;\n\n    \n    Target Reset =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(TemporaryDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n            EnsureCleanDirectory(ToolsPath);\n        })\n        .Triggers(Clean);\n    \n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target CompileProject =\u003E _ =\u003E _\n        .Unlisted()\n        .DependsOn(Clean, Restore)\n        .Executes(() =\u003E\n        {\n            var framework = GetFramework();\n            var version = GetVersion();\n\n            var assemblyVersion = SemVerRegex.IsMatch(version) \n                ? version.Substring(0, version.IndexOf(\u0022.\u0022, StringComparison.InvariantCulture)) \u002B \u0022.0.0.0\u0022\n                : \u00220.0.0.0\u0022;\n\n            Logger.Info(\u0022Assembly version: \u0022 \u002B assemblyVersion);\n\n            DotNetBuild(c =\u003E c\n                .EnableNoRestore()\n                .EnableTreatWarningsAsErrors()\n                .SetProjectFile(SourceDirectory / \u0022Validot/Validot.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .SetFramework(\u0022netstandard2.0\u0022)\n                .SetPackageId(Metadata.Title)\n                .SetTitle(Metadata.Title)\n                .SetDescription(Metadata.Description)\n                .SetRepositoryUrl(Metadata.RepositoryUrl)\n                .SetPackageIconUrl(Metadata.PackageIconUrl)\n                .SetAuthors(Metadata.Author)\n                .SetInformationalVersion(version)\n                .SetAssemblyVersion(assemblyVersion));\n        });\n    \n    Target CompileTests =\u003E _ =\u003E _\n        .Unlisted()\n        .DependsOn(Clean, Restore)\n        .After(CompileProject)\n        .Executes(() =\u003E\n        {\n            var framework = GetFramework();\n\n            var testsProjects = new[]\n            {\n                TestsDirectory / \u0022Validot.Tests.Unit/Validot.Tests.Unit.csproj\u0022\n            };\n\n            foreach (var testProject in testsProjects)\n            {\n                DotNetBuild(c =\u003E c\n                    .EnableNoRestore()\n                    .EnableTreatWarningsAsErrors()\n                    .SetProjectFile(testProject)\n                    .SetConfiguration(Configuration)\n                    .SetFramework(framework));\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(CompileProject, CompileTests);\n    \n    Target Tests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E\n        {\n            var framework = GetFramework();\n            var version = GetVersion();\n\n            DotNetTest(p =\u003E p\n                .EnableNoBuild()\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration.Release)\n                .SetFramework(framework)\n                .SetLogger($\u0022trx;LogFileName={TestsResultsDirectory / $\u0022Validot.{version}.tests.trx\u0022}\u0022)\n            );\n        });\n\n     Target CodeCoverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            var framework = GetFramework();\n            var version = GetVersion();\n\n            var reportFile = CodeCoverageDirectory / $\u0022Validot.{version}.opencover.xml\u0022;\n\n            DotNetTest(p =\u003E p\n                .EnableNoBuild()\n                .SetProjectFile(TestsDirectory / \u0022Validot.Tests.Unit/Validot.Tests.Unit.csproj\u0022)\n                .SetConfiguration(Configuration.Debug)\n                .SetFramework(framework)\n                .AddProperty(\u0022CollectCoverage\u0022, \u0022true\u0022)\n                .AddProperty(\u0022CoverletOutput\u0022, reportFile)\n                .AddProperty(\u0022CoverletOutputFormat\u0022, \u0022opencover\u0022)\n            );\n\n            File.Move(CodeCoverageDirectory / $\u0022Validot.{version}.opencover.{framework}.xml\u0022, reportFile);\n\n            Logger.Info(\u0022CodeCoverage opencover format file location: \u0022 \u002B reportFile);\n        });\n\n    Target CodeCoverageReport =\u003E _ =\u003E _\n        .DependsOn(CodeCoverage)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            var framework = GetFramework();\n            var version = GetVersion();\n\n            var reportFile = CodeCoverageDirectory / $\u0022Validot.{version}.opencover.xml\u0022;\n\n            var toolPath = InstallAndGetToolPath(\u0022dotnet-reportgenerator-globaltool\u0022, \u00224.5.1\u0022, \u0022ReportGenerator.dll\u0022, \u0022netcoreapp3.0\u0022);\n\n            var toolParameters = new[] \n            {\n                $\u0022-reports:{CodeCoverageDirectory / $\u0022Validot.{version}.opencover.xml\u0022}\u0022,\n                $\u0022-reporttypes:HtmlInline_AzurePipelines;JsonSummary\u0022,\n                $\u0022-targetdir:{CodeCoverageReportsDirectory / $\u0022Validot.{version}.coverage_report\u0022}\u0022,\n                $\u0022-historydir:{CodeCoverageReportsDirectory / \u0022_history\u0022}\u0022,\n                $\u0022-title:Validot unit tests code coverage report\u0022,\n                $\u0022-tag:v{version}\u0022 \u002B (CommitSha is null ? \u0022\u0022 : $\u0022, {CommitSha}\u0022),\n            };\n\n            ExecuteTool(toolPath, string.Join(\u0022 \u0022, toolParameters.Select(p =\u003E $\u0022\\\u0022{p}\\\u0022\u0022)));\n\n            File.Move(CodeCoverageReportsDirectory / $\u0022Validot.{version}.coverage_report/Summary.json\u0022, CodeCoverageReportsDirectory / $\u0022Validot.{version}.coverage_summary.json\u0022);\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var version = GetVersion();\n\n            DotNetPack(p =\u003E p\n                .EnableNoBuild()\n                .EnableIncludeSymbols()\n                .SetConfiguration(Configuration.Release)\n                .SetProject(SourceDirectory / \u0022Validot/Validot.csproj\u0022)\n                .SetVersion(version)\n                .SetOutputDirectory(NuGetDirectory / version)\n                .SetTitle(Metadata.Title)\n                .SetDescription(Metadata.Description)\n                .SetRepositoryUrl(Metadata.RepositoryUrl)\n                .SetPackageIconUrl(Metadata.PackageIconUrl)\n                .SetAuthors(Metadata.Author)\n                .SetPackageLicenseUrl(Metadata.PackageLicenceUrl)\n                .SetPackageTags(Metadata.Tags)\n            );\n        });\n\n    Target PublishPackage =\u003E _ =\u003E _\n        .DependsOn(Package)\n        .OnlyWhenDynamic(() =\u003E NuGetApiKey != null)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            var version = GetVersion();\n\n            DotNetNuGetPush(p =\u003E p\n                .SetSource(NuGetApi)\n                .SetApiKey(NuGetApiKey)\n                .SetTargetPath(NuGetDirectory / version / $\u0022Validot.{version}.nupkg\u0022)\n            );\n        });\n\n    Target PublishCodeCoverage =\u003E _ =\u003E _\n        .DependsOn(CodeCoverage)\n        .OnlyWhenDynamic(() =\u003E CodeCovApiKey != null)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            var framework = GetFramework();\n            var version = GetVersion();\n\n            var reportFile = CodeCoverageDirectory / $\u0022Validot.{version}.opencover.xml\u0022;\n\n            var toolPath = InstallAndGetToolPath(\u0022codecov.tool\u0022, \u00221.10.0\u0022, \u0022codecov.dll\u0022, \u0022netcoreapp3.0\u0022);\n\n            var toolParameters = new[] \n            {\n                $\u0022--sha {CommitSha}\u0022,\n                $\u0022--file {reportFile}\u0022,\n                $\u0022--token {CodeCovApiKey}\u0022,\n                $\u0022--required\u0022\n            };\n\n            ExecuteTool(toolPath, string.Join(\u0022 \u0022, toolParameters));\n        });\n    \n    string _framework = null;\n\n    string GetFramework()\n    {\n        if (_framework is null)\n        {\n            var defaultFramework = \u0022netcoreapp3.1\u0022;\n\n            if (DotNet is null)\n            {\n                Logger.Warn(\u0022DotNet: parameter not provided\u0022);\n                _framework = defaultFramework;\n            }\n            else if (DotNet.All(c =\u003E char.IsDigit(c) || c == \u0027.\u0027))\n            {\n                Logger.Info($\u0022DotNet parameter recognized as SDK version: \u0022 \u002B DotNet);\n\n                if (DotNet.StartsWith(\u00222.1.\u0022))\n                {\n                    _framework = \u0022netcoreapp2.1\u0022;\n                }\n                else if (DotNet.StartsWith(\u00223.1.\u0022))\n                {\n                    _framework = \u0022netcoreapp3.1\u0022;\n                }\n                else\n                {\n                    Logger.Warn(\u0022Unrecognized dotnet SDK version: \u0022 \u002B DotNet);\n                    \n                    _framework = DotNet;\n                }\n            }\n            else\n            {\n                Logger.Warn(\u0022Unrecognized dotnet framework id: \u0022 \u002B DotNet);\n\n                _framework = DotNet;\n            }\n\n            Logger.Info(\u0022DotNet: \u0022 \u002B _framework);\n        }\n\n        return _framework;\n    }\n    \n    string _version = null;\n\n    string GetVersion()\n    {\n        if (_version is null)\n        {\n            if (Version is null)\n            {\n                Logger.Warn(\u0022Version: not provided.\u0022);\n                _version = $\u00220.0.0-{BuildTime.DayOfYear}{BuildTime.ToString(\u0022HHmmss\u0022, CultureInfo.InvariantCulture)}\u0022;\n            }\n            else\n            {\n                _version = Version;\n            }\n\n            Logger.Info(\u0022Version: \u0022 \u002B _version);\n        }\n\n        return _version;\n    }\n\n    string _nuGetApi = null;\n\n    string GetNuGetApi() \n    {\n        if (_nuGetApi is null) \n        {\n            if (NuGetApi is null) \n            {\n                Logger.Warn(\u0022NuGetServer: not provided.\u0022);\n\n                _nuGetApi = \u0022https://api.nuget.org/v3/index.json\u0022;\n            }\n            else \n            {\n                _nuGetApi = NuGetApi;\n            }\n\n            Logger.Info(\u0022NuGetApi:\u0022 \u002B _nuGetApi);\n        }\n\n        return _nuGetApi;\n    }\n\n    void ExecuteTool(string toolPath, string parameters) \n    {\n        ProcessTasks.StartProcess(ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022), toolPath \u002B \u0022 -- \u0022 \u002B parameters).AssertZeroExitCode();\n    }\n\n    string InstallAndGetToolPath(string name, string version,  string executableFileName, string framework = null) \n    {\n        var frameworkPart = framework is null ? $\u0022 (framework {framework})\u0022 : string.Empty;\n\n        var toolStamp = $\u0022{name} {version}{frameworkPart}, executable file: {executableFileName}\u0022;\n\n        Logger.Info($\u0022Looking for tool: {toolStamp}\u0022);\n\n        var toolPath = GetToolPath();\n\n        if (toolPath is null) \n        {\n            DotNetToolInstall(c =\u003E c\n                    .SetPackageName(name)\n                    .SetVersion(version)\n                    .SetToolInstallationPath(ToolsPath)\n                    .SetGlobal(false)); \n        }\n\n        toolPath = GetToolPath();\n\n        if (toolPath is null) \n        {\n            Logger.Error($\u0022Unable to find tool path: {name} {version} {executableFileName} {framework}\u0022);\n        }\n\n        return toolPath;\n        \n        string GetToolPath() \n        {\n            var frameworkPart = framework != null ? (framework \u002B \u0022/**/\u0022) : string.Empty;\n\n            return GlobFiles(ToolsPath, $\u0022**/{name}/{version}/**/{frameworkPart}{executableFileName}\u0022).FirstOrDefault();\n        }\n\n    }\n\n    \n}\n"
  },
  {
    "Id": 242592780,
    "FirstIndexed": "2020-04-25T15:47:03.6110612+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629725+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432796+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938582+02:00",
    "Name": "SimplePool",
    "Owner": "AleXr64",
    "HtmlUrl": "https://github.com/AleXr64/SimplePool",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/AleXr64/SimplePool/blob/master/build/Build.cs",
    "BuildFileSize": 3415,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build: NukeBuild\n{\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    [Parameter(\u0022NuGet Api Key\u0022)] readonly string NugetAPIKey;\n\n    [Solution] readonly Solution Solution;\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Parameter] string NugetApiKey;\n\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E\n        _ =\u003E _\n            .Before(Restore)\n            .Executes(() =\u003E\n             {\n                 EnsureCleanDirectory(OutputDirectory);\n             });\n\n    Target Restore =\u003E\n        _ =\u003E _\n           .Executes(() =\u003E\n            {\n                DotNetRestore(_ =\u003E _\n                                 .SetProjectFile(Solution));\n            });\n\n    Target Compile =\u003E\n        _ =\u003E _\n            .DependsOn(Restore)\n            .Executes(() =\u003E\n             {\n                 DotNetBuild(_ =\u003E _\n                                 .SetProjectFile(Solution)\n                                 .SetConfiguration(Configuration)\n                                 .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                                 .SetFileVersion(GitVersion.AssemblySemFileVer)\n                                 .SetInformationalVersion(GitVersion.InformationalVersion)\n                                 .EnableNoRestore());\n             });\n\n    AbsolutePath PackageDirectory =\u003E OutputDirectory / \u0022packages\u0022;\n\n    Target Test =\u003E\n        _ =\u003E _\n            .DependsOn(Compile)\n            .Executes(() =\u003E\n             {\n                 DotNetTest(_ =\u003E _\n                                .SetConfiguration(Configuration)\n                                .SetNoBuild(InvokedTargets.Contains(Compile))\n                                .ResetVerbosity());\n             });\n\n    Target Pack =\u003E\n       _ =\u003E _\n           .DependsOn(Test)\n           .Produces(PackageDirectory / \u0022*.nupkg\u0022)\n           .Executes(() =\u003E\n           {\n               DotNetPack(s =\u003E s\n                               .SetProject(Solution)\n                               .SetOutputDirectory(PackageDirectory));\n           });\n\n\n    Target Push =\u003E\n        _ =\u003E _\n            .DependsOn(Pack)\n            .Executes(() =\u003E\n             {\n                 var packages = PackageDirectory.GlobFiles(\u0022*.nupkg\u0022);\n                 DotNetNuGetPush(_ =\u003E _\n                                     .SetSource(Source)\n                                     .SetApiKey(NugetAPIKey)\n                                     .CombineWith(packages, (_, v) =\u003E _\n                                                     .SetTargetPath(v)),\n                                 5,\n                                 true);\n             });\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Push);\n}\n"
  },
  {
    "Id": 243665178,
    "FirstIndexed": "2020-04-25T15:47:03.6108405+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628041+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432807+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938594+02:00",
    "Name": "dotnet-template-repo",
    "Owner": "grumpydev-net",
    "HtmlUrl": "https://github.com/grumpydev-net/dotnet-template-repo",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/grumpydev-net/dotnet-template-repo/blob/master/build/Build.cs",
    "BuildFileSize": 2158,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 243991968,
    "FirstIndexed": "2020-04-25T15:50:44.735919+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629674+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434605+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940323+02:00",
    "Name": "clean",
    "Owner": "sunnysgithub",
    "HtmlUrl": "https://github.com/sunnysgithub/clean",
    "Description": "Clean Architecture Example",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/sunnysgithub/clean/blob/master/build/Build.cs",
    "BuildFileSize": 2332,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.IO;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 244171126,
    "FirstIndexed": "2020-04-25T15:47:03.6109668+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628695+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432818+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938605+02:00",
    "Name": "XsDupFinder",
    "Owner": "VolkmarR",
    "HtmlUrl": "https://github.com/VolkmarR/XsDupFinder",
    "Description": "XSharp dupicate code finder",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/VolkmarR/XsDupFinder/blob/master/build/Build.cs",
    "BuildFileSize": 3519,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.CI;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\n    \u0022publish\u0022, \n    GitHubActionsImage.WindowsLatest, \n    On = new GitHubActionsTrigger[] { GitHubActionsTrigger.PullRequest },\n    InvokedTargets = new string[]{ nameof(Publish) }\n    )]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath PublishFileName =\u003E ArtifactsDirectory / \u0022XsDupFinder.zip\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetVerbosity(MSBuildVerbosity.Minimal)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .Produces(PublishFileName)\n        .DependsOn(Clean)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var OutputDirectory = ArtifactsDirectory / \u0022XsDupeFinder\u0022;\n\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution.GetProject(\u0022XsDupFinderCmd\u0022))\n                .SetTargets(\u0022Build\u0022)\n                .SetOutDir(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetVerbosity(MSBuildVerbosity.Quiet)\n                .SetNodeReuse(IsLocalBuild));\n\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution.GetProject(\u0022XsDupFinderWin\u0022))\n                .SetTargets(\u0022Build\u0022)\n                .SetOutDir(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .SetVerbosity(MSBuildVerbosity.Quiet)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n\n            CopyFileToDirectory(SourceDirectory / \u0022..\u0022 / \u0022readme.md\u0022, OutputDirectory);\n            CopyFileToDirectory(SourceDirectory / \u0022..\u0022 / \u0022LICENSE\u0022, OutputDirectory);\n\n            Compress(OutputDirectory, PublishFileName);\n        });\n}\n"
  },
  {
    "Id": 244669905,
    "FirstIndexed": "2020-04-25T15:47:03.6110566+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629514+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843283+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938616+02:00",
    "Name": "NSubstitute.FluentAssertionsBridge",
    "Owner": "PapGroup",
    "HtmlUrl": "https://github.com/PapGroup/NSubstitute.FluentAssertionsBridge",
    "Description": "a library for bridging between NSubstitute and FluentAssertions",
    "Archived": false,
    "Stars": 2,
    "Watchers": 2,
    "BuildFilePath": "buildscript/Build.cs",
    "BuildFileUrl": "https://github.com/PapGroup/NSubstitute.FluentAssertionsBridge/blob/master/buildscript/Build.cs",
    "BuildFileSize": 2559,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022Directory which artifacts of build will be placed - Default is \u0027artifacts\u0027 folder in root directory of project\u0022)]\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetClean(a =\u003E a.SetProject(Solution));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(a =\u003E a.SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(a =\u003E\n                a.SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetNoRestore(true)\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(a =\u003E\n                a.SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetNoRestore(true)\n                    .SetNoBuild(true));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(RunTests)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022PAP.NSubstitute.FluentAssertionsBridge\u0022))\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetNoBuild(true)\n                .SetNoRestore(true)\n                .SetConfiguration(Configuration)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n}\n"
  },
  {
    "Id": 244850635,
    "FirstIndexed": "2020-04-25T15:50:44.735915+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629645+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434593+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940312+02:00",
    "Name": "NukeExampleApp",
    "Owner": "darkcell-net",
    "HtmlUrl": "https://github.com/darkcell-net/NukeExampleApp",
    "Description": "Example application using Nuke for CI/CD",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Targets/Build.cs",
    "BuildFileUrl": "https://github.com/darkcell-net/NukeExampleApp/blob/master/build/Targets/Build.cs",
    "BuildFileSize": 2997,
    "BuildFileContent": "\uFEFFusing Build.Settings;\nusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing System.IO;\nusing System.IO.Compression;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nnamespace Build.Targets\n{\n    public partial class Build : NukeBuild\n    {\n        private string _buildVersion;\n        private GlobalSettings _globalSettings;\n\n        public Target Clean =\u003E _ =\u003E _\n            .Description(\u0022Remove previous build output\u0022)\n            .Executes(() =\u003E EnsureCleanDirectory(Settings.BuildOutputDirectory));\n\n        public Target Compile =\u003E _ =\u003E _\n            .DependsOn(Clean)\n            .Description(\u0022Build all projects in the solution\u0022)\n            .Executes(() =\u003E DotNetBuild(settings =\u003E settings.SetProjectFile(Solution.Path)));\n\n        public Target Package =\u003E _ =\u003E _\n            .Description(\u0022Package the application\u0022)\n            .DependsOn(Test)\n            .Executes(() =\u003E\n            {\n                DotNetPublish(\n                    settings =\u003E settings\n                        .SetConfiguration(\u0022Release\u0022)\n                        .SetRuntime(\u0022linux-x64\u0022)\n                        .SetProperty(\u0022Version\u0022, GetBuildVersion())\n                        .SetOutput(Settings.PublishDirectory)\n                        .SetProject(Settings.SourceDirectory / \u0022NukeExampleApp\u0022));\n\n                string packagePath = Settings.PackageDirectory / $\u0022NukeExampleApp_{GetBuildVersion()}.zip\u0022;\n\n                Directory.CreateDirectory(Settings.PackageDirectory);\n                ZipFile.CreateFromDirectory(Settings.PublishDirectory, packagePath);\n\n                using (FileStream zipStream = File.Open(packagePath, FileMode.Open))\n                {\n                    using (var archive = new ZipArchive(zipStream, ZipArchiveMode.Update))\n                    {\n                        foreach (ZipArchiveEntry entry in archive.Entries)\n                        {\n                            entry.ExternalAttributes = (entry.Name == \u0022NukeExampleApp\u0022 ? 0x81e4 : 0x81a4) \u003C\u003C 16;\n                        }\n                    }\n                }\n            });\n\n        public Target Test =\u003E _ =\u003E _\n            .Description(\u0022Perform all unit tests\u0022)\n            .DependsOn(Compile)\n            .Executes(() =\u003E DotNetTest(\n                settings =\u003E settings\n                    .SetProjectFile(Settings.TestDirectory / \u0022Tests\u0022)\n                    .EnableNoBuild()));\n\n        private GlobalSettings Settings =\u003E _globalSettings = _globalSettings ?? new GlobalSettings(RootDirectory);\n\n        [Solution(\u0022NukeExampleApp.sln\u0022)]\n        private Solution Solution { get; }\n\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n        private string GetBuildVersion()\n        {\n            // Normally we would check with GIT to get a commit count, but hardcode for now.\n            if (_buildVersion != null) { return _buildVersion; }\n\n            return _buildVersion = $\u00220.0.1\u0022;\n        }\n    }\n}"
  },
  {
    "Id": 244900639,
    "FirstIndexed": "2020-04-25T15:47:03.6110538+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629503+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432835+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938628+02:00",
    "Name": "NSubstitute.NFluentBridge",
    "Owner": "PapGroup",
    "HtmlUrl": "https://github.com/PapGroup/NSubstitute.NFluentBridge",
    "Description": "a library for bridging between NSubstitute and NFluent",
    "Archived": false,
    "Stars": 1,
    "Watchers": 2,
    "BuildFilePath": "buildscript/Build.cs",
    "BuildFileUrl": "https://github.com/PapGroup/NSubstitute.NFluentBridge/blob/master/buildscript/Build.cs",
    "BuildFileSize": 2549,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022Directory which artifacts of build will be placed - Default is \u0027artifacts\u0027 folder in root directory of project\u0022)]\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetClean(a =\u003E a.SetProject(Solution));\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(a =\u003E a.SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(a =\u003E\n                a.SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetNoRestore(true)\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n\n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(a =\u003E\n                a.SetProjectFile(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetNoRestore(true)\n                    .SetNoBuild(true));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(RunTests)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022PAP.NSubstitute.NFluentBridge\u0022))\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetNoBuild(true)\n                .SetNoRestore(true)\n                .SetConfiguration(Configuration)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n}\n"
  },
  {
    "Id": 245118643,
    "FirstIndexed": "2020-04-25T15:47:03.6108985+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628331+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432847+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938633+02:00",
    "Name": "results",
    "Owner": "vkamiansky",
    "HtmlUrl": "https://github.com/vkamiansky/results",
    "Description": "A C# framework for building railroad-oriented code with results.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/vkamiansky/results/blob/master/build/Build.cs",
    "BuildFileSize": 3642,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI.AppVeyor;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Nuget API key for publishing packages\u0022)] readonly string NugetKey;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022out\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .OnlyWhenDynamic(() =\u003E IsLocalBuild || AppVeyor.Instance.RepositoryTag)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.AssemblySemVer)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild());\n        });\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .OnlyWhenDynamic(() =\u003E IsLocalBuild || AppVeyor.Instance.RepositoryTag,\n                         () =\u003E AppVeyor.Instance != null \u0026\u0026 AppVeyor.Instance.RepositoryBranch == \u0022master\u0022,\n                         () =\u003E AppVeyor.Instance != null \u0026\u0026 !string.IsNullOrWhiteSpace(AppVeyor.Instance.RepositoryTagName))\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                .SetApiKey(NugetKey)\n                .SetTargetPath(OutputDirectory));\n        });\n\n    Target CompleteWorkflow =\u003E _ =\u003E _\n        .Triggers(Publish);\n}\n"
  },
  {
    "Id": 245684168,
    "FirstIndexed": "2020-04-25T15:47:03.6110305+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629571+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432864+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938645+02:00",
    "Name": "ProvisionData.Internet",
    "Owner": "provisiondata",
    "HtmlUrl": "https://github.com/provisiondata/ProvisionData.Internet",
    "Description": "Provides .NETStandard 2.0 compatible types like DomainName, Label, Serial and TTL.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/provisiondata/ProvisionData.Internet/blob/master/build/Build.cs",
    "BuildFileSize": 6318,
    "BuildFileContent": "namespace ProvisionData.Build\r\n{\r\n    using System;\r\n    using System.Linq;\r\n    using Nuke.Common;\r\n    using Nuke.Common.Execution;\r\n    using Nuke.Common.Git;\r\n    using Nuke.Common.IO;\r\n    using Nuke.Common.ProjectModel;\r\n    using Nuke.Common.Tooling;\r\n    using Nuke.Common.Tools.DotNet;\r\n    using Nuke.Common.Tools.GitVersion;\r\n    using Nuke.Common.Utilities.Collections;\r\n    using static Nuke.Common.IO.FileSystemTasks;\r\n    using static Nuke.Common.IO.PathConstruction;\r\n    using static Nuke.Common.Tools.DotNet.DotNetTasks;\r\n    using static Nuke.GitHub.ChangeLogExtensions;\r\n\r\n    [CheckBuildProjectConfigurations]\r\n    [UnsetVisualStudioEnvironmentVariables]\r\n    class Build : NukeBuild\r\n    {\r\n        // Support plug-ins are available for:\r\n        //   - JetBrains ReSharper        https://nuke.build/resharper\r\n        //   - JetBrains Rider            https://nuke.build/rider\r\n        //   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n        //   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n        public static Int32 Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n        [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n        readonly Configuration Configuration = Configuration.Release;\r\n\r\n        [Parameter(\u0022Explicit framework to build\u0022)] readonly String Framework;\r\n        [Parameter(\u0022NuGet API Key\u0022)] readonly String NuGetApiKey;\r\n        [Parameter(\u0022PDSI API Key\u0022)] readonly String PdsiApiKey;\r\n\r\n        [Solution] readonly Solution Solution;\r\n        [GitRepository] readonly GitRepository GitRepository;\r\n        [GitVersion] readonly GitVersion GitVersion;\r\n\r\n        AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\r\n        AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n        AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n        String ChangeLogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\r\n\r\n        Target Clean =\u003E _ =\u003E _\r\n            .Executes(() =\u003E\r\n            {\r\n                SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n                TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n                EnsureCleanDirectory(ArtifactsDirectory);\r\n            });\r\n\r\n        Target Restore =\u003E _ =\u003E _\r\n            .DependsOn(Clean)\r\n            .Executes(() =\u003E\r\n            {\r\n                DotNetRestore(_ =\u003E _\r\n                    .SetProjectFile(Solution));\r\n            });\r\n\r\n        Target Compile =\u003E _ =\u003E _\r\n            .DependsOn(Restore)\r\n            .Executes(() =\u003E\r\n            {\r\n                DotNetBuild(_ =\u003E _\r\n                    .SetProjectFile(Solution)\r\n                    .SetConfiguration(Configuration)\r\n                    .EnableNoRestore());\r\n            });\r\n\r\n        Target Publish =\u003E _ =\u003E _\r\n            .DependsOn(Compile)\r\n            .Executes(() =\u003E\r\n            {\r\n                var publishCombinations = from project in Solution.Projects\r\n                                          from framework in project.GetTargetFrameworks()\r\n                                          select new { project, framework };\r\n\r\n                DotNetPublish(_ =\u003E _\r\n                    .EnableNoRestore()\r\n                    .SetConfiguration(Configuration)\r\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                    .CombineWith(publishCombinations, (oo, v) =\u003E oo\r\n                        .SetProject(v.project)\r\n                        .SetFramework(v.framework)\r\n                        )\r\n                    );\r\n            });\r\n\r\n        Target Test =\u003E _ =\u003E _\r\n                   .DependsOn(Publish)\r\n                   .Executes(() =\u003E\r\n                   {\r\n                       DotNetTest(s =\u003E s\r\n                           .SetConfiguration(Configuration)\r\n                           .EnableNoBuild()\r\n                           .EnableNoRestore()\r\n                           .SetLogger(\u0022trx\u0022)\r\n                           .SetLogOutput(true)\r\n                           .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022))\r\n                           .SetResultsDirectory(TestsDirectory / \u0022results\u0022));\r\n                   });\r\n\r\n        Target Pack =\u003E _ =\u003E _\r\n            .DependsOn(Test)\r\n            .Executes(() =\u003E\r\n            {\r\n                var changeLog = GetCompleteChangeLog(ChangeLogFile)\r\n                                    .EscapeStringPropertyForMsBuild();\r\n\r\n               DotNetPack(s =\u003E s\r\n                    .SetConfiguration(Configuration)\r\n                    .EnableIncludeSymbols()\r\n                    .EnableNoBuild()\r\n                    .EnableNoRestore()\r\n                    .SetProperty(\u0022PackageVersion\u0022, GitVersion.NuGetVersionV2)\r\n                    .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022)\r\n                    .SetPackageReleaseNotes(changeLog));\r\n           });\r\n\r\n        Target PushToNuGet =\u003E _ =\u003E _\r\n            .DependsOn(Pack)\r\n            .Requires(() =\u003E NuGetApiKey)\r\n            .Requires(() =\u003E Equals(Configuration, Configuration.Release))\r\n            .Executes(() =\u003E\r\n            {\r\n                GlobFiles(ArtifactsDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\r\n                    .NotEmpty()\r\n                    .Where(x =\u003E !x.EndsWith(\u0022.symbols.nupkg\u0022))\r\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                        .SetTargetPath(x)\r\n                        .SetSource(\u0022https://api.nuget.org/v3/index.json\u0022)\r\n                        .SetApiKey(NuGetApiKey))\r\n                    );\r\n         });\r\n\r\n        Target PushToPdsi =\u003E _ =\u003E _\r\n            .DependsOn(Pack)\r\n            .Requires(() =\u003E PdsiApiKey)\r\n            .Requires(() =\u003E Equals(Configuration, Configuration.Release))\r\n            .Executes(() =\u003E\r\n            {\r\n                GlobFiles(ArtifactsDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\r\n                    .NotEmpty()\r\n                    .ForEach(x =\u003E DotNetNuGetPush(s =\u003E s\r\n                        .SetTargetPath(x)\r\n                        .SetSource(\u0022https://baget.pdsint.net/v3/index.json\u0022)\r\n                        .SetApiKey(PdsiApiKey)));\r\n         });\r\n    }\r\n}\r\n"
  },
  {
    "Id": 245684220,
    "FirstIndexed": "2020-04-25T15:47:03.6110282+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622261+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432869+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938656+02:00",
    "Name": "DryIoc.Extensions",
    "Owner": "RocketSurgeonsGuild",
    "HtmlUrl": "https://github.com/RocketSurgeonsGuild/DryIoc.Extensions",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": ".build/Build.cs",
    "BuildFileUrl": "https://github.com/RocketSurgeonsGuild/DryIoc.Extensions/blob/master/.build/Build.cs",
    "BuildFileSize": 1726,
    "BuildFileContent": "using JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Rocket.Surgery.Nuke;\nusing Rocket.Surgery.Nuke.DotNetCore;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[AzurePipelinesSteps(\n    InvokedTargets = new[] { nameof(Default) },\n    NonEntryTargets = new[] { nameof(BuildVersion), nameof(Generate_Code_Coverage_Reports), nameof(Default) },\n    ExcludedTargets = new[] { nameof(Restore), nameof(DotnetToolRestore) },\n    Parameters = new[] { nameof(CoverageDirectory), nameof(ArtifactsDirectory), nameof(Verbosity), nameof(Configuration) }\n)]\n[PackageIcon(\n    \u0022https://raw.githubusercontent.com/RocketSurgeonsGuild/graphics/master/png/social-square-thrust-rounded.png\u0022\n)]\n[EnsurePackageSourceHasCredentials(\u0022RocketSurgeonsGuild\u0022)]\n[EnsureGitHooks(GitHook.PreCommit)]\ninternal class Solution : DotNetCoreBuild, IDotNetCoreBuild\n{\n    /// \u003Csummary\u003E\n    /// Support plugins are available for:\n    /// - JetBrains ReSharper        https://nuke.build/resharper\n    /// - JetBrains Rider            https://nuke.build/rider\n    /// - Microsoft VisualStudio     https://nuke.build/visualstudio\n    /// - Microsoft VSCode           https://nuke.build/vscode\n    /// \u003C/summary\u003E\n    public static int Main() =\u003E Execute\u003CSolution\u003E(x =\u003E x.Default);\n\n    private Target Default =\u003E _ =\u003E _\n       .DependsOn(Restore)\n       .DependsOn(Build)\n       .DependsOn(Test)\n       .DependsOn(Pack);\n\n    public Target Restore =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Restore);\n\n    public Target Build =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Build);\n\n    public Target Test =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Test);\n\n    public Target Pack =\u003E _ =\u003E _.With(this, DotNetCoreBuild.Pack);\n}"
  },
  {
    "Id": 246042589,
    "FirstIndexed": "2020-04-25T15:47:03.6110253+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162956+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432881+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938668+02:00",
    "Name": "learn-nuke",
    "Owner": "tkvw",
    "HtmlUrl": "https://github.com/tkvw/learn-nuke",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/tkvw/learn-nuke/blob/master/build/Build.cs",
    "BuildFileSize": 2415,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 246130834,
    "FirstIndexed": "2020-04-25T15:47:03.6109764+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629247+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432892+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938679+02:00",
    "Name": "tand",
    "Owner": "baez90",
    "HtmlUrl": "https://github.com/baez90/tand",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/baez90/tand/blob/master/build/Build.cs",
    "BuildFileSize": 3880,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static _build.benchmarks.DotNetBenchmarkExtensions;\n\n[GitHubActions(\n        \u0022dotnet\u0022,\n        GitHubActionsImage.UbuntuLatest,\n        AutoGenerate = false,\n        On = new []{GitHubActionsTrigger.Push, GitHubActionsTrigger.PullRequest}\n    )\n]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Pack);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022test\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution))\n        );\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .DependsOn(Clean)\n        .Executes(() =\u003E DotNetBuild(s =\u003E s\n            .SetProjectFile(Solution)\n            .SetConfiguration(Configuration)\n            .SetAssemblyVersion(GitVersion.AssemblySemVer)\n            .SetFileVersion(GitVersion.AssemblySemFileVer)\n            .SetInformationalVersion(GitVersion.InformationalVersion)\n            .EnableNoRestore()));\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E DotNetTest(s =\u003E s\n            .SetProjectFile(Solution)\n            .SetConfiguration(Configuration)\n            .EnableNoRestore()\n            .EnableNoBuild()\n            .EnableLogOutput()));\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .OnlyWhenStatic(() =\u003E GitRepository.IsOnMasterBranch())\n        .Executes(() =\u003E SourceDirectory\n            .GlobFiles(\u0022**/*.csproj\u0022)\n            .ForEach(csproj =\u003E DotNetPack(s =\u003E s\n                .SetProject(csproj)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.FullSemVer)\n                .EnableIncludeSource()\n                .EnableIncludeSymbols()\n                .EnableNoRestore()\n                .EnableNoBuild()\n                .EnableLogOutput()\n            )));\n\n    Target Benchmark =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E TestsDirectory\n            .GlobFiles($\u0022**/bin/{Configuration}/**/*Benchmark*.dll\u0022)\n            .ForEach(benchmarkFile =\u003E DotNetBenchmark(\n                s =\u003E s\n                    .WithFilter(\u0022*\u0022)\n                    .WithDllPath(benchmarkFile)))\n        );\n}"
  },
  {
    "Id": 246253626,
    "FirstIndexed": "2020-04-25T15:47:03.6110231+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629543+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432904+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938685+02:00",
    "Name": "learn-nuke-build",
    "Owner": "tkvw",
    "HtmlUrl": "https://github.com/tkvw/learn-nuke-build",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/tkvw/learn-nuke-build/blob/develop/build/Build.cs",
    "BuildFileSize": 2976,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    string ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022; \n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile,GitRepository))\n                .SetOutputDirectory(OutputDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableIncludeSymbols()\n                .SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n            );\n        });\n}\n"
  },
  {
    "Id": 246595763,
    "FirstIndexed": "2020-04-25T15:47:03.6110134+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627534+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432909+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938696+02:00",
    "Name": "Validot",
    "Owner": "bartoszlenar",
    "HtmlUrl": "https://github.com/bartoszlenar/Validot",
    "Description": "Tiny lib for great validations",
    "Archived": false,
    "Stars": 1,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/bartoszlenar/Validot/blob/master/build/Build.cs",
    "BuildFileSize": 16943,
    "BuildFileContent": "using System;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tooling;\n\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    static class Metadata \n    {\n        public static string Title =\u003E \u0022Validot\u0022;\n\n        public static string Description =\u003E \u0022Tiny lib for great validations\u0022;\n\n        public static string Author =\u003E \u0022Bartosz Lenar\u0022;\n\n        public static string RepositoryUrl =\u003E \u0022http://github.com/bartoszlenar/Validot\u0022;\n\n        public static string PackageIconUrl =\u003E \u0022https://github.com/bartoszlenar/Validot/raw/master/logo/icon.png\u0022;\n\n        public static string PackageLicenceUrl =\u003E \u0022https://github.com/bartoszlenar/Validot/blob/master/LICENSE\u0022;\n\n        public static string[] Tags =\u003E new [] { \u0022validot\u0022, \u0022validation\u0022, \u0022validator\u0022, \u0022fluent\u0022, \u0022fluent-api\u0022 };\n    }\n\n    static readonly Regex SemVerRegex = new Regex(@\u0022^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\u002B([0-9a-zA-Z-]\u002B(?:\\.[0-9a-zA-Z-]\u002B)*))?$\u0022, RegexOptions.Compiled);\n\n    static readonly Regex TargetFrameworkRegex = new Regex(@\u0022\u003CTargetFramework\u003E.\u002B\u003C\\/TargetFramework\u003E\u0022, RegexOptions.Compiled);\n    \n    static readonly DateTimeOffset BuildTime = DateTimeOffset.UtcNow;\n\n    static readonly string DefaultFrameworkId = \u0022netcoreapp3.1\u0022;\n    \n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter]\n    Configuration Configuration = Configuration.Debug;\n    \n    [Parameter(\u0022dotnet framework id or SDK version (if SDK version is provided, the highest framework available is selected). Default value is \u0027netcoreapp3.1\u0027\u0022)]\n    string DotNet;\n    \n    [Parameter(\u0022Version. Default value is \u00270.0.0-timestamp\u0027\u0022)]\n    string Version;\n\n    [Parameter(\u0022NuGet API. Where to publish NuGet package. Default value is \u0027https://api.nuget.org/v3/index.json\u0027\u0022)]\n    string NuGetApi = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Parameter(\u0022NuGet API key, allows to publish NuGet package.\u0022)]\n    string NuGetApiKey;\n\n    [Parameter(\u0022CodeCov API key, allows to publish code coverage.\u0022)]\n    string CodeCovApiKey;\n    \n    [Parameter(\u0022Commit SHA\u0022)]\n    string CommitSha;\n    \n    [Parameter(\u0022If true, BenchmarkDotNet will run \u0027short\u0027 jobs.\u0022)]\n    bool QuickBenchmark;\n    \n    [Parameter(\u0022Allow warnings\u0022)]\n    bool AllowWarnings;\n\n    [Solution] readonly Solution Solution;\n    \n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ToolsPath =\u003E RootDirectory / \u0022tools\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath TestsResultsDirectory =\u003E ArtifactsDirectory / \u0022tests\u0022;\n    AbsolutePath CodeCoverageDirectory =\u003E ArtifactsDirectory / \u0022coverage\u0022;\n    AbsolutePath CodeCoverageReportsDirectory =\u003E ArtifactsDirectory / \u0022coverage_reports\u0022;\n    AbsolutePath BenchmarksDirectory =\u003E ArtifactsDirectory / \u0022benchmarks\u0022;\n    AbsolutePath NuGetDirectory =\u003E ArtifactsDirectory / \u0022nuget\u0022;\n\n    protected override void OnBuildInitialized()\n    {\n        base.OnBuildCreated();\n\n        DotNet = GetFramework(DotNet);\n        Logger.Info($\u0022DotNet: {DotNet}\u0022);\n        \n        Version = GetVersion(Version);\n        Logger.Info($\u0022Version: {Version}\u0022);\n\n        Logger.Info($\u0022NuGetApi: {NuGetApi ?? \u0022MISSING\u0022}\u0022);\n        Logger.Info($\u0022Configuration: {Configuration}\u0022);\n        Logger.Info($\u0022CommitSha: {CommitSha ?? \u0022MISSING\u0022}\u0022);\n        Logger.Info($\u0022AllowWarnings: {AllowWarnings}\u0022);\n        \n        Logger.Info($\u0022CommitSha: {CommitSha ?? \u0022MISSING\u0022}\u0022);\n        Logger.Info($\u0022QuickBenchmark: {QuickBenchmark}\u0022);\n\n        var nuGetApiKeyPresence = (NuGetApiKey is null) ? \u0022MISSING\u0022 : \u0022present\u0022;\n        Logger.Info($\u0022NuGetApiKey: {nuGetApiKeyPresence}\u0022);\n        \n        var codeCovApiKeyPresence = (CodeCovApiKey is null) ? \u0022MISSING\u0022 : \u0022present\u0022;\n        Logger.Info($\u0022CodeCovApiKey: {codeCovApiKeyPresence}\u0022);\n\n        SetFrameworkInTests(DotNet);\n    }\n\n    protected override void OnBuildFinished()\n    {\n        ResetFrameworkInTests();\n\n        base.OnBuildFinished();\n    }\n\n    Target Reset =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(TemporaryDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n            EnsureCleanDirectory(ToolsPath);\n            ResetFrameworkInTests();\n        })\n        .Triggers(Clean);\n    \n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target CompileProject =\u003E _ =\u003E _\n        .Unlisted()\n        .DependsOn(Clean, Restore)\n        .Executes(() =\u003E\n        {\n            var assemblyVersion = SemVerRegex.IsMatch(Version) \n                ? Version.Substring(0, Version.IndexOf(\u0022.\u0022, StringComparison.InvariantCulture)) \u002B \u0022.0.0.0\u0022\n                : \u00220.0.0.0\u0022;\n\n            Logger.Info(\u0022Assembly version: \u0022 \u002B assemblyVersion);\n\n            DotNetBuild(c =\u003E c\n                .EnableNoRestore()\n                .SetTreatWarningsAsErrors(!AllowWarnings)\n                .SetProjectFile(SourceDirectory / \u0022Validot/Validot.csproj\u0022)\n                .SetConfiguration(Configuration)\n                .SetFramework(\u0022netstandard2.0\u0022)\n                .SetPackageId(Metadata.Title)\n                .SetTitle(Metadata.Title)\n                .SetDescription(Metadata.Description)\n                .SetRepositoryUrl(Metadata.RepositoryUrl)\n                .SetPackageIconUrl(Metadata.PackageIconUrl)\n                .SetAuthors(Metadata.Author)\n                .SetInformationalVersion(Version)\n                .SetAssemblyVersion(assemblyVersion));\n        });\n    \n    Target CompileTests =\u003E _ =\u003E _\n        .Unlisted()\n        .DependsOn(Clean, Restore)\n        .After(CompileProject)\n        .Executes(() =\u003E\n        {\n            var testsProjects = new[]\n            {\n                TestsDirectory / \u0022Validot.Tests.Unit/Validot.Tests.Unit.csproj\u0022,\n                TestsDirectory / \u0022Validot.Tests.Functional/Validot.Tests.Functional.csproj\u0022\n            };\n\n            foreach (var testProject in testsProjects)\n            {\n                DotNetBuild(c =\u003E c\n                    .EnableNoRestore()\n                    .SetTreatWarningsAsErrors(!AllowWarnings)\n                    .SetProjectFile(testProject)\n                    .SetConfiguration(Configuration)\n                    .SetFramework(DotNet));\n            }\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(CompileProject, CompileTests);\n    \n    Target Tests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .ProceedAfterFailure()\n        .Executes(() =\u003E\n        {\n            DotNetTest(p =\u003E p\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetProjectFile(TestsDirectory / \u0022Validot.Tests.Unit/Validot.Tests.Unit.csproj\u0022)\n                .SetFramework(DotNet)\n                .SetLogger($\u0022trx;LogFileName={TestsResultsDirectory / $\u0022Validot.{Version}.testresults\u0022/ $\u0022Validot.{Version}.unit.trx\u0022}\u0022)\n            );\n            \n            DotNetTest(p =\u003E p\n                .EnableNoBuild()\n                .SetConfiguration(Configuration)\n                .SetProjectFile(TestsDirectory / \u0022Validot.Tests.Functional/Validot.Tests.Functional.csproj\u0022)\n                .SetFramework(DotNet)\n                .SetLogger($\u0022trx;LogFileName={TestsResultsDirectory / $\u0022Validot.{Version}.testresults\u0022 / $\u0022Validot.{Version}.functional.trx\u0022}\u0022)\n            );\n        });\n\n    Target CodeCoverage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            var reportFile = CodeCoverageDirectory / $\u0022Validot.{Version}.opencover.xml\u0022;\n\n            DotNetTest(p =\u003E p\n                .EnableNoBuild()\n                .SetProjectFile(TestsDirectory / \u0022Validot.Tests.Unit/Validot.Tests.Unit.csproj\u0022)\n                .SetConfiguration(Configuration.Debug)\n                .SetFramework(DotNet)\n                .AddProperty(\u0022CollectCoverage\u0022, \u0022true\u0022)\n                .AddProperty(\u0022CoverletOutput\u0022, reportFile)\n                .AddProperty(\u0022CoverletOutputFormat\u0022, \u0022opencover\u0022)\n            );\n            \n            Logger.Info(\u0022CodeCoverage opencover format file location: \u0022 \u002B reportFile);\n        });\n\n    Target CodeCoverageReport =\u003E _ =\u003E _\n        .DependsOn(CodeCoverage)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            var toolPath = InstallAndGetToolPath(\u0022dotnet-reportgenerator-globaltool\u0022, \u00224.5.1\u0022, \u0022ReportGenerator.dll\u0022, \u0022netcoreapp3.0\u0022);\n\n            var toolParameters = new[] \n            {\n                $\u0022-reports:{CodeCoverageDirectory / $\u0022Validot.{Version}.opencover.xml\u0022}\u0022,\n                $\u0022-reporttypes:HtmlInline_AzurePipelines;JsonSummary\u0022,\n                $\u0022-targetdir:{CodeCoverageReportsDirectory / $\u0022Validot.{Version}.coverage_report\u0022}\u0022,\n                $\u0022-historydir:{CodeCoverageReportsDirectory / \u0022_history\u0022}\u0022,\n                $\u0022-title:Validot unit tests code coverage report\u0022,\n                $\u0022-tag:v{Version}\u0022 \u002B (CommitSha is null ? \u0022\u0022 : $\u0022, {CommitSha}\u0022),\n            };\n\n            ExecuteTool(toolPath, string.Join(\u0022 \u0022, toolParameters.Select(p =\u003E $\u0022\\\u0022{p}\\\u0022\u0022)));\n\n            File.Move(CodeCoverageReportsDirectory / $\u0022Validot.{Version}.coverage_report/Summary.json\u0022, CodeCoverageReportsDirectory / $\u0022Validot.{Version}.coverage_summary.json\u0022);\n        });\n\n    Target Benchmarks =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            var benchmarksPath = BenchmarksDirectory / $\u0022Validot.{Version}.benchmarks\u0022;\n\n            var jobShort = QuickBenchmark ? \u0022--job short\u0022 : string.Empty;\n            \n            DotNetRun(p =\u003E p\n                .SetProjectFile(TestsDirectory / \u0022Validot.Benchmarks/Validot.Benchmarks.csproj\u0022)\n                .SetConfiguration(Configuration.Release)\n                .SetArgumentConfigurator(a =\u003E a\n                    .Add(\u0022--\u0022)\n                    .Add($\u0022--artifacts {benchmarksPath} {jobShort}\u0022)\n                    .Add($\u0022--exporters GitHub StackOverflow JSON HTML\u0022)\n                    .Add(\u0022--filter *\u0022)\n                )\n            );\n        });\n    \n    Target NugetPackage =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetPack(p =\u003E p\n                .EnableNoBuild()\n                .EnableIncludeSymbols()\n                .SetConfiguration(Configuration.Release)\n                .SetProject(SourceDirectory / \u0022Validot/Validot.csproj\u0022)\n                .SetVersion(Version)\n                .SetOutputDirectory(NuGetDirectory / Version)\n                .SetTitle(Metadata.Title)\n                .SetDescription(Metadata.Description)\n                .SetRepositoryUrl(Metadata.RepositoryUrl)\n                .SetPackageIconUrl(Metadata.PackageIconUrl)\n                .SetAuthors(Metadata.Author)\n                .SetPackageLicenseUrl(Metadata.PackageLicenceUrl)\n                .SetPackageTags(Metadata.Tags)\n            );\n        });\n\n    Target PublishNugetPackage =\u003E _ =\u003E _\n        .DependsOn(NugetPackage)\n        .OnlyWhenDynamic(() =\u003E NuGetApiKey != null)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(p =\u003E p\n                .SetSource(NuGetApi)\n                .SetApiKey(NuGetApiKey)\n                .SetTargetPath(NuGetDirectory / Version / $\u0022Validot.{Version}.nupkg\u0022)\n            );\n        });\n\n    Target PublishCodeCoverage =\u003E _ =\u003E _\n        .DependsOn(CodeCoverage)\n        .OnlyWhenDynamic(() =\u003E CodeCovApiKey != null)\n        .OnlyWhenDynamic(() =\u003E Configuration == Configuration.Debug)\n        .Executes(() =\u003E\n        {\n            var reportFile = CodeCoverageDirectory / $\u0022Validot.{Version}.opencover.xml\u0022;\n\n            var toolPath = InstallAndGetToolPath(\u0022codecov.tool\u0022, \u00221.10.0\u0022, \u0022codecov.dll\u0022, \u0022netcoreapp3.0\u0022);\n\n            var toolParameters = new[] \n            {\n                $\u0022--sha {CommitSha}\u0022,\n                $\u0022--file {reportFile}\u0022,\n                $\u0022--token {CodeCovApiKey}\u0022,\n                $\u0022--required\u0022\n            };\n\n            ExecuteTool(toolPath, string.Join(\u0022 \u0022, toolParameters));\n        });\n\n    void SetFrameworkInTests(string framework)\n    {\n        var testsCsprojs = new[]\n        {\n            TestsDirectory / \u0022Validot.Tests.Unit/Validot.Tests.Unit.csproj\u0022,\n            TestsDirectory / \u0022Validot.Tests.Functional/Validot.Tests.Functional.csproj\u0022,\n            TestsDirectory / \u0022Validot.Benchmarks/Validot.Benchmarks.csproj\u0022,\n        };\n\n        foreach (var csproj in testsCsprojs)\n        {\n            SetFrameworkInCsProj(framework, csproj);\n        }\n    }\n\n    void SetFrameworkInCsProj(string framework, string csProjPath)\n    {\n        Logger.Info($\u0022Setting framework {framework} in {csProjPath}\u0022);\n        \n        var content = TargetFrameworkRegex.Replace(File.ReadAllText(csProjPath), $\u0022\u003CTargetFramework\u003E{framework}\u003C/TargetFramework\u003E\u0022);\n            \n        File.WriteAllText(csProjPath, content);\n    }\n    \n    void ResetFrameworkInTests() =\u003E SetFrameworkInTests(\u0022netcoreapp3.1\u0022);\n    \n    string GetFramework(string dotnet)\n    {\n        if (dotnet is null)\n        {\n            Logger.Warn(\u0022DotNet: parameter not provided\u0022);\n            return DefaultFrameworkId;\n        } \n        \n        if (dotnet.All(c =\u003E char.IsDigit(c) || c == \u0027.\u0027))\n        {\n            Logger.Info($\u0022DotNet parameter recognized as SDK version: \u0022 \u002B dotnet);\n\n            if (dotnet.StartsWith(\u00222.1.\u0022))\n            {\n                return \u0022netcoreapp2.1\u0022;\n            }\n            \n            if (dotnet.StartsWith(\u00223.1.\u0022))\n            {\n                return \u0022netcoreapp3.1\u0022;\n            }\n            \n            Logger.Warn(\u0022Unrecognized dotnet SDK version: \u0022 \u002B dotnet);\n\n            return dotnet;\n        }\n        \n        if (dotnet.StartsWith(\u0022netcoreapp\u0022) \u0026\u0026 dotnet.Substring(\u0022netcoreapp\u0022.Length).All(c =\u003E char.IsDigit(c) || c == \u0027.\u0027))\n        {\n            Logger.Info(\u0022DotNet parameter recognized as .NET Core target: \u0022 \u002B DotNet);\n                \n            return dotnet;\n        }\n        \n        if (dotnet.StartsWith(\u0022net\u0022) \u0026\u0026 DotNet.Substring(\u0022net\u0022.Length).All(char.IsDigit))\n        {\n            Logger.Info(\u0022DotNet parameter recognized as .NET Framework target: \u0022 \u002B dotnet);\n                \n            return dotnet;\n        }\n        \n        Logger.Warn(\u0022Unrecognized dotnet framework id: \u0022 \u002B dotnet);\n\n        return dotnet;\n    }\n\n    string GetVersion(string version)\n    {\n        if (version is null)\n        {\n            Logger.Warn(\u0022Version: not provided.\u0022);\n            \n            return $\u00220.0.0-{BuildTime.DayOfYear}{BuildTime.ToString(\u0022HHmmss\u0022, CultureInfo.InvariantCulture)}\u0022;\n        }\n\n        return version;\n    }\n\n    void ExecuteTool(string toolPath, string parameters) \n    {\n        ProcessTasks.StartProcess(ToolPathResolver.GetPathExecutable(\u0022dotnet\u0022), toolPath \u002B \u0022 -- \u0022 \u002B parameters).AssertZeroExitCode();\n    }\n\n    string InstallAndGetToolPath(string name, string version,  string executableFileName, string framework = null) \n    {\n        var frameworkPart = framework is null ? $\u0022 (framework {framework})\u0022 : string.Empty;\n\n        var toolStamp = $\u0022{name} {version}{frameworkPart}, executable file: {executableFileName}\u0022;\n\n        Logger.Info($\u0022Looking for tool: {toolStamp}\u0022);\n\n        var toolPath = GetToolPath();\n\n        if (toolPath is null) \n        {\n            DotNetToolInstall(c =\u003E c\n                    .SetPackageName(name)\n                    .SetVersion(version)\n                    .SetToolInstallationPath(ToolsPath)\n                    .SetGlobal(false)); \n        }\n\n        toolPath = GetToolPath();\n\n        if (toolPath is null) \n        {\n            Logger.Error($\u0022Unable to find tool path: {name} {version} {executableFileName} {framework}\u0022);\n        }\n\n        return toolPath;\n        \n        string GetToolPath() \n        {\n            var frameworkPart = framework != null ? (framework \u002B \u0022/**/\u0022) : string.Empty;\n\n            return GlobFiles(ToolsPath, $\u0022**/{name}/{version}/**/{frameworkPart}{executableFileName}\u0022).FirstOrDefault();\n        }\n    }    \n}\n"
  },
  {
    "Id": 246614815,
    "FirstIndexed": "2020-04-25T15:47:03.6110185+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1622204+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432921+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938707+02:00",
    "Name": "Blazor.MultiLang",
    "Owner": "csharp-today",
    "HtmlUrl": "https://github.com/csharp-today/Blazor.MultiLang",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/csharp-today/Blazor.MultiLang/blob/master/build/Build.cs",
    "BuildFileSize": 253,
    "BuildFileContent": "using Nuke.Common.Execution;\nusing Nuke.Useful.Builds;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : AzureDevOpsLibraryBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.BuildAzureDevOpsLibrary);\n}\n"
  },
  {
    "Id": 246667635,
    "FirstIndexed": "2020-04-25T15:47:03.6110157+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629378+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432932+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938719+02:00",
    "Name": "CodingConnected.Composition",
    "Owner": "CodingConnected",
    "HtmlUrl": "https://github.com/CodingConnected/CodingConnected.Composition",
    "Description": "A minuscule composition library for .NET",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/CodingConnected/CodingConnected.Composition/blob/master/build/Build.cs",
    "BuildFileSize": 3670,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Push);\n\n    [Parameter(\u0022Configuration to build\u0022)]\n    readonly Configuration Configuration = Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    [Parameter] string NugetApiUrl = \u0022https://api.nuget.org/v3/index.json\u0022; //default\n    [Parameter] string NugetApiKey;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022CodingConnected.Composition\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetNoDependencies(true)\n                .SetOutputDirectory(OutputDirectory / \u0022nuget\u0022));\n\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Requires(() =\u003E NugetApiUrl)\n        .Requires(() =\u003E NugetApiKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E\n        {\n            GlobFiles(OutputDirectory / \u0022nuget\u0022, \u0022*.nupkg\u0022)\n                .NotEmpty()\n                .Where(x =\u003E !x.EndsWith(\u0022symbols.nupkg\u0022))\n                .ForEach(x =\u003E\n                {\n                    DotNetNuGetPush(s =\u003E s\n                        .SetTargetPath(x)\n                        .SetSource(NugetApiUrl)\n                        .SetApiKey(NugetApiKey)\n                    );\n                });\n        });\n}\n"
  },
  {
    "Id": 247479475,
    "FirstIndexed": "2020-04-25T15:50:44.7358758+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629446+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434565+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940283+02:00",
    "Name": "NSIS-Tool",
    "Owner": "gpailler",
    "HtmlUrl": "https://github.com/gpailler/NSIS-Tool",
    "Description": "Original NSIS binaries packed in a Nuget package",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/gpailler/NSIS-Tool/blob/master/build/Build.cs",
    "BuildFileSize": 3183,
    "BuildFileContent": "using System.IO;\r\nusing System.Linq;\r\nusing System.Net;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.NuGet;\r\nusing static Nuke.Common.IO.CompressionTasks;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.Logger;\r\nusing static Nuke.Common.ControlFlow;\r\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\r\n\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\r\n\r\n    const string NsisUrlTemplate = \u0022https://cfhcable.dl.sourceforge.net/project/nsis/NSIS%203/{0}/nsis-{0}.zip\u0022;\r\n    const string NsisNuSpecFile = \u0022NSIS-Tool.nuspec\u0022;\r\n    const string NuGetServerUrl = \u0022https://api.nuget.org/v3/index.json\u0022;\r\n\r\n    [Parameter] string NsisVersion { get; set; }\r\n\r\n    [Parameter] string NuGetPackageVersion { get; set; }\r\n\r\n    [Parameter] string NuGetApiKey { get; set; }\r\n\r\n    AbsolutePath LibDirectory =\u003E RootDirectory / \u0022lib\u0022;\r\n\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            EnsureCleanDirectory(LibDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target DownloadNsis =\u003E _ =\u003E _\r\n        .DependsOn(Clean)\r\n        .Requires(() =\u003E NsisVersion)\r\n        .Executes(() =\u003E\r\n        {\r\n            string nsisUrl = string.Format(NsisUrlTemplate, NsisVersion);\r\n            string tempNsisArchive = Path.GetTempFileName();\r\n\r\n            Info($\u0022Downloading \u0027{nsisUrl}\u0027 to \u0027{tempNsisArchive}\u0022);\r\n            try\r\n            {\r\n                using (var webClient = new WebClient())\r\n                {\r\n                    webClient.DownloadFile(nsisUrl, tempNsisArchive);\r\n                }\r\n\r\n                Info($\u0022Extracting NSIS to {LibDirectory}\u0022);\r\n                UncompressZip(tempNsisArchive, LibDirectory);\r\n\r\n                Info($\u0022Renaming NSIS folder\u0022);\r\n                RenameDirectory(LibDirectory / \u0022nsis-\u0022 \u002B NsisVersion, LibDirectory / \u0022nsis\u0022);\r\n            }\r\n            finally\r\n            {\r\n                DeleteFile(tempNsisArchive);\r\n            }\r\n        });\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(DownloadNsis)\r\n        .Requires(() =\u003E NuGetPackageVersion)\r\n        .Executes(() =\u003E\r\n        {\r\n            NuGetPack(config =\u003E config\r\n                .SetTargetPath(RootDirectory / NsisNuSpecFile)\r\n                .SetVersion(NuGetPackageVersion)\r\n                .SetOutputDirectory(ArtifactsDirectory)\r\n            );\r\n        });\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .DependsOn(Pack)\r\n        .Requires(() =\u003E NuGetApiKey)\r\n        .Executes(() =\u003E\r\n        {\r\n            var files = ArtifactsDirectory.GlobFiles($\u0022*.{NuGetPackageVersion}.nupkg\u0022);\r\n            Assert(files.Count == 1, $\u0022Package not found in \u0027{ArtifactsDirectory}\u0027\u0022);\r\n\r\n            NuGetPush(config =\u003E config\r\n                .SetSource(NuGetServerUrl)\r\n                .SetApiKey(NuGetApiKey)\r\n                .SetTargetPath(files.Single())\r\n                .SetArgumentConfigurator(arg =\u003E arg.Add(\u0022-SkipDuplicate\u0022))\r\n            );\r\n        });\r\n\r\n}\r\n"
  },
  {
    "Id": 247509322,
    "FirstIndexed": "2020-04-25T15:47:03.6097521+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627551+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432943+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893873+02:00",
    "Name": "SmartHal",
    "Owner": "CreativeCodersTeam",
    "HtmlUrl": "https://github.com/CreativeCodersTeam/SmartHal",
    "Description": "Smart home automation system",
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/CreativeCodersTeam/SmartHal/blob/develop/build/Build.cs",
    "BuildFileSize": 2544,
    "BuildFileContent": "using System.Diagnostics.CodeAnalysis;\nusing CreativeCoders.NukeBuild;\nusing CreativeCoders.NukeBuild.BuildActions;\nusing JetBrains.Annotations;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\n\n[PublicAPI]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[SuppressMessage(\u0022ReSharper\u0022, \u0022ConvertToAutoProperty\u0022)]\n// ReSharper disable once CheckNamespace\nclass Build : NukeBuild, IBuildInfo\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    \n    [GitRepository] readonly GitRepository GitRepository;\n    \n    [GitVersion] readonly GitVersion GitVersion;\n    \n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .UseBuildAction\u003CCleanBuildAction\u003E(this);\n\n    Target Restore =\u003E _ =\u003E _\n        .Before(Compile)\n        .UseBuildAction\u003CRestoreBuildAction\u003E(this);\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .ProceedAfterFailure()\n        .UseBuildAction\u003CDotNetCompileBuildAction\u003E(this);\n\n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .UseBuildAction\u003CUnitTestAction\u003E(this,\n            x =\u003E x\n                .SetUnitTestsBasePath(\u0022UnitTests\u0022)\n                .SetProjectsPattern(\u0022**/*.csproj\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022test_results\u0022));\n    \n    Target Rebuild =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Compile);\n\n    Configuration IBuildInfo.Configuration =\u003E Configuration;\n\n    Solution IBuildInfo.Solution =\u003E Solution;\n\n    GitRepository IBuildInfo.GitRepository =\u003E GitRepository;\n\n    IVersionInfo IBuildInfo.VersionInfo =\u003E new GitVersionWrapper(GitVersion, \u00220.0.0\u0022, 1);\n\n    AbsolutePath IBuildInfo.SourceDirectory =\u003E SourceDirectory;\n\n    AbsolutePath IBuildInfo.ArtifactsDirectory =\u003E ArtifactsDirectory;\n}\n"
  },
  {
    "Id": 247636211,
    "FirstIndexed": "2020-04-25T15:47:03.6109906+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629389+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432949+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938736+02:00",
    "Name": "VCRSharp",
    "Owner": "werwolfby",
    "HtmlUrl": "https://github.com/werwolfby/VCRSharp",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/werwolfby/VCRSharp/blob/develop/build/Build.cs",
    "BuildFileSize": 4707,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.VisualBasic;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Specify to not open generated report\u0022)]\n    readonly bool NotOpenReport = false;\n\n    [Solution] readonly Solution Solution;\n    Project UnitTestsProject =\u003E Solution.GetProject(\u0022VCRSharp.Tests\u0022);\n    \n    Project IntegrationTestsProject =\u003E Solution.GetProject(\u0022VCRSharp.IntegrationTests\u0022);\n\n    AbsolutePath ReportsDirectory =\u003E RootDirectory / \u0022Reports\u0022;\n    \n    List\u003CAbsolutePath\u003E CoverageReports { get; } = new List\u003CAbsolutePath\u003E();\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            foreach (var buildDir in GlobDirectories(RootDirectory, \u0022**/bin\u0022)\n                .Concat(GlobDirectories(RootDirectory, \u0022**/obj\u0022))\n                .Concat(GlobDirectories(RootDirectory, \u0022*Tests/TestResults\u0022))\n                .Concat(ReportsDirectory)\n                .Where(d =\u003E !d.Contains(\u0022build\u0022)))\n            {\n                EnsureCleanDirectory(buildDir);\n            }\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetNoRestore(true));\n        });\n\n    Target Tests =\u003E _ =\u003E _\n        .Triggers(UnitTests)\n        .Triggers(IntegrationTests);\n\n    Target UnitTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            var outputs = DotNetTest(s =\u003E s\n                .SetProjectFile(UnitTestsProject.Path)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .When(InvokedTargets.Contains(Coverage), _ =\u003E _\n                    .SetDataCollector(\u0022XPlat Code Coverage\u0022)));\n            if (InvokedTargets.Contains(Coverage))\n            {\n                CoverageReports.Add(GetAttachment(outputs));\n            }\n        });\n\n    Target IntegrationTests =\u003E _ =\u003E _\n        .After(UnitTests)\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(IntegrationTestsProject.Path));\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .After(UnitTests)\n        .After(IntegrationTests)\n        .Executes(() =\u003E\n        {\n            ControlFlow.Assert(CoverageReports.Count \u003E 0,\n                \u0022CoverageReport task has to be executed with *Tests target\u0027s only\u0022);\n\n            ReportGenerator(s =\u003E s\n                .SetFramework(\u0022netcoreapp3.0\u0022)\n                .SetReports(CoverageReports.Select(s =\u003E (string)s))\n                .SetReportTypes(ReportTypes.HtmlInline_AzurePipelines)\n                .SetTargetDirectory(ReportsDirectory));\n            \n            if (NotOpenReport) return;\n\n            if (IsWin)\n            {\n                Process.Start(\u0022cmd.exe\u0022, @\u0022/c \u0022 \u002B ReportsDirectory / \u0022index.htm\u0022);\n            }\n        });\n\n    AbsolutePath GetAttachment(IEnumerable\u003COutput\u003E outputs)\n    {\n        var attachment = outputs\n            .Where(o =\u003E o.Type == OutputType.Std)\n            .SkipWhile(o =\u003E !o.Text.StartsWith(\u0022Attachments:\u0022))\n            .Skip(1)\n            .Cast\u003COutput?\u003E()\n            .FirstOrDefault();\n        ControlFlow.Assert(attachment != null, \u0022Can\u0027t find test result\u0022);\n        return (AbsolutePath) attachment.Value.Text.Trim();\n    }\n}\n"
  },
  {
    "Id": 247870409,
    "FirstIndexed": "2020-04-25T15:47:03.6109878+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629406+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432961+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938747+02:00",
    "Name": "perpetualinventors.com",
    "Owner": "perpetualinventors",
    "HtmlUrl": "https://github.com/perpetualinventors/perpetualinventors.com",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 2,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/perpetualinventors/perpetualinventors.com/blob/master/build/Build.cs",
    "BuildFileSize": 1475,
    "BuildFileContent": "using System;\nusing NetlifySharp;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\nusing static Nuke.Common.IO.PathConstruction;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n   \n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Deploy);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n    [Parameter(\u0022Netlify access token for packages\u0022)]\n    readonly string NetlifyAccessToken;\n    Target Deploy =\u003E _ =\u003E _\n        .Executes(() =\u003E \n        {\n            Console.WriteLine(RootDirectory.ToString());\n            var netlifyToken = NetlifyAccessToken;\n            if (string.IsNullOrEmpty(netlifyToken))\n            {\n                throw new Exception(\u0022Could not get Netlify token environment variable\u0022);\n            }\n            Console.WriteLine(OutputDirectory.ToString());\n            var client = new NetlifyClient(netlifyToken);\n            client.UpdateSite($\u0022perpetualinventors.netlify.com\u0022, OutputDirectory.ToString()).SendAsync().Wait();\n        });\n\n}\n"
  },
  {
    "Id": 248379463,
    "FirstIndexed": "2020-04-25T15:47:03.6109832+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629349+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432972+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938759+02:00",
    "Name": "hwc-dotnet-buildpack",
    "Owner": "macsux",
    "HtmlUrl": "https://github.com/macsux/hwc-dotnet-buildpack",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/macsux/hwc-dotnet-buildpack/blob/master/build/Build.cs",
    "BuildFileSize": 12979,
    "BuildFileContent": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing ICSharpCode.SharpZipLib.Zip;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitHub;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing Octokit;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing FileMode = System.IO.FileMode;\nusing ZipFile = System.IO.Compression.ZipFile;\n\n[assembly: InternalsVisibleTo(\u0022DotnetHwcBuildpackTests\u0022)]\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    [Flags]\n    public enum StackType\n    {\n        Windows = 1,\n        Linux = 2\n    }\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Publish);\n    const string BuildpackProjectName = \u0022DotnetHwcBuildpack\u0022;\n    string GetPackageZipName(string runtime) =\u003E $\u0022{BuildpackProjectName}-{runtime}-{GitVersion.MajorMinorPatch}.zip\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    \n    [Parameter(\u0022Target CF stack type - \u0027windows\u0027 or \u0027linux\u0027. Determines buildpack runtime (Framework or Core). Default is both\u0022)]\n    readonly StackType Stack = StackType.Windows;\n    \n    [Parameter(\u0022GitHub personal access token with access to the repo\u0022)]\n    string GitHubToken;\n\n    [Parameter(\u0022Application directory against which buildpack will be applied\u0022)]\n    readonly string ApplicationDirectory;\n\n    IEnumerable\u003CPublishTarget\u003E PublishCombinations\n    {\n        get\n        {\n            if (Stack.HasFlag(StackType.Windows))\n                yield return new PublishTarget {Framework = \u0022net472\u0022, Runtime = \u0022win-x64\u0022};\n            if (Stack.HasFlag(StackType.Windows))\n                yield return new PublishTarget {Framework = \u0022net472\u0022, Runtime = \u0022win-x86\u0022};\n        }\n    }\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    \n    string[] LifecycleHooks = {\u0022detect\u0022, \u0022supply\u0022, \u0022release\u0022, \u0022finalize\u0022};\n\n    Target Clean =\u003E _ =\u003E _\n        .Description(\u0022Cleans up **/bin and **/obj folders\u0022)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .Description(\u0022Compiles the buildpack\u0022)\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            \n            Logger.Info(Stack);\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                \n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .CombineWith(PublishCombinations, (c, p) =\u003E c\n                    .SetFramework(p.Framework)\n                    .SetRuntime(p.Runtime)));\n        });\n    \n    Target Publish =\u003E _ =\u003E _\n        .Description(\u0022Packages buildpack in Cloud Foundry expected format into /artifacts directory\u0022)\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            foreach (var publishCombination in PublishCombinations)\n            {\n                var framework = publishCombination.Framework;\n                var runtime = publishCombination.Runtime;\n                var packageZipName = GetPackageZipName(runtime);\n                var workDirectory = TemporaryDirectory / \u0022pack\u0022;\n                EnsureCleanDirectory(TemporaryDirectory);\n                var buildpackProject = Solution.GetProject(BuildpackProjectName);\n                if(buildpackProject == null)\n                    throw new Exception($\u0022Unable to find project called {BuildpackProjectName} in solution {Solution.Name}\u0022);\n                var publishDirectory = buildpackProject.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022;\n                var workBinDirectory = workDirectory / \u0022bin\u0022;\n\n\n                DotNetPublish(s =\u003E s\n                    .SetProject(Solution)\n                    .SetConfiguration(Configuration)\n                    .SetFramework(framework)\n                    .SetRuntime(runtime)\n                    .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                    .SetFileVersion(GitVersion.AssemblySemFileVer)\n                    .SetInformationalVersion(GitVersion.InformationalVersion)\n                );\n\n                var lifecycleBinaries = Solution.GetProjects(\u0022Lifecycle*\u0022)\n                    .Select(x =\u003E x.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022)\n                    .SelectMany(x =\u003E Directory.GetFiles(x).Where(path =\u003E LifecycleHooks.Any(hook =\u003E Path.GetFileName(path).StartsWith(hook))));\n\n                foreach (var lifecycleBinary in lifecycleBinaries)\n                {\n                    CopyFileToDirectory(lifecycleBinary, workBinDirectory, FileExistsPolicy.OverwriteIfNewer);\n                }\n\n                var hwcProject = Solution.GetProject(\u0022Hwc\u0022);\n                var hwcPublishDir = hwcProject.Directory / \u0022bin\u0022 / Configuration / framework / runtime / \u0022publish\u0022;\n                CopyDirectoryRecursively(hwcPublishDir, workBinDirectory / \u0022hwc\u0022, DirectoryExistsPolicy.Merge);\n                CopyDirectoryRecursively(publishDirectory, workBinDirectory, DirectoryExistsPolicy.Merge);\n                \n                \n                var tempZipFile = TemporaryDirectory / packageZipName;\n\n                ZipFile.CreateFromDirectory(workDirectory, tempZipFile, CompressionLevel.NoCompression, false);\n                MakeFilesInZipUnixExecutable(tempZipFile);\n                CopyFileToDirectory(tempZipFile, ArtifactsDirectory, FileExistsPolicy.Overwrite);\n                Logger.Block(ArtifactsDirectory / packageZipName);\n            }\n        });\n    \n    \n    Target Release =\u003E _ =\u003E _\n        .Description(\u0022Creates a GitHub release (or amends existing) and uploads buildpack artifact\u0022)\n        .DependsOn(Publish)\n        .Requires(() =\u003E GitHubToken)\n        .Executes(async () =\u003E\n        {\n            foreach (var publishCombination in PublishCombinations)\n            {\n                var runtime = publishCombination.Runtime;\n                var packageZipName = GetPackageZipName(runtime);\n                if (!GitRepository.IsGitHubRepository())\n                    throw new Exception(\u0022Only supported when git repo remote is github\u0022);\n    \n                var client = new GitHubClient(new ProductHeaderValue(BuildpackProjectName))\n                {\n                    Credentials = new Credentials(GitHubToken, AuthenticationType.Bearer)\n                };\n                var gitIdParts = GitRepository.Identifier.Split(\u0022/\u0022);\n                var owner = gitIdParts[0];\n                var repoName = gitIdParts[1];\n    \n                var releaseName = $\u0022v{GitVersion.MajorMinorPatch}\u0022;\n                Release release;\n                try\n                {\n                    release = await client.Repository.Release.Get(owner, repoName, releaseName);\n                }\n                catch (NotFoundException)\n                {\n                    var newRelease = new NewRelease(releaseName)\n                    {\n                        Name = releaseName,\n                        Draft = false,\n                        Prerelease = false\n                    };\n                    release = await client.Repository.Release.Create(owner, repoName, newRelease);\n                }\n    \n                var existingAsset = release.Assets.FirstOrDefault(x =\u003E x.Name == packageZipName);\n                if (existingAsset != null)\n                {\n                    await client.Repository.Release.DeleteAsset(owner, repoName, existingAsset.Id);\n                }\n    \n                var zipPackageLocation = ArtifactsDirectory / packageZipName;\n                var stream = File.OpenRead(zipPackageLocation);\n                var releaseAssetUpload = new ReleaseAssetUpload(packageZipName, \u0022application/zip\u0022, stream, TimeSpan.FromHours(1));\n                var releaseAsset = await client.Repository.Release.UploadAsset(release, releaseAssetUpload);\n    \n                Logger.Block(releaseAsset.BrowserDownloadUrl);\n            }\n        });\n\n    Target Detect =\u003E _ =\u003E _\n        .Description(\u0022Invokes buildpack \u0027detect\u0027 lifecycle event\u0022)\n        .Requires(() =\u003E ApplicationDirectory)\n        .Executes(() =\u003E\n        {\n            try\n            {\n                DotNetRun(s =\u003E s\n                    .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Detect\u0022).Path)\n                    .SetApplicationArguments(ApplicationDirectory)\n                    .SetConfiguration(Configuration)\n                    .SetFramework(\u0022netcoreapp3.1\u0022));\n                Logger.Block(\u0022Detect returned \u0027true\u0027\u0022);\n            }\n            catch (ProcessException)\n            {\n                Logger.Block(\u0022Detect returned \u0027false\u0027\u0022);\n            }\n        });\n\n    Target Supply =\u003E _ =\u003E _\n        .Description(\u0022Invokes buildpack \u0027supply\u0027 lifecycle event\u0022)\n        .Requires(() =\u003E ApplicationDirectory)\n        .Executes(() =\u003E\n        {\n            var home = (AbsolutePath)Path.GetTempPath() / Guid.NewGuid().ToString();\n            var app = home / \u0022app\u0022;\n            var deps = home / \u0022deps\u0022;\n            var index = 0;\n            var cache = home / \u0022cache\u0022;\n            CopyDirectoryRecursively(ApplicationDirectory, app);\n\n            DotNetRun(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022Lifecycle.Supply\u0022).Path)\n                .SetApplicationArguments($\u0022{app} {cache} {app} {deps} {index}\u0022)\n                .SetConfiguration(Configuration)\n                .SetFramework(\u0022netcoreapp3.1\u0022));\n            Logger.Block($\u0022Buildpack applied. Droplet is available in {home}\u0022);\n\n        });\n\n    public void MakeFilesInZipUnixExecutable(AbsolutePath zipFile)\n    {\n        var tmpFileName = zipFile \u002B \u0022.tmp\u0022;\n        using (var input = new ZipInputStream(File.Open(zipFile, FileMode.Open)))\n        using (var output = new ZipOutputStream(File.Open(tmpFileName, FileMode.Create)))\n        {\n            output.SetLevel(9);\n            ZipEntry entry;\n\t\t\n            while ((entry = input.GetNextEntry()) != null)\n            {\n                var outEntry = new ZipEntry(entry.Name) {HostSystem = (int) HostSystemID.Unix};\n                var entryAttributes =  \n                    ZipEntryAttributes.ReadOwner | \n                    ZipEntryAttributes.ReadOther | \n                    ZipEntryAttributes.ReadGroup |\n                    ZipEntryAttributes.ExecuteOwner | \n                    ZipEntryAttributes.ExecuteOther | \n                    ZipEntryAttributes.ExecuteGroup;\n                entryAttributes = entryAttributes | (entry.IsDirectory ? ZipEntryAttributes.Directory : ZipEntryAttributes.Regular);\n                outEntry.ExternalFileAttributes = (int) (entryAttributes) \u003C\u003C 16; // https://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute\n                output.PutNextEntry(outEntry);\n                input.CopyTo(output);\n            }\n            output.Finish();\n            output.Flush();\n        }\n\n        DeleteFile(zipFile);\n        RenameFile(tmpFileName,zipFile, FileExistsPolicy.Overwrite);\n    }\n    \n    [Flags]\n    enum ZipEntryAttributes\n    {\n        ExecuteOther = 1,\n        WriteOther = 2,\n        ReadOther = 4,\n\t\n        ExecuteGroup = 8,\n        WriteGroup = 16,\n        ReadGroup = 32,\n\n        ExecuteOwner = 64,\n        WriteOwner = 128,\n        ReadOwner = 256,\n\n        Sticky = 512, // S_ISVTX\n        SetGroupIdOnExecution = 1024,\n        SetUserIdOnExecution = 2048,\n\n        //This is the file type constant of a block-oriented device file.\n        NamedPipe = 4096,\n        CharacterSpecial = 8192,\n        Directory = 16384,\n        Block = 24576,\n        Regular = 32768,\n        SymbolicLink = 40960,\n        Socket = 49152\n\t\n    }\n    class PublishTarget\n    {\n        public string Framework { get; set; }\n        public string Runtime { get; set; }\n    }\n}\n"
  },
  {
    "Id": 248846616,
    "FirstIndexed": "2020-04-25T15:47:03.6109787+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629258+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432983+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893877+02:00",
    "Name": "firefly-receipt",
    "Owner": "gevlee",
    "HtmlUrl": "https://github.com/gevlee/firefly-receipt",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/gevlee/firefly-receipt/blob/master/build/Build.cs",
    "BuildFileSize": 3456,
    "BuildFileContent": "using System;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\nclass Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    AbsolutePath ApplicationCsproj =\u003E SourceDirectory / \u0022Gevlee.FireflyReceipt.Application\u0022 / \u0022Gevlee.FireflyReceipt.Application.csproj\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    DotNetPublishSettings ApplyBasePublishSettings(DotNetPublishSettings settings)\r\n    {\r\n        settings.SetProject(ApplicationCsproj);\r\n        settings.SetConfiguration(Configuration);\r\n        settings.SetAssemblyVersion(GitVersion.AssemblySemVer);\r\n        settings.SetFileVersion(GitVersion.AssemblySemFileVer);\r\n        settings.SetInformationalVersion(GitVersion.InformationalVersion);\r\n        settings.EnableNoRestore();\r\n        return settings;\r\n    }\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n    .DependsOn(Restore)\r\n    .Executes(() =\u003E\r\n    {\r\n\r\n        DotNetPublish(s =\u003E ApplyBasePublishSettings(s).SetRuntime(\u0022win-x64\u0022).SetOutput(ArtifactsDirectory / \u0022win\u0022));\r\n        DotNetPublish(s =\u003E ApplyBasePublishSettings(s).SetRuntime(\u0022linux-x64\u0022).SetOutput(ArtifactsDirectory / \u0022linux\u0022));\r\n    });\r\n\r\n}\r\n"
  },
  {
    "Id": 249557787,
    "FirstIndexed": "2020-04-25T15:47:03.6109736+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1629202+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8432995+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938776+02:00",
    "Name": "SharpCastXml",
    "Owner": "KevinGliewe",
    "HtmlUrl": "https://github.com/KevinGliewe/SharpCastXml",
    "Description": "C# Wrapper for CastXML",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/KevinGliewe/SharpCastXml/blob/master/build/Build.cs",
    "BuildFileSize": 4013,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing GCore.Extensions.ArrayEx;\nusing GCore.Extensions.StringShEx;\nusing GCore.Logging;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main()\n    {\n        Log.LoggingHandler.Add(new GCore.Logging.Logger.ConsoleLogger());\n        return Execute\u003CBuild\u003E(x =\u003E x.Compile);\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(ArtifactsDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            var version = new Version(0, 0, 0);\n            try {\n                version = \u0022git tag\u0022.Sh().Split(\u0027\\n\u0027).Get(-2).ExtractVersion();\n            } catch {}\n\n            var commitIndex = \u0022git rev-list --count HEAD\u0022.Sh().Replace(\u0022\\n\u0022, \u0022\u0022).Trim();\n\n            Log.Info(\u0022Repo version:\u0022 \u002B version \u002B \u0022.\u0022 \u002B commitIndex);\n\n            foreach (var project in Solution.AllProjects.Where(p =\u003E !Regex.IsMatch(p, @\u0022(_build|\\.TestProject)\\.csproj$\u0022)))\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .SetNoBuild(InvokedTargets.Contains(Compile))\n                    .SetConfiguration(Configuration)\n                    .SetOutputDirectory(ArtifactsDirectory)\n                    .SetVersion(version \u002B \u0022.\u0022 \u002B commitIndex)\n                    );\n        });\n\n    [Parameter(\u0022NuGet Api Key\u0022)] readonly string ApiKey;\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E {\n            var packages = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022);\n            Debug.Assert(packages.Count == 1, \u0022packages.Count == 4\u0022);\n\n            DotNetNuGetPush(_ =\u003E _\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(packages, (_, v) =\u003E _\n                        .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n        });\n}\n"
  },
  {
    "Id": 249792388,
    "FirstIndexed": "2020-04-25T15:50:44.7357928+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628416+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434553+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940272+02:00",
    "Name": "SampleApp",
    "Owner": "liquidprojections",
    "HtmlUrl": "https://github.com/liquidprojections/SampleApp",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "Build/Build.cs",
    "BuildFileUrl": "https://github.com/liquidprojections/SampleApp/blob/master/Build/Build.cs",
    "BuildFileSize": 1571,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.Npm;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.CompileDotnet);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly string Configuration = IsLocalBuild ? \u0022Debug\u0022 : \u0022Release\u0022;\n\n    [Solution(\u0022SampleService.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath WebApp =\u003E RootDirectory / \u0022Src/SampleService/Webapp\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target CompileJs =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            NpmTasks.NpmInstall(c =\u003E c.SetWorkingDirectory(WebApp));\n        });\n    \n    Target CompileDotnet =\u003E _ =\u003E _\n        .DependsOn(CompileJs)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n    \n}\n"
  },
  {
    "Id": 249808140,
    "FirstIndexed": "2020-04-25T15:50:44.7350481+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627898+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433239+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893902+02:00",
    "Name": "fwdays",
    "Owner": "matkoch",
    "HtmlUrl": "https://github.com/matkoch/fwdays",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/matkoch/fwdays/blob/master/build/Build.cs",
    "BuildFileSize": 4517,
    "BuildFileContent": "using System.Collections.Generic;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.CI.TeamCity;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[TeamCity(TeamCityAgentPlatform.Unix,\n    VcsTriggeredTargets = new[] {nameof(Test)},\n    NonEntryTargets = new[] {nameof(Restore), nameof(Compile)},\n    ManuallyTriggeredTargets = new[] {nameof(Publish)})]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022*/bin\u0022, \u0022*/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    [Solution] readonly Solution Solution;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            // dotnet restore fwdays.sln\n            DotNet($\u0022restore {Solution}\u0022);\n        });\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            // dotnet build fwdays.sln --no-restore --configuration Debug --verbosity minimal\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .EnableNoRestore()\n                .SetConfiguration(Configuration)\n                .SetVerbosity(DotNetVerbosity.Minimal));\n        });\n\n    AbsolutePath TestResultsDirectory =\u003E OutputDirectory / \u0022test_results\u0022;\n    [Partition(3)] readonly Partition TestPartition;\n    IEnumerable\u003CProject\u003E TestProjects =\u003E TestPartition.GetCurrent(Solution.GetProjects(\u0022Tests*\u0022));\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Partition(() =\u003E TestPartition)\n        .Executes(() =\u003E\n        {\n            // dotnet test Tests01.csproj --logger trx;LogFileName=Tests01.trx --no-build --results-directory ...\n            // dotnet test Tests02.csproj --logger trx;LogFileName=Tests02.trx --no-build --results-directory ...\n            // dotnet test Tests03.csproj --logger trx;LogFileName=Tests03.trx --no-build --results-directory ...\n            DotNetTest(_ =\u003E _\n                .EnableNoBuild()\n                .SetResultsDirectory(TestResultsDirectory)\n                .When(Configuration.Equals(Configuration.Release), cs =\u003E cs\n                    .EnableCollectCoverage()\n                    .SetCoverletOutputFormat(CoverletOutputFormat.cobertura))\n                .CombineWith(TestProjects, (cs, v) =\u003E cs\n                    .SetProjectFile(v)\n                    .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\n                    .When(Configuration.Equals(Configuration.Release), cs =\u003E cs\n                        .SetCoverletOutput(TestResultsDirectory / $\u0022{v.Name}.xml\u0022))));\n        });\n\n    [GitVersion] readonly GitVersion GitVersion;\n\n    Target Pack =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            // dotnet pack Library.csproj --version x.x.x --output-directory /.../output\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution.GetProject(\u0022Library\u0022))\n                .SetOutputDirectory(OutputDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2));\n        });\n\n    IEnumerable\u003CAbsolutePath\u003E Packages =\u003E OutputDirectory.GlobFiles(\u0022*.nupkg\u0022);\n    [Parameter] string ApiKey;\n\n    Target Publish =\u003E _ =\u003E _\n        .Requires(() =\u003E ApiKey)\n        .DependsOn(Pack)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(_ =\u003E _\n                .SetSource(\u0022https://www.myget.org/F/matkoch/api/v2/package\u0022)\n                .SetApiKey(ApiKey)\n                .CombineWith(Packages, (_, v) =\u003E _\n                    .SetTargetPath(v)));\n        });\n}\n"
  },
  {
    "Id": 250927412,
    "FirstIndexed": "2020-04-25T15:47:03.6109286+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628535+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938787+02:00",
    "Name": "TextToColor",
    "Owner": "BerserkerDotNet",
    "HtmlUrl": "https://github.com/BerserkerDotNet/TextToColor",
    "Description": "A set of extensions to convert text to System.Drawing.Color.",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BerserkerDotNet/TextToColor/blob/master/build/Build.cs",
    "BuildFileSize": 3654,
    "BuildFileContent": "using GlobExpressions;\nusing Nuke.Common;\nusing Nuke.Common.CI.AzurePipelines;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing System.Linq;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Package);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022TextToColor.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .SetLogger(\u0022trx\u0022)\n                .SetResultsDirectory(ArtifactsDirectory / \u0022TestResults\u0022)\n                .EnableNoBuild()\n                .EnableNoRestore());\n        });\n\n    Target Package =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .EnableIncludeSymbols()\n                .EnableIncludeSource()\n                .SetOutputDirectory(ArtifactsDirectory));\n        });\n\n    Target PublishAzureDevOpsArtifacts =\u003E _ =\u003E _\n        .TriggeredBy(Package)\n        .OnlyWhenStatic(() =\u003E AzurePipelines.Instance != null)\n        .Executes(() =\u003E\n        {\n            var testFiles = Glob.Files(ArtifactsDirectory / \u0022TestResults\u0022, \u0022*.trx\u0022)\n                .Select(f =\u003E (string)(ArtifactsDirectory / \u0022TestResults\u0022 / f));\n\n            AzurePipelines.Instance.PublishTestResults(\u0022TextToColor unit tests\u0022,\n                AzurePipelinesTestResultsType.VSTest,\n                testFiles,\n                mergeResults: true,\n                configuration: Configuration);\n            AzurePipelines.Instance.UploadArtifacts(\u0022Container\u0022, \u0022drop\u0022, ArtifactsDirectory);\n        });\n}\n"
  },
  {
    "Id": 250998925,
    "FirstIndexed": "2020-04-25T15:47:03.6108001+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627819+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433012+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938798+02:00",
    "Name": "n-collection",
    "Owner": "lillo42",
    "HtmlUrl": "https://github.com/lillo42/n-collection",
    "Description": "NCollection",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/lillo42/n-collection/blob/master/build/Build.cs",
    "BuildFileSize": 6209,
    "BuildFileContent": "using System.Collections.Generic;\nusing System.IO;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.Coverlet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.ReportGenerator;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.CompressionTasks;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\n\n[CheckBuildProjectConfigurations]\n[DotNetVerbosityMapping]\n[UnsetVisualStudioEnvironmentVariables]\n[ShutdownDotNetBuildServerOnFinish]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Nuget API key\u0022, Name = \u0022api-key\u0022)] readonly string ApiKey;\n\n    [Parameter(\u0022NuGet Source for Packages\u0022, Name = \u0022nuget-source\u0022)]\n    readonly string NugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion(NoFetch = true)] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    \n    AbsolutePath PackageDirectory =\u003E ArtifactsDirectory / \u0022packages\u0022;\n    \n    AbsolutePath TestResultDirectory =\u003E ArtifactsDirectory / \u0022test-results\u0022;\n    \n    string CoverageReportDirectory =\u003E ArtifactsDirectory / \u0022coverage-report\u0022;\n    string CoverageReportArchive =\u003E ArtifactsDirectory / \u0022coverage-report.zip\u0022;\n    \n    IEnumerable\u003CProject\u003E TestProjects =\u003E Solution.GetProjects(\u0022*.Test\u0022);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetClean(s =\u003E s\n                .SetProject(Solution)\n                .SetConfiguration(Configuration));\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Clean)\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetNoRestore(InvokedTargets.Contains(Restore))\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n        });\n    \n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\n        .Produces(TestResultDirectory / \u0022*.xml\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetResultsDirectory(TestResultDirectory)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .When(InvokedTargets.Contains(Coverage) || IsServerBuild, _ =\u003E _\n                    .EnableCollectCoverage()\n                    .SetCoverletOutputFormat(CoverletOutputFormat.opencover)\n                    .When(IsServerBuild, _ =\u003E _.EnableUseSourceLink()))\n                .CombineWith(TestProjects, (_, v) =\u003E _\n                    .SetProjectFile(v)\n                    .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\n                    .SetCoverletOutput(TestResultDirectory / $\u0022{v.Name}.xml\u0022)));\n        });\n\n    Target Coverage =\u003E _ =\u003E _\n        .DependsOn(Test)\n        .TriggeredBy(Test)\n        .Consumes(Test)\n        .Produces(CoverageReportArchive)\n        .Executes(() =\u003E\n        {\n            if (InvokedTargets.Contains(Coverage) || IsServerBuild)\n            {\n                ReportGenerator(_ =\u003E _\n                    .SetReports(TestResultDirectory / \u0022*.xml\u0022)\n                    .SetReportTypes(ReportTypes.HtmlInline)\n                    .SetTargetDirectory(CoverageReportDirectory)\n                    .SetFramework(\u0022netcoreapp2.1\u0022));\n\n                CompressZip(\n                    directory: CoverageReportDirectory,\n                    archiveFile: CoverageReportArchive,\n                    fileMode: FileMode.Create);\n            }\n        });\n\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile, Test)\n        .Produces(PackageDirectory / \u0022*.nupkg\u0022)\n        .Produces(PackageDirectory / \u0022*.snupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetNoBuild(InvokedTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(PackageDirectory)\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .EnableIncludeSource()\n                .EnableIncludeSymbols()\n                .EnableNoRestore());\n        });\n    \n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Test, Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n                .SetApiKey(ApiKey)\n                .SetSkipDuplicate(true)\n                .SetSource(NugetSource));\n        });\n}\n"
  },
  {
    "Id": 252331072,
    "FirstIndexed": "2020-04-25T15:50:44.7350856+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627625+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433262+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939032+02:00",
    "Name": "NemReview6Client",
    "Owner": "global-roam",
    "HtmlUrl": "https://github.com/global-roam/NemReview6Client",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/global-roam/NemReview6Client/blob/master/build/Build.cs",
    "BuildFileSize": 9139,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Data.SqlClient;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI.AzurePipelines;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\r\n\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n[AzurePipelines(null, AzurePipelinesImage.WindowsLatest\r\n\t, InvokedTargets = new[] { nameof(PublishRelease) }\r\n\t, TriggerBranchesInclude = new[] { \u0022master\u0022 }\r\n\t, AutoGenerate = false\r\n\t)]\r\nclass Build : NukeBuild\r\n{\t\r\n\tpublic static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n\r\n\t[Parameter(\u0022Password for \u0027build\u0027 user on gridlicensing-globalroam-production.database.windows.net\u0022)]\r\n\treadonly string GridLicencsingDatabasePassword;\r\n\r\n\t[Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n\treadonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n\t[Solution] readonly Solution Solution;\r\n\t[GitVersion(Framework = \u0022netcoreapp3.1\u0022)] readonly GitVersion GitVersion;\r\n\r\n\treadonly string ProductName = \u0022NEM-Review\u0022;\r\n\treadonly string LicencedProgramName = \u0022NEM-Review\u0022;\r\n\r\n\t[Parameter]\r\n\tAbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\t[Parameter]\r\n\tAbsolutePath BuildOutput =\u003E RootDirectory / \u0022binaries\u0022;\r\n\r\n\tAbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\r\n\tAbsolutePath TempDirectory =\u003E RootDirectory / \u0022temp\u0022;\r\n\tAbsolutePath InstallerDirectory =\u003E RootDirectory / \u0022installer\u0022;\r\n\tAbsolutePath AllOtherFiles =\u003E InstallerDirectory / \u0022AllOtherFiles.wxs\u0022;\r\n\r\n\tTarget Clean =\u003E _ =\u003E _\r\n\t\t.Before(Restore)\r\n\t\t.Executes(() =\u003E\r\n\t\t{\r\n\t\t\tSourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n\t\t\tInstallerDirectory.GlobDirectories(\u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n\t\t\tEnsureCleanDirectory(BuildOutput);\r\n\t\t\tEnsureCleanDirectory(ArtifactsDirectory);\r\n\t\t});\r\n\r\n\tTarget Restore =\u003E _ =\u003E _\r\n\t\t.Executes(() =\u003E\r\n\t\t{\r\n\t\t\tMSBuild(s =\u003E s\r\n\t\t\t\t.SetTargetPath(Solution)\r\n\t\t\t\t.SetTargets(\u0022Restore\u0022));\r\n\t\t});\r\n\r\n\tTarget Compile =\u003E _ =\u003E _\r\n\t\t.DependsOn(Clean)\r\n\t\t.DependsOn(Restore)\r\n\t\t.Executes(() =\u003E\r\n\t\t{\r\n\t\t\tvar project = Solution.GetProject(\u0022GlobalRoam.NemReviewClient\u0022);\r\n//\t\t\tvar msbuildProject = nemReviewProject.GetMSBuildProject();\r\n\r\n\t\t\tMSBuild(s =\u003E s\r\n\t\t\t\t.SetTargetPath(project)\r\n\t\t\t\t.SetTargets(\u0022Rebuild\u0022)\r\n\t\t\t\t.SetOutDir(BuildOutput)\r\n\t\t\t\t.SetConfiguration(Configuration)\r\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n\t\t\t\t.SetFileVersion(GitVersion.AssemblySemFileVer)\r\n\t\t\t\t.SetInformationalVersion(GitVersion.InformationalVersion)\r\n\t\t\t\t.SetMaxCpuCount(Environment.ProcessorCount)\r\n\t\t\t\t.SetNodeReuse(IsLocalBuild));\r\n\t\t});\r\n\r\n\tTarget HarvestBuildOutput =\u003E _ =\u003E _\r\n\t\t.DependsOn(Compile)\r\n\t\t.Executes(() =\u003E\r\n\t\t{\r\n\t\t\tvar excludeRegexPatterns = new[] { \u0022^NEM-Review.exe$\u0022 }.Select(p =\u003E new Regex(p, RegexOptions.Compiled | RegexOptions.IgnoreCase)).ToArray();\r\n\t\t\tvar excludedFiles = Directory.GetFiles(BuildOutput, \u0022*.*\u0022, SearchOption.AllDirectories)\r\n\t\t\t\t.Select(f =\u003E new FileInfo(f))\r\n\t\t\t\t.Where(file =\u003E\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (var regex in excludeRegexPatterns)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (regex.IsMatch(file.Name))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t})\r\n\t\t\t\t.ToList();\r\n\r\n\t\t\tEnsureExistingDirectory(TempDirectory);\r\n\t\t\tforeach (var file in excludedFiles)\r\n\t\t\t{\r\n\t\t\t\tfile.MoveTo(TempDirectory / file.Name, true);\r\n\t\t\t}\r\n\r\n\t\t\tHeat(arguments: $@\u0022dir \u0022\u0022{BuildOutput}\u0022\u0022 -o \u0022\u0022{AllOtherFiles}\u0022\u0022 -ag -ke -cg AllOtherFiles -scom -sfrag -sreg -srd -dr INSTALLFOLDER -suid -indent 2\u0022);\r\n\r\n\t\t\tforeach (var file in excludedFiles)\r\n\t\t\t{\r\n\t\t\t\tfile.MoveTo(BuildOutput / file.Name, true);\r\n\t\t\t}\r\n\r\n\t\t\tvar txtLines = File.ReadAllLines(AllOtherFiles).ToList();\r\n\t\t\ttxtLines.Insert(txtLines.IndexOf(@\u0022\u003CWix xmlns=\u0022\u0022http://schemas.microsoft.com/wix/2006/wi\u0022\u0022\u003E\u0022) \u002B 1, @\u0022  \u003C?include Variables.wxi ?\u003E\u0022);\r\n\t\t\tFile.WriteAllLines(AllOtherFiles, txtLines);\r\n\r\n\t\t});\r\n\r\n\t[PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022candle.exe\u0022)]\r\n\treadonly Tool Candle;\r\n\t[PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022light.exe\u0022)]\r\n\treadonly Tool Light;\r\n\t[PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022heat.exe\u0022)]\r\n\treadonly Tool Heat;\r\n\r\n\tTarget Installer =\u003E _ =\u003E _\r\n\t\t//.DependsOn(HarvestBuildOutput)\r\n\t\t.Executes(() =\u003E\r\n\t\t{\r\n\t\t\tEnvironment.CurrentDirectory = InstallerDirectory;\r\n\r\n\t\t\tvar sourceFiles = string.Join(\u0022 \u0022, Directory.GetFiles(InstallerDirectory, \u0022*.wxs\u0022).Select(s =\u003E $@\u0022\u0022\u0022{Path.Combine(InstallerDirectory, s)}\u0022\u0022\u0022));\r\n\r\n\t\t\tforeach (var arch in new[] { \u0022x64\u0022, \u0022x86\u0022 })\r\n\t\t\t{\r\n\t\t\t\tvar installerFileName = $\u0022Install_{ProductName}_{GitVersion.AssemblySemVer}_{arch}.msi\u0022;\r\n\t\t\t\tLogger.Normal(\u0022Building {0}\u0022, installerFileName);\r\n\r\n\t\t\t\tvar objFolder = $\u0022obj\\\\{arch}\\\\\u0022;\r\n\t\t\t\tEnsureExistingDirectory(objFolder);\r\n\r\n\t\t\t\tvar candleArgs = $@\u0022-ext WixUtilExtension -out {objFolder} -arch {arch} -dPlatform={arch} -pedantic -v {sourceFiles}\u0022;\r\n\t\t\t\tCandle(arguments: candleArgs);\r\n\r\n\t\t\t\tvar objectFiles = string.Join(\u0022 \u0022, Directory.GetFiles(objFolder).Select(s =\u003E $@\u0022\u0022\u0022{Path.Combine(InstallerDirectory, s)}\u0022\u0022\u0022));\r\n\r\n\t\t\t\tvar lightArgs = $\u0022-b {BuildOutput} -ext WixUtilExtension -ext WixUIExtension -ext WixNetFxExtension -out {ArtifactsDirectory / installerFileName} {objectFiles}\u0022;\r\n\t\t\t\tLight(arguments: lightArgs);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\tTarget AddVersionToLicenceSystem =\u003E _ =\u003E _\r\n\t\t.DependsOn(Installer)\r\n\t\t.Requires(() =\u003E GridLicencsingDatabasePassword)\r\n\t\t.OnlyWhenStatic(() =\u003E IsServerBuild)\r\n\t\t.WhenSkipped(DependencyBehavior.Skip)\r\n\t\t.Executes(async () =\u003E\r\n\t\t{\r\n\t\t\tvar connectionStringBuilder = new SqlConnectionStringBuilder\r\n\t\t\t{\r\n\t\t\t\tDataSource = \u0022gridlicensing-globalroam-production.database.windows.net\u0022,\r\n\t\t\t\tInitialCatalog = \u0022gridlicensing\u0022,\r\n\t\t\t\tUserID = \u0022build\u0022,\r\n\t\t\t\tPassword = GridLicencsingDatabasePassword\r\n\t\t\t};\r\n\r\n\t\t\tvar version = GitVersion.AssemblySemVer;\r\n\t\t\tvar programName = LicencedProgramName;\r\n\t\t\tLogger.Normal(\u0022Adding {0} v{1} to licence system database {2}\u0022, programName, version, connectionStringBuilder.DataSource);\r\n\r\n\t\t\tvar query = File.ReadAllText(RootDirectory / \u0022build/AddNewVersionToLicenceSystem.sql\u0022);\r\n\r\n\t\t\tusing var connection = new SqlConnection(connectionStringBuilder.ConnectionString);\r\n\t\t\tusing var command = connection.CreateCommand();\r\n\t\t\tcommand.CommandText = query;\r\n\t\t\tcommand.Parameters.AddWithValue(\u0022@NewVersion\u0022, version);\r\n\t\t\tcommand.Parameters.AddWithValue(\u0022@ProgramName\u0022, programName);\r\n\r\n\t\t\tLogger.Normal(\u0022Opening connection to {0}\u0022, connectionStringBuilder.DataSource);\r\n\t\t\tawait connection.OpenAsync();\r\n\r\n\t\t\tLogger.Normal(\u0022Execute {0}\u0022, command.CommandText);\r\n\t\t\tawait command.ExecuteNonQueryAsync();\r\n\t\t});\r\n\r\n\tTarget PublishRelease =\u003E _ =\u003E _\r\n\t\t.TriggeredBy(AddVersionToLicenceSystem)\r\n\t\t.DependsOn(AddVersionToLicenceSystem)\r\n\t\t.OnlyWhenStatic(() =\u003E IsServerBuild)\r\n\t\t.WhenSkipped(DependencyBehavior.Skip)\r\n\t\t.Executes(async () =\u003E\r\n\t\t{\r\n\t\t\tvar storageAccount = new Microsoft.WindowsAzure.Storage.CloudStorageAccount(new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(\u0022grinstallers\u0022, \u0022RFzSdJx6iRQi\u002BF0MRdkk5yU31in3aVvWacx54Uuus2\u002BaK3gi3jW88MMLZyDILpVU5elYuX8gt2geTPKO7TtOlg==\u0022), true);\r\n\r\n\t\t\tvar releaseCandidateDcFolder = $@\u0022\\\\dc.gr.local\\RoamSoftware\\global-roam\\global-roam Products\\{ProductName}\\Release Candidate\u0022;\r\n\t\t\tEnsureExistingDirectory(releaseCandidateDcFolder);\r\n\r\n\t\t\tstatic string ReplaceHost(Uri original, string newHostName)\r\n\t\t\t{\r\n\t\t\t\tvar builder = new UriBuilder(original) { Host = newHostName };\r\n\t\t\t\treturn builder.Uri.ToString();\r\n\t\t\t}\r\n\r\n\t\t\tvar installerUris = new List\u003Cstring\u003E();\r\n\t\t\tvar blobClient = storageAccount.CreateCloudBlobClient();\r\n\t\t\tvar container = blobClient.GetContainerReference(ProductName.ToLower());\r\n\t\t\tawait container.CreateIfNotExistsAsync();\r\n\r\n\t\t\tforeach (var installerFile in Directory.GetFiles(ArtifactsDirectory, \u0022*.msi\u0022))\r\n\t\t\t{\r\n\t\t\t\tLogger.Normal($\u0022Copying {installerFile} to {releaseCandidateDcFolder}\u0022);\r\n\t\t\t\tCopyFileToDirectory(installerFile, releaseCandidateDcFolder);\r\n\r\n\t\t\t\tvar installerFileName = Path.GetFileName(installerFile);\r\n\t\t\t\tvar block = container.GetBlockBlobReference(installerFileName);\r\n\t\t\t\tLogger.Normal($\u0022Uploading {installerFile} to {block.Uri}\u0022);\r\n\r\n\t\t\t\tawait block.UploadFromFileAsync(installerFile);\r\n\r\n\t\t\t\tvar grUri = ReplaceHost(block.Uri, \u0022installers.global-roam.com\u0022);\r\n\t\t\t\tLogger.Normal($\u0022Installer available @ {grUri}\u0022);\r\n\t\t\t\tinstallerUris.Add(grUri);\r\n\t\t\t}\r\n\r\n\t\t\tvar indexBlob = container.GetBlockBlobReference(\u0022latest.txt\u0022);\r\n\t\t\tLogger.Normal($\u0022Uploading index to {indexBlob.Uri}\u0022);\r\n\t\t\tawait indexBlob.UploadTextAsync($\u0022{ProductName} latest version\u0022 \u002B Environment.NewLine\r\n\t\t\t\t\u002B GitVersion.AssemblySemVer \u002B Environment.NewLine\r\n\t\t\t\t\u002B string.Join(Environment.NewLine, installerUris)\r\n\t\t\t\t);\r\n\t\t});\r\n}\r\n"
  },
  {
    "Id": 252578288,
    "FirstIndexed": "2020-04-25T15:47:03.6108962+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162837+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433023+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893881+02:00",
    "Name": "SharpEXR",
    "Owner": "KevinGliewe",
    "HtmlUrl": "https://github.com/KevinGliewe/SharpEXR",
    "Description": "Fork of https://github.com/Enichan/sharpexr - A C# implementation of OpenEXR file format - Ported to .NET Standard 2.0 with CI/CD and published on NuGet",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/KevinGliewe/SharpEXR/blob/master/build/Build.cs",
    "BuildFileSize": 4134,
    "BuildFileContent": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.IO;\nusing System.Text.RegularExpressions;\nusing GCore.Extensions.ArrayEx;\nusing GCore.Extensions.StringShEx;\nusing GCore.Logging;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main()\n    {\n        Log.LoggingHandler.Add(new GCore.Logging.Logger.ConsoleLogger());\n        return Execute\u003CBuild\u003E(x =\u003E x.Compile);\n    }\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath ReadmeFile =\u003E RootDirectory / \u0022README.md\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(ArtifactsDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            var version = new Version(1, 0, 0);\n            try {\n                version = \u0022git tag\u0022.Sh().Split(\u0027\\n\u0027).Get(-2).ExtractVersion();\n            } catch {}\n\n            var commitIndex = \u0022git rev-list --count HEAD\u0022.Sh().Replace(\u0022\\n\u0022, \u0022\u0022).Trim();\n\n            Log.Info(\u0022Repo version:\u0022 \u002B version \u002B \u0022.\u0022 \u002B commitIndex);\n\n            foreach (var project in Solution.AllProjects.Where(p =\u003E p.Name == \u0022SharpEXR\u0022))\n                DotNetPack(_ =\u003E _\n                    .SetProject(project)\n                    .SetNoBuild(InvokedTargets.Contains(Compile))\n                    .SetConfiguration(Configuration)\n                    .SetOutputDirectory(ArtifactsDirectory)\n                    .SetVersion(version \u002B \u0022.\u0022 \u002B commitIndex)\n                    // .SetPackageReleaseNotes(File.ReadAllText(ReadmeFile))\n                    );\n        });\n\n    [Parameter(\u0022NuGet Api Key\u0022)] readonly string ApiKey;\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n\n    Target Publish =\u003E _ =\u003E _\n        .DependsOn(Clean, Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E ApiKey)\n        .Executes(() =\u003E {\n            var packages = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022);\n            Debug.Assert(packages.Count == 1, \u0022packages.Count == 4\u0022);\n\n            DotNetNuGetPush(_ =\u003E _\n                    .SetSource(Source)\n                    .SetApiKey(ApiKey)\n                    .CombineWith(packages, (_, v) =\u003E _\n                        .SetTargetPath(v)),\n                degreeOfParallelism: 5,\n                completeOnFailure: true);\n        });\n}\n"
  },
  {
    "Id": 252681426,
    "FirstIndexed": "2020-04-25T15:47:03.6108939+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1621652+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433034+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "AosMyModule3",
    "Owner": "vladimir-buravlev",
    "HtmlUrl": "https://github.com/vladimir-buravlev/AosMyModule3",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 252730424,
    "FirstIndexed": "2020-04-25T15:50:44.7350805+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1621635+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433251+02:00",
    "LastBuildFileUpdated": "0001-01-01T00:00:00",
    "Name": "MyVC3Module2",
    "Owner": "snVmpl",
    "HtmlUrl": "https://github.com/snVmpl/MyVC3Module2",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": null,
    "BuildFileUrl": null,
    "BuildFileSize": 0,
    "BuildFileContent": null
  },
  {
    "Id": 252747978,
    "FirstIndexed": "2020-04-25T15:47:03.6108917+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628359+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433046+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938821+02:00",
    "Name": "FastHttpPostReceiver",
    "Owner": "AleXr64",
    "HtmlUrl": "https://github.com/AleXr64/FastHttpPostReceiver",
    "Description": null,
    "Archived": false,
    "Stars": 4,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/AleXr64/FastHttpPostReceiver/blob/master/build/Build.cs",
    "BuildFileSize": 3186,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Push);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter] string NugetApiKey;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(_ =\u003E _\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(_ =\u003E _\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n    Target Pack =\u003E\n       _ =\u003E _\n           .DependsOn(Compile)\n           .Produces(ArtifactsDirectory / \u0022*.nupkg\u0022)\n           .Executes(() =\u003E\n           {\n               DotNetPack(s =\u003E s\n                               .SetProject(Solution.GetProject(\u0022FastHttpPostReceiver\u0022))\n                               .SetOutputDirectory(ArtifactsDirectory));\n           });\n\n    Target Push =\u003E\n        _ =\u003E _\n            .DependsOn(Pack)\n            .Executes(() =\u003E\n            {\n                var packages = ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022);\n                DotNetNuGetPush(_ =\u003E _\n                                    .SetSource(Source)\n                                    .SetApiKey(NugetApiKey)\n                                    .CombineWith(packages, (_, v) =\u003E _.SetTargetPath(v)),\n                                5,\n                                true);\n            });\n}\n"
  },
  {
    "Id": 253667114,
    "FirstIndexed": "2020-04-25T15:47:03.6108888+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628314+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433052+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938827+02:00",
    "Name": "hangfire-jobs-sample",
    "Owner": "MichaelSL",
    "HtmlUrl": "https://github.com/MichaelSL/hangfire-jobs-sample",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/MichaelSL/hangfire-jobs-sample/blob/master/build/Build.cs",
    "BuildFileSize": 4077,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    private const string SharedProjectName = \u0022HangfireWorkerService.Shared\u0022;\n    private const string SampleJobsProjectName = \u0022HangfireWorkerService.SampleJobs\u0022;\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022Build Version to use\u0022)]\n    readonly string BuildVersion = \u00220.1.0\u0022;\n    [Parameter(\u0022NuGet server API key\u0022)]\n    readonly string NuGetApiKey;\n    [Parameter(\u0022NuGet server URL\u0022)]\n    readonly string NuGetServerUrl;\n\n    [Solution] readonly Solution Solution;\n    //[GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n    Target PackSharedNuGet =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E BuildVersion)\n        .Executes(() =\u003E\n        {\n            DotNetPack(c =\u003E c\n                .SetProject(Solution.GetProject(SharedProjectName).Path)\n                .SetVersion(BuildVersion)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n        });\n\n    Target PackSampleJobs =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Requires(() =\u003E BuildVersion)\n        .Executes(() =\u003E\n        {\n            DotNetPack(c =\u003E c\n                .SetProject(Solution.GetProject(SampleJobsProjectName).Path)\n                .SetVersion(BuildVersion)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n        });\n\n    Target PushSharedNuGet =\u003E _ =\u003E _\n        .DependsOn(PackSharedNuGet)\n        .Requires(() =\u003E BuildVersion)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E NuGetServerUrl)\n        .Executes(() =\u003E\n        {\n            NuGetTasks.NuGetPush(c =\u003E c\n                .SetApiKey(NuGetApiKey)\n                .SetSource(NuGetServerUrl)\n                .SetTargetPath(ArtifactsDirectory / \u0022nuget\u0022 / $\u0022{SharedProjectName}.{BuildVersion}.nupkg\u0022));\n        });\n\n    Target PushSampleJobsNuGet =\u003E _ =\u003E _\n        .DependsOn(PackSampleJobs)\n        .Requires(() =\u003E BuildVersion)\n        .Requires(() =\u003E NuGetApiKey)\n        .Requires(() =\u003E NuGetServerUrl)\n        .Executes(() =\u003E\n        {\n            NuGetTasks.NuGetPush(c =\u003E c\n                .SetApiKey(NuGetApiKey)\n                .SetSource(NuGetServerUrl)\n                .SetTargetPath(ArtifactsDirectory / \u0022nuget\u0022 / $\u0022{SampleJobsProjectName}.{BuildVersion}.nupkg\u0022));\n        });\n\n    Target PushAllNugets =\u003E _ =\u003E _\n        .DependsOn(PushSharedNuGet, PushSampleJobsNuGet)\n        .Executes(() =\u003E { });\n}\n"
  },
  {
    "Id": 253912168,
    "FirstIndexed": "2020-04-25T15:47:03.610886+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628285+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433063+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938838+02:00",
    "Name": "nuke-issue-454",
    "Owner": "paolofulgoni",
    "HtmlUrl": "https://github.com/paolofulgoni/nuke-issue-454",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/paolofulgoni/nuke-issue-454/blob/master/build/Build.cs",
    "BuildFileSize": 2127,
    "BuildFileContent": "using System;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.NuGet;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution]\n    readonly Solution Solution;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022)\n                .SetConfiguration(Configuration));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Build\u0022)\n                .SetConfiguration(Configuration)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n}\n"
  },
  {
    "Id": 253935923,
    "FirstIndexed": "2020-04-25T15:47:03.6108831+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627711+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433074+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893885+02:00",
    "Name": "NEMTicker",
    "Owner": "global-roam",
    "HtmlUrl": "https://github.com/global-roam/NEMTicker",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/global-roam/NEMTicker/blob/master/build/Build.cs",
    "BuildFileSize": 10584,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Data.SqlClient;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI.AzurePipelines;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\r\n\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n[AzurePipelines(null, AzurePipelinesImage.WindowsLatest\r\n    , InvokedTargets = new[] { nameof(PublishRelease) }\r\n    , TriggerBranchesInclude = new[] { \u0022master\u0022 }\r\n    , AutoGenerate = false\r\n    )]\r\nclass Build : NukeBuild\r\n{\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n\r\n    [Parameter(\u0022Password for \u0027build\u0027 user on gridlicensing-globalroam-production.database.windows.net\u0022)]\r\n    readonly string GridLicencsingDatabasePassword;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitVersion(Framework = \u0022netcoreapp3.1\u0022)] readonly GitVersion GitVersion;\r\n\r\n    readonly string ProductName = \u0022NEMTicker\u0022;\r\n    readonly string LicencedProgramName = \u0022NEMTicker\u0022;\r\n\r\n    [Parameter]\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    [Parameter]\r\n    AbsolutePath BuildOutput =\u003E RootDirectory / \u0022binaries\u0022;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\r\n    AbsolutePath TempDirectory =\u003E RootDirectory / \u0022temp\u0022;\r\n    AbsolutePath InstallerDirectory =\u003E RootDirectory / \u0022installer\u0022;\r\n    AbsolutePath AllOtherFiles =\u003E InstallerDirectory / \u0022AllOtherFiles.wxs\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            InstallerDirectory.GlobDirectories(\u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(BuildOutput);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            MSBuild(s =\u003E s\r\n                .SetTargetPath(Solution)\r\n                .SetTargets(\u0022Restore\u0022));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Clean)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            var project = Solution.GetProject(\u0022NEMTicker\u0022);\r\n            MSBuild(s =\u003E s\r\n                .SetTargetPath(Solution)\r\n                .SetTargets(\u0022Rebuild\u0022)\r\n                .SetOutDir(BuildOutput)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .SetMaxCpuCount(Environment.ProcessorCount)\r\n                .SetNodeReuse(IsLocalBuild));\r\n        });\r\n\r\n    Target HarvestBuildOutput =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            var excludeRegexPatterns = new[] { \u0022^NEMTicker.exe$\u0022 }.Select(p =\u003E new Regex(p, RegexOptions.Compiled | RegexOptions.IgnoreCase)).ToArray();\r\n            var excludedFiles = Directory.GetFiles(BuildOutput, \u0022*.*\u0022, SearchOption.AllDirectories)\r\n                .Select(f =\u003E new FileInfo(f))\r\n                .Where(file =\u003E\r\n                    {\r\n                        foreach (var regex in excludeRegexPatterns)\r\n                        {\r\n                            if (regex.IsMatch(file.Name))\r\n                            {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return false;\r\n                    })\r\n                .ToList();\r\n\r\n            EnsureExistingDirectory(TempDirectory);\r\n            foreach (var file in excludedFiles)\r\n            {\r\n                file.MoveTo(TempDirectory / file.Name, true);\r\n            }\r\n\r\n            Heat(arguments: $@\u0022dir \u0022\u0022{BuildOutput}\u0022\u0022 -o \u0022\u0022{AllOtherFiles}\u0022\u0022 -ag -ke -cg AllOtherFiles -scom -sfrag -sreg -srd -dr INSTALLFOLDER -suid -indent 2\u0022);\r\n\r\n            foreach (var file in excludedFiles)\r\n            {\r\n                file.MoveTo(BuildOutput / file.Name, true);\r\n            }\r\n\r\n            var txtLines = File.ReadAllLines(AllOtherFiles).ToList();\r\n            txtLines.Insert(txtLines.IndexOf(@\u0022\u003CWix xmlns=\u0022\u0022http://schemas.microsoft.com/wix/2006/wi\u0022\u0022\u003E\u0022) \u002B 1, @\u0022  \u003C?include Variables.wxi ?\u003E\u0022);\r\n            File.WriteAllLines(AllOtherFiles, txtLines);\r\n\r\n        });\r\n\r\n    [PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022candle.exe\u0022)]\r\n    readonly Tool Candle;\r\n    [PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022light.exe\u0022)]\r\n    readonly Tool Light;\r\n    [PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022heat.exe\u0022)]\r\n    readonly Tool Heat;\r\n\r\n    Target Installer =\u003E _ =\u003E _\r\n        .DependsOn(HarvestBuildOutput)\r\n        .Executes(() =\u003E\r\n        {\r\n            Environment.CurrentDirectory = InstallerDirectory;\r\n\r\n            var sourceFiles = string.Join(\u0022 \u0022, Directory.GetFiles(InstallerDirectory, \u0022*.wxs\u0022).Select(s =\u003E $@\u0022\u0022\u0022{Path.Combine(InstallerDirectory, s)}\u0022\u0022\u0022));\r\n\r\n            foreach (var arch in new[] { \u0022x64\u0022, \u0022x86\u0022 })\r\n            {\r\n                var installerFileName = $\u0022Install_{ProductName}_{GitVersion.AssemblySemVer}_{arch}.msi\u0022;\r\n                Logger.Normal(\u0022Building {0}\u0022, installerFileName);\r\n\r\n                var objFolder = $\u0022obj\\\\{arch}\\\\\u0022;\r\n                EnsureExistingDirectory(objFolder);\r\n\r\n                var candleArgs = $@\u0022-ext WixUtilExtension -out {objFolder} -arch {arch} -dPlatform={arch} -pedantic -v {sourceFiles}\u0022;\r\n                Candle(arguments: candleArgs);\r\n\r\n                var objectFiles = string.Join(\u0022 \u0022, Directory.GetFiles(objFolder).Select(s =\u003E $@\u0022\u0022\u0022{Path.Combine(InstallerDirectory, s)}\u0022\u0022\u0022));\r\n\r\n                var lightArgs = $\u0022-b {BuildOutput} -ext WixUtilExtension -ext WixUIExtension -ext WixNetFxExtension -out {ArtifactsDirectory / installerFileName} {objectFiles}\u0022;\r\n                Light(arguments: lightArgs);\r\n            }\r\n        });\r\n\r\n    Target AddVersionToLicenceSystem =\u003E _ =\u003E _\r\n        .DependsOn(Installer)\r\n        .Requires(() =\u003E GridLicencsingDatabasePassword)\r\n        .OnlyWhenStatic(() =\u003E IsServerBuild)\r\n        .WhenSkipped(DependencyBehavior.Skip)\r\n        .Executes(async () =\u003E\r\n        {\r\n            var connectionStringBuilder = new SqlConnectionStringBuilder\r\n            {\r\n                DataSource = \u0022gridlicensing-globalroam-production.database.windows.net\u0022,\r\n                InitialCatalog = \u0022gridlicensing\u0022,\r\n                UserID = \u0022build\u0022,\r\n                Password = GridLicencsingDatabasePassword\r\n            };\r\n\r\n            var version = GitVersion.AssemblySemVer;\r\n            var programName = LicencedProgramName;\r\n            Logger.Normal(\u0022Adding {0} v{1} to licence system database {2}\u0022, programName, version, connectionStringBuilder.DataSource);\r\n\r\n            var query = File.ReadAllText(RootDirectory / \u0022build/AddNewVersionToLicenceSystem.sql\u0022);\r\n\r\n            using var connection = new SqlConnection(connectionStringBuilder.ConnectionString);\r\n            using var command = connection.CreateCommand();\r\n            command.CommandText = query;\r\n            command.Parameters.AddWithValue(\u0022@NewVersion\u0022, version);\r\n            command.Parameters.AddWithValue(\u0022@ProgramName\u0022, programName);\r\n\r\n            Logger.Normal(\u0022Opening connection to {0}\u0022, connectionStringBuilder.DataSource);\r\n            await connection.OpenAsync();\r\n\r\n            Logger.Normal(\u0022Execute {0}\u0022, command.CommandText);\r\n            await command.ExecuteNonQueryAsync();\r\n        });\r\n\r\n    Target PublishRelease =\u003E _ =\u003E _\r\n        .TriggeredBy(AddVersionToLicenceSystem)\r\n        .DependsOn(AddVersionToLicenceSystem)\r\n        .OnlyWhenStatic(() =\u003E IsServerBuild)\r\n        .WhenSkipped(DependencyBehavior.Skip)\r\n        .Executes(async () =\u003E\r\n        {\r\n            var storageAccount = new Microsoft.WindowsAzure.Storage.CloudStorageAccount(new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(\u0022grinstallers\u0022, \u0022RFzSdJx6iRQi\u002BF0MRdkk5yU31in3aVvWacx54Uuus2\u002BaK3gi3jW88MMLZyDILpVU5elYuX8gt2geTPKO7TtOlg==\u0022), true);\r\n\r\n            var releaseCandidateDcFolder = $@\u0022\\\\dc.gr.local\\RoamSoftware\\global-roam\\global-roam Products\\{ProductName}\\Release Candidate\u0022;\r\n            EnsureExistingDirectory(releaseCandidateDcFolder);\r\n\r\n            static string ReplaceHost(Uri original, string newHostName)\r\n            {\r\n                var builder = new UriBuilder(original) { Host = newHostName };\r\n                return builder.Uri.ToString();\r\n            }\r\n\r\n            var installerUris = new List\u003Cstring\u003E();\r\n            var blobClient = storageAccount.CreateCloudBlobClient();\r\n            var container = blobClient.GetContainerReference(ProductName.ToLower());\r\n            await container.CreateIfNotExistsAsync();\r\n\r\n            foreach (var installerFile in Directory.GetFiles(ArtifactsDirectory, \u0022*.msi\u0022))\r\n            {\r\n                Logger.Normal($\u0022Copying {installerFile} to {releaseCandidateDcFolder}\u0022);\r\n                CopyFileToDirectory(installerFile, releaseCandidateDcFolder);\r\n\r\n                var installerFileName = Path.GetFileName(installerFile);\r\n                var block = container.GetBlockBlobReference(installerFileName);\r\n                Logger.Normal($\u0022Uploading {installerFile} to {block.Uri}\u0022);\r\n\r\n                await block.UploadFromFileAsync(installerFile);\r\n\r\n                var grUri = ReplaceHost(block.Uri, \u0022installers.global-roam.com\u0022);\r\n                Logger.Normal($\u0022Installer available @ {grUri}\u0022);\r\n                installerUris.Add(grUri);\r\n            }\r\n\r\n            var indexBlob = container.GetBlockBlobReference(\u0022latest.txt\u0022);\r\n            Logger.Normal($\u0022Uploading index to {indexBlob.Uri}\u0022);\r\n            await indexBlob.UploadTextAsync($\u0022{ProductName} latest version\u0022 \u002B Environment.NewLine\r\n                \u002B GitVersion.AssemblySemVer \u002B Environment.NewLine\r\n                \u002B string.Join(Environment.NewLine, installerUris)\r\n                );\r\n        });\r\n}\r\n"
  },
  {
    "Id": 254123470,
    "FirstIndexed": "2020-04-25T15:47:03.6108808+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628274+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433086+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938861+02:00",
    "Name": "v00v",
    "Owner": "v0vc",
    "HtmlUrl": "https://github.com/v0vc/v00v",
    "Description": "YouTube content manager (youtube-dl/ffmpeg gui)",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/build/Build.cs",
    "BuildFileUrl": "https://github.com/v0vc/v00v/blob/master/build/build/Build.cs",
    "BuildFileSize": 2703,
    "BuildFileContent": "using System.Collections.Generic;\r\nusing Nuke.Common;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\n\r\nclass Build : NukeBuild\r\n{\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Solution]\r\n    readonly Solution Solution;\r\n\r\n    [Parameter(\u0022configuration\u0022)]\r\n    public string Configuration { get; set; }\r\n\r\n    [Parameter(\u0022version-suffix\u0022)]\r\n    public string VersionSuffix { get; set; }\r\n\r\n    [Parameter(\u0022publish-framework\u0022)]\r\n    public string PublishFramework { get; set; }\r\n\r\n    [Parameter(\u0022publish-runtime\u0022)]\r\n    public string PublishRuntime { get; set; }\r\n\r\n    [Parameter(\u0022publish-project\u0022)]\r\n    public string PublishProject { get; set; }\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n\r\n    //AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n\r\n    protected override void OnBuildInitialized()\r\n    {\r\n        Configuration ??= \u0022Release\u0022;\r\n        VersionSuffix ??= string.Empty;\r\n    }\r\n\r\n    private void DeleteDirectories(IReadOnlyCollection\u003Cstring\u003E directories)\r\n    {\r\n        foreach (var directory in directories)\r\n        {\r\n            DeleteDirectory(directory);\r\n        }\r\n    }\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DeleteDirectories(GlobDirectories(SourceDirectory, \u0022**/bin\u0022, \u0022**/obj\u0022));\r\n            //EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .DependsOn(Clean)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(s =\u003E s\r\n                .SetProjectFile(Solution));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(s =\u003E s\r\n                .SetProjectFile(Solution)\r\n                .SetConfiguration(Configuration)\r\n                .SetVersionSuffix(VersionSuffix)\r\n                .EnableNoRestore());\r\n        });\r\n\r\n    //Target Publish =\u003E _ =\u003E _\r\n    //    .DependsOn(Compile)\r\n    //    .Requires(() =\u003E PublishRuntime)\r\n    //    .Requires(() =\u003E PublishFramework)\r\n    //    .Requires(() =\u003E PublishProject)\r\n    //    .Executes(() =\u003E\r\n    //    {\r\n    //        DotNetPublish(s =\u003E s.SetProject(Solution.GetProject(PublishProject)).SetConfiguration(Configuration)\r\n    //                          .SetVersionSuffix(VersionSuffix).SetFramework(PublishFramework).SetRuntime(PublishRuntime));\r\n    //        //.SetOutput(ArtifactsDirectory / \u0022Publish\u0022 / PublishProject \u002B \u0022-\u0022 \u002B PublishFramework \u002B \u0022-\u0022 \u002B PublishRuntime));\r\n    //    });\r\n}\r\n"
  },
  {
    "Id": 254634877,
    "FirstIndexed": "2020-04-25T15:47:03.6108496+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162808+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433097+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938872+02:00",
    "Name": "testutils",
    "Owner": "piksel",
    "HtmlUrl": "https://github.com/piksel/testutils",
    "Description": "Test Utils for .NET",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/piksel/testutils/blob/master/build/Build.cs",
    "BuildFileSize": 2714,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .Produces(ArtifactsDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution)\n                .SetOutputDirectory(ArtifactsDirectory));\n        });\n\n}\n"
  },
  {
    "Id": 254808665,
    "FirstIndexed": "2020-04-25T15:47:03.6108473+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628069+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433108+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938884+02:00",
    "Name": "Nucular",
    "Owner": "hot33331",
    "HtmlUrl": "https://github.com/hot33331/Nucular",
    "Description": "Trying to build the Xamarin app template with NUKE",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/hot33331/Nucular/blob/master/build/Build.cs",
    "BuildFileSize": 2283,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .SetMaxCpuCount(Environment.ProcessorCount)\n                .SetNodeReuse(IsLocalBuild));\n        });\n\n}\n"
  },
  {
    "Id": 255043730,
    "FirstIndexed": "2020-04-25T15:50:44.7357342+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627841+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434525+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940243+02:00",
    "Name": "NukeExamplesFinder",
    "Owner": "VolkmarR",
    "HtmlUrl": "https://github.com/VolkmarR/NukeExamplesFinder",
    "Description": "Builds a list of Repositories containing a nuke build script",
    "Archived": false,
    "Stars": 1,
    "Watchers": 1,
    "BuildFilePath": "src/NukeExamplesFinder/Startup.cs",
    "BuildFileUrl": "https://github.com/VolkmarR/NukeExamplesFinder/blob/master/src/NukeExamplesFinder/Startup.cs",
    "BuildFileSize": 2306,
    "BuildFileContent": "\uFEFFusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing NukeExamplesFinder.Gateways;\nusing NukeExamplesFinder.Models;\nusing NukeExamplesFinder.Services;\nusing Octokit;\nusing System;\nusing System.IO;\n\nnamespace NukeExamplesFinder\n{\n    public static class Startup\n    {\n        public static IHostBuilder CreateHostBuilder()\n            =\u003E new HostBuilder()\n                .ConfigureAppConfiguration(ConfigureAppConfiguration)\n                .ConfigureServices(ConfigureServices)\n                .UseConsoleLifetime();\n\n        public static void ConfigureAppConfiguration(HostBuilderContext hostContext, IConfigurationBuilder builder)\n        {\n            builder\n             .SetBasePath(Directory.GetCurrentDirectory())\n             .AddJsonFile($\u0022appsettings.json\u0022, optional: false);\n\n            if (string.Equals(Environment.GetEnvironmentVariable(\u0022NETCORE_ENVIRONMENT\u0022) ?? \u0022development\u0022, \u0022development\u0022, StringComparison.OrdinalIgnoreCase))\n                builder.AddUserSecrets\u003CProgram\u003E();\n        }\n\n        public static void ConfigureServices(HostBuilderContext hostContext, IServiceCollection services)\n        {\n            services.Configure\u003CCredentialsSettings\u003E(hostContext.Configuration.GetSection(\u0022Credentials\u0022));\n            services.Configure\u003CDataFilesSettings\u003E(hostContext.Configuration.GetSection(\u0022DataFiles\u0022));\n            services.AddLogging(configure =\u003E configure.AddConsole());\n            services.AddTransient\u003CRenderService\u003E();\n            services.AddTransient\u003CRepositoryListService\u003E();\n            services.AddTransient\u003CIGitHubGateway, GitHubGateway\u003E();\n            services.AddTransient\u003CIFileGateway, FileGateway\u003E();\n\n            services.AddTransient\u003CIGitHubClient\u003E((serviceProvider) =\u003E\n            {\n                var token = serviceProvider.GetRequiredService\u003CIOptions\u003CCredentialsSettings\u003E\u003E().Value.GitHubToken;\n                if (string.IsNullOrEmpty(token))\n                    throw new ArgumentException(\u0022Credentials:GitHubToken can not be empty\u0022);\n\n                return new GitHubClient(new ProductHeaderValue(\u0022NukeExampleFinder\u0022)) { Credentials = new Credentials(token) };\n            });\n        }\n\n    }\n}\n"
  },
  {
    "Id": 255516987,
    "FirstIndexed": "2020-04-25T15:47:03.6108376+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1628001+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843312+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938895+02:00",
    "Name": "GlobalRoam.Configuration",
    "Owner": "global-roam",
    "HtmlUrl": "https://github.com/global-roam/GlobalRoam.Configuration",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/global-roam/GlobalRoam.Configuration/blob/master/build/Build.cs",
    "BuildFileSize": 2381,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing System;\nusing System.Linq;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitVersion(Framework = \u0022netcoreapp3.1\u0022)] readonly GitVersion GitVersion;\n\n    [Parameter]\n    AbsolutePath ArtifactsDirectory { get; set; } = RootDirectory / \u0022artifacts\u0022;\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Produces(ArtifactsDirectory / \u0022*.nupkg\u0022)\n        .Executes(() =\u003E\n        {\n            DotNetPack(_ =\u003E _\n                .SetProject(Solution)\n                .SetNoBuild(ExecutingTargets.Contains(Compile))\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(GitVersion.AssemblySemVer));\n        });\n}\n"
  },
  {
    "Id": 255632738,
    "FirstIndexed": "2020-04-25T15:47:03.6108325+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627944+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433131+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938906+02:00",
    "Name": "Excel",
    "Owner": "Allors",
    "HtmlUrl": "https://github.com/Allors/Excel",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 4,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Allors/Excel/blob/master/build/Build.cs",
    "BuildFileSize": 3396,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Tools.MSBuild;\nusing Nuke.Common.Tools.Xunit;\nusing Nuke.Common.Utilities.Collections;\nusing Nuke.Common.Tools.DotNet;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\nusing static Nuke.Common.Tools.Xunit.XunitTasks;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Ci);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(Solution)\n                .SetTargets(\u0022Restore\u0022));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            MSBuild(s =\u003E s\n                .SetTargetPath(SourceDirectory / \u0022Allors.Excel.Tests\u0022 / \u0022Allors.Excel.Tests.csproj\u0022)\n                .SetTargets(\u0022Rebuild\u0022)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion));\n\n        });\n\n    Target Tests =\u003E _ =\u003E _\n       .DependsOn(Compile)\n       .Executes(() =\u003E\n       {\n           var assembly = (AbsolutePath)GlobFiles(SourceDirectory, \u0022**/Allors.Excel.Tests.dll\u0022).First();\n           var workingDirectory = assembly.Parent;\n\n           Xunit2(v =\u003E v\n                 .SetFramework(\u0022net461\u0022)\n                 .SetWorkingDirectory(workingDirectory)\n                 .AddTargetAssemblies(assembly)\n                 .SetResultReport(Xunit2ResultFormat.Xml, ArtifactsDirectory / \u0022tests\u0022 / \u0022results.xml\u0022));\n       });\n\n    Target Pack =\u003E _ =\u003E _\n       .After(Tests)\n       .DependsOn(Compile)\n       .Executes(() =\u003E\n       {\n           var projects = new[] { \u0022Allors.Excel\u0022, \u0022Allors.Excel.Headless\u0022, \u0022Allors.Excel.Interop\u0022 };\n\n           foreach (var project in projects)\n           {\n               DotNetPack(s =\u003E s\n                     .SetProject(Solution.GetProject(project))\n                     .SetConfiguration(Configuration)\n                     .SetVersion(GitVersion.NuGetVersionV2)\n                     .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n           }\n       });\n\n\n    Target Ci =\u003E _ =\u003E _\n      .DependsOn(Pack, Tests);\n\n}\n"
  },
  {
    "Id": 255793621,
    "FirstIndexed": "2020-04-25T15:50:44.7357199+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627694+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434508+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940221+02:00",
    "Name": "CsvHelper",
    "Owner": "yishuiyuan759712949",
    "HtmlUrl": "https://github.com/yishuiyuan759712949/CsvHelper",
    "Description": "CsvHelper\u5E93\u7684\u4F7F\u7528",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "CsvHelper-master/build/Build.cs",
    "BuildFileUrl": "https://github.com/yishuiyuan759712949/CsvHelper/blob/master/CsvHelper-master/build/Build.cs",
    "BuildFileSize": 4669,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n    [Parameter(\u0022NuGet server URL.\u0022)]\n\treadonly string NugetSource = \u0022https://api.nuget.org/v3/index.json\u0022;\n    [Parameter(\u0022API Key for the NuGet server.\u0022)]\n\treadonly string NugetApiKey;\n\t[Parameter(\u0022Version to use for package.\u0022)]\n\treadonly string Version;\n\n    [Solution]\n\treadonly Solution Solution;\n    [GitRepository]\n\treadonly GitRepository GitRepository;\n    [GitVersion]\n\treadonly GitVersion GitVersion;\n\t\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Project CsvHelperProject =\u003E Solution.GetProject(\u0022CsvHelper\u0022);\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution)\n\t\t\t);\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .EnableNoRestore()\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(Version ?? GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(Version ?? GitVersion.InformationalVersion)\n\t\t\t);\n\n            DotNetPublish(s =\u003E s\n\t\t\t\t.EnableNoRestore()\n\t\t\t\t.EnableNoBuild()\n\t\t\t\t.SetConfiguration(Configuration)\n\t\t\t\t.SetAssemblyVersion(GitVersion.AssemblySemVer)\n\t\t\t\t.SetFileVersion(Version ?? GitVersion.AssemblySemFileVer)\n\t\t\t\t.SetInformationalVersion(Version ?? GitVersion.InformationalVersion)\n\t\t\t\t.CombineWith(\n\t\t\t\t\tfrom project in new[] { CsvHelperProject }\n\t\t\t\t\tfrom framework in project.GetTargetFrameworks()\n                    select new { project, framework }, (cs, v) =\u003E cs\n\t\t\t\t\t\t.SetProject(v.project)\n\t\t\t\t\t\t.SetFramework(v.framework)\n\t\t\t\t)\n\t\t\t);\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore()\n                .EnableNoBuild()\n            );\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Clean, Test)\n\t\t.Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .EnableNoRestore()\n                .EnableNoBuild()\n\t\t\t\t.SetProject(Solution)\n                .SetConfiguration(Configuration)\n                .SetOutputDirectory(ArtifactsDirectory)\n                .SetVersion(Version ?? GitVersion.NuGetVersionV2)\n\t\t\t\t.SetIncludeSymbols(true)\n\t\t\t\t.SetSymbolPackageFormat(DotNetSymbolPackageFormat.snupkg)\n            );\n        });\n\n    Target Push =\u003E _ =\u003E _\n        .DependsOn(Pack)\n        .Consumes(Pack)\n        .Requires(() =\u003E Configuration == Configuration.Release)\n        .Executes(() =\u003E\n        {\n            DotNetNuGetPush(s =\u003E s\n\t\t\t\t.SetSource(NugetSource)\n\t\t\t\t.SetApiKey(NugetApiKey)\n\t\t\t\t.CombineWith(ArtifactsDirectory.GlobFiles(\u0022*.nupkg\u0022), (s, v) =\u003E s\n\t\t\t\t\t.SetTargetPath(v)\n\t\t\t\t)\n            );\n        });\n}\n"
  },
  {
    "Id": 255828361,
    "FirstIndexed": "2020-04-25T15:47:03.6108348+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627654+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433137+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938918+02:00",
    "Name": "deSide",
    "Owner": "global-roam",
    "HtmlUrl": "https://github.com/global-roam/deSide",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/global-roam/deSide/blob/master/build/Build.cs",
    "BuildFileSize": 10579,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Data.SqlClient;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI.AzurePipelines;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.MSBuild;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.MSBuild.MSBuildTasks;\r\n\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n[AzurePipelines(null, AzurePipelinesImage.WindowsLatest\r\n    , InvokedTargets = new[] { nameof(PublishRelease) }\r\n    , TriggerBranchesInclude = new[] { \u0022master\u0022 }\r\n    , AutoGenerate = false\r\n    )]\r\nclass Build : NukeBuild\r\n{\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n\r\n    [Parameter(\u0022Password for \u0027build\u0027 user on gridlicensing-globalroam-production.database.windows.net\u0022)]\r\n    readonly string GridLicencsingDatabasePassword;\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\r\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitVersion(Framework = \u0022netcoreapp3.1\u0022)] readonly GitVersion GitVersion;\r\n\r\n    readonly string ProductName = \u0022deSide\u0022;\r\n    readonly string LicencedProgramName = \u0022deSide\u0022;\r\n\r\n    [Parameter]\r\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\r\n    [Parameter]\r\n    AbsolutePath BuildOutput =\u003E RootDirectory / \u0022binaries\u0022;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022source\u0022;\r\n    AbsolutePath TempDirectory =\u003E RootDirectory / \u0022temp\u0022;\r\n    AbsolutePath InstallerDirectory =\u003E RootDirectory / \u0022installer\u0022;\r\n    AbsolutePath AllOtherFiles =\u003E InstallerDirectory / \u0022AllOtherFiles.wxs\u0022;\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            InstallerDirectory.GlobDirectories(\u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n            EnsureCleanDirectory(BuildOutput);\r\n            EnsureCleanDirectory(ArtifactsDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            MSBuild(s =\u003E s\r\n                .SetTargetPath(Solution)\r\n                .SetTargets(\u0022Restore\u0022));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Clean)\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            var project = Solution.GetProject(\u0022deSide\u0022);\r\n\r\n            MSBuild(s =\u003E s\r\n                .SetTargetPath(project)\r\n                .SetTargets(\u0022Rebuild\u0022)\r\n                .SetOutDir(BuildOutput)\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion)\r\n                .SetMaxCpuCount(Environment.ProcessorCount)\r\n                .SetNodeReuse(IsLocalBuild));\r\n        });\r\n\r\n    Target HarvestBuildOutput =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Executes(() =\u003E\r\n        {\r\n            var excludeRegexPatterns = new[] { \u0022^deside.exe$\u0022 }.Select(p =\u003E new Regex(p, RegexOptions.Compiled | RegexOptions.IgnoreCase)).ToArray();\r\n            var excludedFiles = Directory.GetFiles(BuildOutput, \u0022*.*\u0022, SearchOption.AllDirectories)\r\n                .Select(f =\u003E new FileInfo(f))\r\n                .Where(file =\u003E\r\n                    {\r\n                        foreach (var regex in excludeRegexPatterns)\r\n                        {\r\n                            if (regex.IsMatch(file.Name))\r\n                            {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return false;\r\n                    })\r\n                .ToList();\r\n\r\n            EnsureExistingDirectory(TempDirectory);\r\n            foreach (var file in excludedFiles)\r\n            {\r\n                file.MoveTo(TempDirectory / file.Name, true);\r\n            }\r\n\r\n            Heat(arguments: $@\u0022dir \u0022\u0022{BuildOutput}\u0022\u0022 -o \u0022\u0022{AllOtherFiles}\u0022\u0022 -ag -ke -cg AllOtherFiles -scom -sfrag -sreg -srd -dr INSTALLFOLDER -suid -indent 2\u0022);\r\n\r\n            foreach (var file in excludedFiles)\r\n            {\r\n                file.MoveTo(BuildOutput / file.Name, true);\r\n            }\r\n\r\n            //var txtLines = File.ReadAllLines(AllOtherFiles).ToList();\r\n            //txtLines.Insert(txtLines.IndexOf(@\u0022\u003CWix xmlns=\u0022\u0022http://schemas.microsoft.com/wix/2006/wi\u0022\u0022\u003E\u0022) \u002B 1, @\u0022  \u003C?include Variables.wxi ?\u003E\u0022);\r\n            //File.WriteAllLines(AllOtherFiles, txtLines);\r\n\r\n        });\r\n\r\n    [PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022candle.exe\u0022)]\r\n    readonly Tool Candle;\r\n    [PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022light.exe\u0022)]\r\n    readonly Tool Light;\r\n    [PackageExecutable(packageId: \u0022WiX\u0022, packageExecutable: \u0022heat.exe\u0022)]\r\n    readonly Tool Heat;\r\n\r\n    Target Installer =\u003E _ =\u003E _\r\n        .DependsOn(HarvestBuildOutput)\r\n        .Executes(() =\u003E\r\n        {\r\n            Environment.CurrentDirectory = InstallerDirectory;\r\n\r\n            var sourceFiles = string.Join(\u0022 \u0022, Directory.GetFiles(InstallerDirectory, \u0022*.wxs\u0022).Select(s =\u003E $@\u0022\u0022\u0022{Path.Combine(InstallerDirectory, s)}\u0022\u0022\u0022));\r\n\r\n            foreach (var arch in new[] { \u0022x64\u0022, \u0022x86\u0022 })\r\n            {\r\n                var installerFileName = $\u0022Install_{ProductName}_{GitVersion.AssemblySemVer}_{arch}.msi\u0022;\r\n                Logger.Normal(\u0022Building {0}\u0022, installerFileName);\r\n\r\n                var objFolder = $\u0022obj\\\\{arch}\\\\\u0022;\r\n                EnsureExistingDirectory(objFolder);\r\n\r\n                var candleArgs = $@\u0022-ext WixUtilExtension -out {objFolder} -arch {arch} -dPlatform={arch} -pedantic -v {sourceFiles}\u0022;\r\n                Candle(arguments: candleArgs);\r\n\r\n                var objectFiles = string.Join(\u0022 \u0022, Directory.GetFiles(objFolder).Select(s =\u003E $@\u0022\u0022\u0022{Path.Combine(InstallerDirectory, s)}\u0022\u0022\u0022));\r\n\r\n                var lightArgs = $\u0022-b {BuildOutput} -ext WixUtilExtension -ext WixUIExtension -ext WixNetFxExtension -out {ArtifactsDirectory / installerFileName} {objectFiles}\u0022;\r\n                Light(arguments: lightArgs);\r\n            }\r\n        });\r\n\r\n    Target AddVersionToLicenceSystem =\u003E _ =\u003E _\r\n        .DependsOn(Installer)\r\n        .Requires(() =\u003E GridLicencsingDatabasePassword)\r\n        .OnlyWhenStatic(() =\u003E IsServerBuild)\r\n        .WhenSkipped(DependencyBehavior.Skip)\r\n        .Executes(async () =\u003E\r\n        {\r\n            var connectionStringBuilder = new SqlConnectionStringBuilder\r\n            {\r\n                DataSource = \u0022gridlicensing-globalroam-production.database.windows.net\u0022,\r\n                InitialCatalog = \u0022gridlicensing\u0022,\r\n                UserID = \u0022build\u0022,\r\n                Password = GridLicencsingDatabasePassword\r\n            };\r\n\r\n            var version = GitVersion.AssemblySemVer;\r\n            var programName = LicencedProgramName;\r\n            Logger.Normal(\u0022Adding {0} v{1} to licence system database {2}\u0022, programName, version, connectionStringBuilder.DataSource);\r\n\r\n            var query = File.ReadAllText(RootDirectory / \u0022build/AddNewVersionToLicenceSystem.sql\u0022);\r\n\r\n            using var connection = new SqlConnection(connectionStringBuilder.ConnectionString);\r\n            using var command = connection.CreateCommand();\r\n            command.CommandText = query;\r\n            command.Parameters.AddWithValue(\u0022@NewVersion\u0022, version);\r\n            command.Parameters.AddWithValue(\u0022@ProgramName\u0022, programName);\r\n\r\n            Logger.Normal(\u0022Opening connection to {0}\u0022, connectionStringBuilder.DataSource);\r\n            await connection.OpenAsync();\r\n\r\n            Logger.Normal(\u0022Execute {0}\u0022, command.CommandText);\r\n            await command.ExecuteNonQueryAsync();\r\n        });\r\n\r\n    Target PublishRelease =\u003E _ =\u003E _\r\n        .TriggeredBy(AddVersionToLicenceSystem)\r\n        .DependsOn(AddVersionToLicenceSystem)\r\n        .OnlyWhenStatic(() =\u003E IsServerBuild)\r\n        .WhenSkipped(DependencyBehavior.Skip)\r\n        .Executes(async () =\u003E\r\n        {\r\n            var storageAccount = new Microsoft.WindowsAzure.Storage.CloudStorageAccount(new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(\u0022grinstallers\u0022, \u0022RFzSdJx6iRQi\u002BF0MRdkk5yU31in3aVvWacx54Uuus2\u002BaK3gi3jW88MMLZyDILpVU5elYuX8gt2geTPKO7TtOlg==\u0022), true);\r\n\r\n            var releaseCandidateDcFolder = $@\u0022\\\\dc.gr.local\\RoamSoftware\\global-roam\\global-roam Products\\{ProductName}\\Release Candidate\u0022;\r\n            EnsureExistingDirectory(releaseCandidateDcFolder);\r\n\r\n            static string ReplaceHost(Uri original, string newHostName)\r\n            {\r\n                var builder = new UriBuilder(original) { Host = newHostName };\r\n                return builder.Uri.ToString();\r\n            }\r\n\r\n            var installerUris = new List\u003Cstring\u003E();\r\n            var blobClient = storageAccount.CreateCloudBlobClient();\r\n            var container = blobClient.GetContainerReference(ProductName.ToLower());\r\n            await container.CreateIfNotExistsAsync();\r\n\r\n            foreach (var installerFile in Directory.GetFiles(ArtifactsDirectory, \u0022*.msi\u0022))\r\n            {\r\n                Logger.Normal($\u0022Copying {installerFile} to {releaseCandidateDcFolder}\u0022);\r\n                CopyFileToDirectory(installerFile, releaseCandidateDcFolder);\r\n\r\n                var installerFileName = Path.GetFileName(installerFile);\r\n                var block = container.GetBlockBlobReference(installerFileName);\r\n                Logger.Normal($\u0022Uploading {installerFile} to {block.Uri}\u0022);\r\n\r\n                await block.UploadFromFileAsync(installerFile);\r\n\r\n                var grUri = ReplaceHost(block.Uri, \u0022installers.global-roam.com\u0022);\r\n                Logger.Normal($\u0022Installer available @ {grUri}\u0022);\r\n                installerUris.Add(grUri);\r\n            }\r\n\r\n            var indexBlob = container.GetBlockBlobReference(\u0022latest.txt\u0022);\r\n            Logger.Normal($\u0022Uploading index to {indexBlob.Uri}\u0022);\r\n            await indexBlob.UploadTextAsync($\u0022{ProductName} latest version\u0022 \u002B Environment.NewLine\r\n                \u002B GitVersion.AssemblySemVer \u002B Environment.NewLine\r\n                \u002B string.Join(Environment.NewLine, installerUris)\r\n                );\r\n        });\r\n}\r\n"
  },
  {
    "Id": 255880032,
    "FirstIndexed": "2020-04-25T15:50:44.7357489+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627984+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8434536+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8940255+02:00",
    "Name": "Documents",
    "Owner": "Allors",
    "HtmlUrl": "https://github.com/Allors/Documents",
    "Description": "Generate office documents using embedded templates tags",
    "Archived": false,
    "Stars": 0,
    "Watchers": 4,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Allors/Documents/blob/master/build/Build.cs",
    "BuildFileSize": 3484,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Ci);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Parameter(\u0022Collect code coverage. Default is \u0027true\u0027\u0022)] readonly bool? Cover = true;\n\n    [Parameter(\u0022Coverage threshold. Default is 80%\u0022)] readonly int Threshold = 80;\n\n    [Solution(\u0022src/Documents.sln\u0022)] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target Test =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(Solution.GetProject(\u0022Allors.Documents.Tests\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetLogger(\u0022trx\u0022)\n                .SetLogOutput(true)\n                .SetArgumentConfigurator(arguments =\u003E arguments.Add(\u0022/p:CollectCoverage={0}\u0022, Cover)\n                    .Add(\u0022/p:CoverletOutput={0}/\u0022, ArtifactsDirectory / \u0022coverage\u0022)\n                    .Add(\u0022/p:Threshold={0}\u0022, Threshold)\n                    .Add(\u0022/p:UseSourceLink={0}\u0022, \u0022true\u0022)\n                    .Add(\u0022/p:CoverletOutputFormat={0}\u0022, \u0022cobertura\u0022))\n                .SetResultsDirectory(ArtifactsDirectory / \u0022tests\u0022));\n        });\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E\n        {\n            DotNetPack(s =\u003E s\n                .SetProject(Solution.GetProject(\u0022Allors.Documents\u0022))\n                .SetConfiguration(Configuration)\n                .EnableNoBuild()\n                .EnableNoRestore()\n                .SetVersion(GitVersion.NuGetVersionV2)\n                .SetOutputDirectory(ArtifactsDirectory / \u0022nuget\u0022));\n        });\n\n    Target CiNonWin =\u003E _ =\u003E _\n        .DependsOn(Test);\n    Target Ci =\u003E _ =\u003E _\n        .DependsOn(Pack, Test);\n\n}\n"
  },
  {
    "Id": 256143453,
    "FirstIndexed": "2020-04-25T15:47:03.6108245+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627887+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433148+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938929+02:00",
    "Name": "nhibernate.nodamoney",
    "Owner": "gliljas",
    "HtmlUrl": "https://github.com/gliljas/nhibernate.nodamoney",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/gliljas/nhibernate.nodamoney/blob/master/build/Build.cs",
    "BuildFileSize": 3314,
    "BuildFileContent": "using System;\nusing System.Data.SqlClient;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    AbsolutePath TestProject =\u003E SourceDirectory / \u0022NHibernate.NodaMoney.Tests/NHibernate.NodaMoney.Tests.csproj\u0022;\n\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n    Target SetupDatabase =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            using (var conn = new SqlConnection(@\u0022Server=(local)\\SQL2017;Database=master;User ID=sa;Password=Password12!\u0022))\n            {\n                conn.Open();\n                var cmd = conn.CreateCommand();\n                cmd.CommandText = \u0022CREATE DATABASE NodaMoney\u0022;\n                cmd.ExecuteNonQuery();\n            }\n            Environment.SetEnvironmentVariable(\u0022nhibernate:connection.connection_string\u0022, @\u0022Server=(local)\\SQL2017;Database=NodaMoney;User ID=sa;Password=Password12!\u0022);\n        });\n\n    Target RunTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .Executes(() =\u003E \n        {\n            DotNetTest(s =\u003E s\n                .SetProjectFile(TestProject)\n                .SetConfiguration(Configuration)\n                .SetVerbosity(DotNetVerbosity.Normal)\n                );\n        });\n\n}\n"
  },
  {
    "Id": 256171786,
    "FirstIndexed": "2020-04-25T15:47:03.6108075+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627927+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.843316+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938935+02:00",
    "Name": "nukeselenium",
    "Owner": "uwstransition",
    "HtmlUrl": "https://github.com/uwstransition/nukeselenium",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "AzureDevOpsSelenium.Build/Build.cs",
    "BuildFileUrl": "https://github.com/uwstransition/nukeselenium/blob/master/AzureDevOpsSelenium.Build/Build.cs",
    "BuildFileSize": 501,
    "BuildFileContent": "\uFEFFusing Nuke.Common;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tools.DotNet;\nusing System;\n\nnamespace AzureDevOpsSelenium.Build\n{\n    public class Build : NukeBuild\n    {\n        public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Test);\n        [Solution] readonly Solution Solution;\n\n        Target Test =\u003E _ =\u003E _\n            .Executes(() =\u003E\n            {\n                DotNetTasks.DotNetTest(t =\u003E t.SetProjectFile(Solution.GetProject(\u0022AzureDevOpsSelenium\u0022).Path));\n            });\n    }\n}\n"
  },
  {
    "Id": 256565069,
    "FirstIndexed": "2020-04-25T15:47:03.6107853+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627637+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433171+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938946+02:00",
    "Name": "playground",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/playground",
    "Description": null,
    "Archived": false,
    "Stars": 2,
    "Watchers": 1,
    "BuildFilePath": "build/target-model/Build.cs",
    "BuildFileUrl": "https://github.com/nuke-build/playground/blob/master/build/target-model/Build.cs",
    "BuildFileSize": 1335,
    "BuildFileContent": "using Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing static Nuke.Common.Tools.Git.GitTasks;\n\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    // Invoke: nuke --plan\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [GitRepository] readonly GitRepository Repository;\n    [Parameter] readonly string ApiKey;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore);\n\n    Target Restore =\u003E _ =\u003E _;\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore);\n\n    Target Pack =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .After(UpdateChangelog);\n\n    Target UnitTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .DependentFor(Tests)\n        .WhenSkipped(DependencyBehavior.Skip);\n\n    Target IntegrationTests =\u003E _ =\u003E _\n        .DependsOn(Compile)\n        .DependentFor(Tests)\n        .WhenSkipped(DependencyBehavior.Skip);\n\n    Target Tests =\u003E _ =\u003E _\n        .DependsOn(Compile);\n\n    Target UpdateChangelog =\u003E _ =\u003E _\n        .OnlyWhenStatic(() =\u003E Repository.IsOnReleaseBranch() ||\n                              Repository.IsOnHotfixBranch());\n\n    Target Publish =\u003E _ =\u003E _\n        .Requires(() =\u003E ApiKey)\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\n        .DependsOn(Clean, Tests, UpdateChangelog, Pack);\n\n    Target Announce =\u003E _ =\u003E _\n        .TriggeredBy(Publish);\n}\n"
  },
  {
    "Id": 257664766,
    "FirstIndexed": "2020-04-25T15:47:03.6107978+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627767+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433177+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938958+02:00",
    "Name": "dapper-criteria",
    "Owner": "lillo42",
    "HtmlUrl": "https://github.com/lillo42/dapper-criteria",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/lillo42/dapper-criteria/blob/master/build/Build.cs",
    "BuildFileSize": 2443,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n    AbsolutePath TestsDirectory =\u003E RootDirectory / \u0022tests\u0022;\n    AbsolutePath ArtifactsDirectory =\u003E RootDirectory / \u0022artifacts\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            TestsDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(ArtifactsDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 257906889,
    "FirstIndexed": "2020-04-25T15:47:03.6107876+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627722+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433188+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938969+02:00",
    "Name": "tips",
    "Owner": "nuke-build",
    "HtmlUrl": "https://github.com/nuke-build/tips",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 0,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/nuke-build/tips/blob/master/build/Build.cs",
    "BuildFileSize": 2963,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.CI.GitHubActions;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Utilities;\nusing Tweetinvi;\nusing Tweetinvi.Models;\nusing Tweetinvi.Parameters;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.IO.TextTasks;\nusing static Nuke.Common.Logger;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\n[GitHubActions(\n    \u0022scheduled\u0022,\n    GitHubActionsImage.UbuntuLatest,\n    OnCronSchedule = \u00220 13 * * 1,4\u0022,\n    ImportGitHubTokenAs = nameof(GitHubToken),\n    ImportSecrets =\n        new[]\n        {\n            nameof(TwitterConsumerKey),\n            nameof(TwitterConsumerSecret),\n            nameof(TwitterAccessToken),\n            nameof(TwitterAccessTokenSecret)\n        },\n    InvokedTargets = new[] { nameof(Foo) })]\npartial class Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Foo);\n\n    [Parameter] readonly string GitHubToken;\n\n    [Parameter] readonly string TwitterConsumerKey;\n    [Parameter] readonly string TwitterConsumerSecret;\n    [Parameter] readonly string TwitterAccessToken;\n    [Parameter] readonly string TwitterAccessTokenSecret;\n\n    Target Foo =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Console.WriteLine(DateTime.Now);\n        });\n\n    Target Tweet =\u003E _ =\u003E _\n        .Executes(async () =\u003E\n        {\n            var client = new TwitterClient(\n                new TwitterCredentials(\n                    TwitterConsumerKey,\n                    TwitterConsumerSecret,\n                    TwitterAccessToken,\n                    TwitterAccessTokenSecret));\n\n            var directory = RootDirectory / \u0022src\u0022 / \u0022shell-completion\u0022;\n            var text = ReadAllText(directory.GlobFiles(\u0022*.md\u0022).Single());\n            var media = directory.GlobFiles(\u0022*.png\u0022, \u0022*.jpeg\u0022, \u0022*.jpg\u0022, \u0022*.gif\u0022)\n                .Select(async x =\u003E await client.Upload.UploadTweetImage(\n                    new UploadTweetImageParameters(ReadAllBytes(x))\n                    {\n                        MediaCategory = x.ToString().EndsWithOrdinalIgnoreCase(\u0022gif\u0022)\n                            ? MediaCategory.Gif\n                            : MediaCategory.Image\n                    }))\n                .Select(x =\u003E x.Result).ToList();\n\n            var tweetParameters = new PublishTweetParameters\n                                  {\n                                      Text = text,\n                                      Medias = media\n                                  };\n\n            var tweet = await client.Tweets.PublishTweet(tweetParameters);\n\n            Info($\u0022Sent tweet: {tweet.Url}\u0022);\n        });\n}\n"
  },
  {
    "Id": 258417767,
    "FirstIndexed": "2020-04-25T15:47:03.6107819+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627608+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433199+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.893898+02:00",
    "Name": "Nuke",
    "Owner": "BLaZeKiLL",
    "HtmlUrl": "https://github.com/BLaZeKiLL/Nuke",
    "Description": "Repo for learning Nuke.build",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/BLaZeKiLL/Nuke/blob/master/build/Build.cs",
    "BuildFileSize": 2145,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Tools.GitVersion;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n    [GitVersion] readonly GitVersion GitVersion;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022Nuke\u0022;\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\n\n    Target VersionInfo =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            Logger.Info(GitRepository.Branch);\n            Logger.Info(GitVersion.SemVer);\n        });\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n            EnsureCleanDirectory(OutputDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\n                .SetInformationalVersion(GitVersion.InformationalVersion)\n                .EnableNoRestore());\n        });\n\n}\n"
  },
  {
    "Id": 258425168,
    "FirstIndexed": "2020-04-25T15:47:03.6107779+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627597+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433211+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938986+02:00",
    "Name": "monaco-tool",
    "Owner": "dietrichataristocrat",
    "HtmlUrl": "https://github.com/dietrichataristocrat/monaco-tool",
    "Description": "Monaco development tool",
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/dietrichataristocrat/monaco-tool/blob/master/build/Build.cs",
    "BuildFileSize": 7712,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI;\r\nusing Nuke.Common.CI.GitHubActions;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.Coverlet;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.ReportGenerator;\r\nusing Nuke.Common.Utilities;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.ControlFlow;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.Git.GitTasks;\r\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\r\nusing static Nuke.Common.IO.CompressionTasks;\r\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n[GitHubActions(\r\n    \u0022continuous\u0022,\r\n    GitHubActionsImage.WindowsServer2016R2,\r\n    On = new[] { GitHubActionsTrigger.Push },\r\n    InvokedTargets = new[] { nameof(Compile), nameof(Pack) },\r\n    ImportGitHubTokenAs = nameof(GitHubToken),\r\n    ImportSecrets = new string[] { })]\r\npartial class Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027\u0022)]\r\n    readonly Configuration Configuration = Configuration.Debug;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    [Parameter(\u0022GitHub Token\u0022)] readonly string GitHubToken;\r\n    [Parameter] bool IgnoreFailedSources;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\r\n\r\n    Project ToolProject =\u003E Solution.GetProject(\u0022Monaco.Tool\u0022);\r\n\r\n    const string MasterBranch = \u0022master\u0022;\r\n    const string DevelopBranch = \u0022develop\u0022;\r\n\r\n    AbsolutePath PackageDirectory =\u003E OutputDirectory / \u0022packages\u0022;\r\n    AbsolutePath ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Produces(PackageDirectory / \u0022*.nupkg\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetPack(configurator =\u003E configurator\r\n                .SetProject(Solution)\r\n                .SetNoBuild(InvokedTargets.Contains(Compile))\r\n                .SetConfiguration(Configuration)\r\n                .SetOutputDirectory(PackageDirectory)\r\n                .SetVersion(GitVersion.NuGetVersionV2)\r\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\r\n        });\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(configurator =\u003E configurator\r\n                .SetProjectFile(Solution)\r\n                .SetIgnoreFailedSources(IgnoreFailedSources));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(configurator =\u003E configurator\r\n                .SetProjectFile(Solution)\r\n                .SetNoRestore(InvokedTargets.Contains(Restore))\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion));\r\n        });\r\n\r\n    string CoverageReportDirectory =\u003E OutputDirectory / \u0022coverage-report\u0022;\r\n    string CoverageReportArchive =\u003E OutputDirectory / \u0022coverage-report.zip\u0022;\r\n\r\n    Target Coverage =\u003E _ =\u003E _\r\n        .DependsOn(Test)\r\n        .TriggeredBy(Test)\r\n        .Consumes(Test)\r\n        .Produces(CoverageReportArchive)\r\n        .Executes(() =\u003E\r\n        {\r\n            var toolPath =\r\n                ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, framework: \u0022net472\u0022);\r\n\r\n            ReportGenerator(x =\u003E x\r\n                .SetReports(TestResultDirectory / \u0022*.xml\u0022)\r\n                .SetReportTypes(ReportTypes.HtmlInline)\r\n                .SetTargetDirectory(CoverageReportDirectory)\r\n                .SetToolPath(toolPath)\r\n                .SetFramework(\u0022net472\u0022));\r\n\r\n            CompressZip(\r\n                directory: CoverageReportDirectory,\r\n                archiveFile: CoverageReportArchive,\r\n                fileMode: FileMode.Create);\r\n        });\r\n\r\n    [Partition(2)] readonly Partition TestPartition;\r\n    AbsolutePath TestResultDirectory =\u003E OutputDirectory / \u0022test-results\u0022;\r\n    IEnumerable\u003CProject\u003E TestProjects =\u003E TestPartition.GetCurrent(Solution.GetProjects(\u0022*.Tests\u0022));\r\n\r\n    Target Test =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\r\n        .Produces(TestResultDirectory / \u0022*.xml\u0022)\r\n        .Partition(() =\u003E TestPartition)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetTest(x =\u003E x\r\n                .SetConfiguration(Configuration)\r\n                .SetNoBuild(InvokedTargets.Contains(Compile))\r\n                .ResetVerbosity()\r\n                .SetResultsDirectory(TestResultDirectory)\r\n                .When(InvokedTargets.Contains(Coverage) || IsServerBuild, y =\u003E y\r\n                    .EnableCollectCoverage()\r\n                    .SetCoverletOutputFormat(CoverletOutputFormat.cobertura)\r\n                    .SetExcludeByFile(\u0022*.Generated.cs\u0022)\r\n                    .When(IsServerBuild, z =\u003E z\r\n                        .EnableUseSourceLink()))\r\n                .CombineWith(TestProjects, (s, v) =\u003E s\r\n                    .SetProjectFile(v)\r\n                    .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\r\n                    .When(InvokedTargets.Contains(Coverage) || IsServerBuild, configurator =\u003E configurator\r\n                        .SetCoverletOutput(TestResultDirectory / $\u0022{v.Name}.xml\u0022))));\r\n        });\r\n\r\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://nuget.pkg.github.com/dietrichataristocrat/index.json\u0022;\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .DependsOn(Clean, Test, Pack)\r\n        .Consumes(Pack)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\r\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\r\n        .Requires(() =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch) ||\r\n                        GitRepository.Branch.EqualsOrdinalIgnoreCase(DevelopBranch))\r\n        .Executes(() =\u003E\r\n        {\r\n            var packages = PackageDirectory.GlobFiles(\u0022*.nupkg\u0022);\r\n            Assert(packages.Count == 1, \u0022packages.Count == 1\u0022);\r\n\r\n            DotNetNuGetPush(configurator =\u003E configurator\r\n                    .SetSource(Source)\r\n                    .SetArgumentConfigurator(args =\u003E args.Add(\u0022{0}\u0022))\r\n                    .SetApiKey(GitHubToken)\r\n                    .CombineWith(packages, (s, v) =\u003E s\r\n                        .SetTargetPath(v)),\r\n                degreeOfParallelism: 5,\r\n                completeOnFailure: true);\r\n        });\r\n\r\n}\r\n"
  },
  {
    "Id": 258476076,
    "FirstIndexed": "2020-04-25T15:47:03.6107739+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.162758+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433217+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8938997+02:00",
    "Name": "monaco-tool-emdi",
    "Owner": "dietrichataristocrat",
    "HtmlUrl": "https://github.com/dietrichataristocrat/monaco-tool-emdi",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/dietrichataristocrat/monaco-tool-emdi/blob/master/build/Build.cs",
    "BuildFileSize": 7716,
    "BuildFileContent": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing Nuke.Common;\r\nusing Nuke.Common.CI;\r\nusing Nuke.Common.CI.GitHubActions;\r\nusing Nuke.Common.Execution;\r\nusing Nuke.Common.Git;\r\nusing Nuke.Common.IO;\r\nusing Nuke.Common.ProjectModel;\r\nusing Nuke.Common.Tooling;\r\nusing Nuke.Common.Tools.Coverlet;\r\nusing Nuke.Common.Tools.DotNet;\r\nusing Nuke.Common.Tools.GitVersion;\r\nusing Nuke.Common.Tools.ReportGenerator;\r\nusing Nuke.Common.Utilities;\r\nusing Nuke.Common.Utilities.Collections;\r\nusing static Nuke.Common.ControlFlow;\r\nusing static Nuke.Common.EnvironmentInfo;\r\nusing static Nuke.Common.IO.FileSystemTasks;\r\nusing static Nuke.Common.ChangeLog.ChangelogTasks;\r\nusing static Nuke.Common.IO.PathConstruction;\r\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\r\nusing static Nuke.Common.Tools.Git.GitTasks;\r\nusing static Nuke.Common.Tools.ReportGenerator.ReportGeneratorTasks;\r\nusing static Nuke.Common.IO.CompressionTasks;\r\nusing static Nuke.Common.Tools.NuGet.NuGetTasks;\r\n\r\n[CheckBuildProjectConfigurations]\r\n[UnsetVisualStudioEnvironmentVariables]\r\n[GitHubActions(\r\n    \u0022continuous\u0022,\r\n    GitHubActionsImage.WindowsServer2016R2,\r\n    On = new[] { GitHubActionsTrigger.Push },\r\n    InvokedTargets = new[] { nameof(Compile), nameof(Pack) },\r\n    ImportGitHubTokenAs = nameof(GitHubToken),\r\n    ImportSecrets = new string[] { })]\r\npartial class Build : NukeBuild\r\n{\r\n    /// Support plugins are available for:\r\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\r\n    ///   - JetBrains Rider            https://nuke.build/rider\r\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\r\n    ///   - Microsoft VSCode           https://nuke.build/vscode\r\n\r\n    public static int Main() =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\r\n\r\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027\u0022)]\r\n    readonly Configuration Configuration = Configuration.Debug;\r\n\r\n    [Solution] readonly Solution Solution;\r\n    [GitRepository] readonly GitRepository GitRepository;\r\n    [GitVersion] readonly GitVersion GitVersion;\r\n\r\n    [Parameter(\u0022GitHub Token\u0022)] readonly string GitHubToken;\r\n    [Parameter] bool IgnoreFailedSources;\r\n\r\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\r\n    AbsolutePath OutputDirectory =\u003E RootDirectory / \u0022output\u0022;\r\n\r\n    Project ToolProject =\u003E Solution.GetProject(\u0022Monaco.Tool.Emdi\u0022);\r\n\r\n    const string MasterBranch = \u0022master\u0022;\r\n    const string DevelopBranch = \u0022develop\u0022;\r\n\r\n    AbsolutePath PackageDirectory =\u003E OutputDirectory / \u0022packages\u0022;\r\n    AbsolutePath ChangelogFile =\u003E RootDirectory / \u0022CHANGELOG.md\u0022;\r\n\r\n    Target Pack =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Produces(PackageDirectory / \u0022*.nupkg\u0022)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetPack(configurator =\u003E configurator\r\n                .SetProject(Solution)\r\n                .SetNoBuild(InvokedTargets.Contains(Compile))\r\n                .SetConfiguration(Configuration)\r\n                .SetOutputDirectory(PackageDirectory)\r\n                .SetVersion(GitVersion.NuGetVersionV2)\r\n                .SetPackageReleaseNotes(GetNuGetReleaseNotes(ChangelogFile, GitRepository)));\r\n        });\r\n\r\n    Target Clean =\u003E _ =\u003E _\r\n        .Before(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\r\n        });\r\n\r\n    Target Restore =\u003E _ =\u003E _\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetRestore(configurator =\u003E configurator\r\n                .SetProjectFile(Solution)\r\n                .SetIgnoreFailedSources(IgnoreFailedSources));\r\n        });\r\n\r\n    Target Compile =\u003E _ =\u003E _\r\n        .DependsOn(Restore)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetBuild(configurator =\u003E configurator\r\n                .SetProjectFile(Solution)\r\n                .SetNoRestore(InvokedTargets.Contains(Restore))\r\n                .SetConfiguration(Configuration)\r\n                .SetAssemblyVersion(GitVersion.AssemblySemVer)\r\n                .SetFileVersion(GitVersion.AssemblySemFileVer)\r\n                .SetInformationalVersion(GitVersion.InformationalVersion));\r\n        });\r\n\r\n    string CoverageReportDirectory =\u003E OutputDirectory / \u0022coverage-report\u0022;\r\n    string CoverageReportArchive =\u003E OutputDirectory / \u0022coverage-report.zip\u0022;\r\n\r\n    Target Coverage =\u003E _ =\u003E _\r\n        .DependsOn(Test)\r\n        .TriggeredBy(Test)\r\n        .Consumes(Test)\r\n        .Produces(CoverageReportArchive)\r\n        .Executes(() =\u003E\r\n        {\r\n            var toolPath =\r\n                ToolPathResolver.GetPackageExecutable(\u0022ReportGenerator\u0022, \u0022ReportGenerator.exe\u0022, framework: \u0022net472\u0022);\r\n\r\n            ReportGenerator(x =\u003E x\r\n                .SetReports(TestResultDirectory / \u0022*.xml\u0022)\r\n                .SetReportTypes(ReportTypes.HtmlInline)\r\n                .SetTargetDirectory(CoverageReportDirectory)\r\n                .SetToolPath(toolPath)\r\n                .SetFramework(\u0022net472\u0022));\r\n\r\n            CompressZip(\r\n                directory: CoverageReportDirectory,\r\n                archiveFile: CoverageReportArchive,\r\n                fileMode: FileMode.Create);\r\n        });\r\n\r\n    [Partition(2)] readonly Partition TestPartition;\r\n    AbsolutePath TestResultDirectory =\u003E OutputDirectory / \u0022test-results\u0022;\r\n    IEnumerable\u003CProject\u003E TestProjects =\u003E TestPartition.GetCurrent(Solution.GetProjects(\u0022*.Tests\u0022));\r\n\r\n    Target Test =\u003E _ =\u003E _\r\n        .DependsOn(Compile)\r\n        .Produces(TestResultDirectory / \u0022*.trx\u0022)\r\n        .Produces(TestResultDirectory / \u0022*.xml\u0022)\r\n        .Partition(() =\u003E TestPartition)\r\n        .Executes(() =\u003E\r\n        {\r\n            DotNetTest(x =\u003E x\r\n                .SetConfiguration(Configuration)\r\n                .SetNoBuild(InvokedTargets.Contains(Compile))\r\n                .ResetVerbosity()\r\n                .SetResultsDirectory(TestResultDirectory)\r\n                .When(InvokedTargets.Contains(Coverage) || IsServerBuild, y =\u003E y\r\n                    .EnableCollectCoverage()\r\n                    .SetCoverletOutputFormat(CoverletOutputFormat.cobertura)\r\n                    .SetExcludeByFile(\u0022*.Generated.cs\u0022)\r\n                    .When(IsServerBuild, z =\u003E z\r\n                        .EnableUseSourceLink()))\r\n                .CombineWith(TestProjects, (s, v) =\u003E s\r\n                    .SetProjectFile(v)\r\n                    .SetLogger($\u0022trx;LogFileName={v.Name}.trx\u0022)\r\n                    .When(InvokedTargets.Contains(Coverage) || IsServerBuild, configurator =\u003E configurator\r\n                        .SetCoverletOutput(TestResultDirectory / $\u0022{v.Name}.xml\u0022))));\r\n        });\r\n\r\n    [Parameter(\u0022NuGet Source for Packages\u0022)] readonly string Source = \u0022https://nuget.pkg.github.com/dietrichataristocrat/index.json\u0022;\r\n\r\n    Target Publish =\u003E _ =\u003E _\r\n        .DependsOn(Clean, Test, Pack)\r\n        .Consumes(Pack)\r\n        .Requires(() =\u003E GitHubToken)\r\n        .Requires(() =\u003E GitHasCleanWorkingCopy())\r\n        .Requires(() =\u003E Configuration.Equals(Configuration.Release))\r\n        .Requires(() =\u003E GitRepository.Branch.EqualsOrdinalIgnoreCase(MasterBranch) ||\r\n                        GitRepository.Branch.EqualsOrdinalIgnoreCase(DevelopBranch))\r\n        .Executes(() =\u003E\r\n        {\r\n            var packages = PackageDirectory.GlobFiles(\u0022*.nupkg\u0022);\r\n            Assert(packages.Count == 1, \u0022packages.Count == 1\u0022);\r\n\r\n            DotNetNuGetPush(configurator =\u003E configurator\r\n                    .SetSource(Source)\r\n                    .SetArgumentConfigurator(args =\u003E args.Add(\u0022{0}\u0022))\r\n                    .SetApiKey(GitHubToken)\r\n                    .CombineWith(packages, (s, v) =\u003E s\r\n                        .SetTargetPath(v)),\r\n                degreeOfParallelism: 5,\r\n                completeOnFailure: true);\r\n        });\r\n\r\n}\r\n"
  },
  {
    "Id": 258490315,
    "FirstIndexed": "2020-04-25T15:47:03.6107551+02:00",
    "LastIndexUpdated": "2020-04-25T15:59:09.1627568+02:00",
    "LastDetailUpdated": "2020-04-25T15:52:19.8433228+02:00",
    "LastBuildFileUpdated": "2020-04-25T15:58:15.8939009+02:00",
    "Name": "nuke-bug-repro-489",
    "Owner": "Marat-Gumerov",
    "HtmlUrl": "https://github.com/Marat-Gumerov/nuke-bug-repro-489",
    "Description": null,
    "Archived": false,
    "Stars": 0,
    "Watchers": 1,
    "BuildFilePath": "build/Build.cs",
    "BuildFileUrl": "https://github.com/Marat-Gumerov/nuke-bug-repro-489/blob/master/build/Build.cs",
    "BuildFileSize": 1887,
    "BuildFileContent": "using System;\nusing System.Linq;\nusing Nuke.Common;\nusing Nuke.Common.Execution;\nusing Nuke.Common.Git;\nusing Nuke.Common.IO;\nusing Nuke.Common.ProjectModel;\nusing Nuke.Common.Tooling;\nusing Nuke.Common.Tools.DotNet;\nusing Nuke.Common.Utilities.Collections;\nusing static Nuke.Common.EnvironmentInfo;\nusing static Nuke.Common.IO.FileSystemTasks;\nusing static Nuke.Common.IO.PathConstruction;\nusing static Nuke.Common.Tools.DotNet.DotNetTasks;\n\n[CheckBuildProjectConfigurations]\n[UnsetVisualStudioEnvironmentVariables]\nclass Build : NukeBuild\n{\n    /// Support plugins are available for:\n    ///   - JetBrains ReSharper        https://nuke.build/resharper\n    ///   - JetBrains Rider            https://nuke.build/rider\n    ///   - Microsoft VisualStudio     https://nuke.build/visualstudio\n    ///   - Microsoft VSCode           https://nuke.build/vscode\n\n    public static int Main () =\u003E Execute\u003CBuild\u003E(x =\u003E x.Compile);\n\n    [Parameter(\u0022Configuration to build - Default is \u0027Debug\u0027 (local) or \u0027Release\u0027 (server)\u0022)]\n    readonly Configuration Configuration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\n    [Solution] readonly Solution Solution;\n    [GitRepository] readonly GitRepository GitRepository;\n\n    AbsolutePath SourceDirectory =\u003E RootDirectory / \u0022src\u0022;\n\n    Target Clean =\u003E _ =\u003E _\n        .Before(Restore)\n        .Executes(() =\u003E\n        {\n            SourceDirectory.GlobDirectories(\u0022**/bin\u0022, \u0022**/obj\u0022).ForEach(DeleteDirectory);\n        });\n\n    Target Restore =\u003E _ =\u003E _\n        .Executes(() =\u003E\n        {\n            DotNetRestore(s =\u003E s\n                .SetProjectFile(Solution));\n        });\n\n    Target Compile =\u003E _ =\u003E _\n        .DependsOn(Restore)\n        .Executes(() =\u003E\n        {\n            DotNetBuild(s =\u003E s\n                .SetProjectFile(Solution)\n                .SetConfiguration(Configuration)\n                .EnableNoRestore());\n        });\n\n}\n"
  }
]